{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/picture1.jpg","path":"picture1.jpg","modified":1,"renderable":0},{"_id":"source/img/AQS.png","path":"img/AQS.png","modified":1,"renderable":0},{"_id":"source/img/AQS1.png","path":"img/AQS1.png","modified":1,"renderable":0},{"_id":"source/img/AQS2.png","path":"img/AQS2.png","modified":1,"renderable":0},{"_id":"source/img/AQS5.png","path":"img/AQS5.png","modified":1,"renderable":0},{"_id":"source/img/AQS6.png","path":"img/AQS6.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap13.png","path":"img/ConcurrentHashMap13.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap12.png","path":"img/ConcurrentHashMap12.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap14.png","path":"img/ConcurrentHashMap14.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap15.png","path":"img/ConcurrentHashMap15.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap2.png","path":"img/ConcurrentHashMap2.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap3.png","path":"img/ConcurrentHashMap3.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap5.png","path":"img/ConcurrentHashMap5.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap6.png","path":"img/ConcurrentHashMap6.png","modified":1,"renderable":0},{"_id":"source/img/CopyOnWriteArrayList.png","path":"img/CopyOnWriteArrayList.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap7.png","path":"img/ConcurrentHashMap7.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch1.png","path":"img/CountDownLatch1.png","modified":1,"renderable":0},{"_id":"source/img/PoolSubpage.png","path":"img/PoolSubpage.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase10.png","path":"img/git_rebase10.png","modified":1,"renderable":0},{"_id":"source/img/Page_allocation.png","path":"img/Page_allocation.png","modified":1,"renderable":0},{"_id":"source/img/ico.png","path":"img/ico.png","modified":1,"renderable":0},{"_id":"source/img/git_revert1.png","path":"img/git_revert1.png","modified":1,"renderable":0},{"_id":"source/img/git_reset.png","path":"img/git_reset.png","modified":1,"renderable":0},{"_id":"source/img/mysql.jpeg","path":"img/mysql.jpeg","modified":1,"renderable":0},{"_id":"source/img/picture.jpg","path":"img/picture.jpg","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"source/img/1506269128432DX_IM_FILE_0.png","path":"img/1506269128432DX_IM_FILE_0.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap17.png","path":"img/ConcurrentHashMap17.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap18.png","path":"img/ConcurrentHashMap18.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch3.png","path":"img/CountDownLatch3.png","modified":1,"renderable":0},{"_id":"source/img/Netty概念.png","path":"img/Netty概念.png","modified":1,"renderable":0},{"_id":"source/img/ReetrantReadWriteLock1.png","path":"img/ReetrantReadWriteLock1.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase3.png","path":"img/git_rebase3.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase6.png","path":"img/git_rebase6.png","modified":1,"renderable":0},{"_id":"source/img/wait_notify.png","path":"img/wait_notify.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/img/AQS3.png","path":"img/AQS3.png","modified":1,"renderable":0},{"_id":"source/img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","path":"img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","modified":1,"renderable":0},{"_id":"source/img/AQS4.png","path":"img/AQS4.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch4.png","path":"img/CountDownLatch4.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase5.png","path":"img/git_rebase5.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase7.png","path":"img/git_rebase7.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/picture.jpg","path":"img/picture.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"source/img/myself.png","path":"img/myself.png","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"fe9d2baaf55bea8bb5d417431da9df95248a9ff2","modified":1542675293000},{"_id":"source/picture1.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263650000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1525263651000},{"_id":"themes/yilia/.DS_Store","hash":"fe4c6dc77d2c896f41c82d607eb8feeaf9fa50c5","modified":1525263651000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1525263651000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1525263651000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1525263651000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1525263651000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1525263651000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1525263651000},{"_id":"themes/yilia/_config.yml","hash":"e3eb28dcb36ed1f03b47f742a2bc5f7f98d852df","modified":1531669751000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1525263651000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1525263651000},{"_id":"source/_posts/.DS_Store","hash":"d63a533cba18ccba7c6e42c836671be347f8f907","modified":1542640500000},{"_id":"source/_posts/ConcurrentHashMap-put过程介绍.md","hash":"27c79d9beb2ce8c3bd3eda08e74e7dc5d7648de6","modified":1539505614000},{"_id":"source/_posts/ConcurrentHashMap扩容过程介绍.md","hash":"4c3e9691db088577a3c9506a630410b3f1bd4ae3","modified":1539504910000},{"_id":"source/_posts/ConcurrentHashMap红黑树原理介绍.md","hash":"83b8264f5c9ab9c2a0cc8cae5a572e2438403da1","modified":1538891726000},{"_id":"source/_posts/CountDownLatch源码解读.md","hash":"6f8c4200324bf80d7004007620c894d567c418b3","modified":1540776397000},{"_id":"source/_posts/ES索引创建流程.md","hash":"ce9f0bdd339ed2db67081091ebf0e081cc16a8ec","modified":1525263650000},{"_id":"source/_posts/JAVA-JNI实现hello-world.md","hash":"c13fdcc02835eb10731d8a5730263dad6f1064ba","modified":1542078750000},{"_id":"source/_posts/Java线程知识小结.md","hash":"16713cc561721fcf211d52b001c56b8d78ce6b23","modified":1540740104000},{"_id":"source/_posts/LockSupport源码解读.md","hash":"b9245a570b5a35f87d0cf9af2ce207908a92b42b","modified":1542164470000},{"_id":"source/_posts/Netty-Http通信编码源码阅读.md","hash":"3039907661102036d3e06cb005dc8db0d4e62a21","modified":1527004390000},{"_id":"source/_posts/Netty-Http通信解码源码阅读.md","hash":"494b489738663809ca6a84671ce8b3d652871247","modified":1526221294000},{"_id":"source/_posts/Netty-PoolChunk原理探究.md","hash":"358cee17647bde46463012cdfd09965c825f1f13","modified":1532267041000},{"_id":"source/_posts/Netty-PoolThreadCache源码探究.md","hash":"0ee99f70d07517c24f0a81b6e4eb1275f5d99c95","modified":1532103584000},{"_id":"source/_posts/Netty-PoolSubpage原理探究.md","hash":"ede460cd642d0340b35a4a46776fe0a7605c4ed9","modified":1539745255000},{"_id":"source/_posts/Netty内存学习.md","hash":"940f2beae55abd124108d834a761a84a2138910c","modified":1532306676000},{"_id":"source/_posts/Netty通信编解码源码解读.md","hash":"d5c323eafb17fda97c7046a3d15c9bb3438c8080","modified":1526212097000},{"_id":"source/_posts/NioEventLoop篇.md","hash":"03092a2c6a81e9e588a6fef0f5f9feb78dbf42b1","modified":1525263650000},{"_id":"source/_posts/ReentrantLock源码解读.md","hash":"134701c9f0855bc50601d2dd5710d96fd105f71f","modified":1539742644000},{"_id":"source/_posts/ReentrantReadWriteLock源码解读.md","hash":"406ef58bd6477402d945580afc9d15d0a6fc3864","modified":1540738965000},{"_id":"source/_posts/Semaphore源码解读.md","hash":"aaa4f24361e4aa8091d604cc26a0536c7fad96a8","modified":1540738848000},{"_id":"source/_posts/ServerBootstrap初始篇.md","hash":"70b468e76b3cccd4fc7a9cfa97521da219bb3830","modified":1525263650000},{"_id":"source/_posts/SimpleDateFormat非线程安全分析.md","hash":"eb6446ec0e16688c6079c29c4cfbc9a8a195f4bc","modified":1540958991000},{"_id":"source/_posts/copyOnWriteArrayListy原理解读.md","hash":"4833d4b0eb7813bdfef99ed925f75434dea03c07","modified":1539745312000},{"_id":"source/_posts/git-基本命令学习心得.md","hash":"1da7499423dea941c00a9e1796e0a8f3c0f36dcf","modified":1542629385000},{"_id":"source/img/.DS_Store","hash":"625a81a4b2958eb405d33202ff20309d4c49378a","modified":1542675047000},{"_id":"source/img/AQS.png","hash":"59aa96ea31ed9122d77914e30fa1bfa67ff4d632","modified":1537714692000},{"_id":"source/img/AQS1.png","hash":"3b2ebf04a5ebb9e309c3c9ac8f0d5bcf652493c1","modified":1537717695000},{"_id":"source/img/AQS2.png","hash":"2e28e6c282db6fa9596d06696ab8ec183a24c394","modified":1537758111000},{"_id":"source/img/AQS5.png","hash":"07113ccc55381606f449bb5563cbd5e20f92e3b4","modified":1538090746000},{"_id":"source/img/AQS6.png","hash":"c3b91f5c74a13f08fa638ebf244e3f3415839f91","modified":1538294485000},{"_id":"source/img/ConcurrentHashMap13.png","hash":"f2fd896539ba2ed55cbd04d6af398a019e9424a9","modified":1538879602000},{"_id":"source/img/ConcurrentHashMap12.png","hash":"1a44be80d89b99ae0bd93d25ee0551ba61ad1221","modified":1538879505000},{"_id":"source/img/ConcurrentHashMap14.png","hash":"62d222084f0009e60409d8d3d8cef951f51f0470","modified":1538879634000},{"_id":"source/img/ConcurrentHashMap15.png","hash":"84ae8806f7facf54cfdad41ba372a266ac3e6c0f","modified":1538879653000},{"_id":"source/img/ConcurrentHashMap2.png","hash":"4822efe2340a4ec75f2f8129dead79cea0f01fa5","modified":1538824583000},{"_id":"source/img/ConcurrentHashMap3.png","hash":"cd1a4ae600f039599f6e87d35366ec559f8b300a","modified":1538824582000},{"_id":"source/img/ConcurrentHashMap5.png","hash":"52606d03071fb517a7cfd14ac9db880cd426fa3c","modified":1538844568000},{"_id":"source/img/ConcurrentHashMap6.png","hash":"6cb3a8aac8e39a35057592489fe7a83a069541bd","modified":1538844576000},{"_id":"source/img/CopyOnWriteArrayList.png","hash":"0274b31135dded04d2971f45fbf6af64312ed4b6","modified":1539743940000},{"_id":"source/img/ConcurrentHashMap7.png","hash":"dfdbf02f811a3ac2d2e4fda3aaab30352674c5f9","modified":1538844582000},{"_id":"source/img/CountDownLatch1.png","hash":"10dbb17f285dcd8d8498191ff900fef64123207b","modified":1537805620000},{"_id":"source/img/PoolSubpage.png","hash":"06a66ab03ef681fc02f18161c8a62eb211ce4029","modified":1532247980000},{"_id":"source/img/git_rebase10.png","hash":"5fe73b8d5690e82b5aa1fcf7c0e532715f6a8c8b","modified":1539228026000},{"_id":"source/img/Page_allocation.png","hash":"02abe6207fb3435aab54d6bb82116591220c45ea","modified":1532150655000},{"_id":"source/img/ico.png","hash":"bd609189ddff823f048092b680a3b8d5b886bb97","modified":1531651163000},{"_id":"source/img/git_revert1.png","hash":"b8b39bad790edea30086f8af454448231633d148","modified":1539445726000},{"_id":"source/img/git_reset.png","hash":"d7080a0012ef3691f104551621446f994f84d290","modified":1539498325000},{"_id":"source/img/mysql.jpeg","hash":"6f50b4c867d0f125e9d32856b2b85b2197534dd4","modified":1542640449000},{"_id":"source/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263650000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525263651000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1525263651000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525263651000},{"_id":"themes/yilia/.git/index","hash":"17dc582f429cb43dfcbb8f3b60b9a96a4f89d907","modified":1525266725000},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1525263651000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1525263651000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1525263651000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1525263651000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1525263651000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1525263651000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1525263651000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1525263651000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1525263651000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1525263651000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1525263651000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1525263651000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1525263651000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1525263651000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1525263651000},{"_id":"themes/yilia/source/.DS_Store","hash":"2e125b278324bee8e26c58283773ccf57ca50f62","modified":1525263651000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1525263651000},{"_id":"themes/yilia/source-src/.DS_Store","hash":"eb59082b0722091794ca7702b8f86389094ac262","modified":1525263651000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1525263651000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1525263651000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1525263651000},{"_id":"source/img/1506269128432DX_IM_FILE_0.png","hash":"ca117a42810f1564752b2622cd2485ae15e9e186","modified":1525263650000},{"_id":"source/img/ConcurrentHashMap17.png","hash":"66ec63acad7a0e78f73b9c30991f886d82edd069","modified":1538966493000},{"_id":"source/img/ConcurrentHashMap18.png","hash":"0fc5024b45d9fa616646f42f2db97709c86e3782","modified":1539000280000},{"_id":"source/img/CountDownLatch3.png","hash":"8307e47a0185e27b3bc1ab2f84d8400bb6449aee","modified":1538152076000},{"_id":"source/img/Netty概念.png","hash":"99244a9371b8d5bf29d01cc103f79441ead35765","modified":1525263650000},{"_id":"source/img/ReetrantReadWriteLock1.png","hash":"3d991d2ad556be4e64a58f9826074ef2a501dd20","modified":1538224311000},{"_id":"source/img/git_rebase3.png","hash":"e432a6e20b0d4e633b169f3435dac2c9d11dcd2a","modified":1539017753000},{"_id":"source/img/git_rebase6.png","hash":"4c9d4815796eda540c30e7eed5156cd0b7f50335","modified":1539020224000},{"_id":"source/img/wait_notify.png","hash":"03c21ae8b0dd5c9e32a8916a464f09653a7dc023","modified":1540737189000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525263651000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1525263651000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1525263651000},{"_id":"source/img/AQS3.png","hash":"4e4d461d8702318103dd106d1bdd57bc8f407f9c","modified":1537760136000},{"_id":"source/img/BaseFuture_AbstractQueuedSynchronizer/.DS_Store","hash":"cb6d6e18a173ccc7da6187e4d994338cfd3121ea","modified":1525263650000},{"_id":"source/img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","hash":"912943a8eea0f8e4344511fd8088295787c39422","modified":1525263650000},{"_id":"source/img/AQS4.png","hash":"665b486a14443998e5447fe7543ed5ad4a78efb5","modified":1538090743000},{"_id":"source/img/CountDownLatch4.png","hash":"e505b3f12f273bae92e03ca32f95f7c31ef888c5","modified":1538152081000},{"_id":"source/img/git_rebase5.png","hash":"2ab765ef7ecdd5bdcdfa66d3e7590a70ca79f7a2","modified":1539018526000},{"_id":"source/img/git_rebase7.png","hash":"00bec1a241ccfaa1f978a9266441708e492c5ef1","modified":1539055570000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525263651000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1525263651000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"899793bb3a75b4058b6aee41d3ca043e35774f7d","modified":1540621268000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"5e66afb25890f891563549bcd8d761690f89ec8b","modified":1532085014000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"2907d432d4327eef0239fbae783c027283ea3dd4","modified":1542675532000},{"_id":"themes/yilia/layout/_partial/left-col.ejs_tmp","hash":"25ce2169f8516d90a9ddd6f268f2f6a71172916b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1525263651000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1525263651000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1525263651000},{"_id":"themes/yilia/source/img/.DS_Store","hash":"9a730f22af5f133f1235459006bbcf9661e6099b","modified":1525263651000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1525263651000},{"_id":"themes/yilia/source/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263651000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1525263651000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1525263651000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1525263651000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1525263651000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1525263651000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1525263651000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1525263651000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1525263651000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1525263651000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1525263651000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1525263651000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1525263651000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1525263651000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1525263651000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1525263651000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1525263651000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1525263651000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1525263651000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1525263651000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1525263651000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1525263651000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1525263651000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1525263651000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1525263651000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1525263651000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1525263651000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1525263651000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1525263651000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1525263651000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1525263651000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1525263651000},{"_id":"source/img/myself.png","hash":"4cce9a791da592a5407ce7c363172e0f11be23f4","modified":1542675478000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1525263651000},{"_id":"themes/yilia/.git/objects/pack/pack-81482136cf6b522e44e787dc9c868acfcb7c25a6.idx","hash":"192241e09a6504ede0484bccfdb070cc40a2907a","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"68f0bfe01b23d0a5edd1b5ac44be5e0b33df81a6","modified":1531665850000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs_tmp","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1531665823000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1525263651000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1525263651000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/.git/objects/pack/pack-81482136cf6b522e44e787dc9c868acfcb7c25a6.pack","hash":"a3546a4602f8b7a5a61f5bdc6ff14c6523cf6441","modified":1525263651000},{"_id":"public/baidusitemap.xml","hash":"4a715fb98f76656b296f0e04a31b9c05eea3b328","modified":1542675583988},{"_id":"public/content.json","hash":"d41349d05165b129e17a6f2614aaff8564a33388","modified":1542675584335},{"_id":"public/sitemap.xml","hash":"8002467d84a5b374c3cb8d64ae546e41784df195","modified":1542675584403},{"_id":"public/2018/11/10/LockSupport源码解读/index.html","hash":"26061ef3ef219344c87f0b7a2bb765beb85fc838","modified":1542675584421},{"_id":"public/2018/10/31/SimpleDateFormat非线程安全分析/index.html","hash":"d4b50e4dd373dc9bfa663edd5a21bd96f997275c","modified":1542675584421},{"_id":"public/2018/07/22/Netty-PoolSubpage原理探究/index.html","hash":"c9b0d1895fa6808a60a0802e7305ac52071a7c77","modified":1542675584421},{"_id":"public/2018/07/20/Netty-PoolChunk原理探究/index.html","hash":"e968264569c240bcb0b66902ea49bb5016589269","modified":1542675584421},{"_id":"public/2018/07/14/Netty-PoolThreadCache源码探究/index.html","hash":"cd378fbdf88e8b14383db068bed18e9a09ad89e3","modified":1542675584421},{"_id":"public/2018/05/23/Netty内存学习/index.html","hash":"e3661a9e257f49799ce85ffc660be0284ca78fa0","modified":1542675584422},{"_id":"public/2018/05/04/Netty-Http通信编码源码阅读/index.html","hash":"3cb9aa838a1622b68e1361f0e47663d73ecf0af0","modified":1542675584422},{"_id":"public/2018/04/16/Netty-Http通信解码源码阅读/index.html","hash":"80cf4cdca43412e9b502c889b1626dafd048a430","modified":1542675584422},{"_id":"public/2018/03/25/Netty通信编解码源码解读/index.html","hash":"5e4fbbff3a529f3d0d3ffb30e98553268087b007","modified":1542675584422},{"_id":"public/2018/01/22/NioEventLoop篇/index.html","hash":"75602def032238cb0205fc8ac004d9b8b0d1d07c","modified":1542675584422},{"_id":"public/2018/01/14/ServerBootstrap初始篇/index.html","hash":"36d85d0a97b8155971e4d8691fcfa6461d4dbcf8","modified":1542675584422},{"_id":"public/2017/12/17/ES索引创建流程/index.html","hash":"fb07207481e8fdac4ffdc44266e1aedce1b36567","modified":1542675584422},{"_id":"public/2017/11/14/ConcurrentHashMap扩容过程介绍/index.html","hash":"ffed1d5a258945697257831ff72b6b74faeddc4d","modified":1542675584422},{"_id":"public/2017/11/06/ConcurrentHashMap红黑树原理介绍/index.html","hash":"b676eed06dbb5b391a2825f1642e464799e4feb8","modified":1542675584422},{"_id":"public/2017/11/05/ConcurrentHashMap-put过程介绍/index.html","hash":"bce619899982c3c30b08de66a4662a433c18a7e9","modified":1542675584422},{"_id":"public/2017/09/17/copyOnWriteArrayListy原理解读/index.html","hash":"77344b73f74f78cc2640be7843ccd59e953d459b","modified":1542675584423},{"_id":"public/2017/08/24/CountDownLatch源码解读/index.html","hash":"c308f7e314faf3c1a462ea00592e38a6e1791d80","modified":1542675584423},{"_id":"public/2017/08/15/Semaphore源码解读/index.html","hash":"1441d12b7781ca4a1707b335250c451e9a68d0ff","modified":1542675584423},{"_id":"public/2017/07/28/ReentrantReadWriteLock源码解读/index.html","hash":"5dbabee4b39a9737fcf8b119033e30a09e94bdb4","modified":1542675584423},{"_id":"public/2017/07/23/ReentrantLock源码解读/index.html","hash":"60ed6ee193a2c6b0373a4c5ec30124c292be88a8","modified":1542675584423},{"_id":"public/2017/06/15/JAVA-JNI实现hello-world/index.html","hash":"3f0af765ed01ee908e5af112c8ec59ad31dfd014","modified":1542675584423},{"_id":"public/2017/03/08/git-基本命令学习心得/index.html","hash":"018c1b649e7a44ddb77f73d49568952c9811f149","modified":1542675584423},{"_id":"public/2016/10/27/Java线程知识小结/index.html","hash":"def5b3c90fb4f3b2360ab9ba774ea456beaee42f","modified":1542675584423},{"_id":"public/archives/index.html","hash":"01c6d6e7b9d7d18515bc900aa56b80af5f88767f","modified":1542675584423},{"_id":"public/archives/page/2/index.html","hash":"60f5f31ebde19732cc5e1bc8221aff4da8c4dd44","modified":1542675584424},{"_id":"public/archives/page/3/index.html","hash":"cf000130674d9a2f5a727e67ac6fe1b1c65a63d3","modified":1542675584424},{"_id":"public/archives/2016/index.html","hash":"86f64baf444848f558d325962ffa249d35ff0cb6","modified":1542675584424},{"_id":"public/archives/2016/10/index.html","hash":"1fdeb38d53e3c0231c58a35e770819b4cae7b39b","modified":1542675584424},{"_id":"public/archives/2017/index.html","hash":"2f4cc93b0619514f9e9ca16735686ced6be0cc46","modified":1542675584424},{"_id":"public/archives/2017/page/2/index.html","hash":"d1425360a94ee4d7455ac591943c097f4a3dde44","modified":1542675584424},{"_id":"public/archives/2017/03/index.html","hash":"fe33b6ca0c34dca1f49cf392958a615243e7c343","modified":1542675584424},{"_id":"public/archives/2017/06/index.html","hash":"7a0c0ab833b6b9fb9401f3cf9a174e8de1e52395","modified":1542675584424},{"_id":"public/archives/2017/07/index.html","hash":"d3a4cd324fc7b557c3115d6fd954dc330216fddd","modified":1542675584424},{"_id":"public/archives/2017/08/index.html","hash":"3309fdfb8ecd0e961e0416c1506202821bb1243d","modified":1542675584424},{"_id":"public/archives/2017/09/index.html","hash":"889a91bab393c514deb3677bdb304999b2617502","modified":1542675584424},{"_id":"public/archives/2017/11/index.html","hash":"1f8d980d73e9f2c303fe9e2f027ae449684541e9","modified":1542675584424},{"_id":"public/archives/2017/12/index.html","hash":"b59eed148db9db7da36c9856ce43ef7965f4c0e6","modified":1542675584424},{"_id":"public/archives/2018/index.html","hash":"e3796332f29b988ec1beadb2fb7effd971e24c63","modified":1542675584424},{"_id":"public/archives/2018/page/2/index.html","hash":"77da9415a999c9e5af170653fcd14974ca09aecf","modified":1542675584424},{"_id":"public/archives/2018/01/index.html","hash":"70f76a52b8ea0c3c4439f393c2de1bbd1631f8be","modified":1542675584425},{"_id":"public/archives/2018/03/index.html","hash":"0cc9168adf5425fcb0050a07e0a14d3de5399951","modified":1542675584425},{"_id":"public/archives/2018/04/index.html","hash":"07b71896c60f7b1cde8585d5114c956f5de3baaa","modified":1542675584425},{"_id":"public/archives/2018/05/index.html","hash":"273b7912506a72430440370a8f5f4d9f646faf35","modified":1542675584425},{"_id":"public/archives/2018/07/index.html","hash":"e719a9e14cbb55b762ed850df80f7a93cec286b9","modified":1542675584425},{"_id":"public/archives/2018/10/index.html","hash":"65915fdeaff7fe4fa20171bd996c549e9682ce85","modified":1542675584426},{"_id":"public/archives/2018/11/index.html","hash":"a896253dfe1b513f2e1553a848006bbf7aee7389","modified":1542675584426},{"_id":"public/index.html","hash":"df3a3a0c928499385d20a4806c7a92b281d4a09c","modified":1542675584426},{"_id":"public/page/2/index.html","hash":"ad9777869177ae9c549199fe88de52611a1691e5","modified":1542675584426},{"_id":"public/page/3/index.html","hash":"f58547b88fe1175f18be94c18b0ce41bff8b97cc","modified":1542675584426},{"_id":"public/tags/ReentrantLock/index.html","hash":"350e254d3322a4888e14a9757b8d0e98f46be9a5","modified":1542675584426},{"_id":"public/tags/netty4-ServerBootstrap-Initiale/index.html","hash":"b2c840b53c3dbf32b2dbed314ac2d742ac488ba6","modified":1542675584427},{"_id":"public/tags/git-rebase-cherry-pick-reset-checkout/index.html","hash":"b77709ec6451aebccc8169b5768cc8ae866a71d4","modified":1542675584427},{"_id":"public/picture1.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1542675584439},{"_id":"public/img/AQS.png","hash":"59aa96ea31ed9122d77914e30fa1bfa67ff4d632","modified":1542675584439},{"_id":"public/img/AQS1.png","hash":"3b2ebf04a5ebb9e309c3c9ac8f0d5bcf652493c1","modified":1542675584440},{"_id":"public/img/AQS2.png","hash":"2e28e6c282db6fa9596d06696ab8ec183a24c394","modified":1542675584440},{"_id":"public/img/AQS5.png","hash":"07113ccc55381606f449bb5563cbd5e20f92e3b4","modified":1542675584440},{"_id":"public/img/AQS6.png","hash":"c3b91f5c74a13f08fa638ebf244e3f3415839f91","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap13.png","hash":"f2fd896539ba2ed55cbd04d6af398a019e9424a9","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap12.png","hash":"1a44be80d89b99ae0bd93d25ee0551ba61ad1221","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap14.png","hash":"62d222084f0009e60409d8d3d8cef951f51f0470","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap15.png","hash":"84ae8806f7facf54cfdad41ba372a266ac3e6c0f","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap2.png","hash":"4822efe2340a4ec75f2f8129dead79cea0f01fa5","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap3.png","hash":"cd1a4ae600f039599f6e87d35366ec559f8b300a","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap5.png","hash":"52606d03071fb517a7cfd14ac9db880cd426fa3c","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap6.png","hash":"6cb3a8aac8e39a35057592489fe7a83a069541bd","modified":1542675584440},{"_id":"public/img/CopyOnWriteArrayList.png","hash":"0274b31135dded04d2971f45fbf6af64312ed4b6","modified":1542675584440},{"_id":"public/img/ConcurrentHashMap7.png","hash":"dfdbf02f811a3ac2d2e4fda3aaab30352674c5f9","modified":1542675584440},{"_id":"public/img/PoolSubpage.png","hash":"06a66ab03ef681fc02f18161c8a62eb211ce4029","modified":1542675584440},{"_id":"public/img/CountDownLatch1.png","hash":"10dbb17f285dcd8d8498191ff900fef64123207b","modified":1542675584440},{"_id":"public/img/git_rebase10.png","hash":"5fe73b8d5690e82b5aa1fcf7c0e532715f6a8c8b","modified":1542675584440},{"_id":"public/img/ico.png","hash":"bd609189ddff823f048092b680a3b8d5b886bb97","modified":1542675584440},{"_id":"public/img/Page_allocation.png","hash":"02abe6207fb3435aab54d6bb82116591220c45ea","modified":1542675584440},{"_id":"public/img/git_reset.png","hash":"d7080a0012ef3691f104551621446f994f84d290","modified":1542675584440},{"_id":"public/img/git_revert1.png","hash":"b8b39bad790edea30086f8af454448231633d148","modified":1542675584440},{"_id":"public/img/mysql.jpeg","hash":"6f50b4c867d0f125e9d32856b2b85b2197534dd4","modified":1542675584440},{"_id":"public/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1542675584441},{"_id":"public/img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","hash":"912943a8eea0f8e4344511fd8088295787c39422","modified":1542675584441},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1542675584441},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1542675584441},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1542675584441},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1542675584441},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1542675584441},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1542675584441},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1542675584441},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1542675584441},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1542675584441},{"_id":"public/img/1506269128432DX_IM_FILE_0.png","hash":"ca117a42810f1564752b2622cd2485ae15e9e186","modified":1542675584445},{"_id":"public/img/ConcurrentHashMap17.png","hash":"66ec63acad7a0e78f73b9c30991f886d82edd069","modified":1542675584447},{"_id":"public/img/ConcurrentHashMap18.png","hash":"0fc5024b45d9fa616646f42f2db97709c86e3782","modified":1542675584448},{"_id":"public/img/CountDownLatch3.png","hash":"8307e47a0185e27b3bc1ab2f84d8400bb6449aee","modified":1542675584448},{"_id":"public/img/Netty概念.png","hash":"99244a9371b8d5bf29d01cc103f79441ead35765","modified":1542675584448},{"_id":"public/img/ReetrantReadWriteLock1.png","hash":"3d991d2ad556be4e64a58f9826074ef2a501dd20","modified":1542675584448},{"_id":"public/img/git_rebase3.png","hash":"e432a6e20b0d4e633b169f3435dac2c9d11dcd2a","modified":1542675584448},{"_id":"public/img/git_rebase6.png","hash":"4c9d4815796eda540c30e7eed5156cd0b7f50335","modified":1542675584448},{"_id":"public/img/wait_notify.png","hash":"03c21ae8b0dd5c9e32a8916a464f09653a7dc023","modified":1542675584448},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1542675584452},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1542675584452},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1542675584452},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1542675584452},{"_id":"public/img/AQS3.png","hash":"4e4d461d8702318103dd106d1bdd57bc8f407f9c","modified":1542675584452},{"_id":"public/img/CountDownLatch4.png","hash":"e505b3f12f273bae92e03ca32f95f7c31ef888c5","modified":1542675584452},{"_id":"public/img/git_rebase7.png","hash":"00bec1a241ccfaa1f978a9266441708e492c5ef1","modified":1542675584452},{"_id":"public/img/AQS4.png","hash":"665b486a14443998e5447fe7543ed5ad4a78efb5","modified":1542675584452},{"_id":"public/img/git_rebase5.png","hash":"2ab765ef7ecdd5bdcdfa66d3e7590a70ca79f7a2","modified":1542675584452},{"_id":"public/img/myself.png","hash":"4cce9a791da592a5407ce7c363172e0f11be23f4","modified":1542675584455}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"ConcurrentHashMap Put源码介绍","date":"2017-11-05T03:20:55.000Z","_content":"在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。\n首先放张大图, 对ConcurrentHashMap先有大致的了解。\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"/>\n所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。\nConcurrentHashMap系列将分为以下三个方面进行详细描述:\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>\n# 成员变量介绍\nConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:\n+ LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh\n+ TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。\n+ UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。\n+ MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。\n+ MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容\n+ TREEBIN, 置为-2, 代表此元素后接红黑树。\n+ nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。\n+ sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:\n    0: table还没有被初始化\n    -1: table正在初始化\n    小于-1: 实际值为resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 表明table正在扩容\n    大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n\n+ transferIndex: table容量从n扩到2n时, 是从索引n->1的元素开始迁移, transferIndex代表当前已经迁移的元素下标\n+ ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。\n\n# putVal插入数据\n下面真正开始写入数据:\n```\n    /** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        // 定位到table[]中的i\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            //若table为0， 则初始化这个table\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); //首先初始化\n            //根据hash值计算出在table里面的位置\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //如果没有，则向这个位置添加一个节点\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            //整个table正在扩容\n            else if ((fh = f.hash) == MOVED)\n                //帮着一起扩容\n                tab = helpTransfer(tab, f);\n            //真正插入数据\n            else {\n                V oldVal = null;\n                //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                         //普通的数组\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                //找到key一样的，则直接替换并退出\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        //如果是红合树\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        //开始将table中元素为i的数组转变为二叉树\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        //链表或者红黑树不应该增加table的负载\n        addCount(1L, binCount);\n        return null;\n    }\n```\n主要做了如下事情:\n+ 根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h >>> 16)) & HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash>0一定成立, 若node.hash<0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树\n+ 检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。\n+ 根据i = (n - 1) & hash))确定需要插入table的位置i:\n1. 若table[i]没有元素, 则将key-value存放进去。\n2. 若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)\n3. 否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。\n4. 在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)\n5. 修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。\n\n## initTable初始化\n```\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {//只要没有成功，就一定重新尝试\n            if ((sc = sizeCtl) < 0)  //正在初始化，本节点先尝试放弃cpu的使用\n                Thread.yield(); // lost initialization race; just spin\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { //这里应该是个原子操作，将sizeCtl设置为-1\n                try {\n                    if ((tab = table) == null || tab.length == 0) { //\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n初始化table主要做了如下事情:\n+ 检查sizeCtl, 若发现<0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成\n+ 若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。\n+  初始化table\n+  设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数\n## addCount\naddCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。\n```\n    private final void addCount(long x, int check) {  //若小于0，则不检查扩容\n        CounterCell[] as; long b, s=baseCount+x;\n        .......//更新元素个数metrics\n        }\n        if (check >= 0) { //s是当前table长度\n            Node<K,V>[] tab, nt; int n, sc;\n            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&//达到容积上限，\n                   (n = tab.length) < MAXIMUM_CAPACITY) {\n                int rs = resizeStamp(n); //根据目前table长度做一个标识\n                if (sc < 0) { //说明table正在扩容\n                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                        transferIndex <= 0)\n                        break;\n                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                        transfer(tab, nt);\n                } //第一个线程开始扩容，sizeCtl = resizeStamp(n)<<16 + 2\n                else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs << 16 + 2\n                                             (rs << RESIZE_STAMP_SHIFT) + 2))//rs > 2^15,rs << RESIZE_STAMP_SHIFT) + 2) > 2^31+n,int类型的数就是负数了。\n                    transfer(tab, null);\n                s = sumCount();\n            }\n        }\n    }\n```\n主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。\n+ 若sizeCtl<0, 那么检查是否扩容完成, 若扩容完成了, 退出; 否则将sizeCtl加1, 并进行扩容操作transfer(), 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n+ 若sizeCtl>0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)<<16 + 2, 并进行扩容transfer()\n\n# 总结\nConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。","source":"_posts/ConcurrentHashMap-put过程介绍.md","raw":"---\ntitle: ConcurrentHashMap Put源码介绍\ndate: 2017-11-05 11:20:55\ntags:\n---\n在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。\n首先放张大图, 对ConcurrentHashMap先有大致的了解。\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"/>\n所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。\nConcurrentHashMap系列将分为以下三个方面进行详细描述:\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>\n# 成员变量介绍\nConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:\n+ LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh\n+ TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。\n+ UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。\n+ MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。\n+ MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容\n+ TREEBIN, 置为-2, 代表此元素后接红黑树。\n+ nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。\n+ sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:\n    0: table还没有被初始化\n    -1: table正在初始化\n    小于-1: 实际值为resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 表明table正在扩容\n    大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n\n+ transferIndex: table容量从n扩到2n时, 是从索引n->1的元素开始迁移, transferIndex代表当前已经迁移的元素下标\n+ ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。\n\n# putVal插入数据\n下面真正开始写入数据:\n```\n    /** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        // 定位到table[]中的i\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            //若table为0， 则初始化这个table\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); //首先初始化\n            //根据hash值计算出在table里面的位置\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //如果没有，则向这个位置添加一个节点\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            //整个table正在扩容\n            else if ((fh = f.hash) == MOVED)\n                //帮着一起扩容\n                tab = helpTransfer(tab, f);\n            //真正插入数据\n            else {\n                V oldVal = null;\n                //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                         //普通的数组\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                //找到key一样的，则直接替换并退出\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        //如果是红合树\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        //开始将table中元素为i的数组转变为二叉树\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        //链表或者红黑树不应该增加table的负载\n        addCount(1L, binCount);\n        return null;\n    }\n```\n主要做了如下事情:\n+ 根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h >>> 16)) & HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash>0一定成立, 若node.hash<0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树\n+ 检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。\n+ 根据i = (n - 1) & hash))确定需要插入table的位置i:\n1. 若table[i]没有元素, 则将key-value存放进去。\n2. 若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)\n3. 否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。\n4. 在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)\n5. 修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。\n\n## initTable初始化\n```\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {//只要没有成功，就一定重新尝试\n            if ((sc = sizeCtl) < 0)  //正在初始化，本节点先尝试放弃cpu的使用\n                Thread.yield(); // lost initialization race; just spin\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { //这里应该是个原子操作，将sizeCtl设置为-1\n                try {\n                    if ((tab = table) == null || tab.length == 0) { //\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n初始化table主要做了如下事情:\n+ 检查sizeCtl, 若发现<0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成\n+ 若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。\n+  初始化table\n+  设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数\n## addCount\naddCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。\n```\n    private final void addCount(long x, int check) {  //若小于0，则不检查扩容\n        CounterCell[] as; long b, s=baseCount+x;\n        .......//更新元素个数metrics\n        }\n        if (check >= 0) { //s是当前table长度\n            Node<K,V>[] tab, nt; int n, sc;\n            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&//达到容积上限，\n                   (n = tab.length) < MAXIMUM_CAPACITY) {\n                int rs = resizeStamp(n); //根据目前table长度做一个标识\n                if (sc < 0) { //说明table正在扩容\n                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                        transferIndex <= 0)\n                        break;\n                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                        transfer(tab, nt);\n                } //第一个线程开始扩容，sizeCtl = resizeStamp(n)<<16 + 2\n                else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs << 16 + 2\n                                             (rs << RESIZE_STAMP_SHIFT) + 2))//rs > 2^15,rs << RESIZE_STAMP_SHIFT) + 2) > 2^31+n,int类型的数就是负数了。\n                    transfer(tab, null);\n                s = sumCount();\n            }\n        }\n    }\n```\n主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。\n+ 若sizeCtl<0, 那么检查是否扩容完成, 若扩容完成了, 退出; 否则将sizeCtl加1, 并进行扩容操作transfer(), 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n+ 若sizeCtl>0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)<<16 + 2, 并进行扩容transfer()\n\n# 总结\nConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。","slug":"ConcurrentHashMap-put过程介绍","published":1,"updated":"2018-10-14T08:26:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17luu0000isu563ieheyi","content":"<p>在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。<br>首先放张大图, 对ConcurrentHashMap先有大致的了解。<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"><br>所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。<br>ConcurrentHashMap系列将分为以下三个方面进行详细描述:<br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a></p>\n<h1 id=\"成员变量介绍\"><a href=\"#成员变量介绍\" class=\"headerlink\" title=\"成员变量介绍\"></a>成员变量介绍</h1><p>ConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:</p>\n<ul>\n<li>LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh</li>\n<li>TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。</li>\n<li>UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。</li>\n<li>MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。</li>\n<li>MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容</li>\n<li>TREEBIN, 置为-2, 代表此元素后接红黑树。</li>\n<li>nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。</li>\n<li>sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:<br>  0: table还没有被初始化<br>  -1: table正在初始化<br>  小于-1: 实际值为resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 表明table正在扩容<br>  大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n</li>\n<li>transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标</li>\n<li>ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。</li>\n</ul>\n<h1 id=\"putVal插入数据\"><a href=\"#putVal插入数据\" class=\"headerlink\" title=\"putVal插入数据\"></a>putVal插入数据</h1><p>下面真正开始写入数据:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** Implementation for put and putIfAbsent */</div><div class=\"line\">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class=\"line\">    if (key == null || value == null) throw new NullPointerException();</div><div class=\"line\">    // 定位到table[]中的i</div><div class=\"line\">    int hash = spread(key.hashCode());</div><div class=\"line\">    int binCount = 0;</div><div class=\"line\">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class=\"line\">        //若table为0， 则初始化这个table</div><div class=\"line\">        if (tab == null || (n = tab.length) == 0)</div><div class=\"line\">            tab = initTable(); //首先初始化</div><div class=\"line\">        //根据hash值计算出在table里面的位置</div><div class=\"line\">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class=\"line\">            //如果没有，则向这个位置添加一个节点</div><div class=\"line\">            if (casTabAt(tab, i, null,</div><div class=\"line\">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class=\"line\">                break;                   // no lock when adding to empty bin</div><div class=\"line\">        &#125;</div><div class=\"line\">        //整个table正在扩容</div><div class=\"line\">        else if ((fh = f.hash) == MOVED)</div><div class=\"line\">            //帮着一起扩容</div><div class=\"line\">            tab = helpTransfer(tab, f);</div><div class=\"line\">        //真正插入数据</div><div class=\"line\">        else &#123;</div><div class=\"line\">            V oldVal = null;</div><div class=\"line\">            //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;</div><div class=\"line\">                     //普通的数组</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        binCount = 1;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class=\"line\">                            K ek;</div><div class=\"line\">                            //找到key一样的，则直接替换并退出</div><div class=\"line\">                            if (e.hash == hash &amp;&amp;</div><div class=\"line\">                                ((ek = e.key) == key ||</div><div class=\"line\">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class=\"line\">                                oldVal = e.val;</div><div class=\"line\">                                if (!onlyIfAbsent)</div><div class=\"line\">                                    e.val = value;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            Node&lt;K,V&gt; pred = e;</div><div class=\"line\">                            //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入</div><div class=\"line\">                            if ((e = e.next) == null) &#123;</div><div class=\"line\">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class=\"line\">                                                          value, null);</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //如果是红合树</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;</div><div class=\"line\">                        Node&lt;K,V&gt; p;</div><div class=\"line\">                        //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行</div><div class=\"line\">                        binCount = 2;</div><div class=\"line\">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class=\"line\">                                                       value)) != null) &#123;</div><div class=\"line\">                            oldVal = p.val;</div><div class=\"line\">                            if (!onlyIfAbsent)</div><div class=\"line\">                                p.val = value;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (binCount != 0) &#123;</div><div class=\"line\">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class=\"line\">                    //开始将table中元素为i的数组转变为二叉树</div><div class=\"line\">                    treeifyBin(tab, i);</div><div class=\"line\">                if (oldVal != null)</div><div class=\"line\">                    return oldVal;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //链表或者红黑树不应该增加table的负载</div><div class=\"line\">    addCount(1L, binCount);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash&gt;0一定成立, 若node.hash&lt;0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树</li>\n<li>检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。</li>\n<li>根据i = (n - 1) &amp; hash))确定需要插入table的位置i:</li>\n</ul>\n<ol>\n<li>若table[i]没有元素, 则将key-value存放进去。</li>\n<li>若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)</li>\n<li>否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。</li>\n<li>在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)</li>\n<li>修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。</li>\n</ol>\n<h2 id=\"initTable初始化\"><a href=\"#initTable初始化\" class=\"headerlink\" title=\"initTable初始化\"></a>initTable初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class=\"line\">    Node&lt;K,V&gt;[] tab; int sc;</div><div class=\"line\">    while ((tab = table) == null || tab.length == 0) &#123;//只要没有成功，就一定重新尝试</div><div class=\"line\">        if ((sc = sizeCtl) &lt; 0)  //正在初始化，本节点先尝试放弃cpu的使用</div><div class=\"line\">            Thread.yield(); // lost initialization race; just spin</div><div class=\"line\">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; //这里应该是个原子操作，将sizeCtl设置为-1</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if ((tab = table) == null || tab.length == 0) &#123; //</div><div class=\"line\">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量</div><div class=\"line\">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class=\"line\">                    table = tab = nt;</div><div class=\"line\">                    sc = n - (n &gt;&gt;&gt; 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                sizeCtl = sc;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tab;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>初始化table主要做了如下事情:</p>\n<ul>\n<li>检查sizeCtl, 若发现&lt;0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成</li>\n<li>若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。</li>\n<li>初始化table</li>\n<li>设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数<h2 id=\"addCount\"><a href=\"#addCount\" class=\"headerlink\" title=\"addCount\"></a>addCount</h2>addCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void addCount(long x, int check) &#123;  //若小于0，则不检查扩容</div><div class=\"line\">    CounterCell[] as; long b, s=baseCount+x;</div><div class=\"line\">    .......//更新元素个数metrics</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (check &gt;= 0) &#123; //s是当前table长度</div><div class=\"line\">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class=\"line\">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;//达到容积上限，</div><div class=\"line\">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class=\"line\">            int rs = resizeStamp(n); //根据目前table长度做一个标识</div><div class=\"line\">            if (sc &lt; 0) &#123; //说明table正在扩容</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class=\"line\">                    transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class=\"line\">                    transfer(tab, nt);</div><div class=\"line\">            &#125; //第一个线程开始扩容，sizeCtl = resizeStamp(n)&lt;&lt;16 + 2</div><div class=\"line\">            else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs &lt;&lt; 16 + 2</div><div class=\"line\">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))//rs &gt; 2^15,rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) &gt; 2^31+n,int类型的数就是负数了。</div><div class=\"line\">                transfer(tab, null);</div><div class=\"line\">            s = sumCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。</p>\n<ul>\n<li>若sizeCtl<0, 那么检查是否扩容完成,=\"\" 若扩容完成了,=\"\" 退出;=\"\" 否则将sizectl加1,=\"\" 并进行扩容操作transfer(),=\"\" 详见<a=\"\" href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</0,></li>\n<li>若sizeCtl&gt;0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)&lt;&lt;16 + 2, 并进行扩容transfer()</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。<br>首先放张大图, 对ConcurrentHashMap先有大致的了解。<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"><br>所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。<br>ConcurrentHashMap系列将分为以下三个方面进行详细描述:<br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a></p>\n<h1 id=\"成员变量介绍\"><a href=\"#成员变量介绍\" class=\"headerlink\" title=\"成员变量介绍\"></a>成员变量介绍</h1><p>ConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:</p>\n<ul>\n<li>LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh</li>\n<li>TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。</li>\n<li>UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。</li>\n<li>MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。</li>\n<li>MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容</li>\n<li>TREEBIN, 置为-2, 代表此元素后接红黑树。</li>\n<li>nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。</li>\n<li>sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:<br>  0: table还没有被初始化<br>  -1: table正在初始化<br>  小于-1: 实际值为resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 表明table正在扩容<br>  大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n</li>\n<li>transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标</li>\n<li>ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。</li>\n</ul>\n<h1 id=\"putVal插入数据\"><a href=\"#putVal插入数据\" class=\"headerlink\" title=\"putVal插入数据\"></a>putVal插入数据</h1><p>下面真正开始写入数据:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** Implementation for put and putIfAbsent */</div><div class=\"line\">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class=\"line\">    if (key == null || value == null) throw new NullPointerException();</div><div class=\"line\">    // 定位到table[]中的i</div><div class=\"line\">    int hash = spread(key.hashCode());</div><div class=\"line\">    int binCount = 0;</div><div class=\"line\">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class=\"line\">        //若table为0， 则初始化这个table</div><div class=\"line\">        if (tab == null || (n = tab.length) == 0)</div><div class=\"line\">            tab = initTable(); //首先初始化</div><div class=\"line\">        //根据hash值计算出在table里面的位置</div><div class=\"line\">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class=\"line\">            //如果没有，则向这个位置添加一个节点</div><div class=\"line\">            if (casTabAt(tab, i, null,</div><div class=\"line\">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class=\"line\">                break;                   // no lock when adding to empty bin</div><div class=\"line\">        &#125;</div><div class=\"line\">        //整个table正在扩容</div><div class=\"line\">        else if ((fh = f.hash) == MOVED)</div><div class=\"line\">            //帮着一起扩容</div><div class=\"line\">            tab = helpTransfer(tab, f);</div><div class=\"line\">        //真正插入数据</div><div class=\"line\">        else &#123;</div><div class=\"line\">            V oldVal = null;</div><div class=\"line\">            //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;</div><div class=\"line\">                     //普通的数组</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        binCount = 1;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class=\"line\">                            K ek;</div><div class=\"line\">                            //找到key一样的，则直接替换并退出</div><div class=\"line\">                            if (e.hash == hash &amp;&amp;</div><div class=\"line\">                                ((ek = e.key) == key ||</div><div class=\"line\">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class=\"line\">                                oldVal = e.val;</div><div class=\"line\">                                if (!onlyIfAbsent)</div><div class=\"line\">                                    e.val = value;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            Node&lt;K,V&gt; pred = e;</div><div class=\"line\">                            //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入</div><div class=\"line\">                            if ((e = e.next) == null) &#123;</div><div class=\"line\">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class=\"line\">                                                          value, null);</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //如果是红合树</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;</div><div class=\"line\">                        Node&lt;K,V&gt; p;</div><div class=\"line\">                        //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行</div><div class=\"line\">                        binCount = 2;</div><div class=\"line\">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class=\"line\">                                                       value)) != null) &#123;</div><div class=\"line\">                            oldVal = p.val;</div><div class=\"line\">                            if (!onlyIfAbsent)</div><div class=\"line\">                                p.val = value;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (binCount != 0) &#123;</div><div class=\"line\">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class=\"line\">                    //开始将table中元素为i的数组转变为二叉树</div><div class=\"line\">                    treeifyBin(tab, i);</div><div class=\"line\">                if (oldVal != null)</div><div class=\"line\">                    return oldVal;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //链表或者红黑树不应该增加table的负载</div><div class=\"line\">    addCount(1L, binCount);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash&gt;0一定成立, 若node.hash&lt;0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树</li>\n<li>检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。</li>\n<li>根据i = (n - 1) &amp; hash))确定需要插入table的位置i:</li>\n</ul>\n<ol>\n<li>若table[i]没有元素, 则将key-value存放进去。</li>\n<li>若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)</li>\n<li>否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。</li>\n<li>在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)</li>\n<li>修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。</li>\n</ol>\n<h2 id=\"initTable初始化\"><a href=\"#initTable初始化\" class=\"headerlink\" title=\"initTable初始化\"></a>initTable初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class=\"line\">    Node&lt;K,V&gt;[] tab; int sc;</div><div class=\"line\">    while ((tab = table) == null || tab.length == 0) &#123;//只要没有成功，就一定重新尝试</div><div class=\"line\">        if ((sc = sizeCtl) &lt; 0)  //正在初始化，本节点先尝试放弃cpu的使用</div><div class=\"line\">            Thread.yield(); // lost initialization race; just spin</div><div class=\"line\">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; //这里应该是个原子操作，将sizeCtl设置为-1</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if ((tab = table) == null || tab.length == 0) &#123; //</div><div class=\"line\">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量</div><div class=\"line\">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class=\"line\">                    table = tab = nt;</div><div class=\"line\">                    sc = n - (n &gt;&gt;&gt; 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                sizeCtl = sc;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tab;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>初始化table主要做了如下事情:</p>\n<ul>\n<li>检查sizeCtl, 若发现&lt;0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成</li>\n<li>若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。</li>\n<li>初始化table</li>\n<li>设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数<h2 id=\"addCount\"><a href=\"#addCount\" class=\"headerlink\" title=\"addCount\"></a>addCount</h2>addCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void addCount(long x, int check) &#123;  //若小于0，则不检查扩容</div><div class=\"line\">    CounterCell[] as; long b, s=baseCount+x;</div><div class=\"line\">    .......//更新元素个数metrics</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (check &gt;= 0) &#123; //s是当前table长度</div><div class=\"line\">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class=\"line\">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;//达到容积上限，</div><div class=\"line\">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class=\"line\">            int rs = resizeStamp(n); //根据目前table长度做一个标识</div><div class=\"line\">            if (sc &lt; 0) &#123; //说明table正在扩容</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class=\"line\">                    transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class=\"line\">                    transfer(tab, nt);</div><div class=\"line\">            &#125; //第一个线程开始扩容，sizeCtl = resizeStamp(n)&lt;&lt;16 + 2</div><div class=\"line\">            else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs &lt;&lt; 16 + 2</div><div class=\"line\">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))//rs &gt; 2^15,rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) &gt; 2^31+n,int类型的数就是负数了。</div><div class=\"line\">                transfer(tab, null);</div><div class=\"line\">            s = sumCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。</p>\n<ul>\n<li>若sizeCtl<0, 那么检查是否扩容完成,=\"\" 若扩容完成了,=\"\" 退出;=\"\" 否则将sizectl加1,=\"\" 并进行扩容操作transfer(),=\"\" 详见<a=\"\" href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</0,></li>\n<li>若sizeCtl&gt;0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)&lt;&lt;16 + 2, 并进行扩容transfer()</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。</p>\n"},{"title":"ConcurrentHashMap扩容源码介绍","date":"2017-11-14T03:21:07.000Z","_content":"在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:\n+ 一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容\n+ 一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。\n\n# 协助扩容helpTransfer()\n下面是协助扩容的过程:\n```\nfinal Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { //table扩容\n        Node<K,V>[] nextTab; int sc;\n        if (tab != null && (f instanceof ForwardingNode) &&\n            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n            // 根据 length 得到一个标识符号\n            int rs = resizeStamp(tab.length);\n            while (nextTab == nextTable && table == tab &&\n                   (sc = sizeCtl) < 0) {//说明还在扩容\n                //判断是否标志发生了变化||  扩容结束了\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）\n                    sc == rs + MAX_RESIZERS || transferIndex <= 0)\n                    break;\n                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {\n                    transfer(tab, nextTab);\n                    break;\n                }\n            }\n            return nextTab;\n        }\n        return table;\n    }\n```\n主要做了如下事情:\n+ 检查是否扩容完成\n扩容期间c >>> RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex <= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs << RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。\n+ 对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。\n\n## 扩容transfer\n扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。\n```\n    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n        int n = tab.length, stride;\n        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n           // subdivide range，每个线程最少迁移16个槽位，大的话，最多\n            stride = MIN_TRANSFER_STRIDE;\n        // initiating  才开始初始化新的nextTab\n        if (nextTab == null) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];  //扩容2倍\n                nextTab = nt;\n            } catch (Throwable ex) {      // try to cope with OOME\n                sizeCtl = Integer.MAX_VALUE;\n                return;\n            }\n            nextTable = nextTab;\n            transferIndex = n;//更新的转移下标，\n        }\n        int nextn = nextTab.length;\n        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n        //是否能够向前推进到下一个周期\n        boolean advance = true;\n        // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法\n        boolean finishing = false;\n        for (int i = 0, bound = 0;;) {\n            Node<K,V> f; int fh;\n            while (advance) { //取下一个周期\n                int nextIndex, nextBound;\n                //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理\n                if (--i >= bound || finishing)\n                    advance = false;\n                //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间\n                else if ((nextIndex = transferIndex) <= 0) {\n                    i = -1;\n                    advance = false;\n                }\n                //这个条件改变的是transferIndex的值，从16变成了1\n                else if (U.compareAndSwapInt\n                         (this, TRANSFERINDEX, nextIndex,\n                         //nextBound 是这次迁移任务的边界，注意，是从后往前\n                          nextBound = (nextIndex > stride ?\n                                       nextIndex - stride : 0))) {\n                    bound = nextBound; //一块区间最小桶的下标\n                    i = nextIndex - 1; //能够处理的最大桶的下标\n                    advance = false;\n                }\n            }\n            if (i < 0 || i >= n || i + n >= nextn) { //每个迁移线程都能达到这里\n                int sc;\n                if (finishing) { //迁移完成\n                    nextTable = null;\n                    //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的\n                    table = nextTab;\n                    sizeCtl = (n << 1) - (n >>> 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值\n                    return;\n                }\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n            }\n            //如果对应位置为null， 则将ForwardingNode放在对应的地方\n            else if ((f = tabAt(tab, i)) == null)\n                advance = casTabAt(tab, i, null, fwd);\n            else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标\n                advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束\n            else { //说明位置上有值了，\n                //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {//判断i下标和f是否相同\n                        Node<K,V> ln, hn; //高位桶， 地位桶\n                        if (fh >= 0) {\n                            int runBit = fh & n;//n为2^n, 取余后只能是2^n\n                            Node<K,V> lastRun = f;\n                            ///找到最后一个不和fn相同的节点\n                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n                                int b = p.hash & n;\n                                //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的\n                                if (b != runBit) {\n                                    runBit = b;\n                                    lastRun = p;\n                                }\n                            }\n                            if (runBit == 0) {\n                                ln = lastRun;\n                                hn = null;\n                            }\n                            else { //比如1，16，32,如果低位%16，那么肯定是0。\n                                hn = lastRun;\n                                ln = null;\n                            }\n                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                                int ph = p.hash; K pk = p.key; V pv = p.val;\n                                if ((ph & n) == 0)\n                                     //这样就把相同串的给串起来了\n                                    ln = new Node<K,V>(ph, pk, pv, ln);\n                                else\n                                    //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。\n                                    hn = new Node<K,V>(ph, pk, pv, hn);\n                            }\n                            setTabAt(nextTab, i, ln); //反着给串起来了\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                        else if (f instanceof TreeBin) {// 如果是红黑树\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> lo = null, loTail = null; //也是高低节点\n                            TreeNode<K,V> hi = null, hiTail = null;//也是高低节点\n                            int lc = 0, hc = 0;\n                            for (Node<K,V> e = t.first; e != null; e = e.next) { //中序遍历红黑树\n                                int h = e.hash;\n                                TreeNode<K,V> p = new TreeNode<K,V>\n                                    (h, e.key, e.val, null, null);\n                                if ((h & n) == 0) { //0的放低位\n                                    //注意这里p.prev = loTail，每一个p都是下一个的prev\n                                    if ((p.prev = loTail) == null)\n                                        lo = p; //把头记住\n                                    else\n                                        loTail.next = p;  //上一次的p的next是这次的p\n                                    loTail = p; //把上次p给记住\n                                    ++lc;\n                                }\n                                else { //高位\n                                    if ((p.prev = hiTail) == null)\n                                        hi = p; //把尾记住\n                                    else\n                                        hiTail.next = p;\n                                    hiTail = p;\n                                    ++hc;\n                                }\n                            }\n                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树\n                                (hc != 0) ? new TreeBin<K,V>(lo) : t; //如果没有高低的话，则部分为两个树\n                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                                (lc != 0) ? new TreeBin<K,V>(hi) : t;\n                            setTabAt(nextTab, i, ln);\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n其中有两个变量需要了解下:\nadvance: 表示是否可以向下一个轮元素进行迁移。\nfinishing: table所有元素是否迁移完成。\n大致做了如下事情:\n+ 确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。\n+ 检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。\n+ 进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。\n+ 从i -> bound开始遍历table中每个元素, 这里是`从大到小`遍历的:\n1. 若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。\n2. 若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。\n3. 否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash>0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。\n+ 链表迁移原理如下: `遍历链表每个节点。 若节点的f.hash&n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面`。\n迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。\n首先放一个张图展示扩容的变化:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"/>\n蓝色节点代表:f.hash&n==0, 绿色节点代表f.hash&n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。\n+ 迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。\n4.如何确定table所有元素迁移完成:\n```\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n```\n第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) << RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl> resizeStamp(n) << RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。\n# 总结\ntable扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。\n","source":"_posts/ConcurrentHashMap扩容过程介绍.md","raw":"---\ntitle: ConcurrentHashMap扩容源码介绍\ndate: 2017-11-14 11:21:07\ntags:\n---\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:\n+ 一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容\n+ 一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。\n\n# 协助扩容helpTransfer()\n下面是协助扩容的过程:\n```\nfinal Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { //table扩容\n        Node<K,V>[] nextTab; int sc;\n        if (tab != null && (f instanceof ForwardingNode) &&\n            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n            // 根据 length 得到一个标识符号\n            int rs = resizeStamp(tab.length);\n            while (nextTab == nextTable && table == tab &&\n                   (sc = sizeCtl) < 0) {//说明还在扩容\n                //判断是否标志发生了变化||  扩容结束了\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）\n                    sc == rs + MAX_RESIZERS || transferIndex <= 0)\n                    break;\n                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {\n                    transfer(tab, nextTab);\n                    break;\n                }\n            }\n            return nextTab;\n        }\n        return table;\n    }\n```\n主要做了如下事情:\n+ 检查是否扩容完成\n扩容期间c >>> RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex <= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs << RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。\n+ 对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。\n\n## 扩容transfer\n扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。\n```\n    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n        int n = tab.length, stride;\n        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n           // subdivide range，每个线程最少迁移16个槽位，大的话，最多\n            stride = MIN_TRANSFER_STRIDE;\n        // initiating  才开始初始化新的nextTab\n        if (nextTab == null) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];  //扩容2倍\n                nextTab = nt;\n            } catch (Throwable ex) {      // try to cope with OOME\n                sizeCtl = Integer.MAX_VALUE;\n                return;\n            }\n            nextTable = nextTab;\n            transferIndex = n;//更新的转移下标，\n        }\n        int nextn = nextTab.length;\n        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n        //是否能够向前推进到下一个周期\n        boolean advance = true;\n        // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法\n        boolean finishing = false;\n        for (int i = 0, bound = 0;;) {\n            Node<K,V> f; int fh;\n            while (advance) { //取下一个周期\n                int nextIndex, nextBound;\n                //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理\n                if (--i >= bound || finishing)\n                    advance = false;\n                //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间\n                else if ((nextIndex = transferIndex) <= 0) {\n                    i = -1;\n                    advance = false;\n                }\n                //这个条件改变的是transferIndex的值，从16变成了1\n                else if (U.compareAndSwapInt\n                         (this, TRANSFERINDEX, nextIndex,\n                         //nextBound 是这次迁移任务的边界，注意，是从后往前\n                          nextBound = (nextIndex > stride ?\n                                       nextIndex - stride : 0))) {\n                    bound = nextBound; //一块区间最小桶的下标\n                    i = nextIndex - 1; //能够处理的最大桶的下标\n                    advance = false;\n                }\n            }\n            if (i < 0 || i >= n || i + n >= nextn) { //每个迁移线程都能达到这里\n                int sc;\n                if (finishing) { //迁移完成\n                    nextTable = null;\n                    //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的\n                    table = nextTab;\n                    sizeCtl = (n << 1) - (n >>> 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值\n                    return;\n                }\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n            }\n            //如果对应位置为null， 则将ForwardingNode放在对应的地方\n            else if ((f = tabAt(tab, i)) == null)\n                advance = casTabAt(tab, i, null, fwd);\n            else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标\n                advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束\n            else { //说明位置上有值了，\n                //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {//判断i下标和f是否相同\n                        Node<K,V> ln, hn; //高位桶， 地位桶\n                        if (fh >= 0) {\n                            int runBit = fh & n;//n为2^n, 取余后只能是2^n\n                            Node<K,V> lastRun = f;\n                            ///找到最后一个不和fn相同的节点\n                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n                                int b = p.hash & n;\n                                //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的\n                                if (b != runBit) {\n                                    runBit = b;\n                                    lastRun = p;\n                                }\n                            }\n                            if (runBit == 0) {\n                                ln = lastRun;\n                                hn = null;\n                            }\n                            else { //比如1，16，32,如果低位%16，那么肯定是0。\n                                hn = lastRun;\n                                ln = null;\n                            }\n                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                                int ph = p.hash; K pk = p.key; V pv = p.val;\n                                if ((ph & n) == 0)\n                                     //这样就把相同串的给串起来了\n                                    ln = new Node<K,V>(ph, pk, pv, ln);\n                                else\n                                    //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。\n                                    hn = new Node<K,V>(ph, pk, pv, hn);\n                            }\n                            setTabAt(nextTab, i, ln); //反着给串起来了\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                        else if (f instanceof TreeBin) {// 如果是红黑树\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> lo = null, loTail = null; //也是高低节点\n                            TreeNode<K,V> hi = null, hiTail = null;//也是高低节点\n                            int lc = 0, hc = 0;\n                            for (Node<K,V> e = t.first; e != null; e = e.next) { //中序遍历红黑树\n                                int h = e.hash;\n                                TreeNode<K,V> p = new TreeNode<K,V>\n                                    (h, e.key, e.val, null, null);\n                                if ((h & n) == 0) { //0的放低位\n                                    //注意这里p.prev = loTail，每一个p都是下一个的prev\n                                    if ((p.prev = loTail) == null)\n                                        lo = p; //把头记住\n                                    else\n                                        loTail.next = p;  //上一次的p的next是这次的p\n                                    loTail = p; //把上次p给记住\n                                    ++lc;\n                                }\n                                else { //高位\n                                    if ((p.prev = hiTail) == null)\n                                        hi = p; //把尾记住\n                                    else\n                                        hiTail.next = p;\n                                    hiTail = p;\n                                    ++hc;\n                                }\n                            }\n                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树\n                                (hc != 0) ? new TreeBin<K,V>(lo) : t; //如果没有高低的话，则部分为两个树\n                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                                (lc != 0) ? new TreeBin<K,V>(hi) : t;\n                            setTabAt(nextTab, i, ln);\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n其中有两个变量需要了解下:\nadvance: 表示是否可以向下一个轮元素进行迁移。\nfinishing: table所有元素是否迁移完成。\n大致做了如下事情:\n+ 确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。\n+ 检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。\n+ 进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。\n+ 从i -> bound开始遍历table中每个元素, 这里是`从大到小`遍历的:\n1. 若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。\n2. 若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。\n3. 否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash>0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。\n+ 链表迁移原理如下: `遍历链表每个节点。 若节点的f.hash&n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面`。\n迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。\n首先放一个张图展示扩容的变化:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"/>\n蓝色节点代表:f.hash&n==0, 绿色节点代表f.hash&n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。\n+ 迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。\n4.如何确定table所有元素迁移完成:\n```\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n```\n第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) << RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl> resizeStamp(n) << RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。\n# 总结\ntable扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。\n","slug":"ConcurrentHashMap扩容过程介绍","published":1,"updated":"2018-10-14T08:15:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lv00001isu5n7ptvfmt","content":"<p>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:</p>\n<ul>\n<li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li>\n<li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</li>\n</ul>\n<h1 id=\"协助扩容helpTransfer\"><a href=\"#协助扩容helpTransfer\" class=\"headerlink\" title=\"协助扩容helpTransfer()\"></a>协助扩容helpTransfer()</h1><p>下面是协助扩容的过程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; //table扩容</div><div class=\"line\">        Node&lt;K,V&gt;[] nextTab; int sc;</div><div class=\"line\">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div class=\"line\">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</div><div class=\"line\">            // 根据 length 得到一个标识符号</div><div class=\"line\">            int rs = resizeStamp(tab.length);</div><div class=\"line\">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class=\"line\">                   (sc = sizeCtl) &lt; 0) &#123;//说明还在扩容</div><div class=\"line\">                //判断是否标志发生了变化||  扩容结束了</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</div><div class=\"line\">                    transfer(tab, nextTab);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return nextTab;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return table;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>检查是否扩容完成<br>扩容期间c &gt;&gt;&gt; RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex &lt;= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs &lt;&lt; RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。</li>\n<li>对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</li>\n</ul>\n<h2 id=\"扩容transfer\"><a href=\"#扩容transfer\" class=\"headerlink\" title=\"扩容transfer\"></a>扩容transfer</h2><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class=\"line\">    int n = tab.length, stride;</div><div class=\"line\">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class=\"line\">       // subdivide range，每个线程最少迁移16个槽位，大的话，最多</div><div class=\"line\">        stride = MIN_TRANSFER_STRIDE;</div><div class=\"line\">    // initiating  才开始初始化新的nextTab</div><div class=\"line\">    if (nextTab == null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];  //扩容2倍</div><div class=\"line\">            nextTab = nt;</div><div class=\"line\">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class=\"line\">            sizeCtl = Integer.MAX_VALUE;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        nextTable = nextTab;</div><div class=\"line\">        transferIndex = n;//更新的转移下标，</div><div class=\"line\">    &#125;</div><div class=\"line\">    int nextn = nextTab.length;</div><div class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class=\"line\">    //是否能够向前推进到下一个周期</div><div class=\"line\">    boolean advance = true;</div><div class=\"line\">    // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法</div><div class=\"line\">    boolean finishing = false;</div><div class=\"line\">    for (int i = 0, bound = 0;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int fh;</div><div class=\"line\">        while (advance) &#123; //取下一个周期</div><div class=\"line\">            int nextIndex, nextBound;</div><div class=\"line\">            //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理</div><div class=\"line\">            if (--i &gt;= bound || finishing)</div><div class=\"line\">                advance = false;</div><div class=\"line\">            //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间</div><div class=\"line\">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</div><div class=\"line\">                i = -1;</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //这个条件改变的是transferIndex的值，从16变成了1</div><div class=\"line\">            else if (U.compareAndSwapInt</div><div class=\"line\">                     (this, TRANSFERINDEX, nextIndex,</div><div class=\"line\">                     //nextBound 是这次迁移任务的边界，注意，是从后往前</div><div class=\"line\">                      nextBound = (nextIndex &gt; stride ?</div><div class=\"line\">                                   nextIndex - stride : 0))) &#123;</div><div class=\"line\">                bound = nextBound; //一块区间最小桶的下标</div><div class=\"line\">                i = nextIndex - 1; //能够处理的最大桶的下标</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; //每个迁移线程都能达到这里</div><div class=\"line\">            int sc;</div><div class=\"line\">            if (finishing) &#123; //迁移完成</div><div class=\"line\">                nextTable = null;</div><div class=\"line\">                //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的</div><div class=\"line\">                table = nextTab;</div><div class=\"line\">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //表示当前线程迁移完成了</div><div class=\"line\">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">                 //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">                    return;</div><div class=\"line\">                finishing = advance = true;</div><div class=\"line\">                i = n; // recheck before commit</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //如果对应位置为null， 则将ForwardingNode放在对应的地方</div><div class=\"line\">        else if ((f = tabAt(tab, i)) == null)</div><div class=\"line\">            advance = casTabAt(tab, i, null, fwd);</div><div class=\"line\">        else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标</div><div class=\"line\">            advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束</div><div class=\"line\">        else &#123; //说明位置上有值了，</div><div class=\"line\">            //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;//判断i下标和f是否相同</div><div class=\"line\">                    Node&lt;K,V&gt; ln, hn; //高位桶， 地位桶</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        int runBit = fh &amp; n;//n为2^n, 取余后只能是2^n</div><div class=\"line\">                        Node&lt;K,V&gt; lastRun = f;</div><div class=\"line\">                        ///找到最后一个不和fn相同的节点</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class=\"line\">                            int b = p.hash &amp; n;</div><div class=\"line\">                            //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的</div><div class=\"line\">                            if (b != runBit) &#123;</div><div class=\"line\">                                runBit = b;</div><div class=\"line\">                                lastRun = p;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (runBit == 0) &#123;</div><div class=\"line\">                            ln = lastRun;</div><div class=\"line\">                            hn = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        else &#123; //比如1，16，32,如果低位%16，那么肯定是0。</div><div class=\"line\">                            hn = lastRun;</div><div class=\"line\">                            ln = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class=\"line\">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class=\"line\">                            if ((ph &amp; n) == 0)</div><div class=\"line\">                                 //这样就把相同串的给串起来了</div><div class=\"line\">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class=\"line\">                            else</div><div class=\"line\">                                //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。</div><div class=\"line\">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        setTabAt(nextTab, i, ln); //反着给串起来了</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;// 如果是红黑树</div><div class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class=\"line\">                        TreeNode&lt;K,V&gt; lo = null, loTail = null; //也是高低节点</div><div class=\"line\">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;//也是高低节点</div><div class=\"line\">                        int lc = 0, hc = 0;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; //中序遍历红黑树</div><div class=\"line\">                            int h = e.hash;</div><div class=\"line\">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class=\"line\">                                (h, e.key, e.val, null, null);</div><div class=\"line\">                            if ((h &amp; n) == 0) &#123; //0的放低位</div><div class=\"line\">                                //注意这里p.prev = loTail，每一个p都是下一个的prev</div><div class=\"line\">                                if ((p.prev = loTail) == null)</div><div class=\"line\">                                    lo = p; //把头记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    loTail.next = p;  //上一次的p的next是这次的p</div><div class=\"line\">                                loTail = p; //把上次p给记住</div><div class=\"line\">                                ++lc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            else &#123; //高位</div><div class=\"line\">                                if ((p.prev = hiTail) == null)</div><div class=\"line\">                                    hi = p; //把尾记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    hiTail.next = p;</div><div class=\"line\">                                hiTail = p;</div><div class=\"line\">                                ++hc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树</div><div class=\"line\">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; //如果没有高低的话，则部分为两个树</div><div class=\"line\">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class=\"line\">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class=\"line\">                        setTabAt(nextTab, i, ln);</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有两个变量需要了解下:<br>advance: 表示是否可以向下一个轮元素进行迁移。<br>finishing: table所有元素是否迁移完成。<br>大致做了如下事情:</p>\n<ul>\n<li>确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。</li>\n<li>检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。</li>\n<li>进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。</li>\n<li>从i -&gt; bound开始遍历table中每个元素, 这里是<code>从大到小</code>遍历的:</li>\n</ul>\n<ol>\n<li>若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。</li>\n<li>若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。</li>\n<li>否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。</li>\n</ol>\n<ul>\n<li>链表迁移原理如下: <code>遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面</code>。<br>迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。<br>首先放一个张图展示扩容的变化:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"><br>蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。</li>\n<li>迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。<br>4.如何确定table所有元素迁移完成:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//表示当前线程迁移完成了</div><div class=\"line\">if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">        return;</div><div class=\"line\">    finishing = advance = true;</div><div class=\"line\">    i = n; // recheck before commit</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:</p>\n<ul>\n<li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li>\n<li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</li>\n</ul>\n<h1 id=\"协助扩容helpTransfer\"><a href=\"#协助扩容helpTransfer\" class=\"headerlink\" title=\"协助扩容helpTransfer()\"></a>协助扩容helpTransfer()</h1><p>下面是协助扩容的过程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; //table扩容</div><div class=\"line\">        Node&lt;K,V&gt;[] nextTab; int sc;</div><div class=\"line\">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div class=\"line\">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</div><div class=\"line\">            // 根据 length 得到一个标识符号</div><div class=\"line\">            int rs = resizeStamp(tab.length);</div><div class=\"line\">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class=\"line\">                   (sc = sizeCtl) &lt; 0) &#123;//说明还在扩容</div><div class=\"line\">                //判断是否标志发生了变化||  扩容结束了</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</div><div class=\"line\">                    transfer(tab, nextTab);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return nextTab;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return table;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>检查是否扩容完成<br>扩容期间c &gt;&gt;&gt; RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex &lt;= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs &lt;&lt; RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。</li>\n<li>对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</li>\n</ul>\n<h2 id=\"扩容transfer\"><a href=\"#扩容transfer\" class=\"headerlink\" title=\"扩容transfer\"></a>扩容transfer</h2><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class=\"line\">    int n = tab.length, stride;</div><div class=\"line\">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class=\"line\">       // subdivide range，每个线程最少迁移16个槽位，大的话，最多</div><div class=\"line\">        stride = MIN_TRANSFER_STRIDE;</div><div class=\"line\">    // initiating  才开始初始化新的nextTab</div><div class=\"line\">    if (nextTab == null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];  //扩容2倍</div><div class=\"line\">            nextTab = nt;</div><div class=\"line\">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class=\"line\">            sizeCtl = Integer.MAX_VALUE;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        nextTable = nextTab;</div><div class=\"line\">        transferIndex = n;//更新的转移下标，</div><div class=\"line\">    &#125;</div><div class=\"line\">    int nextn = nextTab.length;</div><div class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class=\"line\">    //是否能够向前推进到下一个周期</div><div class=\"line\">    boolean advance = true;</div><div class=\"line\">    // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法</div><div class=\"line\">    boolean finishing = false;</div><div class=\"line\">    for (int i = 0, bound = 0;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int fh;</div><div class=\"line\">        while (advance) &#123; //取下一个周期</div><div class=\"line\">            int nextIndex, nextBound;</div><div class=\"line\">            //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理</div><div class=\"line\">            if (--i &gt;= bound || finishing)</div><div class=\"line\">                advance = false;</div><div class=\"line\">            //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间</div><div class=\"line\">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</div><div class=\"line\">                i = -1;</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //这个条件改变的是transferIndex的值，从16变成了1</div><div class=\"line\">            else if (U.compareAndSwapInt</div><div class=\"line\">                     (this, TRANSFERINDEX, nextIndex,</div><div class=\"line\">                     //nextBound 是这次迁移任务的边界，注意，是从后往前</div><div class=\"line\">                      nextBound = (nextIndex &gt; stride ?</div><div class=\"line\">                                   nextIndex - stride : 0))) &#123;</div><div class=\"line\">                bound = nextBound; //一块区间最小桶的下标</div><div class=\"line\">                i = nextIndex - 1; //能够处理的最大桶的下标</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; //每个迁移线程都能达到这里</div><div class=\"line\">            int sc;</div><div class=\"line\">            if (finishing) &#123; //迁移完成</div><div class=\"line\">                nextTable = null;</div><div class=\"line\">                //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的</div><div class=\"line\">                table = nextTab;</div><div class=\"line\">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //表示当前线程迁移完成了</div><div class=\"line\">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">                 //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">                    return;</div><div class=\"line\">                finishing = advance = true;</div><div class=\"line\">                i = n; // recheck before commit</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //如果对应位置为null， 则将ForwardingNode放在对应的地方</div><div class=\"line\">        else if ((f = tabAt(tab, i)) == null)</div><div class=\"line\">            advance = casTabAt(tab, i, null, fwd);</div><div class=\"line\">        else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标</div><div class=\"line\">            advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束</div><div class=\"line\">        else &#123; //说明位置上有值了，</div><div class=\"line\">            //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;//判断i下标和f是否相同</div><div class=\"line\">                    Node&lt;K,V&gt; ln, hn; //高位桶， 地位桶</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        int runBit = fh &amp; n;//n为2^n, 取余后只能是2^n</div><div class=\"line\">                        Node&lt;K,V&gt; lastRun = f;</div><div class=\"line\">                        ///找到最后一个不和fn相同的节点</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class=\"line\">                            int b = p.hash &amp; n;</div><div class=\"line\">                            //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的</div><div class=\"line\">                            if (b != runBit) &#123;</div><div class=\"line\">                                runBit = b;</div><div class=\"line\">                                lastRun = p;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (runBit == 0) &#123;</div><div class=\"line\">                            ln = lastRun;</div><div class=\"line\">                            hn = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        else &#123; //比如1，16，32,如果低位%16，那么肯定是0。</div><div class=\"line\">                            hn = lastRun;</div><div class=\"line\">                            ln = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class=\"line\">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class=\"line\">                            if ((ph &amp; n) == 0)</div><div class=\"line\">                                 //这样就把相同串的给串起来了</div><div class=\"line\">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class=\"line\">                            else</div><div class=\"line\">                                //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。</div><div class=\"line\">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        setTabAt(nextTab, i, ln); //反着给串起来了</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;// 如果是红黑树</div><div class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class=\"line\">                        TreeNode&lt;K,V&gt; lo = null, loTail = null; //也是高低节点</div><div class=\"line\">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;//也是高低节点</div><div class=\"line\">                        int lc = 0, hc = 0;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; //中序遍历红黑树</div><div class=\"line\">                            int h = e.hash;</div><div class=\"line\">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class=\"line\">                                (h, e.key, e.val, null, null);</div><div class=\"line\">                            if ((h &amp; n) == 0) &#123; //0的放低位</div><div class=\"line\">                                //注意这里p.prev = loTail，每一个p都是下一个的prev</div><div class=\"line\">                                if ((p.prev = loTail) == null)</div><div class=\"line\">                                    lo = p; //把头记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    loTail.next = p;  //上一次的p的next是这次的p</div><div class=\"line\">                                loTail = p; //把上次p给记住</div><div class=\"line\">                                ++lc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            else &#123; //高位</div><div class=\"line\">                                if ((p.prev = hiTail) == null)</div><div class=\"line\">                                    hi = p; //把尾记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    hiTail.next = p;</div><div class=\"line\">                                hiTail = p;</div><div class=\"line\">                                ++hc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树</div><div class=\"line\">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; //如果没有高低的话，则部分为两个树</div><div class=\"line\">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class=\"line\">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class=\"line\">                        setTabAt(nextTab, i, ln);</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有两个变量需要了解下:<br>advance: 表示是否可以向下一个轮元素进行迁移。<br>finishing: table所有元素是否迁移完成。<br>大致做了如下事情:</p>\n<ul>\n<li>确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。</li>\n<li>检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。</li>\n<li>进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。</li>\n<li>从i -&gt; bound开始遍历table中每个元素, 这里是<code>从大到小</code>遍历的:</li>\n</ul>\n<ol>\n<li>若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。</li>\n<li>若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。</li>\n<li>否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。</li>\n</ol>\n<ul>\n<li>链表迁移原理如下: <code>遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面</code>。<br>迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。<br>首先放一个张图展示扩容的变化:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"><br>蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。</li>\n<li>迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。<br>4.如何确定table所有元素迁移完成:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//表示当前线程迁移完成了</div><div class=\"line\">if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">        return;</div><div class=\"line\">    finishing = advance = true;</div><div class=\"line\">    i = n; // recheck before commit</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p>\n"},{"title":"CountDownLatch源码解读","date":"2017-08-24T08:47:06.000Z","_content":"CountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\nCountDownLatch与ReentrantLock的主要区别是:\n+ CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。\n+ CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。\nCountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。\nCountDownLatch使用方法如下:\n```\nCountDownLatch countDownLatch = new CountDownLatch(3);\n//获取共享锁,获取不到就阻塞\ncountDownLatch.await();\n //释放一份共享锁\ncountDownLatch.countDown();\n```\nawait()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。\n## countDown()\ncountDown()对state减1一:\n```\n    public final boolean releaseShared(int arg) {\n          //如果state为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了如下两个事情:\n+ 对state减一\n+ 若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:\n```\n    private void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                //若是singal，那么就会通知\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播\n                else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            // 如果发生了变动，说明一个线程被唤醒了\n            if (h == head)                    // loop if head changed,\n                break;\n        }\n    }\n```\n这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:\n+ 若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。\n+ 若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。\n+ 若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。\n+ 若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。\n需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。\n释放一个锁的整体过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch3.png\" height=\"250\" width=\"700\"/>\n\n\n## await()\nawait()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n主要做了如下事情:\n+ 首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。\n+ 检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念\n+ 若state > 0, 则需要将该线程加入等待队列。\n加入等待队列在doAcquireSharedInterruptibly中完成的。\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED); //创建共享锁\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) { //如果前继节点是头结点，\n                    int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的\n                    if (r >= 0) { //如果为0，就说明可以退出了\n                        setHeadAndPropagate(node, r); //向下传播释放锁的信号，\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:\n+ 首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch1.png\" height=\"200\" width=\"450\"/>\n+ 开始自旋, 进行判断:\n1. 若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。\n2. 通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。\n+ 若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。\n向后传播通过setHeadAndPropagate()完成, 也是比较简单的:\n```\n    private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node); //node前继节点就是头结点\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 || //如果\n            (h = head) == null || h.waitStatus < 0) { //这里是重复的\n            Node s = node.next;\n            if (s == null || s.isShared()) //本节点是共享的\n                doReleaseShared();\n        }\n    }\n```\n首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。\n获取所得过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch4.png\" height=\"250\" width=\"800\"/>\n\n\n## 超时等待\n在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:\n```\nCountDownLatch.await(100000, TimeUnit.MILLISECONDS)\n```\n指的是, 超时等待100s, 自动退出, `并不会因为超时没有获取到锁而抛出异常`。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。\ndoAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。\n\n## ReentrantLock和CountDownLatch对比\nReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。\nCountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。\n\n## 总结\nCountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。","source":"_posts/CountDownLatch源码解读.md","raw":"---\ntitle: CountDownLatch源码解读\ndate: 2017-08-24 16:47:06\ntags:\n---\nCountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\nCountDownLatch与ReentrantLock的主要区别是:\n+ CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。\n+ CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。\nCountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。\nCountDownLatch使用方法如下:\n```\nCountDownLatch countDownLatch = new CountDownLatch(3);\n//获取共享锁,获取不到就阻塞\ncountDownLatch.await();\n //释放一份共享锁\ncountDownLatch.countDown();\n```\nawait()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。\n## countDown()\ncountDown()对state减1一:\n```\n    public final boolean releaseShared(int arg) {\n          //如果state为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了如下两个事情:\n+ 对state减一\n+ 若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:\n```\n    private void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                //若是singal，那么就会通知\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播\n                else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            // 如果发生了变动，说明一个线程被唤醒了\n            if (h == head)                    // loop if head changed,\n                break;\n        }\n    }\n```\n这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:\n+ 若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。\n+ 若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。\n+ 若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。\n+ 若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。\n需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。\n释放一个锁的整体过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch3.png\" height=\"250\" width=\"700\"/>\n\n\n## await()\nawait()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n主要做了如下事情:\n+ 首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。\n+ 检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念\n+ 若state > 0, 则需要将该线程加入等待队列。\n加入等待队列在doAcquireSharedInterruptibly中完成的。\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED); //创建共享锁\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) { //如果前继节点是头结点，\n                    int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的\n                    if (r >= 0) { //如果为0，就说明可以退出了\n                        setHeadAndPropagate(node, r); //向下传播释放锁的信号，\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:\n+ 首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch1.png\" height=\"200\" width=\"450\"/>\n+ 开始自旋, 进行判断:\n1. 若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。\n2. 通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。\n+ 若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。\n向后传播通过setHeadAndPropagate()完成, 也是比较简单的:\n```\n    private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node); //node前继节点就是头结点\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 || //如果\n            (h = head) == null || h.waitStatus < 0) { //这里是重复的\n            Node s = node.next;\n            if (s == null || s.isShared()) //本节点是共享的\n                doReleaseShared();\n        }\n    }\n```\n首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。\n获取所得过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch4.png\" height=\"250\" width=\"800\"/>\n\n\n## 超时等待\n在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:\n```\nCountDownLatch.await(100000, TimeUnit.MILLISECONDS)\n```\n指的是, 超时等待100s, 自动退出, `并不会因为超时没有获取到锁而抛出异常`。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。\ndoAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。\n\n## ReentrantLock和CountDownLatch对比\nReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。\nCountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。\n\n## 总结\nCountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。","slug":"CountDownLatch源码解读","published":1,"updated":"2018-10-29T01:26:37.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lv30002isu556kta6hp","content":"<p>CountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>CountDownLatch与ReentrantLock的主要区别是:</p>\n<ul>\n<li>CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。</li>\n<li>CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。<br>CountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。<br>CountDownLatch使用方法如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch countDownLatch = new CountDownLatch(3);</div><div class=\"line\">//获取共享锁,获取不到就阻塞</div><div class=\"line\">countDownLatch.await();</div><div class=\"line\"> //释放一份共享锁</div><div class=\"line\">countDownLatch.countDown();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>await()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。</p>\n<h2 id=\"countDown\"><a href=\"#countDown\" class=\"headerlink\" title=\"countDown()\"></a>countDown()</h2><p>countDown()对state减1一:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">      //如果state为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下两个事情:</p>\n<ul>\n<li>对state减一</li>\n<li>若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doReleaseShared() &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Ensure that a release propagates, even if there are other</div><div class=\"line\">     * in-progress acquires/releases.  This proceeds in the usual</div><div class=\"line\">     * way of trying to unparkSuccessor of head if it needs</div><div class=\"line\">     * signal. But if it does not, status is set to PROPAGATE to</div><div class=\"line\">     * ensure that upon release, propagation continues.</div><div class=\"line\">     * Additionally, we must loop in case a new node is added</div><div class=\"line\">     * while we are doing this. Also, unlike other uses of</div><div class=\"line\">     * unparkSuccessor, we need to know if CAS to reset status</div><div class=\"line\">     * fails, if so rechecking.</div><div class=\"line\">     */</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        if (h != null &amp;&amp; h != tail) &#123;</div><div class=\"line\">            int ws = h.waitStatus;</div><div class=\"line\">            //若是singal，那么就会通知</div><div class=\"line\">            if (ws == Node.SIGNAL) &#123;</div><div class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class=\"line\">                    continue;            // loop to recheck cases</div><div class=\"line\">                unparkSuccessor(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播</div><div class=\"line\">            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class=\"line\">                continue;                // loop on failed CAS</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 如果发生了变动，说明一个线程被唤醒了</div><div class=\"line\">        if (h == head)                    // loop if head changed,</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:</p>\n<ul>\n<li>若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。</li>\n<li>若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。</li>\n<li>若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。</li>\n<li>若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。<br>需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。<br>释放一个锁的整体过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch3.png\" height=\"250\" width=\"700\"></li>\n</ul>\n<h2 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await()\"></a>await()</h2><p>await()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireSharedInterruptibly(int arg)</div><div class=\"line\">        throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。</li>\n<li>检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念</li>\n<li>若state &gt; 0, 则需要将该线程加入等待队列。<br>加入等待队列在doAcquireSharedInterruptibly中完成的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doAcquireSharedInterruptibly(int arg)</div><div class=\"line\">    throws InterruptedException &#123;</div><div class=\"line\">    final Node node = addWaiter(Node.SHARED); //创建共享锁</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            final Node p = node.predecessor();</div><div class=\"line\">            if (p == head) &#123; //如果前继节点是头结点，</div><div class=\"line\">                int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的</div><div class=\"line\">                if (r &gt;= 0) &#123; //如果为0，就说明可以退出了</div><div class=\"line\">                    setHeadAndPropagate(node, r); //向下传播释放锁的信号，</div><div class=\"line\">                    p.next = null; // help GC</div><div class=\"line\">                    failed = false;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">                parkAndCheckInterrupt())</div><div class=\"line\">                throw new InterruptedException();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:</p>\n<ul>\n<li>首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch1.png\" height=\"200\" width=\"450\"></li>\n<li>开始自旋, 进行判断:</li>\n</ul>\n<ol>\n<li>若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。</li>\n<li>通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。</li>\n</ol>\n<ul>\n<li>若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。<br>向后传播通过setHeadAndPropagate()完成, 也是比较简单的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class=\"line\">    Node h = head; // Record old head for check below</div><div class=\"line\">    setHead(node); //node前继节点就是头结点</div><div class=\"line\">    /*</div><div class=\"line\">     * Try to signal next queued node if:</div><div class=\"line\">     *   Propagation was indicated by caller,</div><div class=\"line\">     *     or was recorded (as h.waitStatus either before</div><div class=\"line\">     *     or after setHead) by a previous operation</div><div class=\"line\">     *     (note: this uses sign-check of waitStatus because</div><div class=\"line\">     *      PROPAGATE status may transition to SIGNAL.)</div><div class=\"line\">     * and</div><div class=\"line\">     *   The next node is waiting in shared mode,</div><div class=\"line\">     *     or we don&apos;t know, because it appears null</div><div class=\"line\">     *</div><div class=\"line\">     * The conservatism in both of these checks may cause</div><div class=\"line\">     * unnecessary wake-ups, but only when there are multiple</div><div class=\"line\">     * racing acquires/releases, so most need signals now or soon</div><div class=\"line\">     * anyway.</div><div class=\"line\">     */</div><div class=\"line\">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || //如果</div><div class=\"line\">        (h = head) == null || h.waitStatus &lt; 0) &#123; //这里是重复的</div><div class=\"line\">        Node s = node.next;</div><div class=\"line\">        if (s == null || s.isShared()) //本节点是共享的</div><div class=\"line\">            doReleaseShared();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。<br>获取所得过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch4.png\" height=\"250\" width=\"800\"></p>\n<h2 id=\"超时等待\"><a href=\"#超时等待\" class=\"headerlink\" title=\"超时等待\"></a>超时等待</h2><p>在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch.await(100000, TimeUnit.MILLISECONDS)</div></pre></td></tr></table></figure></p>\n<p>指的是, 超时等待100s, 自动退出, <code>并不会因为超时没有获取到锁而抛出异常</code>。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。<br>doAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。</p>\n<h2 id=\"ReentrantLock和CountDownLatch对比\"><a href=\"#ReentrantLock和CountDownLatch对比\" class=\"headerlink\" title=\"ReentrantLock和CountDownLatch对比\"></a>ReentrantLock和CountDownLatch对比</h2><p>ReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。<br>CountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>CountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>CountDownLatch与ReentrantLock的主要区别是:</p>\n<ul>\n<li>CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。</li>\n<li>CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。<br>CountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。<br>CountDownLatch使用方法如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch countDownLatch = new CountDownLatch(3);</div><div class=\"line\">//获取共享锁,获取不到就阻塞</div><div class=\"line\">countDownLatch.await();</div><div class=\"line\"> //释放一份共享锁</div><div class=\"line\">countDownLatch.countDown();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>await()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。</p>\n<h2 id=\"countDown\"><a href=\"#countDown\" class=\"headerlink\" title=\"countDown()\"></a>countDown()</h2><p>countDown()对state减1一:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">      //如果state为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下两个事情:</p>\n<ul>\n<li>对state减一</li>\n<li>若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doReleaseShared() &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Ensure that a release propagates, even if there are other</div><div class=\"line\">     * in-progress acquires/releases.  This proceeds in the usual</div><div class=\"line\">     * way of trying to unparkSuccessor of head if it needs</div><div class=\"line\">     * signal. But if it does not, status is set to PROPAGATE to</div><div class=\"line\">     * ensure that upon release, propagation continues.</div><div class=\"line\">     * Additionally, we must loop in case a new node is added</div><div class=\"line\">     * while we are doing this. Also, unlike other uses of</div><div class=\"line\">     * unparkSuccessor, we need to know if CAS to reset status</div><div class=\"line\">     * fails, if so rechecking.</div><div class=\"line\">     */</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        if (h != null &amp;&amp; h != tail) &#123;</div><div class=\"line\">            int ws = h.waitStatus;</div><div class=\"line\">            //若是singal，那么就会通知</div><div class=\"line\">            if (ws == Node.SIGNAL) &#123;</div><div class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class=\"line\">                    continue;            // loop to recheck cases</div><div class=\"line\">                unparkSuccessor(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播</div><div class=\"line\">            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class=\"line\">                continue;                // loop on failed CAS</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 如果发生了变动，说明一个线程被唤醒了</div><div class=\"line\">        if (h == head)                    // loop if head changed,</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:</p>\n<ul>\n<li>若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。</li>\n<li>若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。</li>\n<li>若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。</li>\n<li>若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。<br>需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。<br>释放一个锁的整体过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch3.png\" height=\"250\" width=\"700\"></li>\n</ul>\n<h2 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await()\"></a>await()</h2><p>await()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireSharedInterruptibly(int arg)</div><div class=\"line\">        throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。</li>\n<li>检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念</li>\n<li>若state &gt; 0, 则需要将该线程加入等待队列。<br>加入等待队列在doAcquireSharedInterruptibly中完成的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doAcquireSharedInterruptibly(int arg)</div><div class=\"line\">    throws InterruptedException &#123;</div><div class=\"line\">    final Node node = addWaiter(Node.SHARED); //创建共享锁</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            final Node p = node.predecessor();</div><div class=\"line\">            if (p == head) &#123; //如果前继节点是头结点，</div><div class=\"line\">                int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的</div><div class=\"line\">                if (r &gt;= 0) &#123; //如果为0，就说明可以退出了</div><div class=\"line\">                    setHeadAndPropagate(node, r); //向下传播释放锁的信号，</div><div class=\"line\">                    p.next = null; // help GC</div><div class=\"line\">                    failed = false;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">                parkAndCheckInterrupt())</div><div class=\"line\">                throw new InterruptedException();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:</p>\n<ul>\n<li>首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch1.png\" height=\"200\" width=\"450\"></li>\n<li>开始自旋, 进行判断:</li>\n</ul>\n<ol>\n<li>若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。</li>\n<li>通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。</li>\n</ol>\n<ul>\n<li>若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。<br>向后传播通过setHeadAndPropagate()完成, 也是比较简单的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class=\"line\">    Node h = head; // Record old head for check below</div><div class=\"line\">    setHead(node); //node前继节点就是头结点</div><div class=\"line\">    /*</div><div class=\"line\">     * Try to signal next queued node if:</div><div class=\"line\">     *   Propagation was indicated by caller,</div><div class=\"line\">     *     or was recorded (as h.waitStatus either before</div><div class=\"line\">     *     or after setHead) by a previous operation</div><div class=\"line\">     *     (note: this uses sign-check of waitStatus because</div><div class=\"line\">     *      PROPAGATE status may transition to SIGNAL.)</div><div class=\"line\">     * and</div><div class=\"line\">     *   The next node is waiting in shared mode,</div><div class=\"line\">     *     or we don&apos;t know, because it appears null</div><div class=\"line\">     *</div><div class=\"line\">     * The conservatism in both of these checks may cause</div><div class=\"line\">     * unnecessary wake-ups, but only when there are multiple</div><div class=\"line\">     * racing acquires/releases, so most need signals now or soon</div><div class=\"line\">     * anyway.</div><div class=\"line\">     */</div><div class=\"line\">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || //如果</div><div class=\"line\">        (h = head) == null || h.waitStatus &lt; 0) &#123; //这里是重复的</div><div class=\"line\">        Node s = node.next;</div><div class=\"line\">        if (s == null || s.isShared()) //本节点是共享的</div><div class=\"line\">            doReleaseShared();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。<br>获取所得过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/CountDownLatch4.png\" height=\"250\" width=\"800\"></p>\n<h2 id=\"超时等待\"><a href=\"#超时等待\" class=\"headerlink\" title=\"超时等待\"></a>超时等待</h2><p>在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch.await(100000, TimeUnit.MILLISECONDS)</div></pre></td></tr></table></figure></p>\n<p>指的是, 超时等待100s, 自动退出, <code>并不会因为超时没有获取到锁而抛出异常</code>。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。<br>doAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。</p>\n<h2 id=\"ReentrantLock和CountDownLatch对比\"><a href=\"#ReentrantLock和CountDownLatch对比\" class=\"headerlink\" title=\"ReentrantLock和CountDownLatch对比\"></a>ReentrantLock和CountDownLatch对比</h2><p>ReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。<br>CountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>CountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。</p>\n"},{"title":"ConcurrentHashMap红黑树原理介绍","date":"2017-11-06T09:48:34.000Z","_content":"为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。\n# 红黑树介绍\n一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:\n1）每个节点或者是黑的，或者是红的。\n2）根节点是黑的。\n3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n4）如果一个节点是红的，则它的两个儿子都是黑的。\n5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。\n红黑树示例如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"/>\n## 链表转化为红黑树\n```\n        TreeBin(TreeNode<K,V> b) {\n            super(TREEBIN, null, null, null);\n            this.first = b;\n            //设置前置节点\n            TreeNode<K,V> r = null;\n            for (TreeNode<K,V> x = b, next; x != null; x = next) {\n                next = (TreeNode<K,V>)x.next;\n                x.left = x.right = null;\n                //初始化节点\n                if (r == null) {\n                    x.parent = null;\n                    x.red = false;\n                    r = x;\n                }\n                else {\n                    K k = x.key;\n                    int h = x.hash;\n                    Class<?> kc = null;\n                    //从根节点开始找到合适的地方存放\n                    for (TreeNode<K,V> p = r;;) {\n                        int dir, ph;\n                        K pk = p.key;\n                        //左边\n                        if ((ph = p.hash) > h)\n                            dir = -1;\n                        //右边\n                        else if (ph < h)\n                            dir = 1;\n                        else if ((kc == null && //继续比较，类名接口名、hash值等方面来比较\n                                  (kc = comparableClassFor(k)) == null) ||\n                                 (dir = compareComparables(kc, k, pk)) == 0)\n                            dir = tieBreakOrder(k, pk);\n                            TreeNode<K,V> xp = p;\n                        if ((p = (dir <= 0) ? p.left : p.right) == null) { //判断是否找到头了，\n                            x.parent = xp;\n                            if (dir <= 0)\n                                xp.left = x;\n                            else\n                                xp.right = x;\n                            //开始调整\n                            r = balanceInsertion(r, x);\n                            break;\n                        }\n                    }\n                }\n            }\n            this.root = r;\n            assert checkInvariants(root);\n        }\n```\n主要做了如下事情:\n+ 初始化TreeBin节点, 设置其hash=TREEBIN(-2)\n+ 设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。\n+ 根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。\n## 红黑树插入后平衡balanceInsertion\n插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:\n```\n        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            x.red = true;//首先赋值头为red\n            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n                if ((xp = x.parent) == null) { //如果插入的是头结点\n                    x.red = false; //那么可以直接退出\n                    return x;\n                }\n                else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par\n                    //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）\n                    return root;\n                if (xp == (xppl = xpp.left)) { //父节点是左孩子\n                    if ((xppr = xpp.right) != null && xppr.red) { //叔叔节点是红色的\n                        xppr.red = false;\n                        xp.red = false;\n                        xpp.red = true;\n                        x = xpp; //x节点上移到祖父节点\n                    }\n                    else {\n                        //叔叔节点是黑色节点，x是右节点，那么移动到左边\n                        if (x == xp.right) {\n                            //x变成xp的位置，结构没变，只是x指向变了\n                            root = rotateLeft(root, x = xp);\n                            xpp = (xp = x.parent) == null ? null : xp.parent;\n                        }\n                        if (xp != null) { //叔叔是黑色节点，x是左节点\n                            xp.red = false;\n                            if (xpp != null) { //那么右旋就行了\n                                xpp.red = true;\n                                root = rotateRight(root, xpp);\n                            }\n                        }\n                    }\n                }\n                else {\n                   ...\n                }\n            }\n        }\n```\n首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:\ncase1. 叔叔C是红色的\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A\ncase2. 叔叔C是黑色的, 插入节点X是右孩子\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况\ncase3. 叔叔C是黑色的, 插入节点X是左孩子\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"/>\n调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。\n\n## 红黑树删除后平衡balanceInsertion\n红黑树删除分为两步:\n+ 二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是`该节点的中序遍历的后继节点`, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。\n+ 删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:\n```\n        //x点代表了一次删除的那个黑色\n        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            for (TreeNode<K,V> xp, xpl, xpr;;)  {\n                if (x == null || x == root)\n                    return root;\n                else if ((xp = x.parent) == null) {\n                    x.red = false;\n                    return x;\n                }\n                 //红色的，那么直接将红色变成黑色\n                else if (x.red) {\n                    x.red = false;\n                    return root;\n                }\n                //开始分两种情况，都是一样的， x是左兄弟\n                else if ((xpl = xp.left) == x) {\n                 //第一种情况：有兄弟是红色的，先将兄弟变成红色的\n                    if ((xpr = xp.right) != null && xpr.red) {\n                        xpr.red = false;\n                        xp.red = true;\n                        root = rotateLeft(root, xp);\n                        xpr = (xp = x.parent) == null ? null : xp.right;\n                    }\n                    if (xpr == null)//若有兄弟不存在，可以向上移动一个节点\n                        x = xp;\n                    else { //那么右兄弟为黑色的\n                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;\n                        if ((sr == null || !sr.red) &&\n                         //右兄弟的两个孩子若存在，那么是黑色的\n                            (sl == null || !sl.red)) {\n                            //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点\n                            xpr.red = true;\n                            x = xp;\n                        }\n                        else { //右兄弟为黑色\n                            //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色\n                            if (sr == null || !sr.red) {\n                                if (sl != null)//这里判断没有意义，一定是red\n                                    sl.red = false;\n                                xpr.red = true;\n                                root = rotateRight(root, xpr);//右旋\n                                xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针\n                                    null : xp.right;\n                            }\n                            //右兄弟为黑色，右兄弟的右孩子一定为red\n                            if (xpr != null) {\n                                xpr.red = (xp == null) ? false : xp.red;\n                                if ((sr = xpr.right) != null)\n                                    sr.red = false;\n                            }\n                            if (xp != null) {\n                                xp.red = false;\n                                root = rotateLeft(root, xp);\n                            }\n                            x = root;//那么旋转结束\n                        }\n                    }\n                }\n                else { // symmetric\n                   ...\n                }\n            }\n        }\n```\n若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.\n这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点\ncase1: 兄弟是红色的\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"/>\n调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色\ncase2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"/>\n调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。\ncase3: 兄弟是黑色的, 兄弟的左孩子是红色。\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"/>\n调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。\ncase3: 兄弟是黑色的, 兄弟的右孩子是红色。\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"/>\n调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。\n# 总结\n红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。","source":"_posts/ConcurrentHashMap红黑树原理介绍.md","raw":"---\ntitle: ConcurrentHashMap红黑树原理介绍\ndate: 2017-11-06 17:48:34\ntags:\n---\n为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。\n# 红黑树介绍\n一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:\n1）每个节点或者是黑的，或者是红的。\n2）根节点是黑的。\n3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n4）如果一个节点是红的，则它的两个儿子都是黑的。\n5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。\n红黑树示例如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"/>\n## 链表转化为红黑树\n```\n        TreeBin(TreeNode<K,V> b) {\n            super(TREEBIN, null, null, null);\n            this.first = b;\n            //设置前置节点\n            TreeNode<K,V> r = null;\n            for (TreeNode<K,V> x = b, next; x != null; x = next) {\n                next = (TreeNode<K,V>)x.next;\n                x.left = x.right = null;\n                //初始化节点\n                if (r == null) {\n                    x.parent = null;\n                    x.red = false;\n                    r = x;\n                }\n                else {\n                    K k = x.key;\n                    int h = x.hash;\n                    Class<?> kc = null;\n                    //从根节点开始找到合适的地方存放\n                    for (TreeNode<K,V> p = r;;) {\n                        int dir, ph;\n                        K pk = p.key;\n                        //左边\n                        if ((ph = p.hash) > h)\n                            dir = -1;\n                        //右边\n                        else if (ph < h)\n                            dir = 1;\n                        else if ((kc == null && //继续比较，类名接口名、hash值等方面来比较\n                                  (kc = comparableClassFor(k)) == null) ||\n                                 (dir = compareComparables(kc, k, pk)) == 0)\n                            dir = tieBreakOrder(k, pk);\n                            TreeNode<K,V> xp = p;\n                        if ((p = (dir <= 0) ? p.left : p.right) == null) { //判断是否找到头了，\n                            x.parent = xp;\n                            if (dir <= 0)\n                                xp.left = x;\n                            else\n                                xp.right = x;\n                            //开始调整\n                            r = balanceInsertion(r, x);\n                            break;\n                        }\n                    }\n                }\n            }\n            this.root = r;\n            assert checkInvariants(root);\n        }\n```\n主要做了如下事情:\n+ 初始化TreeBin节点, 设置其hash=TREEBIN(-2)\n+ 设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。\n+ 根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。\n## 红黑树插入后平衡balanceInsertion\n插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:\n```\n        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            x.red = true;//首先赋值头为red\n            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n                if ((xp = x.parent) == null) { //如果插入的是头结点\n                    x.red = false; //那么可以直接退出\n                    return x;\n                }\n                else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par\n                    //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）\n                    return root;\n                if (xp == (xppl = xpp.left)) { //父节点是左孩子\n                    if ((xppr = xpp.right) != null && xppr.red) { //叔叔节点是红色的\n                        xppr.red = false;\n                        xp.red = false;\n                        xpp.red = true;\n                        x = xpp; //x节点上移到祖父节点\n                    }\n                    else {\n                        //叔叔节点是黑色节点，x是右节点，那么移动到左边\n                        if (x == xp.right) {\n                            //x变成xp的位置，结构没变，只是x指向变了\n                            root = rotateLeft(root, x = xp);\n                            xpp = (xp = x.parent) == null ? null : xp.parent;\n                        }\n                        if (xp != null) { //叔叔是黑色节点，x是左节点\n                            xp.red = false;\n                            if (xpp != null) { //那么右旋就行了\n                                xpp.red = true;\n                                root = rotateRight(root, xpp);\n                            }\n                        }\n                    }\n                }\n                else {\n                   ...\n                }\n            }\n        }\n```\n首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:\ncase1. 叔叔C是红色的\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A\ncase2. 叔叔C是黑色的, 插入节点X是右孩子\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况\ncase3. 叔叔C是黑色的, 插入节点X是左孩子\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"/>\n调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。\n\n## 红黑树删除后平衡balanceInsertion\n红黑树删除分为两步:\n+ 二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是`该节点的中序遍历的后继节点`, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。\n+ 删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:\n```\n        //x点代表了一次删除的那个黑色\n        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            for (TreeNode<K,V> xp, xpl, xpr;;)  {\n                if (x == null || x == root)\n                    return root;\n                else if ((xp = x.parent) == null) {\n                    x.red = false;\n                    return x;\n                }\n                 //红色的，那么直接将红色变成黑色\n                else if (x.red) {\n                    x.red = false;\n                    return root;\n                }\n                //开始分两种情况，都是一样的， x是左兄弟\n                else if ((xpl = xp.left) == x) {\n                 //第一种情况：有兄弟是红色的，先将兄弟变成红色的\n                    if ((xpr = xp.right) != null && xpr.red) {\n                        xpr.red = false;\n                        xp.red = true;\n                        root = rotateLeft(root, xp);\n                        xpr = (xp = x.parent) == null ? null : xp.right;\n                    }\n                    if (xpr == null)//若有兄弟不存在，可以向上移动一个节点\n                        x = xp;\n                    else { //那么右兄弟为黑色的\n                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;\n                        if ((sr == null || !sr.red) &&\n                         //右兄弟的两个孩子若存在，那么是黑色的\n                            (sl == null || !sl.red)) {\n                            //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点\n                            xpr.red = true;\n                            x = xp;\n                        }\n                        else { //右兄弟为黑色\n                            //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色\n                            if (sr == null || !sr.red) {\n                                if (sl != null)//这里判断没有意义，一定是red\n                                    sl.red = false;\n                                xpr.red = true;\n                                root = rotateRight(root, xpr);//右旋\n                                xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针\n                                    null : xp.right;\n                            }\n                            //右兄弟为黑色，右兄弟的右孩子一定为red\n                            if (xpr != null) {\n                                xpr.red = (xp == null) ? false : xp.red;\n                                if ((sr = xpr.right) != null)\n                                    sr.red = false;\n                            }\n                            if (xp != null) {\n                                xp.red = false;\n                                root = rotateLeft(root, xp);\n                            }\n                            x = root;//那么旋转结束\n                        }\n                    }\n                }\n                else { // symmetric\n                   ...\n                }\n            }\n        }\n```\n若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.\n这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点\ncase1: 兄弟是红色的\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"/>\n调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色\ncase2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"/>\n调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。\ncase3: 兄弟是黑色的, 兄弟的左孩子是红色。\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"/>\n调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。\ncase3: 兄弟是黑色的, 兄弟的右孩子是红色。\n<img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"/>\n调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。\n# 总结\n红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。","slug":"ConcurrentHashMap红黑树原理介绍","published":1,"updated":"2018-10-07T05:55:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lv40003isu5h2jp5tpz","content":"<p>为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。</p>\n<h1 id=\"红黑树介绍\"><a href=\"#红黑树介绍\" class=\"headerlink\" title=\"红黑树介绍\"></a>红黑树介绍</h1><p>一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:<br>1）每个节点或者是黑的，或者是红的。<br>2）根节点是黑的。<br>3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>4）如果一个节点是红的，则它的两个儿子都是黑的。<br>5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。<br>红黑树示例如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"></p>\n<h2 id=\"链表转化为红黑树\"><a href=\"#链表转化为红黑树\" class=\"headerlink\" title=\"链表转化为红黑树\"></a>链表转化为红黑树</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class=\"line\">    super(TREEBIN, null, null, null);</div><div class=\"line\">    this.first = b;</div><div class=\"line\">    //设置前置节点</div><div class=\"line\">    TreeNode&lt;K,V&gt; r = null;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</div><div class=\"line\">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class=\"line\">        x.left = x.right = null;</div><div class=\"line\">        //初始化节点</div><div class=\"line\">        if (r == null) &#123;</div><div class=\"line\">            x.parent = null;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            r = x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            K k = x.key;</div><div class=\"line\">            int h = x.hash;</div><div class=\"line\">            Class&lt;?&gt; kc = null;</div><div class=\"line\">            //从根节点开始找到合适的地方存放</div><div class=\"line\">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class=\"line\">                int dir, ph;</div><div class=\"line\">                K pk = p.key;</div><div class=\"line\">                //左边</div><div class=\"line\">                if ((ph = p.hash) &gt; h)</div><div class=\"line\">                    dir = -1;</div><div class=\"line\">                //右边</div><div class=\"line\">                else if (ph &lt; h)</div><div class=\"line\">                    dir = 1;</div><div class=\"line\">                else if ((kc == null &amp;&amp; //继续比较，类名接口名、hash值等方面来比较</div><div class=\"line\">                          (kc = comparableClassFor(k)) == null) ||</div><div class=\"line\">                         (dir = compareComparables(kc, k, pk)) == 0)</div><div class=\"line\">                    dir = tieBreakOrder(k, pk);</div><div class=\"line\">                    TreeNode&lt;K,V&gt; xp = p;</div><div class=\"line\">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; //判断是否找到头了，</div><div class=\"line\">                    x.parent = xp;</div><div class=\"line\">                    if (dir &lt;= 0)</div><div class=\"line\">                        xp.left = x;</div><div class=\"line\">                    else</div><div class=\"line\">                        xp.right = x;</div><div class=\"line\">                    //开始调整</div><div class=\"line\">                    r = balanceInsertion(r, x);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.root = r;</div><div class=\"line\">    assert checkInvariants(root);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要做了如下事情:</p>\n<ul>\n<li>初始化TreeBin节点, 设置其hash=TREEBIN(-2)</li>\n<li>设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。</li>\n<li>根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。<h2 id=\"红黑树插入后平衡balanceInsertion\"><a href=\"#红黑树插入后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树插入后平衡balanceInsertion\"></a>红黑树插入后平衡balanceInsertion</h2>插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    x.red = true;//首先赋值头为red</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class=\"line\">        if ((xp = x.parent) == null) &#123; //如果插入的是头结点</div><div class=\"line\">            x.red = false; //那么可以直接退出</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par</div><div class=\"line\">            //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）</div><div class=\"line\">            return root;</div><div class=\"line\">        if (xp == (xppl = xpp.left)) &#123; //父节点是左孩子</div><div class=\"line\">            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; //叔叔节点是红色的</div><div class=\"line\">                xppr.red = false;</div><div class=\"line\">                xp.red = false;</div><div class=\"line\">                xpp.red = true;</div><div class=\"line\">                x = xpp; //x节点上移到祖父节点</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                //叔叔节点是黑色节点，x是右节点，那么移动到左边</div><div class=\"line\">                if (x == xp.right) &#123;</div><div class=\"line\">                    //x变成xp的位置，结构没变，只是x指向变了</div><div class=\"line\">                    root = rotateLeft(root, x = xp);</div><div class=\"line\">                    xpp = (xp = x.parent) == null ? null : xp.parent;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (xp != null) &#123; //叔叔是黑色节点，x是左节点</div><div class=\"line\">                    xp.red = false;</div><div class=\"line\">                    if (xpp != null) &#123; //那么右旋就行了</div><div class=\"line\">                        xpp.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:<br>case1. 叔叔C是红色的<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"><br>调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A<br>case2. 叔叔C是黑色的, 插入节点X是右孩子<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"><br>调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况<br>case3. 叔叔C是黑色的, 插入节点X是左孩子<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"><br>调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。</p>\n<h2 id=\"红黑树删除后平衡balanceInsertion\"><a href=\"#红黑树删除后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树删除后平衡balanceInsertion\"></a>红黑树删除后平衡balanceInsertion</h2><p>红黑树删除分为两步:</p>\n<ul>\n<li>二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是<code>该节点的中序遍历的后继节点</code>, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。</li>\n<li>删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">//x点代表了一次删除的那个黑色</div><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</div><div class=\"line\">        if (x == null || x == root)</div><div class=\"line\">            return root;</div><div class=\"line\">        else if ((xp = x.parent) == null) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //红色的，那么直接将红色变成黑色</div><div class=\"line\">        else if (x.red) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return root;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //开始分两种情况，都是一样的， x是左兄弟</div><div class=\"line\">        else if ((xpl = xp.left) == x) &#123;</div><div class=\"line\">         //第一种情况：有兄弟是红色的，先将兄弟变成红色的</div><div class=\"line\">            if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</div><div class=\"line\">                xpr.red = false;</div><div class=\"line\">                xp.red = true;</div><div class=\"line\">                root = rotateLeft(root, xp);</div><div class=\"line\">                xpr = (xp = x.parent) == null ? null : xp.right;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (xpr == null)//若有兄弟不存在，可以向上移动一个节点</div><div class=\"line\">                x = xp;</div><div class=\"line\">            else &#123; //那么右兄弟为黑色的</div><div class=\"line\">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</div><div class=\"line\">                if ((sr == null || !sr.red) &amp;&amp;</div><div class=\"line\">                 //右兄弟的两个孩子若存在，那么是黑色的</div><div class=\"line\">                    (sl == null || !sl.red)) &#123;</div><div class=\"line\">                    //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点</div><div class=\"line\">                    xpr.red = true;</div><div class=\"line\">                    x = xp;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123; //右兄弟为黑色</div><div class=\"line\">                    //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色</div><div class=\"line\">                    if (sr == null || !sr.red) &#123;</div><div class=\"line\">                        if (sl != null)//这里判断没有意义，一定是red</div><div class=\"line\">                            sl.red = false;</div><div class=\"line\">                        xpr.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpr);//右旋</div><div class=\"line\">                        xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针</div><div class=\"line\">                            null : xp.right;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //右兄弟为黑色，右兄弟的右孩子一定为red</div><div class=\"line\">                    if (xpr != null) &#123;</div><div class=\"line\">                        xpr.red = (xp == null) ? false : xp.red;</div><div class=\"line\">                        if ((sr = xpr.right) != null)</div><div class=\"line\">                            sr.red = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (xp != null) &#123;</div><div class=\"line\">                        xp.red = false;</div><div class=\"line\">                        root = rotateLeft(root, xp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    x = root;//那么旋转结束</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123; // symmetric</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.<br>这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点<br>case1: 兄弟是红色的<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"><br>调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色<br>case2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"><br>调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。<br>case3: 兄弟是黑色的, 兄弟的左孩子是红色。<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"><br>调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。<br>case3: 兄弟是黑色的, 兄弟的右孩子是红色。<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"><br>调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。</p>\n<h1 id=\"红黑树介绍\"><a href=\"#红黑树介绍\" class=\"headerlink\" title=\"红黑树介绍\"></a>红黑树介绍</h1><p>一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:<br>1）每个节点或者是黑的，或者是红的。<br>2）根节点是黑的。<br>3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>4）如果一个节点是红的，则它的两个儿子都是黑的。<br>5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。<br>红黑树示例如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"></p>\n<h2 id=\"链表转化为红黑树\"><a href=\"#链表转化为红黑树\" class=\"headerlink\" title=\"链表转化为红黑树\"></a>链表转化为红黑树</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class=\"line\">    super(TREEBIN, null, null, null);</div><div class=\"line\">    this.first = b;</div><div class=\"line\">    //设置前置节点</div><div class=\"line\">    TreeNode&lt;K,V&gt; r = null;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</div><div class=\"line\">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class=\"line\">        x.left = x.right = null;</div><div class=\"line\">        //初始化节点</div><div class=\"line\">        if (r == null) &#123;</div><div class=\"line\">            x.parent = null;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            r = x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            K k = x.key;</div><div class=\"line\">            int h = x.hash;</div><div class=\"line\">            Class&lt;?&gt; kc = null;</div><div class=\"line\">            //从根节点开始找到合适的地方存放</div><div class=\"line\">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class=\"line\">                int dir, ph;</div><div class=\"line\">                K pk = p.key;</div><div class=\"line\">                //左边</div><div class=\"line\">                if ((ph = p.hash) &gt; h)</div><div class=\"line\">                    dir = -1;</div><div class=\"line\">                //右边</div><div class=\"line\">                else if (ph &lt; h)</div><div class=\"line\">                    dir = 1;</div><div class=\"line\">                else if ((kc == null &amp;&amp; //继续比较，类名接口名、hash值等方面来比较</div><div class=\"line\">                          (kc = comparableClassFor(k)) == null) ||</div><div class=\"line\">                         (dir = compareComparables(kc, k, pk)) == 0)</div><div class=\"line\">                    dir = tieBreakOrder(k, pk);</div><div class=\"line\">                    TreeNode&lt;K,V&gt; xp = p;</div><div class=\"line\">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; //判断是否找到头了，</div><div class=\"line\">                    x.parent = xp;</div><div class=\"line\">                    if (dir &lt;= 0)</div><div class=\"line\">                        xp.left = x;</div><div class=\"line\">                    else</div><div class=\"line\">                        xp.right = x;</div><div class=\"line\">                    //开始调整</div><div class=\"line\">                    r = balanceInsertion(r, x);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.root = r;</div><div class=\"line\">    assert checkInvariants(root);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要做了如下事情:</p>\n<ul>\n<li>初始化TreeBin节点, 设置其hash=TREEBIN(-2)</li>\n<li>设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。</li>\n<li>根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。<h2 id=\"红黑树插入后平衡balanceInsertion\"><a href=\"#红黑树插入后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树插入后平衡balanceInsertion\"></a>红黑树插入后平衡balanceInsertion</h2>插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    x.red = true;//首先赋值头为red</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class=\"line\">        if ((xp = x.parent) == null) &#123; //如果插入的是头结点</div><div class=\"line\">            x.red = false; //那么可以直接退出</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par</div><div class=\"line\">            //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）</div><div class=\"line\">            return root;</div><div class=\"line\">        if (xp == (xppl = xpp.left)) &#123; //父节点是左孩子</div><div class=\"line\">            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; //叔叔节点是红色的</div><div class=\"line\">                xppr.red = false;</div><div class=\"line\">                xp.red = false;</div><div class=\"line\">                xpp.red = true;</div><div class=\"line\">                x = xpp; //x节点上移到祖父节点</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                //叔叔节点是黑色节点，x是右节点，那么移动到左边</div><div class=\"line\">                if (x == xp.right) &#123;</div><div class=\"line\">                    //x变成xp的位置，结构没变，只是x指向变了</div><div class=\"line\">                    root = rotateLeft(root, x = xp);</div><div class=\"line\">                    xpp = (xp = x.parent) == null ? null : xp.parent;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (xp != null) &#123; //叔叔是黑色节点，x是左节点</div><div class=\"line\">                    xp.red = false;</div><div class=\"line\">                    if (xpp != null) &#123; //那么右旋就行了</div><div class=\"line\">                        xpp.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:<br>case1. 叔叔C是红色的<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"><br>调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A<br>case2. 叔叔C是黑色的, 插入节点X是右孩子<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"><br>调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况<br>case3. 叔叔C是黑色的, 插入节点X是左孩子<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"><br>调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。</p>\n<h2 id=\"红黑树删除后平衡balanceInsertion\"><a href=\"#红黑树删除后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树删除后平衡balanceInsertion\"></a>红黑树删除后平衡balanceInsertion</h2><p>红黑树删除分为两步:</p>\n<ul>\n<li>二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是<code>该节点的中序遍历的后继节点</code>, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。</li>\n<li>删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">//x点代表了一次删除的那个黑色</div><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</div><div class=\"line\">        if (x == null || x == root)</div><div class=\"line\">            return root;</div><div class=\"line\">        else if ((xp = x.parent) == null) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //红色的，那么直接将红色变成黑色</div><div class=\"line\">        else if (x.red) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return root;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //开始分两种情况，都是一样的， x是左兄弟</div><div class=\"line\">        else if ((xpl = xp.left) == x) &#123;</div><div class=\"line\">         //第一种情况：有兄弟是红色的，先将兄弟变成红色的</div><div class=\"line\">            if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</div><div class=\"line\">                xpr.red = false;</div><div class=\"line\">                xp.red = true;</div><div class=\"line\">                root = rotateLeft(root, xp);</div><div class=\"line\">                xpr = (xp = x.parent) == null ? null : xp.right;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (xpr == null)//若有兄弟不存在，可以向上移动一个节点</div><div class=\"line\">                x = xp;</div><div class=\"line\">            else &#123; //那么右兄弟为黑色的</div><div class=\"line\">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</div><div class=\"line\">                if ((sr == null || !sr.red) &amp;&amp;</div><div class=\"line\">                 //右兄弟的两个孩子若存在，那么是黑色的</div><div class=\"line\">                    (sl == null || !sl.red)) &#123;</div><div class=\"line\">                    //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点</div><div class=\"line\">                    xpr.red = true;</div><div class=\"line\">                    x = xp;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123; //右兄弟为黑色</div><div class=\"line\">                    //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色</div><div class=\"line\">                    if (sr == null || !sr.red) &#123;</div><div class=\"line\">                        if (sl != null)//这里判断没有意义，一定是red</div><div class=\"line\">                            sl.red = false;</div><div class=\"line\">                        xpr.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpr);//右旋</div><div class=\"line\">                        xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针</div><div class=\"line\">                            null : xp.right;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //右兄弟为黑色，右兄弟的右孩子一定为red</div><div class=\"line\">                    if (xpr != null) &#123;</div><div class=\"line\">                        xpr.red = (xp == null) ? false : xp.red;</div><div class=\"line\">                        if ((sr = xpr.right) != null)</div><div class=\"line\">                            sr.red = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (xp != null) &#123;</div><div class=\"line\">                        xp.red = false;</div><div class=\"line\">                        root = rotateLeft(root, xp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    x = root;//那么旋转结束</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123; // symmetric</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.<br>这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点<br>case1: 兄弟是红色的<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"><br>调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色<br>case2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"><br>调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。<br>case3: 兄弟是黑色的, 兄弟的左孩子是红色。<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"><br>调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。<br>case3: 兄弟是黑色的, 兄弟的右孩子是红色。<br><img src=\"http://owsl7963b.bkt.clouddn.com/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"><br>调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。</p>\n"},{"title":"ES索引创建流程","date":"2017-12-17T15:25:54.000Z","_content":"","source":"_posts/ES索引创建流程.md","raw":"---\ntitle: ES索引创建流程\ndate: 2017-12-17 23:25:54\ntags:\n---\n","slug":"ES索引创建流程","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lv60004isu5aqz2kq6x","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"JAVA JNI实现hello world","date":"2017-06-15T10:15:08.000Z","_content":"jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。\n# 使用\n```\npublic class Native1{\n    public native void  sayHello();\n\n    public static void main(String[] args) {\n        System.loadLibrary(\"hellworld\");\n        new Native1().sayHello();\n    }\n}\n```\n我们定义了sayHello函数为native属性的。这里System.loadLibrary(\"hellworld\")必不可少, 否则会报如下异常\n```\nException in thread \"main\" java.lang.UnsatisfiedLinkError: Native1.sayHello()V\n        at Native1.sayHello(Native Method)\n        at Native1.main(Native1.java:6)\n```\n之后再讲解这行代码, 主要步骤如下:\n1. 首先执行javac Native1.java, 这样获得了Native1.class文件\n2. 执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下\n```\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class Native1 */\n\n#ifndef _Included_Native1\n#define _Included_Native1\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     Native1\n * Method:    sayHello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_Native1_sayHello\n  (JNIEnv *, jobject);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\njava的native方法转变为c++函数的规则如下：Java_{package_and_classname}_{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：\n++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数\n++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass\n我们需要在myNative.c(.cpp文件也是支持的)里面实现Java_Native_sayHello函数:\n```\n#include \"/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h\"\n#include <stdio.h>\nJNIEXPORT void JNICALL Java_Native_sayHello(JNIEnv *env, jobject thisObj)\n{\n    printf(\"Hello，JNI\");\n}\n```\n头文件指明了Native1.h。这里主要定义了Java_Native_sayHello函数。\n3. 生成动态链接库libhelloworld.jnilib\n`gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib`\n这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(\"hellworld\"); 系统才能正常识别。\n4. 执行java Native1, 获得如下结果。\n```\nHello，JNI%\n```\n\n# 参考\nhttps://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\nhttps://blog.csdn.net/createchance/article/details/53783490\nhttps://blog.csdn.net/abc5382334/article/details/18052757","source":"_posts/JAVA-JNI实现hello-world.md","raw":"---\ntitle: JAVA JNI实现hello world\ndate: 2017-06-15 18:15:08\ntags:\n---\njvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。\n# 使用\n```\npublic class Native1{\n    public native void  sayHello();\n\n    public static void main(String[] args) {\n        System.loadLibrary(\"hellworld\");\n        new Native1().sayHello();\n    }\n}\n```\n我们定义了sayHello函数为native属性的。这里System.loadLibrary(\"hellworld\")必不可少, 否则会报如下异常\n```\nException in thread \"main\" java.lang.UnsatisfiedLinkError: Native1.sayHello()V\n        at Native1.sayHello(Native Method)\n        at Native1.main(Native1.java:6)\n```\n之后再讲解这行代码, 主要步骤如下:\n1. 首先执行javac Native1.java, 这样获得了Native1.class文件\n2. 执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下\n```\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class Native1 */\n\n#ifndef _Included_Native1\n#define _Included_Native1\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     Native1\n * Method:    sayHello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_Native1_sayHello\n  (JNIEnv *, jobject);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\njava的native方法转变为c++函数的规则如下：Java_{package_and_classname}_{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：\n++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数\n++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass\n我们需要在myNative.c(.cpp文件也是支持的)里面实现Java_Native_sayHello函数:\n```\n#include \"/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h\"\n#include <stdio.h>\nJNIEXPORT void JNICALL Java_Native_sayHello(JNIEnv *env, jobject thisObj)\n{\n    printf(\"Hello，JNI\");\n}\n```\n头文件指明了Native1.h。这里主要定义了Java_Native_sayHello函数。\n3. 生成动态链接库libhelloworld.jnilib\n`gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib`\n这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(\"hellworld\"); 系统才能正常识别。\n4. 执行java Native1, 获得如下结果。\n```\nHello，JNI%\n```\n\n# 参考\nhttps://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\nhttps://blog.csdn.net/createchance/article/details/53783490\nhttps://blog.csdn.net/abc5382334/article/details/18052757","slug":"JAVA-JNI实现hello-world","published":1,"updated":"2018-11-13T03:12:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lva0005isu5lje8ql2s","content":"<p>jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Native1&#123;</div><div class=\"line\">    public native void  sayHello();</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        System.loadLibrary(&quot;hellworld&quot;);</div><div class=\"line\">        new Native1().sayHello();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们定义了sayHello函数为native属性的。这里System.loadLibrary(“hellworld”)必不可少, 否则会报如下异常<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: Native1.sayHello()V</div><div class=\"line\">        at Native1.sayHello(Native Method)</div><div class=\"line\">        at Native1.main(Native1.java:6)</div></pre></td></tr></table></figure></p>\n<p>之后再讲解这行代码, 主要步骤如下:</p>\n<ol>\n<li>首先执行javac Native1.java, 这样获得了Native1.class文件</li>\n<li>执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* DO NOT EDIT THIS FILE - it is machine generated */</div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">/* Header for class Native1 */</div><div class=\"line\"></div><div class=\"line\">#ifndef _Included_Native1</div><div class=\"line\">#define _Included_Native1</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">extern &quot;C&quot; &#123;</div><div class=\"line\">#endif</div><div class=\"line\">/*</div><div class=\"line\"> * Class:     Native1</div><div class=\"line\"> * Method:    sayHello</div><div class=\"line\"> * Signature: ()V</div><div class=\"line\"> */</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native1_sayHello</div><div class=\"line\">  (JNIEnv *, jobject);</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">&#125;</div><div class=\"line\">#endif</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>java的native方法转变为c++函数的规则如下：Java_{package_and<em>classname}</em>{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：<br>++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数<br>++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass<br>我们需要在myNative.c(.cpp文件也是支持的)里面实现Java_Native_sayHello函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h&quot;</div><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native_sayHello(JNIEnv *env, jobject thisObj)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Hello，JNI&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>头文件指明了Native1.h。这里主要定义了Java_Native_sayHello函数。</p>\n<ol>\n<li>生成动态链接库libhelloworld.jnilib<br><code>gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib</code><br>这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(“hellworld”); 系统才能正常识别。</li>\n<li>执行java Native1, 获得如下结果。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello，JNI%</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\" target=\"_blank\" rel=\"external\">https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp</a><br><a href=\"https://blog.csdn.net/createchance/article/details/53783490\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/createchance/article/details/53783490</a><br><a href=\"https://blog.csdn.net/abc5382334/article/details/18052757\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/abc5382334/article/details/18052757</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Native1&#123;</div><div class=\"line\">    public native void  sayHello();</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        System.loadLibrary(&quot;hellworld&quot;);</div><div class=\"line\">        new Native1().sayHello();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们定义了sayHello函数为native属性的。这里System.loadLibrary(“hellworld”)必不可少, 否则会报如下异常<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: Native1.sayHello()V</div><div class=\"line\">        at Native1.sayHello(Native Method)</div><div class=\"line\">        at Native1.main(Native1.java:6)</div></pre></td></tr></table></figure></p>\n<p>之后再讲解这行代码, 主要步骤如下:</p>\n<ol>\n<li>首先执行javac Native1.java, 这样获得了Native1.class文件</li>\n<li>执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* DO NOT EDIT THIS FILE - it is machine generated */</div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">/* Header for class Native1 */</div><div class=\"line\"></div><div class=\"line\">#ifndef _Included_Native1</div><div class=\"line\">#define _Included_Native1</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">extern &quot;C&quot; &#123;</div><div class=\"line\">#endif</div><div class=\"line\">/*</div><div class=\"line\"> * Class:     Native1</div><div class=\"line\"> * Method:    sayHello</div><div class=\"line\"> * Signature: ()V</div><div class=\"line\"> */</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native1_sayHello</div><div class=\"line\">  (JNIEnv *, jobject);</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">&#125;</div><div class=\"line\">#endif</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>java的native方法转变为c++函数的规则如下：Java_{package_and<em>classname}</em>{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：<br>++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数<br>++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass<br>我们需要在myNative.c(.cpp文件也是支持的)里面实现Java_Native_sayHello函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h&quot;</div><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native_sayHello(JNIEnv *env, jobject thisObj)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Hello，JNI&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>头文件指明了Native1.h。这里主要定义了Java_Native_sayHello函数。</p>\n<ol>\n<li>生成动态链接库libhelloworld.jnilib<br><code>gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib</code><br>这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(“hellworld”); 系统才能正常识别。</li>\n<li>执行java Native1, 获得如下结果。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello，JNI%</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\" target=\"_blank\" rel=\"external\">https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp</a><br><a href=\"https://blog.csdn.net/createchance/article/details/53783490\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/createchance/article/details/53783490</a><br><a href=\"https://blog.csdn.net/abc5382334/article/details/18052757\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/abc5382334/article/details/18052757</a></p>\n"},{"title":"Java 线程知识小结","date":"2016-10-27T06:18:30.000Z","_content":"# wait/notify/notifyAll:\nwait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:\n```\npublic static Object lock = new Object();\n\npublic void run(){//线程A\n        try {\n            synchronized (lock) {\n                lock.wait(); //进入睡眠进行等待\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\npublic void run(){//线程B\n        try {\n            synchronized (lock) {\n                lock.notify(); //唤醒A线程\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\n```\n线程执行状态如下:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/wait_notify.png\" height=\"300\" width=\"800\"/>\n需要注意一下几点:\n+ wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;\n+ 线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是`线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中`, 线程A的状态由wait变化为blocked\n+ 线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。\nnotify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。\n\n# Join\njoin函数的作用是等别的线程退出后再继续执行, 基本使用如下:\n```\n        Thread thread = new Thread(new a2());\n        thread.start();\n        thread.join();\n```\n当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:\n```\n     public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (millis == 0) {//没有设置超时时间\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {//超时等待的话\n            while (isAlive()) { //循环检查\n                long delay = millis - now;\n                if (delay <= 0) { //超时时间到了之后退出\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。","source":"_posts/Java线程知识小结.md","raw":"---\ntitle: Java 线程知识小结\ndate: 2016-10-27 14:18:30\ntags:\n---\n# wait/notify/notifyAll:\nwait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:\n```\npublic static Object lock = new Object();\n\npublic void run(){//线程A\n        try {\n            synchronized (lock) {\n                lock.wait(); //进入睡眠进行等待\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\npublic void run(){//线程B\n        try {\n            synchronized (lock) {\n                lock.notify(); //唤醒A线程\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\n```\n线程执行状态如下:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/wait_notify.png\" height=\"300\" width=\"800\"/>\n需要注意一下几点:\n+ wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;\n+ 线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是`线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中`, 线程A的状态由wait变化为blocked\n+ 线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。\nnotify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。\n\n# Join\njoin函数的作用是等别的线程退出后再继续执行, 基本使用如下:\n```\n        Thread thread = new Thread(new a2());\n        thread.start();\n        thread.join();\n```\n当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:\n```\n     public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (millis == 0) {//没有设置超时时间\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {//超时等待的话\n            while (isAlive()) { //循环检查\n                long delay = millis - now;\n                if (delay <= 0) { //超时时间到了之后退出\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。","slug":"Java线程知识小结","published":1,"updated":"2018-10-28T15:21:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvc0006isu5xyqrom44","content":"<h1 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait/notify/notifyAll:\"></a>wait/notify/notifyAll:</h1><p>wait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Object lock = new Object();</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程A</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.wait(); //进入睡眠进行等待</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程B</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.notify(); //唤醒A线程</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>线程执行状态如下:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/wait_notify.png\" height=\"300\" width=\"800\"><br>需要注意一下几点:</p>\n<ul>\n<li>wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;</li>\n<li>线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是<code>线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中</code>, 线程A的状态由wait变化为blocked</li>\n<li>线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。<br>notify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。</li>\n</ul>\n<h1 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h1><p>join函数的作用是等别的线程退出后再继续执行, 基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread thread = new Thread(new a2());</div><div class=\"line\">thread.start();</div><div class=\"line\">thread.join();</div></pre></td></tr></table></figure></p>\n<p>当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final synchronized void join(long millis) throws InterruptedException &#123;</div><div class=\"line\">    long base = System.currentTimeMillis();</div><div class=\"line\">    long now = 0;</div><div class=\"line\">    if (millis &lt; 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (millis == 0) &#123;//没有设置超时时间</div><div class=\"line\">        while (isAlive()) &#123;</div><div class=\"line\">            wait(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;//超时等待的话</div><div class=\"line\">        while (isAlive()) &#123; //循环检查</div><div class=\"line\">            long delay = millis - now;</div><div class=\"line\">            if (delay &lt;= 0) &#123; //超时时间到了之后退出</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            wait(delay);</div><div class=\"line\">            now = System.currentTimeMillis() - base;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait/notify/notifyAll:\"></a>wait/notify/notifyAll:</h1><p>wait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Object lock = new Object();</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程A</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.wait(); //进入睡眠进行等待</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程B</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.notify(); //唤醒A线程</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>线程执行状态如下:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/wait_notify.png\" height=\"300\" width=\"800\"><br>需要注意一下几点:</p>\n<ul>\n<li>wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;</li>\n<li>线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是<code>线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中</code>, 线程A的状态由wait变化为blocked</li>\n<li>线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。<br>notify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。</li>\n</ul>\n<h1 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h1><p>join函数的作用是等别的线程退出后再继续执行, 基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread thread = new Thread(new a2());</div><div class=\"line\">thread.start();</div><div class=\"line\">thread.join();</div></pre></td></tr></table></figure></p>\n<p>当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final synchronized void join(long millis) throws InterruptedException &#123;</div><div class=\"line\">    long base = System.currentTimeMillis();</div><div class=\"line\">    long now = 0;</div><div class=\"line\">    if (millis &lt; 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (millis == 0) &#123;//没有设置超时时间</div><div class=\"line\">        while (isAlive()) &#123;</div><div class=\"line\">            wait(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;//超时等待的话</div><div class=\"line\">        while (isAlive()) &#123; //循环检查</div><div class=\"line\">            long delay = millis - now;</div><div class=\"line\">            if (delay &lt;= 0) &#123; //超时时间到了之后退出</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            wait(delay);</div><div class=\"line\">            now = System.currentTimeMillis() - base;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。</p>\n"},{"title":"LockSupport原理解读","date":"2018-11-10T09:16:56.000Z","_content":"LockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 以下展示了LockSupport的基本用法:\n```\n```\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\nhttp://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","source":"_posts/LockSupport源码解读.md","raw":"---\ntitle: LockSupport原理解读\ndate: 2018-11-10 17:16:56\ntags:\n---\nLockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 以下展示了LockSupport的基本用法:\n```\n```\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\nhttp://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","slug":"LockSupport源码解读","published":1,"updated":"2018-11-14T03:01:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvd0007isu57plaq26u","content":"<p>LockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 以下展示了LockSupport的基本用法:</p>\n<pre><code>\n</code></pre><p><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html</a><br><a href=\"http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"external\">http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 以下展示了LockSupport的基本用法:</p>\n<pre><code>\n</code></pre><p><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html</a><br><a href=\"http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"external\">http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>\n"},{"title":"Netty Http通信源码二(编码)阅读","date":"2018-05-03T16:02:39.000Z","_content":"解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\" />\n涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。\n开始向外发送数据时, 如下:\n```\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context\n        final Object m = pipeline.touch(msg, next);\n        EventExecutor executor = next.executor();\n        if (executor.inEventLoop()) {\n            if (flush) {\n                next.invokeWriteAndFlush(m, promise);\n            } else {\n                next.invokeWrite(m, promise);\n            }\n        } else {\n            AbstractWriteTask task;\n            if (flush) {\n                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行\n            }  else {\n                task = WriteTask.newInstance(next, m, promise);\n            }\n            safeExecute(executor, task, promise, m);\n        }\n    }\n```\n当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:\n```\n        @Override\n        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n            super.write(ctx, msg, promise); //一般只是存放在缓存中\n            ctx.invokeFlush(); //真正的调用write,\n        }\n```\n可以看出, 写数据分为两个过程:write()和flush():\n+ write只是将数据放在了缓存ChannelOutboundBuffer中\n+ 通过调用channal.write()向网络发送数据。\n\n# HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\n我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。\n首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:\n```\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        CodecOutputList out = null;\n        try {\n            if (acceptOutboundMessage(msg)) {\n                out = CodecOutputList.newInstance();\n                I cast = (I) msg;\n                try {\n                    encode(ctx, cast, out);\n                } finally {\n                    ReferenceCountUtil.release(cast);\n                }\n                if (out.isEmpty()) {\n                    out.recycle();\n                    out = null;\n                    throw new EncoderException(\n                            StringUtil.simpleClassName(this) + \" must produce at least one message.\");\n                }\n            } else {\n                ctx.write(msg, promise);\n            }\n        }\n        } finally {\n            if (out != null) {\n                final int sizeMinusOne = out.size() - 1;\n                if (sizeMinusOne == 0) {\n                    ctx.write(out.get(0), promise);\n                } else if (sizeMinusOne > 0) {\n                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure\n                    // See https://github.com/netty/netty/issues/2525\n                    ChannelPromise voidPromise = ctx.voidPromise();\n                    boolean isVoidPromise = promise == voidPromise;\n                    for (int i = 0; i < sizeMinusOne; i ++) {//分开向下发送\n                        ChannelPromise p;\n                        if (isVoidPromise) {\n                            p = voidPromise;\n                        } else {\n                            p = ctx.newPromise();\n                        }\n                        ctx.write(out.getUnsafe(i), p);\n                    }\n                    ctx.write(out.getUnsafe(sizeMinusOne), promise);\n                }\n                out.recycle();\n            }\n        }\n    }\n```\n实现也很简单,主要做了如下两件事:\n1. 首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。\n2. 针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。\n\n## HttpContentEncoder的encode()函数\n首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: \"gzip,deflat,br\"为例。\n\nendoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分\n```\n@Override    //msg: DefaultFullHttpResponse\n    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;\n        switch (state) {\n            case AWAIT_HEADERS: {  //初始取值\n                ensureHeaders(msg);\n                assert encoder == null;\n\n                final HttpResponse res = (HttpResponse) msg;\n                 //根据返回结果确定是否需要编码\n                final int code = res.status().code();\n                final CharSequence acceptEncoding;\n                if (code == CONTINUE_CODE) { //continue_code\n                    // We need to not poll the encoding when response with CONTINUE as another response will follow\n                    // for the issued request. See https://github.com/netty/netty/issues/4079\n                    acceptEncoding = null;\n                } else {\n                    // Get the list of encodings accepted by the peer.\n                    acceptEncoding = acceptEncodingQueue.poll(); //\"gzip.default.br\"\n                    if (acceptEncoding == null) {\n                        throw new IllegalStateException(\"cannot send more responses than requests\");\n                    }\n                }\n                /*\n                 * per rfc2616 4.3 Message Body\n                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a\n                 * message-body. All other responses do include a message-body, although it MAY be of zero length.\n                 *\n                 * 9.4 HEAD\n                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body\n                 * in the response.\n                 *\n                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.\n                 *\n                 * See https://github.com/netty/netty/issues/5382\n                 */\n                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) { //是否接下来是没有body的\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n                if (isFull) {\n                    // Pass through the full response with empty content and continue waiting for the the next resp.\n                    if (!((ByteBufHolder) res).content().isReadable()) {\n                        out.add(ReferenceCountUtil.retain(res));\n                        break;\n                    }\n                }\n\n                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity\n                final Result result = beginEncode(res, acceptEncoding.toString());\n\n                // If unable to encode, pass through.\n                if (result == null) {\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n\n                encoder = result.contentEncoder(); //encoder = EmbeddedChannel\n\n                // Encode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip\n\n                // Output the rewritten response.\n                if (isFull) {\n                    // Convert full message into unfull one.\n                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());\n                    newRes.headers().set(res.headers());\n                    out.add(newRes);  //newRes里面还没有放数据\n\n                    ensureContent(res);\n                    encodeFullResponse(newRes, (HttpContent) res, out);\n                    break;\n                } else {\n                    // Make the response chunked to simplify content transformation.\n                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n\n                    out.add(res);\n                    state = State.AWAIT_CONTENT;\n                    if (!(msg instanceof HttpContent)) {\n                        // only break out the switch statement if we have not content to process\n                        // See https://github.com/netty/netty/issues/2006\n                        break;\n                    }\n                    // Fall through to encode the content\n                }\n            }\n            case AWAIT_CONTENT: {\n                ensureContent(msg);\n                if (encodeContent((HttpContent) msg, out)) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n            case PASS_THROUGH: {\n                ensureContent(msg);\n                out.add(ReferenceCountUtil.retain(msg));\n                // Passed through all following contents of the current response.\n                if (msg instanceof LastHttpContent) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n        }\n    }\n```\n该编码器encode主要做的事情:\n1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:\n+ 若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。\n+ 否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br\n2.根据规范`rfc2616 4.3 Message Body`, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。\n3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。\n4.在beginEncode中建立相应压缩管道EmbeddedChannel:\n```\n protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {\n        ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP\n        if (wrapper == null) {\n            return null;\n        }\n        String targetContentEncoding;\n        switch (wrapper) {\n        case GZIP:\n            targetContentEncoding = \"gzip\";\n            break;\n        case ZLIB:\n            targetContentEncoding = \"deflate\";\n            break;\n        default:\n            throw new Error();\n        }\n\n        return new Result(\n                targetContentEncoding,\n                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),\n                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(\n                        wrapper, compressionLevel, windowBits, memLevel)));\n    }\n```\n主要做了如下事情:\n+ 首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip>deflate\n+ 返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\" />\n对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。\n5.向返回值headler中添加 content-encoding:gzip\n6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.\n7.在encodeFullResponse中调用编码函数encodeContent()\n```\nprivate boolean encodeContent(HttpContent c, List<Object> out) {\n        ByteBuf content = c.content();\n        encode(content, out);\n        if (c instanceof LastHttpContent) {\n            finishEncode(out);\n            LastHttpContent last = (LastHttpContent) c;\n            // Generate an additional chunk if the decoder produced\n            // the last product on closure,\n            HttpHeaders headers = last.trailingHeaders();\n            if (headers.isEmpty()) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                out.add(new ComposedLastHttpContent(headers));\n            }\n            return true;\n        }\n        return false;\n    }\n```\n7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。\n+ 调用JdkZlibEncoder.encode()进行压缩。\n+ 将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。\n+ 在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。\n7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。\n这样整个输出帧的内容存放在out中, 拥有的对象如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\" />\n其中:\n+ DefaultHttpResponse: 存放的是Http/1.1 status, Header等\n+ 第一个DefaultHttpContent存放的是压缩的内容。\n+ 第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。\n+ LastHttpContent代表整个帧的结束, content部分为空。\n8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。\n## JdkZlibEncoder压缩\n我们可以了解下JdkZlibEncoder.encode()是怎么压缩的\n```\n    @Override\n    protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {\n        int len = uncompressed.readableBytes(); //总共刻度数据\n        int offset;\n        byte[] inAry;\n        if (uncompressed.hasArray()) {  //若有数组,直接获得数组\n            // if it is backed by an array we not need to to do a copy at all\n            inAry = uncompressed.array();\n            offset = uncompressed.arrayOffset() + uncompressed.readerIndex();\n            // skip all bytes as we will consume all of them\n            uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度\n        } else {\n            inAry = new byte[len];\n            uncompressed.readBytes(inAry);//将数据读取到这个byte数组中\n            offset = 0;\n        }\n        if (writeHeader) { //将数组写进去， 最开始编码，需要写\n            writeHeader = false;\n            if (wrapper == ZlibWrapper.GZIP) {\n                out.writeBytes(gzipHeader);//首先写进去头\n            }\n        }\n        if (wrapper == ZlibWrapper.GZIP) {\n            crc.update(inAry, offset, len);\n        }\n        //向压缩器中传递带压缩的数组\n        deflater.setInput(inAry, offset, len);\n        while (!deflater.needsInput()) {\n            deflate(out); //进行真正的压缩\n        }\n    }\n```\n可以看到:\n+ 首先获得bytebuf的byte数组\n+ 向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];\n其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;\n+ 直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。\n\n\n## DefalueChannalHadlerContext.write()\nDefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。\n接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:\n```\n         ByteBuf buf = null;\n        if (msg instanceof HttpMessage) {  //如果是头部，则先编码头部\n            if (state != ST_INIT) {\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n            }\n            H m = (H) msg;\n            buf = ctx.alloc().buffer();//直接内存分配的地址\n            // Encode the message.\n            encodeInitialLine(buf, m); //先是编码initial部分\n            encodeHeaders(m.headers(), buf);//再编码header部分\n            buf.writeBytes(CRLF);\n            state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK\n                    HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;\n        }\n        if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {\n            out.add(EMPTY_BUFFER);\n            return;\n        }\n        //如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse\n        if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\n            switch (state) {\n                case ST_INIT:\n                    throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n                case ST_CONTENT_NON_CHUNK: //st_content_non_chunk\n                    final long contentLength = contentLength(msg);\n                    if (contentLength > 0) {//可写的空间够，直接放到直接内存buf中\n                        if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {//必须是content类型的\n                            // merge into other buffer for performance reasons\n                            buf.writeBytes(((HttpContent) msg).content());\n                            out.add(buf);\n                        } else {\n                            if (buf != null) {\n                                out.add(buf); //先把直接内存放进去\n                            }\n                            out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去\n                        }\n\n                        if (msg instanceof LastHttpContent) {\n                            state = ST_INIT; //编码完成后，直接复位\n                        }\n                        break;\n                    }\n                    // fall-through!\n                case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里\n\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    } else {\n                        // Need to produce some output otherwise an\n                        // IllegalStateException will be thrown\n                        out.add(EMPTY_BUFFER);\n                    }\n\n                    break;\n                case ST_CONTENT_CHUNK:\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    }\n                    encodeChunkedContent(ctx, msg, contentLength(msg), out);\n                    break;\n                default:\n                    throw new Error();\n            }\n            if (msg instanceof LastHttpContent) { //解码完成，再置位\n                state = ST_INIT;\n            }\n        } else if (buf != null) {\n            out.add(buf);\n        }\n```\nstate初始值为ST_INIT, 该函数主要做了如下操作:\n1. 首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。\n+ 通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)\n```\n         response.protocolVersion().encode(buf); //首先存放version编码\n        buf.writeByte(SP); //存放byte:32水平空格\n        response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=\"200 ok\"\n        buf.writeBytes(CRLF); //  { CR, LF }回车换行\n```\n+ 通过encodeHeaders编码header部分, 每个header属性编码如下:\n```\n         final int nameLen = name.length();\n        final int valueLen = value.length();\n        final int entryLen = nameLen + valueLen + 4;\n        buf.ensureWritable(entryLen);  //检查buf的最小长度\n        int offset = buf.writerIndex();\n        writeAscii(buf, offset, name); // 使用US_ASCII编码\n        offset += nameLen;\n        buf.setByte(offset ++, ':');//:\n        buf.setByte(offset ++, ' ');//空格\n        writeAscii(buf, offset, value);\n        offset += valueLen;\n        buf.setByte(offset ++, '\\r');//\n        buf.setByte(offset ++, '\\n');\n        buf.writerIndex(offset);\n```\n1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格\n2) 通过CharsetUtil.US_ASCII编码key和value\n+ 再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\" />\n\n然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。\n2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。\n+ 会直接将整个DefaltHttpContent放入out向外写\n+ 当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。\n\n\n# Netty水位\n\n向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:\n```\n   @Override\n        public final void write(Object msg, ChannelPromise promise) {\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位\n            int size;\n            try {\n                msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap\n                size = pipeline.estimatorHandle().size(msg);\n                if (size < 0) {\n                    size = 0;\n                }\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                ReferenceCountUtil.release(msg);\n                return;\n            }\n            outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer\n        }\n```\n+ 在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。\n+ 通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。\n我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\" />\nflushEntry 表示即将刷新的位置\nunflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。\ntailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。\n当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:\n```\n        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息\n        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法\n            setUnwritable(invokeLater);\n        }\n```\n所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?\n在netty启动时, 只需要添加如下参数即可:\n```\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);\n```\n代表:\n+ 当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。\n+ 当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.\n## setUnwritable设置不可写\n\n```\n        for (;;) {\n            final int oldValue = unwritable;\n            final int newValue = oldValue | 1;\n            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态\n                if (oldValue == 0 && newValue != 0) {\n                    fireChannelWritabilityChanged(invokeLater);//\n                }//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。\n                break;\n            }\n        }\n```\n这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写->不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。\n在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。\n\n# Flush\n数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:\n```\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            unsafe.flush();\n        }\n```\n这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():\n```\n        @Override\n        public final void flush() {\n            assertEventLoop();\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null) {\n                return;\n            }\n            outboundBuffer.addFlush();\n            flush0();//写完了\n        }\n```\n主要做了如下事情:\n+ outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;\n+ 调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():\n## 内部flush0\n```\n        @SuppressWarnings(\"deprecation\")\n        protected void flush0() {\n            if (inFlush0) { //有正在写（真正的调用write写）\n                // Avoid re-entrance\n                return;\n            }\n            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n                return;\n            }\n            inFlush0 = true; //标记正在写\n            // Mark all pending write requests as failure if the channel is inactive.\n            if (!isActive()) {\n                try {\n                    if (isOpen()) {\n                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);\n                    } else {\n                        // Do not trigger channelWritabilityChanged because the channel is closed already.\n                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);\n                    }\n                } finally {\n                    inFlush0 = false;\n                }\n                return;\n            }\n            try {\n                doWrite(outboundBuffer);\n            } catch (Throwable t) {\n               ......\n            } finally {\n                inFlush0 = false;\n            }\n        }\n```\n该代码主要做了如下事情:\n1. 检查是否有正在flush,  如是的话, 直接退出。\n2. 标志正在flush\n3.调用doWrite继续刷:\n```\nprotected void doWrite(ChannelOutboundBuffer in) throws Exception {\n        for (;;) {\n            int size = in.size(); //所有的都写完了\n            if (size == 0) {\n                // All written so clear OP_WRITE\n                clearOpWrite();\n                break;\n            }\n            long writtenBytes = 0;\n            boolean done = false;\n            boolean setOpWrite = false;\n            // Ensure the pending writes are made of ByteBufs only.\n            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个\n            int nioBufferCnt = in.nioBufferCount();\n            long expectedWrittenBytes = in.nioBufferSize();\n            SocketChannel ch = javaChannel();\n            // Always us nioBuffers() to workaround data-corruption.\n            // See https://github.com/netty/netty/issues/2761\n            switch (nioBufferCnt) {\n                case 0:\n                    // We have something else beside ByteBuffers to write so fallback to normal writes.\n                    super.doWrite(in);\n                    return;\n                case 1:\n                    // Only one ByteBuf so use non-gathering write\n                    ByteBuffer nioBuffer = nioBuffers[0];\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {\n                        final int localWrittenBytes = ch.write(nioBuffer);\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {//循环16次, 可能一次写不完\n                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            // Release the fully written buffers, and update the indexes of the partially written buffer.\n            in.removeBytes(writtenBytes); //记录可丢弃的数据\n            if (!done) {//若没有写完\n                // Did not write all buffers completely.\n                incompleteWrite(setOpWrite);\n                break;\n            }\n        }\n    }\n```\n该函数主要做了如下事情:\n1. 通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]\n2. 当content个数>=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。\n\n至此, write到缓存、flush到网络部分全部讲完了。\n","source":"_posts/Netty-Http通信编码源码阅读.md","raw":"---\ntitle: Netty Http通信源码二(编码)阅读\ndate: 2018-05-04 00:02:39\ntags:\n---\n解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\" />\n涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。\n开始向外发送数据时, 如下:\n```\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context\n        final Object m = pipeline.touch(msg, next);\n        EventExecutor executor = next.executor();\n        if (executor.inEventLoop()) {\n            if (flush) {\n                next.invokeWriteAndFlush(m, promise);\n            } else {\n                next.invokeWrite(m, promise);\n            }\n        } else {\n            AbstractWriteTask task;\n            if (flush) {\n                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行\n            }  else {\n                task = WriteTask.newInstance(next, m, promise);\n            }\n            safeExecute(executor, task, promise, m);\n        }\n    }\n```\n当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:\n```\n        @Override\n        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n            super.write(ctx, msg, promise); //一般只是存放在缓存中\n            ctx.invokeFlush(); //真正的调用write,\n        }\n```\n可以看出, 写数据分为两个过程:write()和flush():\n+ write只是将数据放在了缓存ChannelOutboundBuffer中\n+ 通过调用channal.write()向网络发送数据。\n\n# HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\n我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。\n首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:\n```\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        CodecOutputList out = null;\n        try {\n            if (acceptOutboundMessage(msg)) {\n                out = CodecOutputList.newInstance();\n                I cast = (I) msg;\n                try {\n                    encode(ctx, cast, out);\n                } finally {\n                    ReferenceCountUtil.release(cast);\n                }\n                if (out.isEmpty()) {\n                    out.recycle();\n                    out = null;\n                    throw new EncoderException(\n                            StringUtil.simpleClassName(this) + \" must produce at least one message.\");\n                }\n            } else {\n                ctx.write(msg, promise);\n            }\n        }\n        } finally {\n            if (out != null) {\n                final int sizeMinusOne = out.size() - 1;\n                if (sizeMinusOne == 0) {\n                    ctx.write(out.get(0), promise);\n                } else if (sizeMinusOne > 0) {\n                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure\n                    // See https://github.com/netty/netty/issues/2525\n                    ChannelPromise voidPromise = ctx.voidPromise();\n                    boolean isVoidPromise = promise == voidPromise;\n                    for (int i = 0; i < sizeMinusOne; i ++) {//分开向下发送\n                        ChannelPromise p;\n                        if (isVoidPromise) {\n                            p = voidPromise;\n                        } else {\n                            p = ctx.newPromise();\n                        }\n                        ctx.write(out.getUnsafe(i), p);\n                    }\n                    ctx.write(out.getUnsafe(sizeMinusOne), promise);\n                }\n                out.recycle();\n            }\n        }\n    }\n```\n实现也很简单,主要做了如下两件事:\n1. 首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。\n2. 针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。\n\n## HttpContentEncoder的encode()函数\n首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: \"gzip,deflat,br\"为例。\n\nendoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分\n```\n@Override    //msg: DefaultFullHttpResponse\n    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;\n        switch (state) {\n            case AWAIT_HEADERS: {  //初始取值\n                ensureHeaders(msg);\n                assert encoder == null;\n\n                final HttpResponse res = (HttpResponse) msg;\n                 //根据返回结果确定是否需要编码\n                final int code = res.status().code();\n                final CharSequence acceptEncoding;\n                if (code == CONTINUE_CODE) { //continue_code\n                    // We need to not poll the encoding when response with CONTINUE as another response will follow\n                    // for the issued request. See https://github.com/netty/netty/issues/4079\n                    acceptEncoding = null;\n                } else {\n                    // Get the list of encodings accepted by the peer.\n                    acceptEncoding = acceptEncodingQueue.poll(); //\"gzip.default.br\"\n                    if (acceptEncoding == null) {\n                        throw new IllegalStateException(\"cannot send more responses than requests\");\n                    }\n                }\n                /*\n                 * per rfc2616 4.3 Message Body\n                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a\n                 * message-body. All other responses do include a message-body, although it MAY be of zero length.\n                 *\n                 * 9.4 HEAD\n                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body\n                 * in the response.\n                 *\n                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.\n                 *\n                 * See https://github.com/netty/netty/issues/5382\n                 */\n                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) { //是否接下来是没有body的\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n                if (isFull) {\n                    // Pass through the full response with empty content and continue waiting for the the next resp.\n                    if (!((ByteBufHolder) res).content().isReadable()) {\n                        out.add(ReferenceCountUtil.retain(res));\n                        break;\n                    }\n                }\n\n                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity\n                final Result result = beginEncode(res, acceptEncoding.toString());\n\n                // If unable to encode, pass through.\n                if (result == null) {\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n\n                encoder = result.contentEncoder(); //encoder = EmbeddedChannel\n\n                // Encode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip\n\n                // Output the rewritten response.\n                if (isFull) {\n                    // Convert full message into unfull one.\n                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());\n                    newRes.headers().set(res.headers());\n                    out.add(newRes);  //newRes里面还没有放数据\n\n                    ensureContent(res);\n                    encodeFullResponse(newRes, (HttpContent) res, out);\n                    break;\n                } else {\n                    // Make the response chunked to simplify content transformation.\n                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n\n                    out.add(res);\n                    state = State.AWAIT_CONTENT;\n                    if (!(msg instanceof HttpContent)) {\n                        // only break out the switch statement if we have not content to process\n                        // See https://github.com/netty/netty/issues/2006\n                        break;\n                    }\n                    // Fall through to encode the content\n                }\n            }\n            case AWAIT_CONTENT: {\n                ensureContent(msg);\n                if (encodeContent((HttpContent) msg, out)) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n            case PASS_THROUGH: {\n                ensureContent(msg);\n                out.add(ReferenceCountUtil.retain(msg));\n                // Passed through all following contents of the current response.\n                if (msg instanceof LastHttpContent) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n        }\n    }\n```\n该编码器encode主要做的事情:\n1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:\n+ 若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。\n+ 否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br\n2.根据规范`rfc2616 4.3 Message Body`, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。\n3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。\n4.在beginEncode中建立相应压缩管道EmbeddedChannel:\n```\n protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {\n        ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP\n        if (wrapper == null) {\n            return null;\n        }\n        String targetContentEncoding;\n        switch (wrapper) {\n        case GZIP:\n            targetContentEncoding = \"gzip\";\n            break;\n        case ZLIB:\n            targetContentEncoding = \"deflate\";\n            break;\n        default:\n            throw new Error();\n        }\n\n        return new Result(\n                targetContentEncoding,\n                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),\n                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(\n                        wrapper, compressionLevel, windowBits, memLevel)));\n    }\n```\n主要做了如下事情:\n+ 首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip>deflate\n+ 返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\" />\n对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。\n5.向返回值headler中添加 content-encoding:gzip\n6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.\n7.在encodeFullResponse中调用编码函数encodeContent()\n```\nprivate boolean encodeContent(HttpContent c, List<Object> out) {\n        ByteBuf content = c.content();\n        encode(content, out);\n        if (c instanceof LastHttpContent) {\n            finishEncode(out);\n            LastHttpContent last = (LastHttpContent) c;\n            // Generate an additional chunk if the decoder produced\n            // the last product on closure,\n            HttpHeaders headers = last.trailingHeaders();\n            if (headers.isEmpty()) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                out.add(new ComposedLastHttpContent(headers));\n            }\n            return true;\n        }\n        return false;\n    }\n```\n7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。\n+ 调用JdkZlibEncoder.encode()进行压缩。\n+ 将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。\n+ 在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。\n7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。\n这样整个输出帧的内容存放在out中, 拥有的对象如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\" />\n其中:\n+ DefaultHttpResponse: 存放的是Http/1.1 status, Header等\n+ 第一个DefaultHttpContent存放的是压缩的内容。\n+ 第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。\n+ LastHttpContent代表整个帧的结束, content部分为空。\n8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。\n## JdkZlibEncoder压缩\n我们可以了解下JdkZlibEncoder.encode()是怎么压缩的\n```\n    @Override\n    protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {\n        int len = uncompressed.readableBytes(); //总共刻度数据\n        int offset;\n        byte[] inAry;\n        if (uncompressed.hasArray()) {  //若有数组,直接获得数组\n            // if it is backed by an array we not need to to do a copy at all\n            inAry = uncompressed.array();\n            offset = uncompressed.arrayOffset() + uncompressed.readerIndex();\n            // skip all bytes as we will consume all of them\n            uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度\n        } else {\n            inAry = new byte[len];\n            uncompressed.readBytes(inAry);//将数据读取到这个byte数组中\n            offset = 0;\n        }\n        if (writeHeader) { //将数组写进去， 最开始编码，需要写\n            writeHeader = false;\n            if (wrapper == ZlibWrapper.GZIP) {\n                out.writeBytes(gzipHeader);//首先写进去头\n            }\n        }\n        if (wrapper == ZlibWrapper.GZIP) {\n            crc.update(inAry, offset, len);\n        }\n        //向压缩器中传递带压缩的数组\n        deflater.setInput(inAry, offset, len);\n        while (!deflater.needsInput()) {\n            deflate(out); //进行真正的压缩\n        }\n    }\n```\n可以看到:\n+ 首先获得bytebuf的byte数组\n+ 向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];\n其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;\n+ 直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。\n\n\n## DefalueChannalHadlerContext.write()\nDefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。\n接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:\n```\n         ByteBuf buf = null;\n        if (msg instanceof HttpMessage) {  //如果是头部，则先编码头部\n            if (state != ST_INIT) {\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n            }\n            H m = (H) msg;\n            buf = ctx.alloc().buffer();//直接内存分配的地址\n            // Encode the message.\n            encodeInitialLine(buf, m); //先是编码initial部分\n            encodeHeaders(m.headers(), buf);//再编码header部分\n            buf.writeBytes(CRLF);\n            state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK\n                    HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;\n        }\n        if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {\n            out.add(EMPTY_BUFFER);\n            return;\n        }\n        //如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse\n        if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\n            switch (state) {\n                case ST_INIT:\n                    throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n                case ST_CONTENT_NON_CHUNK: //st_content_non_chunk\n                    final long contentLength = contentLength(msg);\n                    if (contentLength > 0) {//可写的空间够，直接放到直接内存buf中\n                        if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {//必须是content类型的\n                            // merge into other buffer for performance reasons\n                            buf.writeBytes(((HttpContent) msg).content());\n                            out.add(buf);\n                        } else {\n                            if (buf != null) {\n                                out.add(buf); //先把直接内存放进去\n                            }\n                            out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去\n                        }\n\n                        if (msg instanceof LastHttpContent) {\n                            state = ST_INIT; //编码完成后，直接复位\n                        }\n                        break;\n                    }\n                    // fall-through!\n                case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里\n\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    } else {\n                        // Need to produce some output otherwise an\n                        // IllegalStateException will be thrown\n                        out.add(EMPTY_BUFFER);\n                    }\n\n                    break;\n                case ST_CONTENT_CHUNK:\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    }\n                    encodeChunkedContent(ctx, msg, contentLength(msg), out);\n                    break;\n                default:\n                    throw new Error();\n            }\n            if (msg instanceof LastHttpContent) { //解码完成，再置位\n                state = ST_INIT;\n            }\n        } else if (buf != null) {\n            out.add(buf);\n        }\n```\nstate初始值为ST_INIT, 该函数主要做了如下操作:\n1. 首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。\n+ 通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)\n```\n         response.protocolVersion().encode(buf); //首先存放version编码\n        buf.writeByte(SP); //存放byte:32水平空格\n        response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=\"200 ok\"\n        buf.writeBytes(CRLF); //  { CR, LF }回车换行\n```\n+ 通过encodeHeaders编码header部分, 每个header属性编码如下:\n```\n         final int nameLen = name.length();\n        final int valueLen = value.length();\n        final int entryLen = nameLen + valueLen + 4;\n        buf.ensureWritable(entryLen);  //检查buf的最小长度\n        int offset = buf.writerIndex();\n        writeAscii(buf, offset, name); // 使用US_ASCII编码\n        offset += nameLen;\n        buf.setByte(offset ++, ':');//:\n        buf.setByte(offset ++, ' ');//空格\n        writeAscii(buf, offset, value);\n        offset += valueLen;\n        buf.setByte(offset ++, '\\r');//\n        buf.setByte(offset ++, '\\n');\n        buf.writerIndex(offset);\n```\n1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格\n2) 通过CharsetUtil.US_ASCII编码key和value\n+ 再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\" />\n\n然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。\n2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。\n+ 会直接将整个DefaltHttpContent放入out向外写\n+ 当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。\n\n\n# Netty水位\n\n向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:\n```\n   @Override\n        public final void write(Object msg, ChannelPromise promise) {\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位\n            int size;\n            try {\n                msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap\n                size = pipeline.estimatorHandle().size(msg);\n                if (size < 0) {\n                    size = 0;\n                }\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                ReferenceCountUtil.release(msg);\n                return;\n            }\n            outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer\n        }\n```\n+ 在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。\n+ 通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。\n我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\" />\nflushEntry 表示即将刷新的位置\nunflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。\ntailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。\n当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:\n```\n        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息\n        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法\n            setUnwritable(invokeLater);\n        }\n```\n所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?\n在netty启动时, 只需要添加如下参数即可:\n```\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);\n```\n代表:\n+ 当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。\n+ 当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.\n## setUnwritable设置不可写\n\n```\n        for (;;) {\n            final int oldValue = unwritable;\n            final int newValue = oldValue | 1;\n            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态\n                if (oldValue == 0 && newValue != 0) {\n                    fireChannelWritabilityChanged(invokeLater);//\n                }//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。\n                break;\n            }\n        }\n```\n这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写->不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。\n在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。\n\n# Flush\n数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:\n```\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            unsafe.flush();\n        }\n```\n这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():\n```\n        @Override\n        public final void flush() {\n            assertEventLoop();\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null) {\n                return;\n            }\n            outboundBuffer.addFlush();\n            flush0();//写完了\n        }\n```\n主要做了如下事情:\n+ outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;\n+ 调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():\n## 内部flush0\n```\n        @SuppressWarnings(\"deprecation\")\n        protected void flush0() {\n            if (inFlush0) { //有正在写（真正的调用write写）\n                // Avoid re-entrance\n                return;\n            }\n            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n                return;\n            }\n            inFlush0 = true; //标记正在写\n            // Mark all pending write requests as failure if the channel is inactive.\n            if (!isActive()) {\n                try {\n                    if (isOpen()) {\n                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);\n                    } else {\n                        // Do not trigger channelWritabilityChanged because the channel is closed already.\n                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);\n                    }\n                } finally {\n                    inFlush0 = false;\n                }\n                return;\n            }\n            try {\n                doWrite(outboundBuffer);\n            } catch (Throwable t) {\n               ......\n            } finally {\n                inFlush0 = false;\n            }\n        }\n```\n该代码主要做了如下事情:\n1. 检查是否有正在flush,  如是的话, 直接退出。\n2. 标志正在flush\n3.调用doWrite继续刷:\n```\nprotected void doWrite(ChannelOutboundBuffer in) throws Exception {\n        for (;;) {\n            int size = in.size(); //所有的都写完了\n            if (size == 0) {\n                // All written so clear OP_WRITE\n                clearOpWrite();\n                break;\n            }\n            long writtenBytes = 0;\n            boolean done = false;\n            boolean setOpWrite = false;\n            // Ensure the pending writes are made of ByteBufs only.\n            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个\n            int nioBufferCnt = in.nioBufferCount();\n            long expectedWrittenBytes = in.nioBufferSize();\n            SocketChannel ch = javaChannel();\n            // Always us nioBuffers() to workaround data-corruption.\n            // See https://github.com/netty/netty/issues/2761\n            switch (nioBufferCnt) {\n                case 0:\n                    // We have something else beside ByteBuffers to write so fallback to normal writes.\n                    super.doWrite(in);\n                    return;\n                case 1:\n                    // Only one ByteBuf so use non-gathering write\n                    ByteBuffer nioBuffer = nioBuffers[0];\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {\n                        final int localWrittenBytes = ch.write(nioBuffer);\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {//循环16次, 可能一次写不完\n                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            // Release the fully written buffers, and update the indexes of the partially written buffer.\n            in.removeBytes(writtenBytes); //记录可丢弃的数据\n            if (!done) {//若没有写完\n                // Did not write all buffers completely.\n                incompleteWrite(setOpWrite);\n                break;\n            }\n        }\n    }\n```\n该函数主要做了如下事情:\n1. 通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]\n2. 当content个数>=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。\n\n至此, write到缓存、flush到网络部分全部讲完了。\n","slug":"Netty-Http通信编码源码阅读","published":1,"updated":"2018-05-22T15:53:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvh0008isu5jjmc5e6z","content":"<p>解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\"><br>涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。<br>开始向外发送数据时, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</div><div class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context</div><div class=\"line\">        final Object m = pipeline.touch(msg, next);</div><div class=\"line\">        EventExecutor executor = next.executor();</div><div class=\"line\">        if (executor.inEventLoop()) &#123;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                next.invokeWriteAndFlush(m, promise);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                next.invokeWrite(m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            AbstractWriteTask task;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行</div><div class=\"line\">            &#125;  else &#123;</div><div class=\"line\">                task = WriteTask.newInstance(next, m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            safeExecute(executor, task, promise, m);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">    super.write(ctx, msg, promise); //一般只是存放在缓存中</div><div class=\"line\">    ctx.invokeFlush(); //真正的调用write,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 写数据分为两个过程:write()和flush():</p>\n<ul>\n<li>write只是将数据放在了缓存ChannelOutboundBuffer中</li>\n<li>通过调用channal.write()向网络发送数据。</li>\n</ul>\n<h1 id=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"><a href=\"#HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\" class=\"headerlink\" title=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"></a>HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec</h1><p>我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。<br>首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class=\"line\">    CodecOutputList out = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (acceptOutboundMessage(msg)) &#123;</div><div class=\"line\">            out = CodecOutputList.newInstance();</div><div class=\"line\">            I cast = (I) msg;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                encode(ctx, cast, out);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                ReferenceCountUtil.release(cast);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (out.isEmpty()) &#123;</div><div class=\"line\">                out.recycle();</div><div class=\"line\">                out = null;</div><div class=\"line\">                throw new EncoderException(</div><div class=\"line\">                        StringUtil.simpleClassName(this) + &quot; must produce at least one message.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.write(msg, promise);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            final int sizeMinusOne = out.size() - 1;</div><div class=\"line\">            if (sizeMinusOne == 0) &#123;</div><div class=\"line\">                ctx.write(out.get(0), promise);</div><div class=\"line\">            &#125; else if (sizeMinusOne &gt; 0) &#123;</div><div class=\"line\">                // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2525</div><div class=\"line\">                ChannelPromise voidPromise = ctx.voidPromise();</div><div class=\"line\">                boolean isVoidPromise = promise == voidPromise;</div><div class=\"line\">                for (int i = 0; i &lt; sizeMinusOne; i ++) &#123;//分开向下发送</div><div class=\"line\">                    ChannelPromise p;</div><div class=\"line\">                    if (isVoidPromise) &#123;</div><div class=\"line\">                        p = voidPromise;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        p = ctx.newPromise();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    ctx.write(out.getUnsafe(i), p);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ctx.write(out.getUnsafe(sizeMinusOne), promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现也很简单,主要做了如下两件事:</p>\n<ol>\n<li>首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。</li>\n<li>针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。</li>\n</ol>\n<h2 id=\"HttpContentEncoder的encode-函数\"><a href=\"#HttpContentEncoder的encode-函数\" class=\"headerlink\" title=\"HttpContentEncoder的encode()函数\"></a>HttpContentEncoder的encode()函数</h2><p>首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: “gzip,deflat,br”为例。</p>\n<p>endoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override    //msg: DefaultFullHttpResponse</div><div class=\"line\">    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        final boolean isFull = msg instanceof HttpResponse &amp;&amp; msg instanceof LastHttpContent;</div><div class=\"line\">        switch (state) &#123;</div><div class=\"line\">            case AWAIT_HEADERS: &#123;  //初始取值</div><div class=\"line\">                ensureHeaders(msg);</div><div class=\"line\">                assert encoder == null;</div><div class=\"line\"></div><div class=\"line\">                final HttpResponse res = (HttpResponse) msg;</div><div class=\"line\">                 //根据返回结果确定是否需要编码</div><div class=\"line\">                final int code = res.status().code();</div><div class=\"line\">                final CharSequence acceptEncoding;</div><div class=\"line\">                if (code == CONTINUE_CODE) &#123; //continue_code</div><div class=\"line\">                    // We need to not poll the encoding when response with CONTINUE as another response will follow</div><div class=\"line\">                    // for the issued request. See https://github.com/netty/netty/issues/4079</div><div class=\"line\">                    acceptEncoding = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Get the list of encodings accepted by the peer.</div><div class=\"line\">                    acceptEncoding = acceptEncodingQueue.poll(); //&quot;gzip.default.br&quot;</div><div class=\"line\">                    if (acceptEncoding == null) &#123;</div><div class=\"line\">                        throw new IllegalStateException(&quot;cannot send more responses than requests&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                /*</div><div class=\"line\">                 * per rfc2616 4.3 Message Body</div><div class=\"line\">                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a</div><div class=\"line\">                 * message-body. All other responses do include a message-body, although it MAY be of zero length.</div><div class=\"line\">                 *</div><div class=\"line\">                 * 9.4 HEAD</div><div class=\"line\">                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body</div><div class=\"line\">                 * in the response.</div><div class=\"line\">                 *</div><div class=\"line\">                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.</div><div class=\"line\">                 *</div><div class=\"line\">                 * See https://github.com/netty/netty/issues/5382</div><div class=\"line\">                 */</div><div class=\"line\">                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) &#123; //是否接下来是没有body的</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Pass through the full response with empty content and continue waiting for the the next resp.</div><div class=\"line\">                    if (!((ByteBufHolder) res).content().isReadable()) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity</div><div class=\"line\">                final Result result = beginEncode(res, acceptEncoding.toString());</div><div class=\"line\"></div><div class=\"line\">                // If unable to encode, pass through.</div><div class=\"line\">                if (result == null) &#123;</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                encoder = result.contentEncoder(); //encoder = EmbeddedChannel</div><div class=\"line\"></div><div class=\"line\">                // Encode the content and remove or replace the existing headers</div><div class=\"line\">                // so that the message looks like a decoded message.</div><div class=\"line\">                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip</div><div class=\"line\"></div><div class=\"line\">                // Output the rewritten response.</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Convert full message into unfull one.</div><div class=\"line\">                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());</div><div class=\"line\">                    newRes.headers().set(res.headers());</div><div class=\"line\">                    out.add(newRes);  //newRes里面还没有放数据</div><div class=\"line\"></div><div class=\"line\">                    ensureContent(res);</div><div class=\"line\">                    encodeFullResponse(newRes, (HttpContent) res, out);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Make the response chunked to simplify content transformation.</div><div class=\"line\">                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);</div><div class=\"line\">                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);</div><div class=\"line\"></div><div class=\"line\">                    out.add(res);</div><div class=\"line\">                    state = State.AWAIT_CONTENT;</div><div class=\"line\">                    if (!(msg instanceof HttpContent)) &#123;</div><div class=\"line\">                        // only break out the switch statement if we have not content to process</div><div class=\"line\">                        // See https://github.com/netty/netty/issues/2006</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Fall through to encode the content</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case AWAIT_CONTENT: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                if (encodeContent((HttpContent) msg, out)) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case PASS_THROUGH: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                out.add(ReferenceCountUtil.retain(msg));</div><div class=\"line\">                // Passed through all following contents of the current response.</div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>该编码器encode主要做的事情:<br>1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:</p>\n<ul>\n<li>若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。</li>\n<li>否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br<br>2.根据规范<code>rfc2616 4.3 Message Body</code>, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。<br>3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。<br>4.在beginEncode中建立相应压缩管道EmbeddedChannel:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception &#123;</div><div class=\"line\">       ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP</div><div class=\"line\">       if (wrapper == null) &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">       String targetContentEncoding;</div><div class=\"line\">       switch (wrapper) &#123;</div><div class=\"line\">       case GZIP:</div><div class=\"line\">           targetContentEncoding = &quot;gzip&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       case ZLIB:</div><div class=\"line\">           targetContentEncoding = &quot;deflate&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       default:</div><div class=\"line\">           throw new Error();</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return new Result(</div><div class=\"line\">               targetContentEncoding,</div><div class=\"line\">               new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),</div><div class=\"line\">                       ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(</div><div class=\"line\">                       wrapper, compressionLevel, windowBits, memLevel)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip&gt;deflate</li>\n<li>返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\"><br>对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。<br>5.向返回值headler中添加 content-encoding:gzip<br>6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.<br>7.在encodeFullResponse中调用编码函数encodeContent()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean encodeContent(HttpContent c, List&lt;Object&gt; out) &#123;</div><div class=\"line\">        ByteBuf content = c.content();</div><div class=\"line\">        encode(content, out);</div><div class=\"line\">        if (c instanceof LastHttpContent) &#123;</div><div class=\"line\">            finishEncode(out);</div><div class=\"line\">            LastHttpContent last = (LastHttpContent) c;</div><div class=\"line\">            // Generate an additional chunk if the decoder produced</div><div class=\"line\">            // the last product on closure,</div><div class=\"line\">            HttpHeaders headers = last.trailingHeaders();</div><div class=\"line\">            if (headers.isEmpty()) &#123;</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new ComposedLastHttpContent(headers));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。</p>\n<ul>\n<li>调用JdkZlibEncoder.encode()进行压缩。</li>\n<li>将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。</li>\n<li>在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。<br>7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。<br>这样整个输出帧的内容存放在out中, 拥有的对象如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\"><br>其中:</li>\n<li>DefaultHttpResponse: 存放的是Http/1.1 status, Header等</li>\n<li>第一个DefaultHttpContent存放的是压缩的内容。</li>\n<li>第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。</li>\n<li>LastHttpContent代表整个帧的结束, content部分为空。<br>8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。<h2 id=\"JdkZlibEncoder压缩\"><a href=\"#JdkZlibEncoder压缩\" class=\"headerlink\" title=\"JdkZlibEncoder压缩\"></a>JdkZlibEncoder压缩</h2>我们可以了解下JdkZlibEncoder.encode()是怎么压缩的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception &#123;</div><div class=\"line\">    int len = uncompressed.readableBytes(); //总共刻度数据</div><div class=\"line\">    int offset;</div><div class=\"line\">    byte[] inAry;</div><div class=\"line\">    if (uncompressed.hasArray()) &#123;  //若有数组,直接获得数组</div><div class=\"line\">        // if it is backed by an array we not need to to do a copy at all</div><div class=\"line\">        inAry = uncompressed.array();</div><div class=\"line\">        offset = uncompressed.arrayOffset() + uncompressed.readerIndex();</div><div class=\"line\">        // skip all bytes as we will consume all of them</div><div class=\"line\">        uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        inAry = new byte[len];</div><div class=\"line\">        uncompressed.readBytes(inAry);//将数据读取到这个byte数组中</div><div class=\"line\">        offset = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (writeHeader) &#123; //将数组写进去， 最开始编码，需要写</div><div class=\"line\">        writeHeader = false;</div><div class=\"line\">        if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">            out.writeBytes(gzipHeader);//首先写进去头</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">        crc.update(inAry, offset, len);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //向压缩器中传递带压缩的数组</div><div class=\"line\">    deflater.setInput(inAry, offset, len);</div><div class=\"line\">    while (!deflater.needsInput()) &#123;</div><div class=\"line\">        deflate(out); //进行真正的压缩</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先获得bytebuf的byte数组</li>\n<li>向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];<br>其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;</li>\n<li>直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。</li>\n</ul>\n<h2 id=\"DefalueChannalHadlerContext-write\"><a href=\"#DefalueChannalHadlerContext-write\" class=\"headerlink\" title=\"DefalueChannalHadlerContext.write()\"></a>DefalueChannalHadlerContext.write()</h2><p>DefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。<br>接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ByteBuf buf = null;</div><div class=\"line\">if (msg instanceof HttpMessage) &#123;  //如果是头部，则先编码头部</div><div class=\"line\">    if (state != ST_INIT) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">    &#125;</div><div class=\"line\">    H m = (H) msg;</div><div class=\"line\">    buf = ctx.alloc().buffer();//直接内存分配的地址</div><div class=\"line\">    // Encode the message.</div><div class=\"line\">    encodeInitialLine(buf, m); //先是编码initial部分</div><div class=\"line\">    encodeHeaders(m.headers(), buf);//再编码header部分</div><div class=\"line\">    buf.writeBytes(CRLF);</div><div class=\"line\">    state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK</div><div class=\"line\">            HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg instanceof ByteBuf &amp;&amp; !((ByteBuf) msg).isReadable()) &#123;</div><div class=\"line\">    out.add(EMPTY_BUFFER);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse</div><div class=\"line\">if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) &#123;</div><div class=\"line\">    switch (state) &#123;</div><div class=\"line\">        case ST_INIT:</div><div class=\"line\">            throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">        case ST_CONTENT_NON_CHUNK: //st_content_non_chunk</div><div class=\"line\">            final long contentLength = contentLength(msg);</div><div class=\"line\">            if (contentLength &gt; 0) &#123;//可写的空间够，直接放到直接内存buf中</div><div class=\"line\">                if (buf != null &amp;&amp; buf.writableBytes() &gt;= contentLength &amp;&amp; msg instanceof HttpContent) &#123;//必须是content类型的</div><div class=\"line\">                    // merge into other buffer for performance reasons</div><div class=\"line\">                    buf.writeBytes(((HttpContent) msg).content());</div><div class=\"line\">                    out.add(buf);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (buf != null) &#123;</div><div class=\"line\">                        out.add(buf); //先把直接内存放进去</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = ST_INIT; //编码完成后，直接复位</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // fall-through!</div><div class=\"line\">        case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里</div><div class=\"line\"></div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Need to produce some output otherwise an</div><div class=\"line\">                // IllegalStateException will be thrown</div><div class=\"line\">                out.add(EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            break;</div><div class=\"line\">        case ST_CONTENT_CHUNK:</div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125;</div><div class=\"line\">            encodeChunkedContent(ctx, msg, contentLength(msg), out);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            throw new Error();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg instanceof LastHttpContent) &#123; //解码完成，再置位</div><div class=\"line\">        state = ST_INIT;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (buf != null) &#123;</div><div class=\"line\">    out.add(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>state初始值为ST_INIT, 该函数主要做了如下操作:</p>\n<ol>\n<li>首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。</li>\n</ol>\n<ul>\n<li><p>通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> response.protocolVersion().encode(buf); //首先存放version编码</div><div class=\"line\">buf.writeByte(SP); //存放byte:32水平空格</div><div class=\"line\">response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=&quot;200 ok&quot;</div><div class=\"line\">buf.writeBytes(CRLF); //  &#123; CR, LF &#125;回车换行</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过encodeHeaders编码header部分, 每个header属性编码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> final int nameLen = name.length();</div><div class=\"line\">final int valueLen = value.length();</div><div class=\"line\">final int entryLen = nameLen + valueLen + 4;</div><div class=\"line\">buf.ensureWritable(entryLen);  //检查buf的最小长度</div><div class=\"line\">int offset = buf.writerIndex();</div><div class=\"line\">writeAscii(buf, offset, name); // 使用US_ASCII编码</div><div class=\"line\">offset += nameLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;:&apos;);//:</div><div class=\"line\">buf.setByte(offset ++, &apos; &apos;);//空格</div><div class=\"line\">writeAscii(buf, offset, value);</div><div class=\"line\">offset += valueLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;\\r&apos;);//</div><div class=\"line\">buf.setByte(offset ++, &apos;\\n&apos;);</div><div class=\"line\">buf.writerIndex(offset);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格<br>2) 通过CharsetUtil.US_ASCII编码key和value</p>\n<ul>\n<li>再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\"></li>\n</ul>\n<p>然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。<br>2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。</p>\n<ul>\n<li>会直接将整个DefaltHttpContent放入out向外写</li>\n<li>当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。</li>\n</ul>\n<h1 id=\"Netty水位\"><a href=\"#Netty水位\" class=\"headerlink\" title=\"Netty水位\"></a>Netty水位</h1><p>向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">     public final void write(Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位</div><div class=\"line\">         int size;</div><div class=\"line\">         try &#123;</div><div class=\"line\">             msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap</div><div class=\"line\">             size = pipeline.estimatorHandle().size(msg);</div><div class=\"line\">             if (size &lt; 0) &#123;</div><div class=\"line\">                 size = 0;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; catch (Throwable t) &#123;</div><div class=\"line\">             safeSetFailure(promise, t);</div><div class=\"line\">             ReferenceCountUtil.release(msg);</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。</li>\n<li>通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。<br>我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\"><br>flushEntry 表示即将刷新的位置<br>unflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。<br>tailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。<br>当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息</div><div class=\"line\">if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法</div><div class=\"line\">    setUnwritable(invokeLater);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?<br>在netty启动时, 只需要添加如下参数即可:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);</div></pre></td></tr></table></figure></p>\n<p>代表:</p>\n<ul>\n<li>当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。</li>\n<li>当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.<h2 id=\"setUnwritable设置不可写\"><a href=\"#setUnwritable设置不可写\" class=\"headerlink\" title=\"setUnwritable设置不可写\"></a>setUnwritable设置不可写</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    final int oldValue = unwritable;</div><div class=\"line\">    final int newValue = oldValue | 1;</div><div class=\"line\">    if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) &#123;//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态</div><div class=\"line\">        if (oldValue == 0 &amp;&amp; newValue != 0) &#123;</div><div class=\"line\">            fireChannelWritabilityChanged(invokeLater);//</div><div class=\"line\">        &#125;//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写-&gt;不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。<br>在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。</p>\n<h1 id=\"Flush\"><a href=\"#Flush\" class=\"headerlink\" title=\"Flush\"></a>Flush</h1><p>数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">    unsafe.flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public final void flush() &#123;</div><div class=\"line\">    assertEventLoop();</div><div class=\"line\">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    outboundBuffer.addFlush();</div><div class=\"line\">    flush0();//写完了</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;</li>\n<li>调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():<h2 id=\"内部flush0\"><a href=\"#内部flush0\" class=\"headerlink\" title=\"内部flush0\"></a>内部flush0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">protected void flush0() &#123;</div><div class=\"line\">    if (inFlush0) &#123; //有正在写（真正的调用write写）</div><div class=\"line\">        // Avoid re-entrance</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    inFlush0 = true; //标记正在写</div><div class=\"line\">    // Mark all pending write requests as failure if the channel is inactive.</div><div class=\"line\">    if (!isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (isOpen()) &#123;</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Do not trigger channelWritabilityChanged because the channel is closed already.</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            inFlush0 = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        doWrite(outboundBuffer);</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">       ......</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        inFlush0 = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该代码主要做了如下事情:</p>\n<ol>\n<li>检查是否有正在flush,  如是的话, 直接退出。</li>\n<li>标志正在flush<br>3.调用doWrite继续刷:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            int size = in.size(); //所有的都写完了</div><div class=\"line\">            if (size == 0) &#123;</div><div class=\"line\">                // All written so clear OP_WRITE</div><div class=\"line\">                clearOpWrite();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            long writtenBytes = 0;</div><div class=\"line\">            boolean done = false;</div><div class=\"line\">            boolean setOpWrite = false;</div><div class=\"line\">            // Ensure the pending writes are made of ByteBufs only.</div><div class=\"line\">            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个</div><div class=\"line\">            int nioBufferCnt = in.nioBufferCount();</div><div class=\"line\">            long expectedWrittenBytes = in.nioBufferSize();</div><div class=\"line\">            SocketChannel ch = javaChannel();</div><div class=\"line\">            // Always us nioBuffers() to workaround data-corruption.</div><div class=\"line\">            // See https://github.com/netty/netty/issues/2761</div><div class=\"line\">            switch (nioBufferCnt) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                    // We have something else beside ByteBuffers to write so fallback to normal writes.</div><div class=\"line\">                    super.doWrite(in);</div><div class=\"line\">                    return;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    // Only one ByteBuf so use non-gathering write</div><div class=\"line\">                    ByteBuffer nioBuffer = nioBuffers[0];</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;</div><div class=\"line\">                        final int localWrittenBytes = ch.write(nioBuffer);</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;//循环16次, 可能一次写不完</div><div class=\"line\">                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">            in.removeBytes(writtenBytes); //记录可丢弃的数据</div><div class=\"line\">            if (!done) &#123;//若没有写完</div><div class=\"line\">                // Did not write all buffers completely.</div><div class=\"line\">                incompleteWrite(setOpWrite);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]</li>\n<li>当content个数&gt;=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。</li>\n</ol>\n<p>至此, write到缓存、flush到网络部分全部讲完了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\"><br>涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。<br>开始向外发送数据时, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</div><div class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context</div><div class=\"line\">        final Object m = pipeline.touch(msg, next);</div><div class=\"line\">        EventExecutor executor = next.executor();</div><div class=\"line\">        if (executor.inEventLoop()) &#123;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                next.invokeWriteAndFlush(m, promise);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                next.invokeWrite(m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            AbstractWriteTask task;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行</div><div class=\"line\">            &#125;  else &#123;</div><div class=\"line\">                task = WriteTask.newInstance(next, m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            safeExecute(executor, task, promise, m);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">    super.write(ctx, msg, promise); //一般只是存放在缓存中</div><div class=\"line\">    ctx.invokeFlush(); //真正的调用write,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 写数据分为两个过程:write()和flush():</p>\n<ul>\n<li>write只是将数据放在了缓存ChannelOutboundBuffer中</li>\n<li>通过调用channal.write()向网络发送数据。</li>\n</ul>\n<h1 id=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"><a href=\"#HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\" class=\"headerlink\" title=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"></a>HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec</h1><p>我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。<br>首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class=\"line\">    CodecOutputList out = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (acceptOutboundMessage(msg)) &#123;</div><div class=\"line\">            out = CodecOutputList.newInstance();</div><div class=\"line\">            I cast = (I) msg;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                encode(ctx, cast, out);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                ReferenceCountUtil.release(cast);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (out.isEmpty()) &#123;</div><div class=\"line\">                out.recycle();</div><div class=\"line\">                out = null;</div><div class=\"line\">                throw new EncoderException(</div><div class=\"line\">                        StringUtil.simpleClassName(this) + &quot; must produce at least one message.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.write(msg, promise);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            final int sizeMinusOne = out.size() - 1;</div><div class=\"line\">            if (sizeMinusOne == 0) &#123;</div><div class=\"line\">                ctx.write(out.get(0), promise);</div><div class=\"line\">            &#125; else if (sizeMinusOne &gt; 0) &#123;</div><div class=\"line\">                // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2525</div><div class=\"line\">                ChannelPromise voidPromise = ctx.voidPromise();</div><div class=\"line\">                boolean isVoidPromise = promise == voidPromise;</div><div class=\"line\">                for (int i = 0; i &lt; sizeMinusOne; i ++) &#123;//分开向下发送</div><div class=\"line\">                    ChannelPromise p;</div><div class=\"line\">                    if (isVoidPromise) &#123;</div><div class=\"line\">                        p = voidPromise;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        p = ctx.newPromise();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    ctx.write(out.getUnsafe(i), p);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ctx.write(out.getUnsafe(sizeMinusOne), promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现也很简单,主要做了如下两件事:</p>\n<ol>\n<li>首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。</li>\n<li>针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。</li>\n</ol>\n<h2 id=\"HttpContentEncoder的encode-函数\"><a href=\"#HttpContentEncoder的encode-函数\" class=\"headerlink\" title=\"HttpContentEncoder的encode()函数\"></a>HttpContentEncoder的encode()函数</h2><p>首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: “gzip,deflat,br”为例。</p>\n<p>endoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override    //msg: DefaultFullHttpResponse</div><div class=\"line\">    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        final boolean isFull = msg instanceof HttpResponse &amp;&amp; msg instanceof LastHttpContent;</div><div class=\"line\">        switch (state) &#123;</div><div class=\"line\">            case AWAIT_HEADERS: &#123;  //初始取值</div><div class=\"line\">                ensureHeaders(msg);</div><div class=\"line\">                assert encoder == null;</div><div class=\"line\"></div><div class=\"line\">                final HttpResponse res = (HttpResponse) msg;</div><div class=\"line\">                 //根据返回结果确定是否需要编码</div><div class=\"line\">                final int code = res.status().code();</div><div class=\"line\">                final CharSequence acceptEncoding;</div><div class=\"line\">                if (code == CONTINUE_CODE) &#123; //continue_code</div><div class=\"line\">                    // We need to not poll the encoding when response with CONTINUE as another response will follow</div><div class=\"line\">                    // for the issued request. See https://github.com/netty/netty/issues/4079</div><div class=\"line\">                    acceptEncoding = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Get the list of encodings accepted by the peer.</div><div class=\"line\">                    acceptEncoding = acceptEncodingQueue.poll(); //&quot;gzip.default.br&quot;</div><div class=\"line\">                    if (acceptEncoding == null) &#123;</div><div class=\"line\">                        throw new IllegalStateException(&quot;cannot send more responses than requests&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                /*</div><div class=\"line\">                 * per rfc2616 4.3 Message Body</div><div class=\"line\">                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a</div><div class=\"line\">                 * message-body. All other responses do include a message-body, although it MAY be of zero length.</div><div class=\"line\">                 *</div><div class=\"line\">                 * 9.4 HEAD</div><div class=\"line\">                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body</div><div class=\"line\">                 * in the response.</div><div class=\"line\">                 *</div><div class=\"line\">                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.</div><div class=\"line\">                 *</div><div class=\"line\">                 * See https://github.com/netty/netty/issues/5382</div><div class=\"line\">                 */</div><div class=\"line\">                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) &#123; //是否接下来是没有body的</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Pass through the full response with empty content and continue waiting for the the next resp.</div><div class=\"line\">                    if (!((ByteBufHolder) res).content().isReadable()) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity</div><div class=\"line\">                final Result result = beginEncode(res, acceptEncoding.toString());</div><div class=\"line\"></div><div class=\"line\">                // If unable to encode, pass through.</div><div class=\"line\">                if (result == null) &#123;</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                encoder = result.contentEncoder(); //encoder = EmbeddedChannel</div><div class=\"line\"></div><div class=\"line\">                // Encode the content and remove or replace the existing headers</div><div class=\"line\">                // so that the message looks like a decoded message.</div><div class=\"line\">                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip</div><div class=\"line\"></div><div class=\"line\">                // Output the rewritten response.</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Convert full message into unfull one.</div><div class=\"line\">                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());</div><div class=\"line\">                    newRes.headers().set(res.headers());</div><div class=\"line\">                    out.add(newRes);  //newRes里面还没有放数据</div><div class=\"line\"></div><div class=\"line\">                    ensureContent(res);</div><div class=\"line\">                    encodeFullResponse(newRes, (HttpContent) res, out);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Make the response chunked to simplify content transformation.</div><div class=\"line\">                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);</div><div class=\"line\">                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);</div><div class=\"line\"></div><div class=\"line\">                    out.add(res);</div><div class=\"line\">                    state = State.AWAIT_CONTENT;</div><div class=\"line\">                    if (!(msg instanceof HttpContent)) &#123;</div><div class=\"line\">                        // only break out the switch statement if we have not content to process</div><div class=\"line\">                        // See https://github.com/netty/netty/issues/2006</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Fall through to encode the content</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case AWAIT_CONTENT: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                if (encodeContent((HttpContent) msg, out)) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case PASS_THROUGH: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                out.add(ReferenceCountUtil.retain(msg));</div><div class=\"line\">                // Passed through all following contents of the current response.</div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>该编码器encode主要做的事情:<br>1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:</p>\n<ul>\n<li>若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。</li>\n<li>否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br<br>2.根据规范<code>rfc2616 4.3 Message Body</code>, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。<br>3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。<br>4.在beginEncode中建立相应压缩管道EmbeddedChannel:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception &#123;</div><div class=\"line\">       ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP</div><div class=\"line\">       if (wrapper == null) &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">       String targetContentEncoding;</div><div class=\"line\">       switch (wrapper) &#123;</div><div class=\"line\">       case GZIP:</div><div class=\"line\">           targetContentEncoding = &quot;gzip&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       case ZLIB:</div><div class=\"line\">           targetContentEncoding = &quot;deflate&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       default:</div><div class=\"line\">           throw new Error();</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return new Result(</div><div class=\"line\">               targetContentEncoding,</div><div class=\"line\">               new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),</div><div class=\"line\">                       ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(</div><div class=\"line\">                       wrapper, compressionLevel, windowBits, memLevel)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip&gt;deflate</li>\n<li>返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\"><br>对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。<br>5.向返回值headler中添加 content-encoding:gzip<br>6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.<br>7.在encodeFullResponse中调用编码函数encodeContent()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean encodeContent(HttpContent c, List&lt;Object&gt; out) &#123;</div><div class=\"line\">        ByteBuf content = c.content();</div><div class=\"line\">        encode(content, out);</div><div class=\"line\">        if (c instanceof LastHttpContent) &#123;</div><div class=\"line\">            finishEncode(out);</div><div class=\"line\">            LastHttpContent last = (LastHttpContent) c;</div><div class=\"line\">            // Generate an additional chunk if the decoder produced</div><div class=\"line\">            // the last product on closure,</div><div class=\"line\">            HttpHeaders headers = last.trailingHeaders();</div><div class=\"line\">            if (headers.isEmpty()) &#123;</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new ComposedLastHttpContent(headers));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。</p>\n<ul>\n<li>调用JdkZlibEncoder.encode()进行压缩。</li>\n<li>将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。</li>\n<li>在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。<br>7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。<br>这样整个输出帧的内容存放在out中, 拥有的对象如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\"><br>其中:</li>\n<li>DefaultHttpResponse: 存放的是Http/1.1 status, Header等</li>\n<li>第一个DefaultHttpContent存放的是压缩的内容。</li>\n<li>第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。</li>\n<li>LastHttpContent代表整个帧的结束, content部分为空。<br>8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。<h2 id=\"JdkZlibEncoder压缩\"><a href=\"#JdkZlibEncoder压缩\" class=\"headerlink\" title=\"JdkZlibEncoder压缩\"></a>JdkZlibEncoder压缩</h2>我们可以了解下JdkZlibEncoder.encode()是怎么压缩的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception &#123;</div><div class=\"line\">    int len = uncompressed.readableBytes(); //总共刻度数据</div><div class=\"line\">    int offset;</div><div class=\"line\">    byte[] inAry;</div><div class=\"line\">    if (uncompressed.hasArray()) &#123;  //若有数组,直接获得数组</div><div class=\"line\">        // if it is backed by an array we not need to to do a copy at all</div><div class=\"line\">        inAry = uncompressed.array();</div><div class=\"line\">        offset = uncompressed.arrayOffset() + uncompressed.readerIndex();</div><div class=\"line\">        // skip all bytes as we will consume all of them</div><div class=\"line\">        uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        inAry = new byte[len];</div><div class=\"line\">        uncompressed.readBytes(inAry);//将数据读取到这个byte数组中</div><div class=\"line\">        offset = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (writeHeader) &#123; //将数组写进去， 最开始编码，需要写</div><div class=\"line\">        writeHeader = false;</div><div class=\"line\">        if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">            out.writeBytes(gzipHeader);//首先写进去头</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">        crc.update(inAry, offset, len);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //向压缩器中传递带压缩的数组</div><div class=\"line\">    deflater.setInput(inAry, offset, len);</div><div class=\"line\">    while (!deflater.needsInput()) &#123;</div><div class=\"line\">        deflate(out); //进行真正的压缩</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先获得bytebuf的byte数组</li>\n<li>向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];<br>其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;</li>\n<li>直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。</li>\n</ul>\n<h2 id=\"DefalueChannalHadlerContext-write\"><a href=\"#DefalueChannalHadlerContext-write\" class=\"headerlink\" title=\"DefalueChannalHadlerContext.write()\"></a>DefalueChannalHadlerContext.write()</h2><p>DefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。<br>接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ByteBuf buf = null;</div><div class=\"line\">if (msg instanceof HttpMessage) &#123;  //如果是头部，则先编码头部</div><div class=\"line\">    if (state != ST_INIT) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">    &#125;</div><div class=\"line\">    H m = (H) msg;</div><div class=\"line\">    buf = ctx.alloc().buffer();//直接内存分配的地址</div><div class=\"line\">    // Encode the message.</div><div class=\"line\">    encodeInitialLine(buf, m); //先是编码initial部分</div><div class=\"line\">    encodeHeaders(m.headers(), buf);//再编码header部分</div><div class=\"line\">    buf.writeBytes(CRLF);</div><div class=\"line\">    state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK</div><div class=\"line\">            HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg instanceof ByteBuf &amp;&amp; !((ByteBuf) msg).isReadable()) &#123;</div><div class=\"line\">    out.add(EMPTY_BUFFER);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse</div><div class=\"line\">if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) &#123;</div><div class=\"line\">    switch (state) &#123;</div><div class=\"line\">        case ST_INIT:</div><div class=\"line\">            throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">        case ST_CONTENT_NON_CHUNK: //st_content_non_chunk</div><div class=\"line\">            final long contentLength = contentLength(msg);</div><div class=\"line\">            if (contentLength &gt; 0) &#123;//可写的空间够，直接放到直接内存buf中</div><div class=\"line\">                if (buf != null &amp;&amp; buf.writableBytes() &gt;= contentLength &amp;&amp; msg instanceof HttpContent) &#123;//必须是content类型的</div><div class=\"line\">                    // merge into other buffer for performance reasons</div><div class=\"line\">                    buf.writeBytes(((HttpContent) msg).content());</div><div class=\"line\">                    out.add(buf);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (buf != null) &#123;</div><div class=\"line\">                        out.add(buf); //先把直接内存放进去</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = ST_INIT; //编码完成后，直接复位</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // fall-through!</div><div class=\"line\">        case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里</div><div class=\"line\"></div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Need to produce some output otherwise an</div><div class=\"line\">                // IllegalStateException will be thrown</div><div class=\"line\">                out.add(EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            break;</div><div class=\"line\">        case ST_CONTENT_CHUNK:</div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125;</div><div class=\"line\">            encodeChunkedContent(ctx, msg, contentLength(msg), out);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            throw new Error();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg instanceof LastHttpContent) &#123; //解码完成，再置位</div><div class=\"line\">        state = ST_INIT;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (buf != null) &#123;</div><div class=\"line\">    out.add(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>state初始值为ST_INIT, 该函数主要做了如下操作:</p>\n<ol>\n<li>首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。</li>\n</ol>\n<ul>\n<li><p>通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> response.protocolVersion().encode(buf); //首先存放version编码</div><div class=\"line\">buf.writeByte(SP); //存放byte:32水平空格</div><div class=\"line\">response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=&quot;200 ok&quot;</div><div class=\"line\">buf.writeBytes(CRLF); //  &#123; CR, LF &#125;回车换行</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过encodeHeaders编码header部分, 每个header属性编码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> final int nameLen = name.length();</div><div class=\"line\">final int valueLen = value.length();</div><div class=\"line\">final int entryLen = nameLen + valueLen + 4;</div><div class=\"line\">buf.ensureWritable(entryLen);  //检查buf的最小长度</div><div class=\"line\">int offset = buf.writerIndex();</div><div class=\"line\">writeAscii(buf, offset, name); // 使用US_ASCII编码</div><div class=\"line\">offset += nameLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;:&apos;);//:</div><div class=\"line\">buf.setByte(offset ++, &apos; &apos;);//空格</div><div class=\"line\">writeAscii(buf, offset, value);</div><div class=\"line\">offset += valueLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;\\r&apos;);//</div><div class=\"line\">buf.setByte(offset ++, &apos;\\n&apos;);</div><div class=\"line\">buf.writerIndex(offset);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格<br>2) 通过CharsetUtil.US_ASCII编码key和value</p>\n<ul>\n<li>再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\"></li>\n</ul>\n<p>然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。<br>2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。</p>\n<ul>\n<li>会直接将整个DefaltHttpContent放入out向外写</li>\n<li>当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。</li>\n</ul>\n<h1 id=\"Netty水位\"><a href=\"#Netty水位\" class=\"headerlink\" title=\"Netty水位\"></a>Netty水位</h1><p>向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">     public final void write(Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位</div><div class=\"line\">         int size;</div><div class=\"line\">         try &#123;</div><div class=\"line\">             msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap</div><div class=\"line\">             size = pipeline.estimatorHandle().size(msg);</div><div class=\"line\">             if (size &lt; 0) &#123;</div><div class=\"line\">                 size = 0;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; catch (Throwable t) &#123;</div><div class=\"line\">             safeSetFailure(promise, t);</div><div class=\"line\">             ReferenceCountUtil.release(msg);</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。</li>\n<li>通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。<br>我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\"><br>flushEntry 表示即将刷新的位置<br>unflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。<br>tailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。<br>当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息</div><div class=\"line\">if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法</div><div class=\"line\">    setUnwritable(invokeLater);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?<br>在netty启动时, 只需要添加如下参数即可:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);</div></pre></td></tr></table></figure></p>\n<p>代表:</p>\n<ul>\n<li>当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。</li>\n<li>当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.<h2 id=\"setUnwritable设置不可写\"><a href=\"#setUnwritable设置不可写\" class=\"headerlink\" title=\"setUnwritable设置不可写\"></a>setUnwritable设置不可写</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    final int oldValue = unwritable;</div><div class=\"line\">    final int newValue = oldValue | 1;</div><div class=\"line\">    if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) &#123;//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态</div><div class=\"line\">        if (oldValue == 0 &amp;&amp; newValue != 0) &#123;</div><div class=\"line\">            fireChannelWritabilityChanged(invokeLater);//</div><div class=\"line\">        &#125;//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写-&gt;不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。<br>在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。</p>\n<h1 id=\"Flush\"><a href=\"#Flush\" class=\"headerlink\" title=\"Flush\"></a>Flush</h1><p>数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">    unsafe.flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public final void flush() &#123;</div><div class=\"line\">    assertEventLoop();</div><div class=\"line\">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    outboundBuffer.addFlush();</div><div class=\"line\">    flush0();//写完了</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;</li>\n<li>调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():<h2 id=\"内部flush0\"><a href=\"#内部flush0\" class=\"headerlink\" title=\"内部flush0\"></a>内部flush0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">protected void flush0() &#123;</div><div class=\"line\">    if (inFlush0) &#123; //有正在写（真正的调用write写）</div><div class=\"line\">        // Avoid re-entrance</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    inFlush0 = true; //标记正在写</div><div class=\"line\">    // Mark all pending write requests as failure if the channel is inactive.</div><div class=\"line\">    if (!isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (isOpen()) &#123;</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Do not trigger channelWritabilityChanged because the channel is closed already.</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            inFlush0 = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        doWrite(outboundBuffer);</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">       ......</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        inFlush0 = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该代码主要做了如下事情:</p>\n<ol>\n<li>检查是否有正在flush,  如是的话, 直接退出。</li>\n<li>标志正在flush<br>3.调用doWrite继续刷:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            int size = in.size(); //所有的都写完了</div><div class=\"line\">            if (size == 0) &#123;</div><div class=\"line\">                // All written so clear OP_WRITE</div><div class=\"line\">                clearOpWrite();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            long writtenBytes = 0;</div><div class=\"line\">            boolean done = false;</div><div class=\"line\">            boolean setOpWrite = false;</div><div class=\"line\">            // Ensure the pending writes are made of ByteBufs only.</div><div class=\"line\">            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个</div><div class=\"line\">            int nioBufferCnt = in.nioBufferCount();</div><div class=\"line\">            long expectedWrittenBytes = in.nioBufferSize();</div><div class=\"line\">            SocketChannel ch = javaChannel();</div><div class=\"line\">            // Always us nioBuffers() to workaround data-corruption.</div><div class=\"line\">            // See https://github.com/netty/netty/issues/2761</div><div class=\"line\">            switch (nioBufferCnt) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                    // We have something else beside ByteBuffers to write so fallback to normal writes.</div><div class=\"line\">                    super.doWrite(in);</div><div class=\"line\">                    return;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    // Only one ByteBuf so use non-gathering write</div><div class=\"line\">                    ByteBuffer nioBuffer = nioBuffers[0];</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;</div><div class=\"line\">                        final int localWrittenBytes = ch.write(nioBuffer);</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;//循环16次, 可能一次写不完</div><div class=\"line\">                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">            in.removeBytes(writtenBytes); //记录可丢弃的数据</div><div class=\"line\">            if (!done) &#123;//若没有写完</div><div class=\"line\">                // Did not write all buffers completely.</div><div class=\"line\">                incompleteWrite(setOpWrite);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]</li>\n<li>当content个数&gt;=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。</li>\n</ol>\n<p>至此, write到缓存、flush到网络部分全部讲完了。</p>\n"},{"title":"Netty PoolChunk原理探究","date":"2018-07-20T10:48:20.000Z","_content":"Netty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunk1.png\" height=\"400\" width=\"450\"/>\n该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。\n+ 如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。\n+ 若申请32K的内存, 那么在该二叉树第8层申请。\n+ 若申请8K的内存, 那么将直接在第11层申请。\n*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>\n接下来介绍PoolChunk的成员属性:\n```\n    //该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配\n    final PoolArena<T> arena;。\n    //对外内存: DirectByteBuffer, 堆内内存 byte[]。\n    final T memory;\n    // 是内存池还是非内存池方式\n    final boolean unpooled;\n    private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明\n    private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。\n    //与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了\n    private final PoolSubpage<T>[] subpages;\n    /** Used to determine if the requested capacity is equal to or greater than pageSize. */\n    //用来判断申请的内存是否超过pageSize大小\n    private final int subpageOverflowMask;\n    //每个PoolSubpage的大小，默认为8192个字节（8K)\n    private final int pageSize;\n    //pageSize 2的 pageShifts幂\n    private final int pageShifts;\n    // 平衡二叉树的深度，\n    private final int maxOrder;\n    //PoolChunk的总内存大小,chunkSize =   (1<<maxOrder) * pageSize。\n    private final int chunkSize;\n    // PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。\n    private final int maxSubpageAllocs;\n    /** Used to mark memory as unusable */\n    //标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配\n    private final byte unusable;\n\n    //当前PoolChunk剩余可分配内存, 初始为16M。\n    private int freeBytes;\n\n    //一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)\n    PoolChunkList<T> parent;\n```\n当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke%20allocation.png\" height=\"400\" width=\"450\"/>\nNetty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。\n当第11层下标为2048的节点被分配出去:\n1. 则该节点的层号被修改为12, 表示该节点不可再分配。\n2. 同时id为1024的父节点层号改为11, id为512的节点层号改为10, ..., id为1的节点层号改为2.\n\n当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。\n构造函数中该成员斌量初始过程如下:\n```\n        memoryMap = new byte[maxSubpageAllocs << 1];\n        depthMap = new byte[memoryMap.length];\n        int memoryMapIndex = 1;\n        for (int d = 0; d <= maxOrder; ++ d) { // move down the tree one level at a time\n            int depth = 1 << d;\n            for (int p = 0; p < depth; ++ p) {\n                // in each level traverse left to right and set value to the depth of subtree\n                memoryMap[memoryMapIndex] = (byte) d;\n                depthMap[memoryMapIndex] = (byte) d;\n                memoryMapIndex ++;\n            }\n        }\n```\n实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。\n\n# PoolChunk分配内存\n下面看如何是从PoolChunk中分配内存的:\n```\n    long allocate(int normCapacity) {\n        if ((normCapacity & subpageOverflowMask) != 0) {\n            return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id\n        } else {  //分配小于8k\n            return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位\n        }\n    }\n```\n+ 返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。\n+ 若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。\n\n## 分配大于page的内存\n我们首先看allocateRun是如何操作的\n```\n     private long allocateRun(int normCapacity) {//64k\n         //算出当前大小的内存需要在那一层完成分配\n        int d = maxOrder - (log2(normCapacity) - pageShifts);\n        int id = allocateNode(d);\n        if (id < 0) {\n            return id;\n        }\n        freeBytes -= runLength(id);\n        return id;\n    }\n```\n1. 首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。\n2. 开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:\n```\n    private int allocateNode(int d) {\n        int id = 1;\n        int initial = - (1 << d); // has last d bits = 0 and rest all = 1\n        byte val = value(id);\n        //若第一层的深度不够，那么该chunkend不够分配\n        if (val > d) { // unusable\n            return -1;\n        }\n        // id & initial == 1 << d for all ids at depth d, for < d it is 0\n        while (val < d || (id & initial) == 0) {\n            id <<= 1;\n            val = value(id);\n            if (val > d) {\n                id ^= 1;\n                val = value(id);\n            }\n        }\n        byte value = value(id);\n        assert value == d && (id & initial) == 1 << d :\n        String.format(\"val = %d, id & initial = %d, d = %d\", value, id & initial, d);\n        setValue(id, unusable); // mark as unusable\n        updateParentsAlloc(id);\n        return id; //返回的是查找到的那个节点的下标\n    }\n```\n主要做了如下工作:\n1. 从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(`若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点`, 并且在该节点的下标一定>=2^d)\n2. 若当前节点层数<d, 或者当前节点的下标 < 2^d, 那么继续下一层左孩子节点查找, 直到找到某一个节点的层数==目前层数d, 则完成查找。若发现该节点剩余大小不够分配, 则在兄弟节点继续查找。\n如下图, 当查找层号为11的节点, 找到符合下标id>=x 2^11的节点 && 层号 == 11的节点 , 只能在下标为2049的那个节点。\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"/>\n其中 (id & initial) == 0) 等价于id <2^d, 作用: 若当前节点的下标< 2^s, 则会继续在当前节点的孩子节点查找。\n3. 将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。\n4. 更新该节点的所有祖父父节点层号:\n```\n   private void updateParentsAlloc(int id) {\n        while (id > 1) {  //开始更新父类节点的值\n            int parentId = id >>> 1;\n            byte val1 = value(id);\n            byte val2 = value(id ^ 1);  //获取相邻节点的值\n            byte val = val1 < val2 ? val1 : val2;\n            setValue(parentId, val);\n            id = parentId;\n        }\n    }\n```\n父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。\n\n## 分配小于page的内存\n我们来看是如何分配小于8k的内存。\n```\n    private long allocateSubpage(int normCapacity) {\n        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n        // This is need as we may add it back and so alter the linked-list structure.\n        PoolSubpage<T> head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点\n        synchronized (head) {\n            int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起\n            int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点\n            if (id < 0) {\n                return id;\n            }\n\n            final PoolSubpage<T>[] subpages = this.subpages;\n            final int pageSize = this.pageSize;\n\n            freeBytes -= pageSize;//（就是一个16M的空间）\n\n            int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）\n            PoolSubpage<T> subpage = subpages[subpageIdx];\n            if (subpage == null) {  //说明这个PoolSubpagte还没有分配出去\n                subpage = new PoolSubpage<T>(head, this, id, runOffset(id), pageSize, normCapacity);\n                subpages[subpageIdx] = subpage;\n            } else {\n                subpage.init(head, normCapacity);\n            }\n            return subpage.allocate();\n        }\n    }\n```\n主要做了如下事情:\n+ 我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。\n+ 查看该节点是第几个叶子节点: subpageIdx。\n+ 获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。\n\n## 释放内存\n上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。\n```\n    void free(long handle) {\n        int memoryMapIdx = memoryMapIdx(handle);\n        int bitmapIdx = bitmapIdx(handle);\n\n        if (bitmapIdx != 0) { // free a subpage\n            PoolSubpage<T> subpage = subpages[subpageIdx(memoryMapIdx)];\n            assert subpage != null && subpage.doNotDestroy;\n\n            // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n            // This is need as we may add it back and so alter the linked-list structure.\n            PoolSubpage<T> head = arena.findSubpagePoolHead(subpage.elemSize);\n            synchronized (head) {\n                if (subpage.free(head, bitmapIdx & 0x3FFFFFFF)) {\n                    return;\n                }\n            }\n        }\n        freeBytes += runLength(memoryMapIdx);\n        setValue(memoryMapIdx, depth(memoryMapIdx));\n        updateParentsFree(memoryMapIdx);\n    }\n```\n做了如下事情:\n+ 首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。\n```\n    private static int memoryMapIdx(long handle) { //低32位\n        return (int) handle;\n    }\n    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n    private static int bitmapIdx(long handle) { //高32位\n        return (int) (handle >>> Integer.SIZE);\n    }\n```\nhandlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。\n+ 判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数\n+ 若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。\n\n# 总结\n\nNetty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。","source":"_posts/Netty-PoolChunk原理探究.md","raw":"---\ntitle: Netty PoolChunk原理探究\ndate: 2018-07-20 18:48:20\ntags:\n---\nNetty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunk1.png\" height=\"400\" width=\"450\"/>\n该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。\n+ 如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。\n+ 若申请32K的内存, 那么在该二叉树第8层申请。\n+ 若申请8K的内存, 那么将直接在第11层申请。\n*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>\n接下来介绍PoolChunk的成员属性:\n```\n    //该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配\n    final PoolArena<T> arena;。\n    //对外内存: DirectByteBuffer, 堆内内存 byte[]。\n    final T memory;\n    // 是内存池还是非内存池方式\n    final boolean unpooled;\n    private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明\n    private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。\n    //与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了\n    private final PoolSubpage<T>[] subpages;\n    /** Used to determine if the requested capacity is equal to or greater than pageSize. */\n    //用来判断申请的内存是否超过pageSize大小\n    private final int subpageOverflowMask;\n    //每个PoolSubpage的大小，默认为8192个字节（8K)\n    private final int pageSize;\n    //pageSize 2的 pageShifts幂\n    private final int pageShifts;\n    // 平衡二叉树的深度，\n    private final int maxOrder;\n    //PoolChunk的总内存大小,chunkSize =   (1<<maxOrder) * pageSize。\n    private final int chunkSize;\n    // PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。\n    private final int maxSubpageAllocs;\n    /** Used to mark memory as unusable */\n    //标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配\n    private final byte unusable;\n\n    //当前PoolChunk剩余可分配内存, 初始为16M。\n    private int freeBytes;\n\n    //一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)\n    PoolChunkList<T> parent;\n```\n当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke%20allocation.png\" height=\"400\" width=\"450\"/>\nNetty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。\n当第11层下标为2048的节点被分配出去:\n1. 则该节点的层号被修改为12, 表示该节点不可再分配。\n2. 同时id为1024的父节点层号改为11, id为512的节点层号改为10, ..., id为1的节点层号改为2.\n\n当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。\n构造函数中该成员斌量初始过程如下:\n```\n        memoryMap = new byte[maxSubpageAllocs << 1];\n        depthMap = new byte[memoryMap.length];\n        int memoryMapIndex = 1;\n        for (int d = 0; d <= maxOrder; ++ d) { // move down the tree one level at a time\n            int depth = 1 << d;\n            for (int p = 0; p < depth; ++ p) {\n                // in each level traverse left to right and set value to the depth of subtree\n                memoryMap[memoryMapIndex] = (byte) d;\n                depthMap[memoryMapIndex] = (byte) d;\n                memoryMapIndex ++;\n            }\n        }\n```\n实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。\n\n# PoolChunk分配内存\n下面看如何是从PoolChunk中分配内存的:\n```\n    long allocate(int normCapacity) {\n        if ((normCapacity & subpageOverflowMask) != 0) {\n            return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id\n        } else {  //分配小于8k\n            return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位\n        }\n    }\n```\n+ 返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。\n+ 若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。\n\n## 分配大于page的内存\n我们首先看allocateRun是如何操作的\n```\n     private long allocateRun(int normCapacity) {//64k\n         //算出当前大小的内存需要在那一层完成分配\n        int d = maxOrder - (log2(normCapacity) - pageShifts);\n        int id = allocateNode(d);\n        if (id < 0) {\n            return id;\n        }\n        freeBytes -= runLength(id);\n        return id;\n    }\n```\n1. 首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。\n2. 开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:\n```\n    private int allocateNode(int d) {\n        int id = 1;\n        int initial = - (1 << d); // has last d bits = 0 and rest all = 1\n        byte val = value(id);\n        //若第一层的深度不够，那么该chunkend不够分配\n        if (val > d) { // unusable\n            return -1;\n        }\n        // id & initial == 1 << d for all ids at depth d, for < d it is 0\n        while (val < d || (id & initial) == 0) {\n            id <<= 1;\n            val = value(id);\n            if (val > d) {\n                id ^= 1;\n                val = value(id);\n            }\n        }\n        byte value = value(id);\n        assert value == d && (id & initial) == 1 << d :\n        String.format(\"val = %d, id & initial = %d, d = %d\", value, id & initial, d);\n        setValue(id, unusable); // mark as unusable\n        updateParentsAlloc(id);\n        return id; //返回的是查找到的那个节点的下标\n    }\n```\n主要做了如下工作:\n1. 从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(`若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点`, 并且在该节点的下标一定>=2^d)\n2. 若当前节点层数<d, 或者当前节点的下标 < 2^d, 那么继续下一层左孩子节点查找, 直到找到某一个节点的层数==目前层数d, 则完成查找。若发现该节点剩余大小不够分配, 则在兄弟节点继续查找。\n如下图, 当查找层号为11的节点, 找到符合下标id>=x 2^11的节点 && 层号 == 11的节点 , 只能在下标为2049的那个节点。\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"/>\n其中 (id & initial) == 0) 等价于id <2^d, 作用: 若当前节点的下标< 2^s, 则会继续在当前节点的孩子节点查找。\n3. 将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。\n4. 更新该节点的所有祖父父节点层号:\n```\n   private void updateParentsAlloc(int id) {\n        while (id > 1) {  //开始更新父类节点的值\n            int parentId = id >>> 1;\n            byte val1 = value(id);\n            byte val2 = value(id ^ 1);  //获取相邻节点的值\n            byte val = val1 < val2 ? val1 : val2;\n            setValue(parentId, val);\n            id = parentId;\n        }\n    }\n```\n父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。\n\n## 分配小于page的内存\n我们来看是如何分配小于8k的内存。\n```\n    private long allocateSubpage(int normCapacity) {\n        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n        // This is need as we may add it back and so alter the linked-list structure.\n        PoolSubpage<T> head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点\n        synchronized (head) {\n            int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起\n            int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点\n            if (id < 0) {\n                return id;\n            }\n\n            final PoolSubpage<T>[] subpages = this.subpages;\n            final int pageSize = this.pageSize;\n\n            freeBytes -= pageSize;//（就是一个16M的空间）\n\n            int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）\n            PoolSubpage<T> subpage = subpages[subpageIdx];\n            if (subpage == null) {  //说明这个PoolSubpagte还没有分配出去\n                subpage = new PoolSubpage<T>(head, this, id, runOffset(id), pageSize, normCapacity);\n                subpages[subpageIdx] = subpage;\n            } else {\n                subpage.init(head, normCapacity);\n            }\n            return subpage.allocate();\n        }\n    }\n```\n主要做了如下事情:\n+ 我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。\n+ 查看该节点是第几个叶子节点: subpageIdx。\n+ 获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。\n\n## 释放内存\n上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。\n```\n    void free(long handle) {\n        int memoryMapIdx = memoryMapIdx(handle);\n        int bitmapIdx = bitmapIdx(handle);\n\n        if (bitmapIdx != 0) { // free a subpage\n            PoolSubpage<T> subpage = subpages[subpageIdx(memoryMapIdx)];\n            assert subpage != null && subpage.doNotDestroy;\n\n            // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n            // This is need as we may add it back and so alter the linked-list structure.\n            PoolSubpage<T> head = arena.findSubpagePoolHead(subpage.elemSize);\n            synchronized (head) {\n                if (subpage.free(head, bitmapIdx & 0x3FFFFFFF)) {\n                    return;\n                }\n            }\n        }\n        freeBytes += runLength(memoryMapIdx);\n        setValue(memoryMapIdx, depth(memoryMapIdx));\n        updateParentsFree(memoryMapIdx);\n    }\n```\n做了如下事情:\n+ 首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。\n```\n    private static int memoryMapIdx(long handle) { //低32位\n        return (int) handle;\n    }\n    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n    private static int bitmapIdx(long handle) { //高32位\n        return (int) (handle >>> Integer.SIZE);\n    }\n```\nhandlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。\n+ 判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数\n+ 若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。\n\n# 总结\n\nNetty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。","slug":"Netty-PoolChunk原理探究","published":1,"updated":"2018-07-22T13:44:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvi0009isu50wpq7m0h","content":"<p>Netty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunk1.png\" height=\"400\" width=\"450\"><br>该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。</p>\n<ul>\n<li>如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。</li>\n<li>若申请32K的内存, 那么在该二叉树第8层申请。</li>\n<li>若申请8K的内存, 那么将直接在第11层申请。<br>*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a><br>接下来介绍PoolChunk的成员属性:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">//该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配</div><div class=\"line\">final PoolArena&lt;T&gt; arena;。</div><div class=\"line\">//对外内存: DirectByteBuffer, 堆内内存 byte[]。</div><div class=\"line\">final T memory;</div><div class=\"line\">// 是内存池还是非内存池方式</div><div class=\"line\">final boolean unpooled;</div><div class=\"line\">private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明</div><div class=\"line\">private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。</div><div class=\"line\">//与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] subpages;</div><div class=\"line\">/** Used to determine if the requested capacity is equal to or greater than pageSize. */</div><div class=\"line\">//用来判断申请的内存是否超过pageSize大小</div><div class=\"line\">private final int subpageOverflowMask;</div><div class=\"line\">//每个PoolSubpage的大小，默认为8192个字节（8K)</div><div class=\"line\">private final int pageSize;</div><div class=\"line\">//pageSize 2的 pageShifts幂</div><div class=\"line\">private final int pageShifts;</div><div class=\"line\">// 平衡二叉树的深度，</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//PoolChunk的总内存大小,chunkSize =   (1&lt;&lt;maxOrder) * pageSize。</div><div class=\"line\">private final int chunkSize;</div><div class=\"line\">// PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。</div><div class=\"line\">private final int maxSubpageAllocs;</div><div class=\"line\">/** Used to mark memory as unusable */</div><div class=\"line\">//标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配</div><div class=\"line\">private final byte unusable;</div><div class=\"line\"></div><div class=\"line\">//当前PoolChunk剩余可分配内存, 初始为16M。</div><div class=\"line\">private int freeBytes;</div><div class=\"line\"></div><div class=\"line\">//一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)</div><div class=\"line\">PoolChunkList&lt;T&gt; parent;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke%20allocation.png\" height=\"400\" width=\"450\"><br>Netty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。<br>当第11层下标为2048的节点被分配出去:</p>\n<ol>\n<li>则该节点的层号被修改为12, 表示该节点不可再分配。</li>\n<li>同时id为1024的父节点层号改为11, id为512的节点层号改为10, …, id为1的节点层号改为2.</li>\n</ol>\n<p>当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。<br>构造函数中该成员斌量初始过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1];</div><div class=\"line\">depthMap = new byte[memoryMap.length];</div><div class=\"line\">int memoryMapIndex = 1;</div><div class=\"line\">for (int d = 0; d &lt;= maxOrder; ++ d) &#123; // move down the tree one level at a time</div><div class=\"line\">    int depth = 1 &lt;&lt; d;</div><div class=\"line\">    for (int p = 0; p &lt; depth; ++ p) &#123;</div><div class=\"line\">        // in each level traverse left to right and set value to the depth of subtree</div><div class=\"line\">        memoryMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        depthMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        memoryMapIndex ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。</p>\n<h1 id=\"PoolChunk分配内存\"><a href=\"#PoolChunk分配内存\" class=\"headerlink\" title=\"PoolChunk分配内存\"></a>PoolChunk分配内存</h1><p>下面看如何是从PoolChunk中分配内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate(int normCapacity) &#123;</div><div class=\"line\">    if ((normCapacity &amp; subpageOverflowMask) != 0) &#123;</div><div class=\"line\">        return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id</div><div class=\"line\">    &#125; else &#123;  //分配小于8k</div><div class=\"line\">        return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。</li>\n<li>若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。</li>\n</ul>\n<h2 id=\"分配大于page的内存\"><a href=\"#分配大于page的内存\" class=\"headerlink\" title=\"分配大于page的内存\"></a>分配大于page的内存</h2><p>我们首先看allocateRun是如何操作的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private long allocateRun(int normCapacity) &#123;//64k</div><div class=\"line\">     //算出当前大小的内存需要在那一层完成分配</div><div class=\"line\">    int d = maxOrder - (log2(normCapacity) - pageShifts);</div><div class=\"line\">    int id = allocateNode(d);</div><div class=\"line\">    if (id &lt; 0) &#123;</div><div class=\"line\">        return id;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes -= runLength(id);</div><div class=\"line\">    return id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。</li>\n<li>开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int allocateNode(int d) &#123;</div><div class=\"line\">    int id = 1;</div><div class=\"line\">    int initial = - (1 &lt;&lt; d); // has last d bits = 0 and rest all = 1</div><div class=\"line\">    byte val = value(id);</div><div class=\"line\">    //若第一层的深度不够，那么该chunkend不够分配</div><div class=\"line\">    if (val &gt; d) &#123; // unusable</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</div><div class=\"line\">    while (val &lt; d || (id &amp; initial) == 0) &#123;</div><div class=\"line\">        id &lt;&lt;= 1;</div><div class=\"line\">        val = value(id);</div><div class=\"line\">        if (val &gt; d) &#123;</div><div class=\"line\">            id ^= 1;</div><div class=\"line\">            val = value(id);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    byte value = value(id);</div><div class=\"line\">    assert value == d &amp;&amp; (id &amp; initial) == 1 &lt;&lt; d :</div><div class=\"line\">    String.format(&quot;val = %d, id &amp; initial = %d, d = %d&quot;, value, id &amp; initial, d);</div><div class=\"line\">    setValue(id, unusable); // mark as unusable</div><div class=\"line\">    updateParentsAlloc(id);</div><div class=\"line\">    return id; //返回的是查找到的那个节点的下标</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要做了如下工作:</p>\n<ol>\n<li>从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(<code>若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点</code>, 并且在该节点的下标一定&gt;=2^d)</li>\n<li>若当前节点层数<d, 或者当前节点的下标=\"\" <=\"\" 2^d,=\"\" 那么继续下一层左孩子节点查找,=\"\" 直到找到某一个节点的层数=\"=目前层数d,\" 则完成查找。若发现该节点剩余大小不够分配,=\"\" 则在兄弟节点继续查找。=\"\" 如下图,=\"\" 当查找层号为11的节点,=\"\" 找到符合下标id=\"\">=x 2^11的节点 &amp;&amp; 层号 == 11的节点 , 只能在下标为2049的那个节点。<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"><br>其中 (id &amp; initial) == 0) 等价于id &lt;2^d, 作用: 若当前节点的下标&lt; 2^s, 则会继续在当前节点的孩子节点查找。</d,></li>\n<li>将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。</li>\n<li>更新该节点的所有祖父父节点层号:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void updateParentsAlloc(int id) &#123;</div><div class=\"line\">     while (id &gt; 1) &#123;  //开始更新父类节点的值</div><div class=\"line\">         int parentId = id &gt;&gt;&gt; 1;</div><div class=\"line\">         byte val1 = value(id);</div><div class=\"line\">         byte val2 = value(id ^ 1);  //获取相邻节点的值</div><div class=\"line\">         byte val = val1 &lt; val2 ? val1 : val2;</div><div class=\"line\">         setValue(parentId, val);</div><div class=\"line\">         id = parentId;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。</p>\n<h2 id=\"分配小于page的内存\"><a href=\"#分配小于page的内存\" class=\"headerlink\" title=\"分配小于page的内存\"></a>分配小于page的内存</h2><p>我们来看是如何分配小于8k的内存。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long allocateSubpage(int normCapacity) &#123;</div><div class=\"line\">    // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">    // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点</div><div class=\"line\">    synchronized (head) &#123;</div><div class=\"line\">        int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起</div><div class=\"line\">        int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点</div><div class=\"line\">        if (id &lt; 0) &#123;</div><div class=\"line\">            return id;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final PoolSubpage&lt;T&gt;[] subpages = this.subpages;</div><div class=\"line\">        final int pageSize = this.pageSize;</div><div class=\"line\"></div><div class=\"line\">        freeBytes -= pageSize;//（就是一个16M的空间）</div><div class=\"line\"></div><div class=\"line\">        int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</div><div class=\"line\">        if (subpage == null) &#123;  //说明这个PoolSubpagte还没有分配出去</div><div class=\"line\">            subpage = new PoolSubpage&lt;T&gt;(head, this, id, runOffset(id), pageSize, normCapacity);</div><div class=\"line\">            subpages[subpageIdx] = subpage;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            subpage.init(head, normCapacity);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return subpage.allocate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。</li>\n<li>查看该节点是第几个叶子节点: subpageIdx。</li>\n<li>获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。</li>\n</ul>\n<h2 id=\"释放内存\"><a href=\"#释放内存\" class=\"headerlink\" title=\"释放内存\"></a>释放内存</h2><p>上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">void free(long handle) &#123;</div><div class=\"line\">    int memoryMapIdx = memoryMapIdx(handle);</div><div class=\"line\">    int bitmapIdx = bitmapIdx(handle);</div><div class=\"line\"></div><div class=\"line\">    if (bitmapIdx != 0) &#123; // free a subpage</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</div><div class=\"line\">        assert subpage != null &amp;&amp; subpage.doNotDestroy;</div><div class=\"line\"></div><div class=\"line\">        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">        // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</div><div class=\"line\">        synchronized (head) &#123;</div><div class=\"line\">            if (subpage.free(head, bitmapIdx &amp; 0x3FFFFFFF)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes += runLength(memoryMapIdx);</div><div class=\"line\">    setValue(memoryMapIdx, depth(memoryMapIdx));</div><div class=\"line\">    updateParentsFree(memoryMapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int memoryMapIdx(long handle) &#123; //低32位</div><div class=\"line\">    return (int) handle;</div><div class=\"line\">&#125;</div><div class=\"line\">////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">private static int bitmapIdx(long handle) &#123; //高32位</div><div class=\"line\">    return (int) (handle &gt;&gt;&gt; Integer.SIZE);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>handlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。</p>\n<ul>\n<li>判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数</li>\n<li>若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Netty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Netty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunk1.png\" height=\"400\" width=\"450\"><br>该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。</p>\n<ul>\n<li>如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。</li>\n<li>若申请32K的内存, 那么在该二叉树第8层申请。</li>\n<li>若申请8K的内存, 那么将直接在第11层申请。<br>*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a><br>接下来介绍PoolChunk的成员属性:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">//该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配</div><div class=\"line\">final PoolArena&lt;T&gt; arena;。</div><div class=\"line\">//对外内存: DirectByteBuffer, 堆内内存 byte[]。</div><div class=\"line\">final T memory;</div><div class=\"line\">// 是内存池还是非内存池方式</div><div class=\"line\">final boolean unpooled;</div><div class=\"line\">private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明</div><div class=\"line\">private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。</div><div class=\"line\">//与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] subpages;</div><div class=\"line\">/** Used to determine if the requested capacity is equal to or greater than pageSize. */</div><div class=\"line\">//用来判断申请的内存是否超过pageSize大小</div><div class=\"line\">private final int subpageOverflowMask;</div><div class=\"line\">//每个PoolSubpage的大小，默认为8192个字节（8K)</div><div class=\"line\">private final int pageSize;</div><div class=\"line\">//pageSize 2的 pageShifts幂</div><div class=\"line\">private final int pageShifts;</div><div class=\"line\">// 平衡二叉树的深度，</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//PoolChunk的总内存大小,chunkSize =   (1&lt;&lt;maxOrder) * pageSize。</div><div class=\"line\">private final int chunkSize;</div><div class=\"line\">// PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。</div><div class=\"line\">private final int maxSubpageAllocs;</div><div class=\"line\">/** Used to mark memory as unusable */</div><div class=\"line\">//标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配</div><div class=\"line\">private final byte unusable;</div><div class=\"line\"></div><div class=\"line\">//当前PoolChunk剩余可分配内存, 初始为16M。</div><div class=\"line\">private int freeBytes;</div><div class=\"line\"></div><div class=\"line\">//一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)</div><div class=\"line\">PoolChunkList&lt;T&gt; parent;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke%20allocation.png\" height=\"400\" width=\"450\"><br>Netty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。<br>当第11层下标为2048的节点被分配出去:</p>\n<ol>\n<li>则该节点的层号被修改为12, 表示该节点不可再分配。</li>\n<li>同时id为1024的父节点层号改为11, id为512的节点层号改为10, …, id为1的节点层号改为2.</li>\n</ol>\n<p>当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。<br>构造函数中该成员斌量初始过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1];</div><div class=\"line\">depthMap = new byte[memoryMap.length];</div><div class=\"line\">int memoryMapIndex = 1;</div><div class=\"line\">for (int d = 0; d &lt;= maxOrder; ++ d) &#123; // move down the tree one level at a time</div><div class=\"line\">    int depth = 1 &lt;&lt; d;</div><div class=\"line\">    for (int p = 0; p &lt; depth; ++ p) &#123;</div><div class=\"line\">        // in each level traverse left to right and set value to the depth of subtree</div><div class=\"line\">        memoryMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        depthMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        memoryMapIndex ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。</p>\n<h1 id=\"PoolChunk分配内存\"><a href=\"#PoolChunk分配内存\" class=\"headerlink\" title=\"PoolChunk分配内存\"></a>PoolChunk分配内存</h1><p>下面看如何是从PoolChunk中分配内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate(int normCapacity) &#123;</div><div class=\"line\">    if ((normCapacity &amp; subpageOverflowMask) != 0) &#123;</div><div class=\"line\">        return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id</div><div class=\"line\">    &#125; else &#123;  //分配小于8k</div><div class=\"line\">        return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。</li>\n<li>若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。</li>\n</ul>\n<h2 id=\"分配大于page的内存\"><a href=\"#分配大于page的内存\" class=\"headerlink\" title=\"分配大于page的内存\"></a>分配大于page的内存</h2><p>我们首先看allocateRun是如何操作的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private long allocateRun(int normCapacity) &#123;//64k</div><div class=\"line\">     //算出当前大小的内存需要在那一层完成分配</div><div class=\"line\">    int d = maxOrder - (log2(normCapacity) - pageShifts);</div><div class=\"line\">    int id = allocateNode(d);</div><div class=\"line\">    if (id &lt; 0) &#123;</div><div class=\"line\">        return id;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes -= runLength(id);</div><div class=\"line\">    return id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。</li>\n<li>开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int allocateNode(int d) &#123;</div><div class=\"line\">    int id = 1;</div><div class=\"line\">    int initial = - (1 &lt;&lt; d); // has last d bits = 0 and rest all = 1</div><div class=\"line\">    byte val = value(id);</div><div class=\"line\">    //若第一层的深度不够，那么该chunkend不够分配</div><div class=\"line\">    if (val &gt; d) &#123; // unusable</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</div><div class=\"line\">    while (val &lt; d || (id &amp; initial) == 0) &#123;</div><div class=\"line\">        id &lt;&lt;= 1;</div><div class=\"line\">        val = value(id);</div><div class=\"line\">        if (val &gt; d) &#123;</div><div class=\"line\">            id ^= 1;</div><div class=\"line\">            val = value(id);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    byte value = value(id);</div><div class=\"line\">    assert value == d &amp;&amp; (id &amp; initial) == 1 &lt;&lt; d :</div><div class=\"line\">    String.format(&quot;val = %d, id &amp; initial = %d, d = %d&quot;, value, id &amp; initial, d);</div><div class=\"line\">    setValue(id, unusable); // mark as unusable</div><div class=\"line\">    updateParentsAlloc(id);</div><div class=\"line\">    return id; //返回的是查找到的那个节点的下标</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要做了如下工作:</p>\n<ol>\n<li>从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(<code>若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点</code>, 并且在该节点的下标一定&gt;=2^d)</li>\n<li>若当前节点层数<d, 或者当前节点的下标=\"\" <=\"\" 2^d,=\"\" 那么继续下一层左孩子节点查找,=\"\" 直到找到某一个节点的层数=\"=目前层数d,\" 则完成查找。若发现该节点剩余大小不够分配,=\"\" 则在兄弟节点继续查找。=\"\" 如下图,=\"\" 当查找层号为11的节点,=\"\" 找到符合下标id=\"\">=x 2^11的节点 &amp;&amp; 层号 == 11的节点 , 只能在下标为2049的那个节点。<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"><br>其中 (id &amp; initial) == 0) 等价于id &lt;2^d, 作用: 若当前节点的下标&lt; 2^s, 则会继续在当前节点的孩子节点查找。</d,></li>\n<li>将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。</li>\n<li>更新该节点的所有祖父父节点层号:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void updateParentsAlloc(int id) &#123;</div><div class=\"line\">     while (id &gt; 1) &#123;  //开始更新父类节点的值</div><div class=\"line\">         int parentId = id &gt;&gt;&gt; 1;</div><div class=\"line\">         byte val1 = value(id);</div><div class=\"line\">         byte val2 = value(id ^ 1);  //获取相邻节点的值</div><div class=\"line\">         byte val = val1 &lt; val2 ? val1 : val2;</div><div class=\"line\">         setValue(parentId, val);</div><div class=\"line\">         id = parentId;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。</p>\n<h2 id=\"分配小于page的内存\"><a href=\"#分配小于page的内存\" class=\"headerlink\" title=\"分配小于page的内存\"></a>分配小于page的内存</h2><p>我们来看是如何分配小于8k的内存。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long allocateSubpage(int normCapacity) &#123;</div><div class=\"line\">    // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">    // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点</div><div class=\"line\">    synchronized (head) &#123;</div><div class=\"line\">        int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起</div><div class=\"line\">        int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点</div><div class=\"line\">        if (id &lt; 0) &#123;</div><div class=\"line\">            return id;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final PoolSubpage&lt;T&gt;[] subpages = this.subpages;</div><div class=\"line\">        final int pageSize = this.pageSize;</div><div class=\"line\"></div><div class=\"line\">        freeBytes -= pageSize;//（就是一个16M的空间）</div><div class=\"line\"></div><div class=\"line\">        int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</div><div class=\"line\">        if (subpage == null) &#123;  //说明这个PoolSubpagte还没有分配出去</div><div class=\"line\">            subpage = new PoolSubpage&lt;T&gt;(head, this, id, runOffset(id), pageSize, normCapacity);</div><div class=\"line\">            subpages[subpageIdx] = subpage;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            subpage.init(head, normCapacity);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return subpage.allocate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。</li>\n<li>查看该节点是第几个叶子节点: subpageIdx。</li>\n<li>获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。</li>\n</ul>\n<h2 id=\"释放内存\"><a href=\"#释放内存\" class=\"headerlink\" title=\"释放内存\"></a>释放内存</h2><p>上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">void free(long handle) &#123;</div><div class=\"line\">    int memoryMapIdx = memoryMapIdx(handle);</div><div class=\"line\">    int bitmapIdx = bitmapIdx(handle);</div><div class=\"line\"></div><div class=\"line\">    if (bitmapIdx != 0) &#123; // free a subpage</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</div><div class=\"line\">        assert subpage != null &amp;&amp; subpage.doNotDestroy;</div><div class=\"line\"></div><div class=\"line\">        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">        // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</div><div class=\"line\">        synchronized (head) &#123;</div><div class=\"line\">            if (subpage.free(head, bitmapIdx &amp; 0x3FFFFFFF)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes += runLength(memoryMapIdx);</div><div class=\"line\">    setValue(memoryMapIdx, depth(memoryMapIdx));</div><div class=\"line\">    updateParentsFree(memoryMapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int memoryMapIdx(long handle) &#123; //低32位</div><div class=\"line\">    return (int) handle;</div><div class=\"line\">&#125;</div><div class=\"line\">////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">private static int bitmapIdx(long handle) &#123; //高32位</div><div class=\"line\">    return (int) (handle &gt;&gt;&gt; Integer.SIZE);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>handlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。</p>\n<ul>\n<li>判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数</li>\n<li>若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Netty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。</p>\n"},{"title":"Netty Http通信源码一(解码)阅读","date":"2018-04-15T16:06:17.000Z","_content":"首先给出一个http server pipiLine里面的处理器的组成结构的示例:\n```\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);\n            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个\n            ch.pipeline().addLast(\"decoder\", decoder);\n            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n            final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));\n            ch.pipeline().addLast(\"aggregator\", aggregator);  //包的聚合\n            ch.pipeline().addLast(\"encoder_compress\", new HttpContentCompressor(transport.compressionLevel));\n            ch.pipeline().addLast(\"pipelining\", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));\n            ch.pipeline().addLast(\"handler\", requestHandler);\n        }\n```\n其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。\nhttp处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。\n这里有一个问题:\n`为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?`\n# HttpObjectDecoder和HttpRequestDecoder\n首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:\n+ HttpRequest: 主要存放inital, head等。\n+ HttpContent: 传输的数据部分\nHttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成`HttpRequest`,实际就是将`ChannelBuffer`转变为多个`HttpChunk`对象。\nHttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。\nHttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。\ndecode函数实现如下:\n```\nprotected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) { //没有break\n        case SKIP_CONTROL_CHARS: { //skip_control_chars\n            if (!skipControlCharacters(buffer)) {\n                return;\n            }\n            currentState = State.READ_INITIAL;   //read_initail\n        }\n        case READ_INITIAL: try {  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1\n            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line); //{Method, URL, HTTPVersion\n            if (initialLine.length < 3) { //无效的请求， 忽略。\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars\n                return;\n            }\n            message = createMessage(initialLine);  //DefaultHttpRequest\n            currentState = State.READ_HEADER;  //read_header\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {    //read_header\n            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:   //skip_control_char\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE: //read_chunk_size\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:  //或者读取变量类型长度或者定长\n                long contentLength = contentLength();//没有长度相关变量就是-1\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content\n                    resetNow();\n                    return;\n                }\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content\n                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {  //read_fixed_lengt_content\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength; // 注意这两个直接赋值一样\n                }\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {  //read_variable_length_content\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {  //read_fixed_length_content\n            int readLimit = buffer.readableBytes();\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create a HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面\n            chunkSize -= toRead; //content = PooledSlicedByteBuf\n            if (chunkSize == 0) {  //要是定长的话，就直接content就是DefaultLastHttpContent，\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow(); //解析完了就该返回了\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {//read_chunk_size\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: { //read_chunked_content\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n            out.add(chunk);\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {//read_chunked_delimiter\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {//read_chunked_foooter\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {  //bad_message\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {//upgraded\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n```\n注意这里的case并没有break, decode主要做了如下逻辑:\n1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。\n```\nprivate static boolean skipControlCharacters(ByteBuf buffer) {\n        boolean skiped = false;\n        final int wIdx = buffer.writerIndex();\n        int rIdx = buffer.readerIndex();\n        while (wIdx > rIdx) {\n            int c = buffer.getUnsignedByte(rIdx++);\n            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等\n                rIdx--;\n                skiped = true;\n                break;\n            }\n        }\n        buffer.readerIndex(rIdx);\n        return skiped;\n    }\n```\n首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。\n2) 读取INITIAL部分\n从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:`GET /_cat/indices HTTP/1.1`, 创建对象:DefaultHttpRequest, 其中\n```\nhttpVersion: HTTP/1.1\nmethod: GET\nuri: /_cat/indices\n```\n这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。\n3) 读取Headers部分\n```\nprivate State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;  //DefaultHttpRequest\n        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders\n        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while{}为循环\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do { //这是个while循环，以换行符来进行分割\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n                line = headerParser.parse(buffer);   //\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {   //解析出最后一个header\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {  //header是否为空\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始\n        } else if (HttpUtil.isTransferEncodingChunked(message)) { // 是否包含 transfer-encoding: chunked\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {   //Content-Length: 80\n            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值\n        } else { //没有Content-Length和chunked相关的，就是读取变量类型长度\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n        }\n```\n主要做的事:\n+ 读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:\n```\n\"Accept\" -> \"*/*\"\n\"User-Agent\" -> \"curl/7/43/0\"\n\"Host\" -> \"127.0.0.1:9200\"\n\"Content-Length\" -> \"66735\"\n\"Content-Encoding\" -> \"gzip\"\n\"Content-Type\" -> \"application/x-www-form-urlencoded\"\n\"Expect\" -> \"100-continue\"\n\"null\" -> \"null\"\n```\n我们需要了解一个参数:Expect: 100-continue\n\n> <a href=\"https://blog.csdn.net/MitKey/article/details/52042537\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。<p>客户端策略:\n如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}\n如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。\n并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。\n有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。<p>服务端策略:\n正确情况下，收到请求后，返回 100 或错误码。\n如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。\n\n这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度>=1025时, 客户端发送的header里面才会有这个参数。\n+ 如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。\n这里会设置状态为READ_FIXED_LENGTH_CONTENT\n4)  读取内容\n因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<Math.min(readableLength, maxChunkSize), 每读取maxChunkSize长度的值就向后传递, 同时修改chunkSize的值。读取第二个chunked的动作在MessageToMessageDecoder中发出(该content的readableBytes>0)。\n这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。\n# HttpObjectAggregator和 MessageAggregator\nHttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。\nMessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:\n```\n    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {\n        if (isStartMessage(msg)) {//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行\n            handlingOversizedMessage = false;\n            if (currentMessage != null) {\n                currentMessage.release();\n                currentMessage = null;\n                throw new MessageAggregationException();\n            }\n            @SuppressWarnings(\"unchecked\")\n            S m = (S) msg; //DefaultHttpRequest\n            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)\n            // Check before content length. Failing an expectation may result in a different response being sent.\n            Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse\n            if (continueResponse != null) { //向客户端返回100-continue, 告诉客户端可以发送content了\n                // Cache the write listener for reuse.\n                ChannelFutureListener listener = continueResponseWriteListener;\n                if (listener == null) {\n                    continueResponseWriteListener = listener = new ChannelFutureListener() {\n                        @Override\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                ctx.fireExceptionCaught(future.cause());\n                            }\n                        }\n                    };\n                }\n                // Make sure to call this before writing, otherwise reference counts may be invalid.\n                boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);\n                handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);\n\n                final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);\n\n                if (closeAfterWrite) {\n                    future.addListener(ChannelFutureListener.CLOSE);\n                    return;\n                }\n                if (handlingOversizedMessage) {\n                    return;\n                }\n            } else if (isContentLengthInvalid(m, maxContentLength)) { //检查length是否有效，\n                // if content length is set, preemptively close if it's too large\n                invokeHandleOversizedMessage(ctx, m);\n                return;\n            }\n\n            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {\n                O aggregated;\n                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {\n                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());\n                } else {\n                    aggregated = beginAggregation(m, EMPTY_BUFFER);\n                }\n                finishAggregation(aggregated);\n                out.add(aggregated);\n                return;\n            }\n             //同时生成好Compent\n            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.\n            CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可\n            if (m instanceof ByteBufHolder) {\n                appendPartialContent(content, ((ByteBufHolder) m).content());\n            }\n            currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest\n        } else if (isContentMessage(msg)) { //解析内容部分\n            if (currentMessage == null) {\n                // it is possible that a TooLongFrameException was already thrown but we can still discard data\n                // until the begging of the next request/response.\n                return;\n            }\n\n            // Merge the received chunk into the content of the current message.\n            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();\n\n            @SuppressWarnings(\"unchecked\")\n            final C m = (C) msg; //可能是DefaultLastHttpContent\n            // Handle oversized message.\n            if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {\n                // By convention, full message type extends first message type.\n                @SuppressWarnings(\"unchecked\")\n                S s = (S) currentMessage;\n                invokeHandleOversizedMessage(ctx, s);\n                return;\n            }\n            // Append the content of the chunk.\n            appendPartialContent(content, m.content()); //把产生的数据添加到末尾\n            //\n            // Give the subtypes a chance to merge additional information such as trailing headers.\n            aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest\n\n            final boolean last;\n            if (m instanceof DecoderResultProvider) {\n                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();\n                if (!decoderResult.isSuccess()) {\n                    if (currentMessage instanceof DecoderResultProvider) {\n                        ((DecoderResultProvider) currentMessage).setDecoderResult(\n                                DecoderResult.failure(decoderResult.cause()));\n                    }\n                    last = true;\n                } else {\n                    last = isLastContentMessage(m);\n                }\n            } else {\n                last = isLastContentMessage(m);\n            }\n\n            if (last) {  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，\n                finishAggregation(currentMessage);\n\n                // All done\n                out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。\n                currentMessage = null;\n            }\n        } else {\n            throw new MessageAggregationException();\n        }\n    }\n```\ndecode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。\n1) 若请求是HttpRequest\n说明该部分是request最开始的那一部分。\n+ 首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。\n+ 生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。\n需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性`List<Component> components`构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。\n\n2) 若请求是HttpContent部分\n+ 将content添加进CompositeByteBuf中\n通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:\n```\n     private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {\n            .....\n            if (cIndex == components.size()) {\n                wasAdded = components.add(c);\n                if (cIndex == 0) {\n                    c.endOffset = readableBytes;\n                } else {\n                    Component prev = components.get(cIndex - 1);\n                    c.offset = prev.endOffset;\n                    c.endOffset = c.offset + readableBytes;\n                }\n            }\n            .....\n            if (increaseWriterIndex) {\n                writerIndex(writerIndex() + buffer.readableBytes());\n            }\n            return cIndex;\n        }\n    }\n```\n每个Component结构如下:\n```\n        ByteBuf buf;  //该Component实际存储\n        final int length;\n        int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。\n        int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。\n```\n在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。\n\n+ 等待所有的content发送过来\n1. 轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。\n2. 直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。\n\n至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\" />\n# 附\n如何将Composite转换为一个连续的堆内buf呢?\n通过Unpooled.copiedBuffer(request.content())方法即可。\n","source":"_posts/Netty-Http通信解码源码阅读.md","raw":"---\ntitle: Netty Http通信源码一(解码)阅读\ndate: 2018-04-16 00:06:17\ntags:\n---\n首先给出一个http server pipiLine里面的处理器的组成结构的示例:\n```\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);\n            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个\n            ch.pipeline().addLast(\"decoder\", decoder);\n            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n            final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));\n            ch.pipeline().addLast(\"aggregator\", aggregator);  //包的聚合\n            ch.pipeline().addLast(\"encoder_compress\", new HttpContentCompressor(transport.compressionLevel));\n            ch.pipeline().addLast(\"pipelining\", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));\n            ch.pipeline().addLast(\"handler\", requestHandler);\n        }\n```\n其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。\nhttp处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。\n这里有一个问题:\n`为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?`\n# HttpObjectDecoder和HttpRequestDecoder\n首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:\n+ HttpRequest: 主要存放inital, head等。\n+ HttpContent: 传输的数据部分\nHttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成`HttpRequest`,实际就是将`ChannelBuffer`转变为多个`HttpChunk`对象。\nHttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。\nHttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。\ndecode函数实现如下:\n```\nprotected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) { //没有break\n        case SKIP_CONTROL_CHARS: { //skip_control_chars\n            if (!skipControlCharacters(buffer)) {\n                return;\n            }\n            currentState = State.READ_INITIAL;   //read_initail\n        }\n        case READ_INITIAL: try {  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1\n            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line); //{Method, URL, HTTPVersion\n            if (initialLine.length < 3) { //无效的请求， 忽略。\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars\n                return;\n            }\n            message = createMessage(initialLine);  //DefaultHttpRequest\n            currentState = State.READ_HEADER;  //read_header\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {    //read_header\n            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:   //skip_control_char\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE: //read_chunk_size\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:  //或者读取变量类型长度或者定长\n                long contentLength = contentLength();//没有长度相关变量就是-1\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content\n                    resetNow();\n                    return;\n                }\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content\n                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {  //read_fixed_lengt_content\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength; // 注意这两个直接赋值一样\n                }\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {  //read_variable_length_content\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {  //read_fixed_length_content\n            int readLimit = buffer.readableBytes();\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create a HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面\n            chunkSize -= toRead; //content = PooledSlicedByteBuf\n            if (chunkSize == 0) {  //要是定长的话，就直接content就是DefaultLastHttpContent，\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow(); //解析完了就该返回了\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {//read_chunk_size\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: { //read_chunked_content\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n            out.add(chunk);\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {//read_chunked_delimiter\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {//read_chunked_foooter\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {  //bad_message\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {//upgraded\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n```\n注意这里的case并没有break, decode主要做了如下逻辑:\n1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。\n```\nprivate static boolean skipControlCharacters(ByteBuf buffer) {\n        boolean skiped = false;\n        final int wIdx = buffer.writerIndex();\n        int rIdx = buffer.readerIndex();\n        while (wIdx > rIdx) {\n            int c = buffer.getUnsignedByte(rIdx++);\n            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等\n                rIdx--;\n                skiped = true;\n                break;\n            }\n        }\n        buffer.readerIndex(rIdx);\n        return skiped;\n    }\n```\n首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。\n2) 读取INITIAL部分\n从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:`GET /_cat/indices HTTP/1.1`, 创建对象:DefaultHttpRequest, 其中\n```\nhttpVersion: HTTP/1.1\nmethod: GET\nuri: /_cat/indices\n```\n这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。\n3) 读取Headers部分\n```\nprivate State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;  //DefaultHttpRequest\n        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders\n        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while{}为循环\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do { //这是个while循环，以换行符来进行分割\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n                line = headerParser.parse(buffer);   //\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {   //解析出最后一个header\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {  //header是否为空\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始\n        } else if (HttpUtil.isTransferEncodingChunked(message)) { // 是否包含 transfer-encoding: chunked\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {   //Content-Length: 80\n            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值\n        } else { //没有Content-Length和chunked相关的，就是读取变量类型长度\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n        }\n```\n主要做的事:\n+ 读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:\n```\n\"Accept\" -> \"*/*\"\n\"User-Agent\" -> \"curl/7/43/0\"\n\"Host\" -> \"127.0.0.1:9200\"\n\"Content-Length\" -> \"66735\"\n\"Content-Encoding\" -> \"gzip\"\n\"Content-Type\" -> \"application/x-www-form-urlencoded\"\n\"Expect\" -> \"100-continue\"\n\"null\" -> \"null\"\n```\n我们需要了解一个参数:Expect: 100-continue\n\n> <a href=\"https://blog.csdn.net/MitKey/article/details/52042537\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。<p>客户端策略:\n如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}\n如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。\n并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。\n有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。<p>服务端策略:\n正确情况下，收到请求后，返回 100 或错误码。\n如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。\n\n这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度>=1025时, 客户端发送的header里面才会有这个参数。\n+ 如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。\n这里会设置状态为READ_FIXED_LENGTH_CONTENT\n4)  读取内容\n因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<Math.min(readableLength, maxChunkSize), 每读取maxChunkSize长度的值就向后传递, 同时修改chunkSize的值。读取第二个chunked的动作在MessageToMessageDecoder中发出(该content的readableBytes>0)。\n这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。\n# HttpObjectAggregator和 MessageAggregator\nHttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。\nMessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:\n```\n    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {\n        if (isStartMessage(msg)) {//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行\n            handlingOversizedMessage = false;\n            if (currentMessage != null) {\n                currentMessage.release();\n                currentMessage = null;\n                throw new MessageAggregationException();\n            }\n            @SuppressWarnings(\"unchecked\")\n            S m = (S) msg; //DefaultHttpRequest\n            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)\n            // Check before content length. Failing an expectation may result in a different response being sent.\n            Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse\n            if (continueResponse != null) { //向客户端返回100-continue, 告诉客户端可以发送content了\n                // Cache the write listener for reuse.\n                ChannelFutureListener listener = continueResponseWriteListener;\n                if (listener == null) {\n                    continueResponseWriteListener = listener = new ChannelFutureListener() {\n                        @Override\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                ctx.fireExceptionCaught(future.cause());\n                            }\n                        }\n                    };\n                }\n                // Make sure to call this before writing, otherwise reference counts may be invalid.\n                boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);\n                handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);\n\n                final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);\n\n                if (closeAfterWrite) {\n                    future.addListener(ChannelFutureListener.CLOSE);\n                    return;\n                }\n                if (handlingOversizedMessage) {\n                    return;\n                }\n            } else if (isContentLengthInvalid(m, maxContentLength)) { //检查length是否有效，\n                // if content length is set, preemptively close if it's too large\n                invokeHandleOversizedMessage(ctx, m);\n                return;\n            }\n\n            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {\n                O aggregated;\n                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {\n                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());\n                } else {\n                    aggregated = beginAggregation(m, EMPTY_BUFFER);\n                }\n                finishAggregation(aggregated);\n                out.add(aggregated);\n                return;\n            }\n             //同时生成好Compent\n            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.\n            CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可\n            if (m instanceof ByteBufHolder) {\n                appendPartialContent(content, ((ByteBufHolder) m).content());\n            }\n            currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest\n        } else if (isContentMessage(msg)) { //解析内容部分\n            if (currentMessage == null) {\n                // it is possible that a TooLongFrameException was already thrown but we can still discard data\n                // until the begging of the next request/response.\n                return;\n            }\n\n            // Merge the received chunk into the content of the current message.\n            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();\n\n            @SuppressWarnings(\"unchecked\")\n            final C m = (C) msg; //可能是DefaultLastHttpContent\n            // Handle oversized message.\n            if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {\n                // By convention, full message type extends first message type.\n                @SuppressWarnings(\"unchecked\")\n                S s = (S) currentMessage;\n                invokeHandleOversizedMessage(ctx, s);\n                return;\n            }\n            // Append the content of the chunk.\n            appendPartialContent(content, m.content()); //把产生的数据添加到末尾\n            //\n            // Give the subtypes a chance to merge additional information such as trailing headers.\n            aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest\n\n            final boolean last;\n            if (m instanceof DecoderResultProvider) {\n                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();\n                if (!decoderResult.isSuccess()) {\n                    if (currentMessage instanceof DecoderResultProvider) {\n                        ((DecoderResultProvider) currentMessage).setDecoderResult(\n                                DecoderResult.failure(decoderResult.cause()));\n                    }\n                    last = true;\n                } else {\n                    last = isLastContentMessage(m);\n                }\n            } else {\n                last = isLastContentMessage(m);\n            }\n\n            if (last) {  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，\n                finishAggregation(currentMessage);\n\n                // All done\n                out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。\n                currentMessage = null;\n            }\n        } else {\n            throw new MessageAggregationException();\n        }\n    }\n```\ndecode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。\n1) 若请求是HttpRequest\n说明该部分是request最开始的那一部分。\n+ 首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。\n+ 生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。\n需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性`List<Component> components`构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。\n\n2) 若请求是HttpContent部分\n+ 将content添加进CompositeByteBuf中\n通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:\n```\n     private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {\n            .....\n            if (cIndex == components.size()) {\n                wasAdded = components.add(c);\n                if (cIndex == 0) {\n                    c.endOffset = readableBytes;\n                } else {\n                    Component prev = components.get(cIndex - 1);\n                    c.offset = prev.endOffset;\n                    c.endOffset = c.offset + readableBytes;\n                }\n            }\n            .....\n            if (increaseWriterIndex) {\n                writerIndex(writerIndex() + buffer.readableBytes());\n            }\n            return cIndex;\n        }\n    }\n```\n每个Component结构如下:\n```\n        ByteBuf buf;  //该Component实际存储\n        final int length;\n        int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。\n        int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。\n```\n在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。\n\n+ 等待所有的content发送过来\n1. 轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。\n2. 直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。\n\n至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\" />\n# 附\n如何将Composite转换为一个连续的堆内buf呢?\n通过Unpooled.copiedBuffer(request.content())方法即可。\n","slug":"Netty-Http通信解码源码阅读","published":1,"updated":"2018-05-13T14:21:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvj000aisu5td8qs8q3","content":"<p>首先给出一个http server pipiLine里面的处理器的组成结构的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void initChannel(Channel ch) throws Exception &#123;</div><div class=\"line\">    final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);</div><div class=\"line\">    decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个</div><div class=\"line\">    ch.pipeline().addLast(&quot;decoder&quot;, decoder);</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder&quot;, new HttpResponseEncoder());</div><div class=\"line\">    final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));</div><div class=\"line\">    ch.pipeline().addLast(&quot;aggregator&quot;, aggregator);  //包的聚合</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder_compress&quot;, new HttpContentCompressor(transport.compressionLevel));</div><div class=\"line\">    ch.pipeline().addLast(&quot;pipelining&quot;, new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));</div><div class=\"line\">    ch.pipeline().addLast(&quot;handler&quot;, requestHandler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。<br>http处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。<br>这里有一个问题:<br><code>为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?</code></p>\n<h1 id=\"HttpObjectDecoder和HttpRequestDecoder\"><a href=\"#HttpObjectDecoder和HttpRequestDecoder\" class=\"headerlink\" title=\"HttpObjectDecoder和HttpRequestDecoder\"></a>HttpObjectDecoder和HttpRequestDecoder</h1><p>首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:</p>\n<ul>\n<li>HttpRequest: 主要存放inital, head等。</li>\n<li>HttpContent: 传输的数据部分<br>HttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成<code>HttpRequest</code>,实际就是将<code>ChannelBuffer</code>转变为多个<code>HttpChunk</code>对象。<br>HttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。<br>HttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。<br>decode函数实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        if (resetRequested) &#123;</div><div class=\"line\">            resetNow();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        switch (currentState) &#123; //没有break</div><div class=\"line\">        case SKIP_CONTROL_CHARS: &#123; //skip_control_chars</div><div class=\"line\">            if (!skipControlCharacters(buffer)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_INITIAL;   //read_initail</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_INITIAL: try &#123;  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String[] initialLine = splitInitialLine(line); //&#123;Method, URL, HTTPVersion</div><div class=\"line\">            if (initialLine.length &lt; 3) &#123; //无效的请求， 忽略。</div><div class=\"line\">                // Invalid initial line - ignore.</div><div class=\"line\">                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            message = createMessage(initialLine);  //DefaultHttpRequest</div><div class=\"line\">            currentState = State.READ_HEADER;  //read_header</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_HEADER: try &#123;    //read_header</div><div class=\"line\">            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式</div><div class=\"line\">            if (nextState == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = nextState;</div><div class=\"line\">            switch (nextState) &#123;</div><div class=\"line\">            case SKIP_CONTROL_CHARS:   //skip_control_char</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content</div><div class=\"line\">                resetNow();</div><div class=\"line\">                return;</div><div class=\"line\">            case READ_CHUNK_SIZE: //read_chunk_size</div><div class=\"line\">                if (!chunkedSupported) &#123;</div><div class=\"line\">                    throw new IllegalArgumentException(&quot;Chunked messages not supported&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                return;</div><div class=\"line\">            default:  //或者读取变量类型长度或者定长</div><div class=\"line\">                long contentLength = contentLength();//没有长度相关变量就是-1</div><div class=\"line\">                if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) &#123;</div><div class=\"line\">                    out.add(message);</div><div class=\"line\">                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content</div><div class=\"line\">                    resetNow();</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content</div><div class=\"line\">                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content</div><div class=\"line\">                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分</div><div class=\"line\">                if (nextState == State.READ_FIXED_LENGTH_CONTENT) &#123;  //read_fixed_lengt_content</div><div class=\"line\">                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.</div><div class=\"line\">                    chunkSize = contentLength; // 注意这两个直接赋值一样</div><div class=\"line\">                &#125;</div><div class=\"line\">                // We return here, this forces decode to be called again where we will decode the content</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_VARIABLE_LENGTH_CONTENT: &#123;  //read_variable_length_content</div><div class=\"line\">            // Keep reading data as a chunk until the end of connection is reached.</div><div class=\"line\">            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);</div><div class=\"line\">            if (toRead &gt; 0) &#123;</div><div class=\"line\">                ByteBuf content = buffer.readRetainedSlice(toRead);</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_FIXED_LENGTH_CONTENT: &#123;  //read_fixed_length_content</div><div class=\"line\">            int readLimit = buffer.readableBytes();</div><div class=\"line\">            // Check if the buffer is readable first as we use the readable byte count</div><div class=\"line\">            // to create the HttpChunk. This is needed as otherwise we may end up with</div><div class=\"line\">            // create a HttpChunk instance that contains an empty buffer and so is</div><div class=\"line\">            // handled like it is the last HttpChunk.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/433</div><div class=\"line\">            if (readLimit == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int toRead = Math.min(readLimit, maxChunkSize);</div><div class=\"line\">            if (toRead &gt; chunkSize) &#123;</div><div class=\"line\">                toRead = (int) chunkSize;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面</div><div class=\"line\">            chunkSize -= toRead; //content = PooledSlicedByteBuf</div><div class=\"line\">            if (chunkSize == 0) &#123;  //要是定长的话，就直接content就是DefaultLastHttpContent，</div><div class=\"line\">                // Read all content.</div><div class=\"line\">                out.add(new DefaultLastHttpContent(content, validateHeaders));</div><div class=\"line\">                resetNow(); //解析完了就该返回了</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        /**</div><div class=\"line\">         * everything else after this point takes care of reading chunked content. basically, read chunk size,</div><div class=\"line\">         * read chunk, read and ignore the CRLF and repeat until 0</div><div class=\"line\">         */</div><div class=\"line\">        case READ_CHUNK_SIZE: try &#123;//read_chunk_size</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer);</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int chunkSize = getChunkSize(line.toString());</div><div class=\"line\">            this.chunkSize = chunkSize;</div><div class=\"line\">            if (chunkSize == 0) &#123;</div><div class=\"line\">                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNKED_CONTENT: &#123; //read_chunked_content</div><div class=\"line\">            assert chunkSize &lt;= Integer.MAX_VALUE;</div><div class=\"line\">            int toRead = Math.min((int) chunkSize, maxChunkSize);</div><div class=\"line\">            toRead = Math.min(toRead, buffer.readableBytes());</div><div class=\"line\">            if (toRead == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));</div><div class=\"line\">            chunkSize -= toRead;</div><div class=\"line\">            out.add(chunk);</div><div class=\"line\">            if (chunkSize != 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_DELIMITER: &#123;//read_chunked_delimiter</div><div class=\"line\">            final int wIdx = buffer.writerIndex();</div><div class=\"line\">            int rIdx = buffer.readerIndex();</div><div class=\"line\">            while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">                byte next = buffer.getByte(rIdx++);</div><div class=\"line\">                if (next == HttpConstants.LF) &#123;</div><div class=\"line\">                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            buffer.readerIndex(rIdx);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_FOOTER: try &#123;//read_chunked_foooter</div><div class=\"line\">            LastHttpContent trailer = readTrailingHeaders(buffer);</div><div class=\"line\">            if (trailer == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.add(trailer);</div><div class=\"line\">            resetNow();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case BAD_MESSAGE: &#123;  //bad_message</div><div class=\"line\">            // Keep discarding until disconnection.</div><div class=\"line\">            buffer.skipBytes(buffer.readableBytes());</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case UPGRADED: &#123;//upgraded</div><div class=\"line\">            int readableBytes = buffer.readableBytes();</div><div class=\"line\">            if (readableBytes &gt; 0) &#123;</div><div class=\"line\">                // Keep on consuming as otherwise we may trigger an DecoderException,</div><div class=\"line\">                // other handler will replace this codec with the upgraded protocol codec to</div><div class=\"line\">                // take the traffic over at some point then.</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2173</div><div class=\"line\">                out.add(buffer.readBytes(readableBytes));</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意这里的case并没有break, decode主要做了如下逻辑:<br>1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean skipControlCharacters(ByteBuf buffer) &#123;</div><div class=\"line\">        boolean skiped = false;</div><div class=\"line\">        final int wIdx = buffer.writerIndex();</div><div class=\"line\">        int rIdx = buffer.readerIndex();</div><div class=\"line\">        while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">            int c = buffer.getUnsignedByte(rIdx++);</div><div class=\"line\">            if (!Character.isISOControl(c) &amp;&amp; !Character.isWhitespace(c)) &#123;//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等</div><div class=\"line\">                rIdx--;</div><div class=\"line\">                skiped = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        buffer.readerIndex(rIdx);</div><div class=\"line\">        return skiped;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。<br>2) 读取INITIAL部分<br>从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:<code>GET /_cat/indices HTTP/1.1</code>, 创建对象:DefaultHttpRequest, 其中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpVersion: HTTP/1.1</div><div class=\"line\">method: GET</div><div class=\"line\">uri: /_cat/indices</div></pre></td></tr></table></figure></p>\n<p>这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。<br>3) 读取Headers部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">private State readHeaders(ByteBuf buffer) &#123;</div><div class=\"line\">        final HttpMessage message = this.message;  //DefaultHttpRequest</div><div class=\"line\">        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders</div><div class=\"line\">        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while&#123;&#125;为循环</div><div class=\"line\">        if (line == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (line.length() &gt; 0) &#123;</div><div class=\"line\">            do &#123; //这是个while循环，以换行符来进行分割</div><div class=\"line\">                char firstChar = line.charAt(0);</div><div class=\"line\">                if (name != null &amp;&amp; (firstChar == &apos; &apos; || firstChar == &apos;\\t&apos;)) &#123;</div><div class=\"line\">                    String trimmedLine = line.toString().trim();</div><div class=\"line\">                    String valueStr = String.valueOf(value);</div><div class=\"line\">                    value = valueStr + &apos; &apos; + trimmedLine;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (name != null) &#123;</div><div class=\"line\">                        headers.add(name, value);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    splitHeader(line);</div><div class=\"line\">                &#125;</div><div class=\"line\">                line = headerParser.parse(buffer);   //</div><div class=\"line\">                if (line == null) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; while (line.length() &gt; 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Add the last header.</div><div class=\"line\">        if (name != null) &#123;   //解析出最后一个header</div><div class=\"line\">            headers.add(name, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        // reset name and value fields</div><div class=\"line\">        name = null;</div><div class=\"line\">        value = null;</div><div class=\"line\"></div><div class=\"line\">        State nextState;</div><div class=\"line\"></div><div class=\"line\">        if (isContentAlwaysEmpty(message)) &#123;  //header是否为空</div><div class=\"line\">            HttpUtil.setTransferEncodingChunked(message, false);</div><div class=\"line\">            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始</div><div class=\"line\">        &#125; else if (HttpUtil.isTransferEncodingChunked(message)) &#123; // 是否包含 transfer-encoding: chunked</div><div class=\"line\">            nextState = State.READ_CHUNK_SIZE;</div><div class=\"line\">        &#125; else if (contentLength() &gt;= 0) &#123;   //Content-Length: 80</div><div class=\"line\">            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值</div><div class=\"line\">        &#125; else &#123; //没有Content-Length和chunked相关的，就是读取变量类型长度</div><div class=\"line\">            nextState = State.READ_VARIABLE_LENGTH_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return nextState;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;Accept&quot; -&gt; &quot;*/*&quot;</div><div class=\"line\">&quot;User-Agent&quot; -&gt; &quot;curl/7/43/0&quot;</div><div class=\"line\">&quot;Host&quot; -&gt; &quot;127.0.0.1:9200&quot;</div><div class=\"line\">&quot;Content-Length&quot; -&gt; &quot;66735&quot;</div><div class=\"line\">&quot;Content-Encoding&quot; -&gt; &quot;gzip&quot;</div><div class=\"line\">&quot;Content-Type&quot; -&gt; &quot;application/x-www-form-urlencoded&quot;</div><div class=\"line\">&quot;Expect&quot; -&gt; &quot;100-continue&quot;</div><div class=\"line\">&quot;null&quot; -&gt; &quot;null&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们需要了解一个参数:Expect: 100-continue</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/MitKey/article/details/52042537\" target=\"_blank\" rel=\"external\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。</p><p>客户端策略:<br>如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}<br>如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。<br>并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。<br>有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。</p><p>服务端策略:<br>正确情况下，收到请求后，返回 100 或错误码。<br>如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。</p>\n</blockquote>\n<p>这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度&gt;=1025时, 客户端发送的header里面才会有这个参数。</p>\n<ul>\n<li>如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。<br>这里会设置状态为READ_FIXED_LENGTH_CONTENT<br>4)  读取内容<br>因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<math.min(readablelength, maxchunksize),=\"\" 每读取maxchunksize长度的值就向后传递,=\"\" 同时修改chunksize的值。读取第二个chunked的动作在messagetomessagedecoder中发出(该content的readablebytes=\"\">0)。<br>这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。<h1 id=\"HttpObjectAggregator和-MessageAggregator\"><a href=\"#HttpObjectAggregator和-MessageAggregator\" class=\"headerlink\" title=\"HttpObjectAggregator和 MessageAggregator\"></a>HttpObjectAggregator和 MessageAggregator</h1>HttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。<br>MessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">    if (isStartMessage(msg)) &#123;//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行</div><div class=\"line\">        handlingOversizedMessage = false;</div><div class=\"line\">        if (currentMessage != null) &#123;</div><div class=\"line\">            currentMessage.release();</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">            throw new MessageAggregationException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        S m = (S) msg; //DefaultHttpRequest</div><div class=\"line\">        // Send the continue response if necessary (e.g. &apos;Expect: 100-continue&apos; header)</div><div class=\"line\">        // Check before content length. Failing an expectation may result in a different response being sent.</div><div class=\"line\">        Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse</div><div class=\"line\">        if (continueResponse != null) &#123; //向客户端返回100-continue, 告诉客户端可以发送content了</div><div class=\"line\">            // Cache the write listener for reuse.</div><div class=\"line\">            ChannelFutureListener listener = continueResponseWriteListener;</div><div class=\"line\">            if (listener == null) &#123;</div><div class=\"line\">                continueResponseWriteListener = listener = new ChannelFutureListener() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                        if (!future.isSuccess()) &#123;</div><div class=\"line\">                            ctx.fireExceptionCaught(future.cause());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Make sure to call this before writing, otherwise reference counts may be invalid.</div><div class=\"line\">            boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);</div><div class=\"line\">            handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);</div><div class=\"line\"></div><div class=\"line\">            final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);</div><div class=\"line\"></div><div class=\"line\">            if (closeAfterWrite) &#123;</div><div class=\"line\">                future.addListener(ChannelFutureListener.CLOSE);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (handlingOversizedMessage) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; //检查length是否有效，</div><div class=\"line\">            // if content length is set, preemptively close if it&apos;s too large</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, m);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123;</div><div class=\"line\">            O aggregated;</div><div class=\"line\">            if (m instanceof ByteBufHolder &amp;&amp; ((ByteBufHolder) m).content().isReadable()) &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\">            finishAggregation(aggregated);</div><div class=\"line\">            out.add(aggregated);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //同时生成好Compent</div><div class=\"line\">        // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.</div><div class=\"line\">        CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可</div><div class=\"line\">        if (m instanceof ByteBufHolder) &#123;</div><div class=\"line\">            appendPartialContent(content, ((ByteBufHolder) m).content());</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest</div><div class=\"line\">    &#125; else if (isContentMessage(msg)) &#123; //解析内容部分</div><div class=\"line\">        if (currentMessage == null) &#123;</div><div class=\"line\">            // it is possible that a TooLongFrameException was already thrown but we can still discard data</div><div class=\"line\">            // until the begging of the next request/response.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Merge the received chunk into the content of the current message.</div><div class=\"line\">        CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();</div><div class=\"line\"></div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        final C m = (C) msg; //可能是DefaultLastHttpContent</div><div class=\"line\">        // Handle oversized message.</div><div class=\"line\">        if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123;</div><div class=\"line\">            // By convention, full message type extends first message type.</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            S s = (S) currentMessage;</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, s);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // Append the content of the chunk.</div><div class=\"line\">        appendPartialContent(content, m.content()); //把产生的数据添加到末尾</div><div class=\"line\">        //</div><div class=\"line\">        // Give the subtypes a chance to merge additional information such as trailing headers.</div><div class=\"line\">        aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest</div><div class=\"line\"></div><div class=\"line\">        final boolean last;</div><div class=\"line\">        if (m instanceof DecoderResultProvider) &#123;</div><div class=\"line\">            DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();</div><div class=\"line\">            if (!decoderResult.isSuccess()) &#123;</div><div class=\"line\">                if (currentMessage instanceof DecoderResultProvider) &#123;</div><div class=\"line\">                    ((DecoderResultProvider) currentMessage).setDecoderResult(</div><div class=\"line\">                            DecoderResult.failure(decoderResult.cause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">                last = true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                last = isLastContentMessage(m);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            last = isLastContentMessage(m);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (last) &#123;  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，</div><div class=\"line\">            finishAggregation(currentMessage);</div><div class=\"line\"></div><div class=\"line\">            // All done</div><div class=\"line\">            out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new MessageAggregationException();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</math.min(readablelength,></li>\n</ul>\n<p>decode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。<br>1) 若请求是HttpRequest<br>说明该部分是request最开始的那一部分。</p>\n<ul>\n<li>首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。</li>\n<li>生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。<br>需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性<code>List&lt;Component&gt; components</code>构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。</li>\n</ul>\n<p>2) 若请求是HttpContent部分</p>\n<ul>\n<li>将content添加进CompositeByteBuf中<br>通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) &#123;</div><div class=\"line\">        .....</div><div class=\"line\">        if (cIndex == components.size()) &#123;</div><div class=\"line\">            wasAdded = components.add(c);</div><div class=\"line\">            if (cIndex == 0) &#123;</div><div class=\"line\">                c.endOffset = readableBytes;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Component prev = components.get(cIndex - 1);</div><div class=\"line\">                c.offset = prev.endOffset;</div><div class=\"line\">                c.endOffset = c.offset + readableBytes;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .....</div><div class=\"line\">        if (increaseWriterIndex) &#123;</div><div class=\"line\">            writerIndex(writerIndex() + buffer.readableBytes());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个Component结构如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf buf;  //该Component实际存储</div><div class=\"line\">final int length;</div><div class=\"line\">int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。</div><div class=\"line\">int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。</div></pre></td></tr></table></figure></p>\n<p>在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。</p>\n<ul>\n<li>等待所有的content发送过来</li>\n</ul>\n<ol>\n<li>轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。</li>\n<li>直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。</li>\n</ol>\n<p>至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\"></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>如何将Composite转换为一个连续的堆内buf呢?<br>通过Unpooled.copiedBuffer(request.content())方法即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先给出一个http server pipiLine里面的处理器的组成结构的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void initChannel(Channel ch) throws Exception &#123;</div><div class=\"line\">    final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);</div><div class=\"line\">    decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个</div><div class=\"line\">    ch.pipeline().addLast(&quot;decoder&quot;, decoder);</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder&quot;, new HttpResponseEncoder());</div><div class=\"line\">    final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));</div><div class=\"line\">    ch.pipeline().addLast(&quot;aggregator&quot;, aggregator);  //包的聚合</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder_compress&quot;, new HttpContentCompressor(transport.compressionLevel));</div><div class=\"line\">    ch.pipeline().addLast(&quot;pipelining&quot;, new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));</div><div class=\"line\">    ch.pipeline().addLast(&quot;handler&quot;, requestHandler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。<br>http处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。<br>这里有一个问题:<br><code>为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?</code></p>\n<h1 id=\"HttpObjectDecoder和HttpRequestDecoder\"><a href=\"#HttpObjectDecoder和HttpRequestDecoder\" class=\"headerlink\" title=\"HttpObjectDecoder和HttpRequestDecoder\"></a>HttpObjectDecoder和HttpRequestDecoder</h1><p>首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:</p>\n<ul>\n<li>HttpRequest: 主要存放inital, head等。</li>\n<li>HttpContent: 传输的数据部分<br>HttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成<code>HttpRequest</code>,实际就是将<code>ChannelBuffer</code>转变为多个<code>HttpChunk</code>对象。<br>HttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。<br>HttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。<br>decode函数实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        if (resetRequested) &#123;</div><div class=\"line\">            resetNow();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        switch (currentState) &#123; //没有break</div><div class=\"line\">        case SKIP_CONTROL_CHARS: &#123; //skip_control_chars</div><div class=\"line\">            if (!skipControlCharacters(buffer)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_INITIAL;   //read_initail</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_INITIAL: try &#123;  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String[] initialLine = splitInitialLine(line); //&#123;Method, URL, HTTPVersion</div><div class=\"line\">            if (initialLine.length &lt; 3) &#123; //无效的请求， 忽略。</div><div class=\"line\">                // Invalid initial line - ignore.</div><div class=\"line\">                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            message = createMessage(initialLine);  //DefaultHttpRequest</div><div class=\"line\">            currentState = State.READ_HEADER;  //read_header</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_HEADER: try &#123;    //read_header</div><div class=\"line\">            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式</div><div class=\"line\">            if (nextState == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = nextState;</div><div class=\"line\">            switch (nextState) &#123;</div><div class=\"line\">            case SKIP_CONTROL_CHARS:   //skip_control_char</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content</div><div class=\"line\">                resetNow();</div><div class=\"line\">                return;</div><div class=\"line\">            case READ_CHUNK_SIZE: //read_chunk_size</div><div class=\"line\">                if (!chunkedSupported) &#123;</div><div class=\"line\">                    throw new IllegalArgumentException(&quot;Chunked messages not supported&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                return;</div><div class=\"line\">            default:  //或者读取变量类型长度或者定长</div><div class=\"line\">                long contentLength = contentLength();//没有长度相关变量就是-1</div><div class=\"line\">                if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) &#123;</div><div class=\"line\">                    out.add(message);</div><div class=\"line\">                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content</div><div class=\"line\">                    resetNow();</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content</div><div class=\"line\">                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content</div><div class=\"line\">                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分</div><div class=\"line\">                if (nextState == State.READ_FIXED_LENGTH_CONTENT) &#123;  //read_fixed_lengt_content</div><div class=\"line\">                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.</div><div class=\"line\">                    chunkSize = contentLength; // 注意这两个直接赋值一样</div><div class=\"line\">                &#125;</div><div class=\"line\">                // We return here, this forces decode to be called again where we will decode the content</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_VARIABLE_LENGTH_CONTENT: &#123;  //read_variable_length_content</div><div class=\"line\">            // Keep reading data as a chunk until the end of connection is reached.</div><div class=\"line\">            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);</div><div class=\"line\">            if (toRead &gt; 0) &#123;</div><div class=\"line\">                ByteBuf content = buffer.readRetainedSlice(toRead);</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_FIXED_LENGTH_CONTENT: &#123;  //read_fixed_length_content</div><div class=\"line\">            int readLimit = buffer.readableBytes();</div><div class=\"line\">            // Check if the buffer is readable first as we use the readable byte count</div><div class=\"line\">            // to create the HttpChunk. This is needed as otherwise we may end up with</div><div class=\"line\">            // create a HttpChunk instance that contains an empty buffer and so is</div><div class=\"line\">            // handled like it is the last HttpChunk.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/433</div><div class=\"line\">            if (readLimit == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int toRead = Math.min(readLimit, maxChunkSize);</div><div class=\"line\">            if (toRead &gt; chunkSize) &#123;</div><div class=\"line\">                toRead = (int) chunkSize;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面</div><div class=\"line\">            chunkSize -= toRead; //content = PooledSlicedByteBuf</div><div class=\"line\">            if (chunkSize == 0) &#123;  //要是定长的话，就直接content就是DefaultLastHttpContent，</div><div class=\"line\">                // Read all content.</div><div class=\"line\">                out.add(new DefaultLastHttpContent(content, validateHeaders));</div><div class=\"line\">                resetNow(); //解析完了就该返回了</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        /**</div><div class=\"line\">         * everything else after this point takes care of reading chunked content. basically, read chunk size,</div><div class=\"line\">         * read chunk, read and ignore the CRLF and repeat until 0</div><div class=\"line\">         */</div><div class=\"line\">        case READ_CHUNK_SIZE: try &#123;//read_chunk_size</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer);</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int chunkSize = getChunkSize(line.toString());</div><div class=\"line\">            this.chunkSize = chunkSize;</div><div class=\"line\">            if (chunkSize == 0) &#123;</div><div class=\"line\">                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNKED_CONTENT: &#123; //read_chunked_content</div><div class=\"line\">            assert chunkSize &lt;= Integer.MAX_VALUE;</div><div class=\"line\">            int toRead = Math.min((int) chunkSize, maxChunkSize);</div><div class=\"line\">            toRead = Math.min(toRead, buffer.readableBytes());</div><div class=\"line\">            if (toRead == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));</div><div class=\"line\">            chunkSize -= toRead;</div><div class=\"line\">            out.add(chunk);</div><div class=\"line\">            if (chunkSize != 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_DELIMITER: &#123;//read_chunked_delimiter</div><div class=\"line\">            final int wIdx = buffer.writerIndex();</div><div class=\"line\">            int rIdx = buffer.readerIndex();</div><div class=\"line\">            while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">                byte next = buffer.getByte(rIdx++);</div><div class=\"line\">                if (next == HttpConstants.LF) &#123;</div><div class=\"line\">                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            buffer.readerIndex(rIdx);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_FOOTER: try &#123;//read_chunked_foooter</div><div class=\"line\">            LastHttpContent trailer = readTrailingHeaders(buffer);</div><div class=\"line\">            if (trailer == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.add(trailer);</div><div class=\"line\">            resetNow();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case BAD_MESSAGE: &#123;  //bad_message</div><div class=\"line\">            // Keep discarding until disconnection.</div><div class=\"line\">            buffer.skipBytes(buffer.readableBytes());</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case UPGRADED: &#123;//upgraded</div><div class=\"line\">            int readableBytes = buffer.readableBytes();</div><div class=\"line\">            if (readableBytes &gt; 0) &#123;</div><div class=\"line\">                // Keep on consuming as otherwise we may trigger an DecoderException,</div><div class=\"line\">                // other handler will replace this codec with the upgraded protocol codec to</div><div class=\"line\">                // take the traffic over at some point then.</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2173</div><div class=\"line\">                out.add(buffer.readBytes(readableBytes));</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意这里的case并没有break, decode主要做了如下逻辑:<br>1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean skipControlCharacters(ByteBuf buffer) &#123;</div><div class=\"line\">        boolean skiped = false;</div><div class=\"line\">        final int wIdx = buffer.writerIndex();</div><div class=\"line\">        int rIdx = buffer.readerIndex();</div><div class=\"line\">        while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">            int c = buffer.getUnsignedByte(rIdx++);</div><div class=\"line\">            if (!Character.isISOControl(c) &amp;&amp; !Character.isWhitespace(c)) &#123;//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等</div><div class=\"line\">                rIdx--;</div><div class=\"line\">                skiped = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        buffer.readerIndex(rIdx);</div><div class=\"line\">        return skiped;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。<br>2) 读取INITIAL部分<br>从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:<code>GET /_cat/indices HTTP/1.1</code>, 创建对象:DefaultHttpRequest, 其中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpVersion: HTTP/1.1</div><div class=\"line\">method: GET</div><div class=\"line\">uri: /_cat/indices</div></pre></td></tr></table></figure></p>\n<p>这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。<br>3) 读取Headers部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">private State readHeaders(ByteBuf buffer) &#123;</div><div class=\"line\">        final HttpMessage message = this.message;  //DefaultHttpRequest</div><div class=\"line\">        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders</div><div class=\"line\">        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while&#123;&#125;为循环</div><div class=\"line\">        if (line == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (line.length() &gt; 0) &#123;</div><div class=\"line\">            do &#123; //这是个while循环，以换行符来进行分割</div><div class=\"line\">                char firstChar = line.charAt(0);</div><div class=\"line\">                if (name != null &amp;&amp; (firstChar == &apos; &apos; || firstChar == &apos;\\t&apos;)) &#123;</div><div class=\"line\">                    String trimmedLine = line.toString().trim();</div><div class=\"line\">                    String valueStr = String.valueOf(value);</div><div class=\"line\">                    value = valueStr + &apos; &apos; + trimmedLine;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (name != null) &#123;</div><div class=\"line\">                        headers.add(name, value);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    splitHeader(line);</div><div class=\"line\">                &#125;</div><div class=\"line\">                line = headerParser.parse(buffer);   //</div><div class=\"line\">                if (line == null) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; while (line.length() &gt; 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Add the last header.</div><div class=\"line\">        if (name != null) &#123;   //解析出最后一个header</div><div class=\"line\">            headers.add(name, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        // reset name and value fields</div><div class=\"line\">        name = null;</div><div class=\"line\">        value = null;</div><div class=\"line\"></div><div class=\"line\">        State nextState;</div><div class=\"line\"></div><div class=\"line\">        if (isContentAlwaysEmpty(message)) &#123;  //header是否为空</div><div class=\"line\">            HttpUtil.setTransferEncodingChunked(message, false);</div><div class=\"line\">            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始</div><div class=\"line\">        &#125; else if (HttpUtil.isTransferEncodingChunked(message)) &#123; // 是否包含 transfer-encoding: chunked</div><div class=\"line\">            nextState = State.READ_CHUNK_SIZE;</div><div class=\"line\">        &#125; else if (contentLength() &gt;= 0) &#123;   //Content-Length: 80</div><div class=\"line\">            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值</div><div class=\"line\">        &#125; else &#123; //没有Content-Length和chunked相关的，就是读取变量类型长度</div><div class=\"line\">            nextState = State.READ_VARIABLE_LENGTH_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return nextState;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;Accept&quot; -&gt; &quot;*/*&quot;</div><div class=\"line\">&quot;User-Agent&quot; -&gt; &quot;curl/7/43/0&quot;</div><div class=\"line\">&quot;Host&quot; -&gt; &quot;127.0.0.1:9200&quot;</div><div class=\"line\">&quot;Content-Length&quot; -&gt; &quot;66735&quot;</div><div class=\"line\">&quot;Content-Encoding&quot; -&gt; &quot;gzip&quot;</div><div class=\"line\">&quot;Content-Type&quot; -&gt; &quot;application/x-www-form-urlencoded&quot;</div><div class=\"line\">&quot;Expect&quot; -&gt; &quot;100-continue&quot;</div><div class=\"line\">&quot;null&quot; -&gt; &quot;null&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们需要了解一个参数:Expect: 100-continue</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/MitKey/article/details/52042537\" target=\"_blank\" rel=\"external\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。</p><p>客户端策略:<br>如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}<br>如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。<br>并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。<br>有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。</p><p>服务端策略:<br>正确情况下，收到请求后，返回 100 或错误码。<br>如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。</p>\n</blockquote>\n<p>这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度&gt;=1025时, 客户端发送的header里面才会有这个参数。</p>\n<ul>\n<li>如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。<br>这里会设置状态为READ_FIXED_LENGTH_CONTENT<br>4)  读取内容<br>因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<math.min(readablelength, maxchunksize),=\"\" 每读取maxchunksize长度的值就向后传递,=\"\" 同时修改chunksize的值。读取第二个chunked的动作在messagetomessagedecoder中发出(该content的readablebytes=\"\">0)。<br>这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。<h1 id=\"HttpObjectAggregator和-MessageAggregator\"><a href=\"#HttpObjectAggregator和-MessageAggregator\" class=\"headerlink\" title=\"HttpObjectAggregator和 MessageAggregator\"></a>HttpObjectAggregator和 MessageAggregator</h1>HttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。<br>MessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">    if (isStartMessage(msg)) &#123;//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行</div><div class=\"line\">        handlingOversizedMessage = false;</div><div class=\"line\">        if (currentMessage != null) &#123;</div><div class=\"line\">            currentMessage.release();</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">            throw new MessageAggregationException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        S m = (S) msg; //DefaultHttpRequest</div><div class=\"line\">        // Send the continue response if necessary (e.g. &apos;Expect: 100-continue&apos; header)</div><div class=\"line\">        // Check before content length. Failing an expectation may result in a different response being sent.</div><div class=\"line\">        Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse</div><div class=\"line\">        if (continueResponse != null) &#123; //向客户端返回100-continue, 告诉客户端可以发送content了</div><div class=\"line\">            // Cache the write listener for reuse.</div><div class=\"line\">            ChannelFutureListener listener = continueResponseWriteListener;</div><div class=\"line\">            if (listener == null) &#123;</div><div class=\"line\">                continueResponseWriteListener = listener = new ChannelFutureListener() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                        if (!future.isSuccess()) &#123;</div><div class=\"line\">                            ctx.fireExceptionCaught(future.cause());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Make sure to call this before writing, otherwise reference counts may be invalid.</div><div class=\"line\">            boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);</div><div class=\"line\">            handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);</div><div class=\"line\"></div><div class=\"line\">            final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);</div><div class=\"line\"></div><div class=\"line\">            if (closeAfterWrite) &#123;</div><div class=\"line\">                future.addListener(ChannelFutureListener.CLOSE);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (handlingOversizedMessage) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; //检查length是否有效，</div><div class=\"line\">            // if content length is set, preemptively close if it&apos;s too large</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, m);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123;</div><div class=\"line\">            O aggregated;</div><div class=\"line\">            if (m instanceof ByteBufHolder &amp;&amp; ((ByteBufHolder) m).content().isReadable()) &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\">            finishAggregation(aggregated);</div><div class=\"line\">            out.add(aggregated);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //同时生成好Compent</div><div class=\"line\">        // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.</div><div class=\"line\">        CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可</div><div class=\"line\">        if (m instanceof ByteBufHolder) &#123;</div><div class=\"line\">            appendPartialContent(content, ((ByteBufHolder) m).content());</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest</div><div class=\"line\">    &#125; else if (isContentMessage(msg)) &#123; //解析内容部分</div><div class=\"line\">        if (currentMessage == null) &#123;</div><div class=\"line\">            // it is possible that a TooLongFrameException was already thrown but we can still discard data</div><div class=\"line\">            // until the begging of the next request/response.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Merge the received chunk into the content of the current message.</div><div class=\"line\">        CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();</div><div class=\"line\"></div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        final C m = (C) msg; //可能是DefaultLastHttpContent</div><div class=\"line\">        // Handle oversized message.</div><div class=\"line\">        if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123;</div><div class=\"line\">            // By convention, full message type extends first message type.</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            S s = (S) currentMessage;</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, s);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // Append the content of the chunk.</div><div class=\"line\">        appendPartialContent(content, m.content()); //把产生的数据添加到末尾</div><div class=\"line\">        //</div><div class=\"line\">        // Give the subtypes a chance to merge additional information such as trailing headers.</div><div class=\"line\">        aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest</div><div class=\"line\"></div><div class=\"line\">        final boolean last;</div><div class=\"line\">        if (m instanceof DecoderResultProvider) &#123;</div><div class=\"line\">            DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();</div><div class=\"line\">            if (!decoderResult.isSuccess()) &#123;</div><div class=\"line\">                if (currentMessage instanceof DecoderResultProvider) &#123;</div><div class=\"line\">                    ((DecoderResultProvider) currentMessage).setDecoderResult(</div><div class=\"line\">                            DecoderResult.failure(decoderResult.cause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">                last = true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                last = isLastContentMessage(m);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            last = isLastContentMessage(m);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (last) &#123;  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，</div><div class=\"line\">            finishAggregation(currentMessage);</div><div class=\"line\"></div><div class=\"line\">            // All done</div><div class=\"line\">            out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new MessageAggregationException();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</math.min(readablelength,></li>\n</ul>\n<p>decode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。<br>1) 若请求是HttpRequest<br>说明该部分是request最开始的那一部分。</p>\n<ul>\n<li>首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。</li>\n<li>生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。<br>需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性<code>List&lt;Component&gt; components</code>构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。</li>\n</ul>\n<p>2) 若请求是HttpContent部分</p>\n<ul>\n<li>将content添加进CompositeByteBuf中<br>通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) &#123;</div><div class=\"line\">        .....</div><div class=\"line\">        if (cIndex == components.size()) &#123;</div><div class=\"line\">            wasAdded = components.add(c);</div><div class=\"line\">            if (cIndex == 0) &#123;</div><div class=\"line\">                c.endOffset = readableBytes;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Component prev = components.get(cIndex - 1);</div><div class=\"line\">                c.offset = prev.endOffset;</div><div class=\"line\">                c.endOffset = c.offset + readableBytes;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .....</div><div class=\"line\">        if (increaseWriterIndex) &#123;</div><div class=\"line\">            writerIndex(writerIndex() + buffer.readableBytes());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个Component结构如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf buf;  //该Component实际存储</div><div class=\"line\">final int length;</div><div class=\"line\">int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。</div><div class=\"line\">int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。</div></pre></td></tr></table></figure></p>\n<p>在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。</p>\n<ul>\n<li>等待所有的content发送过来</li>\n</ul>\n<ol>\n<li>轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。</li>\n<li>直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。</li>\n</ol>\n<p>至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\"></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>如何将Composite转换为一个连续的堆内buf呢?<br>通过Unpooled.copiedBuffer(request.content())方法即可。</p>\n"},{"title":"Netty PoolThreadCache原理探究","date":"2018-07-14T11:04:06.000Z","_content":"NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。\n# PoolThreadCache\nNetty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\"/>\n图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32>>4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。\n下面大致介绍下PoolThreadCache里面的属性作用:\n```\n    final PoolArena<byte[]> heapArena;\n    final PoolArena<ByteBuffer> directArena;\n\n    // Hold the caches for the different size classes, which are tiny, small and normal.\n    //tiny内存缓存的个数。默认为512\n    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;\n    //small内存缓存的个数,默认为256个\n    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;\n    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;\n    //normalCacheSize缓存的个数，默认为64\n    private final MemoryRegionCache<byte[]>[] normalHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;\n\n    private final int freeSweepAllocationThreshold;\n\n    private final Thread deathWatchThread;\n    //线程消亡后，释放资源\n    private final Runnable freeTask;\n    //freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。\n    private int allocations;\n\n```\n`heapArena`与`directArena`作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。`smallSubPageHeapCaches`数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, ... , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。`normalHeapCaches`数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a>\n 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:\n ```\n private static <T> MemoryRegionCache<T>[] createNormalCaches(\n            int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {\n        if (cacheSize > 0) {\n            int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k\n            //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的\n            int arraySize = Math.max(1, log2(max / area.pageSize) + 1);\n            //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住\n            @SuppressWarnings(\"unchecked\")\n            MemoryRegionCache<T>[] cache = new MemoryRegionCache[arraySize];\n            for (int i = 0; i < cache.length; i++) {\n                cache[i] = new NormalMemoryRegionCache<T>(cacheSize);\n            }\n            return cache;\n        } else {\n            return null;\n        }\n    }\n ```\n 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。\n\n以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:\n```\n     boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {\n        return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);\n    }\n```\n在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:\n```\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private boolean allocate(MemoryRegionCache<?> cache, PooledByteBuf buf, int reqCapacity) {\n        if (cache == null) {\n            // no cache found so just return false here\n            return false;\n        }\n        boolean allocated = cache.allocate(buf, reqCapacity);\n        if (++ allocations >= freeSweepAllocationThreshold) {\n            allocations = 0;\n            trim();\n        }\n        return allocated;\n    }\n```\n做了如下事情:\n+ 若没有该级别的缓存块, 则直接退出。\n+ 若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。\n\ntrim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:\n```\n        public final void trim() {\n            int free = size - allocations;\n            allocations = 0;\n\n            // We not even allocated all the number that are\n             //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次\n            if (free > 0) {\n                free(free);//才不会释放该缓存\n            }\n        }\n```\n`size`表示该16K级别的queue最大能缓存的内存数(默认64个)\n`allocations`表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。\nfree代表的含义是需要释放16KB级别缓存queue中缓存的个数, 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。\n\n## PoolThreadLocalCache\n文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。\nPoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadLocalCache。 该类封装了java的ThreadLocal.get()方法:\n```\n    public final V get() {\n        return get(InternalThreadLocalMap.get());\n    }\n\n    public final V get(InternalThreadLocalMap threadLocalMap) {\n         //想得到该层级缓存，发现没有，那么只能去初始话一个\n        Object v = threadLocalMap.indexedVariable(index);\n        if (v != InternalThreadLocalMap.UNSET) {\n            return (V) v;\n        }\n\n        return initialize(threadLocalMap);\n    }\n```\n在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。\n```\nstatic final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();\n```\n若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:\n```\n        protected synchronized PoolThreadCache initialValue() {\n            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea\n            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n\n            if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) {\n                return new PoolThreadCache( //为每一级别增加缓存\n                        heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,\n                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);\n            }\n            // No caching for non FastThreadLocalThreads.\n            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);\n        }\n```\n这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。\n至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。\n\n","source":"_posts/Netty-PoolThreadCache源码探究.md","raw":"---\ntitle: Netty PoolThreadCache原理探究\ndate: 2018-07-14 19:04:06\ntags:\n---\nNioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。\n# PoolThreadCache\nNetty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\"/>\n图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32>>4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。\n下面大致介绍下PoolThreadCache里面的属性作用:\n```\n    final PoolArena<byte[]> heapArena;\n    final PoolArena<ByteBuffer> directArena;\n\n    // Hold the caches for the different size classes, which are tiny, small and normal.\n    //tiny内存缓存的个数。默认为512\n    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;\n    //small内存缓存的个数,默认为256个\n    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;\n    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;\n    //normalCacheSize缓存的个数，默认为64\n    private final MemoryRegionCache<byte[]>[] normalHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;\n\n    private final int freeSweepAllocationThreshold;\n\n    private final Thread deathWatchThread;\n    //线程消亡后，释放资源\n    private final Runnable freeTask;\n    //freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。\n    private int allocations;\n\n```\n`heapArena`与`directArena`作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。`smallSubPageHeapCaches`数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, ... , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。`normalHeapCaches`数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a>\n 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:\n ```\n private static <T> MemoryRegionCache<T>[] createNormalCaches(\n            int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {\n        if (cacheSize > 0) {\n            int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k\n            //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的\n            int arraySize = Math.max(1, log2(max / area.pageSize) + 1);\n            //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住\n            @SuppressWarnings(\"unchecked\")\n            MemoryRegionCache<T>[] cache = new MemoryRegionCache[arraySize];\n            for (int i = 0; i < cache.length; i++) {\n                cache[i] = new NormalMemoryRegionCache<T>(cacheSize);\n            }\n            return cache;\n        } else {\n            return null;\n        }\n    }\n ```\n 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。\n\n以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:\n```\n     boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {\n        return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);\n    }\n```\n在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:\n```\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private boolean allocate(MemoryRegionCache<?> cache, PooledByteBuf buf, int reqCapacity) {\n        if (cache == null) {\n            // no cache found so just return false here\n            return false;\n        }\n        boolean allocated = cache.allocate(buf, reqCapacity);\n        if (++ allocations >= freeSweepAllocationThreshold) {\n            allocations = 0;\n            trim();\n        }\n        return allocated;\n    }\n```\n做了如下事情:\n+ 若没有该级别的缓存块, 则直接退出。\n+ 若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。\n\ntrim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:\n```\n        public final void trim() {\n            int free = size - allocations;\n            allocations = 0;\n\n            // We not even allocated all the number that are\n             //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次\n            if (free > 0) {\n                free(free);//才不会释放该缓存\n            }\n        }\n```\n`size`表示该16K级别的queue最大能缓存的内存数(默认64个)\n`allocations`表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。\nfree代表的含义是需要释放16KB级别缓存queue中缓存的个数, 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。\n\n## PoolThreadLocalCache\n文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。\nPoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadLocalCache。 该类封装了java的ThreadLocal.get()方法:\n```\n    public final V get() {\n        return get(InternalThreadLocalMap.get());\n    }\n\n    public final V get(InternalThreadLocalMap threadLocalMap) {\n         //想得到该层级缓存，发现没有，那么只能去初始话一个\n        Object v = threadLocalMap.indexedVariable(index);\n        if (v != InternalThreadLocalMap.UNSET) {\n            return (V) v;\n        }\n\n        return initialize(threadLocalMap);\n    }\n```\n在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。\n```\nstatic final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();\n```\n若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:\n```\n        protected synchronized PoolThreadCache initialValue() {\n            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea\n            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n\n            if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) {\n                return new PoolThreadCache( //为每一级别增加缓存\n                        heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,\n                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);\n            }\n            // No caching for non FastThreadLocalThreads.\n            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);\n        }\n```\n这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。\n至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。\n\n","slug":"Netty-PoolThreadCache源码探究","published":1,"updated":"2018-07-20T16:19:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvl000bisu5aqqbdeys","content":"<p>NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。</p>\n<h1 id=\"PoolThreadCache\"><a href=\"#PoolThreadCache\" class=\"headerlink\" title=\"PoolThreadCache\"></a>PoolThreadCache</h1><p>Netty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\"><br>图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32&gt;&gt;4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。<br>下面大致介绍下PoolThreadCache里面的属性作用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">final PoolArena&lt;byte[]&gt; heapArena;</div><div class=\"line\">final PoolArena&lt;ByteBuffer&gt; directArena;</div><div class=\"line\"></div><div class=\"line\">// Hold the caches for the different size classes, which are tiny, small and normal.</div><div class=\"line\">//tiny内存缓存的个数。默认为512</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] tinySubPageHeapCaches;</div><div class=\"line\">//small内存缓存的个数,默认为256个</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] smallSubPageHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</div><div class=\"line\">//normalCacheSize缓存的个数，默认为64</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] normalHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</div><div class=\"line\"></div><div class=\"line\">private final int freeSweepAllocationThreshold;</div><div class=\"line\"></div><div class=\"line\">private final Thread deathWatchThread;</div><div class=\"line\">//线程消亡后，释放资源</div><div class=\"line\">private final Runnable freeTask;</div><div class=\"line\">//freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。</div><div class=\"line\">private int allocations;</div></pre></td></tr></table></figure></p>\n<p><code>heapArena</code>与<code>directArena</code>作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&amp;heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。<code>smallSubPageHeapCaches</code>数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, … , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。<code>normalHeapCaches</code>数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a><br> 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createNormalCaches(</div><div class=\"line\">           int cacheSize, int maxCachedBufferCapacity, PoolArena&lt;T&gt; area) &#123;</div><div class=\"line\">       if (cacheSize &gt; 0) &#123;</div><div class=\"line\">           int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k</div><div class=\"line\">           //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的</div><div class=\"line\">           int arraySize = Math.max(1, log2(max / area.pageSize) + 1);</div><div class=\"line\">           //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住</div><div class=\"line\">           @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">           MemoryRegionCache&lt;T&gt;[] cache = new MemoryRegionCache[arraySize];</div><div class=\"line\">           for (int i = 0; i &lt; cache.length; i++) &#123;</div><div class=\"line\">               cache[i] = new NormalMemoryRegionCache&lt;T&gt;(cacheSize);</div><div class=\"line\">           &#125;</div><div class=\"line\">           return cache;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p> 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。</p>\n<p>以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean allocateNormal(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</div><div class=\"line\">private boolean allocate(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, int reqCapacity) &#123;</div><div class=\"line\">    if (cache == null) &#123;</div><div class=\"line\">        // no cache found so just return false here</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean allocated = cache.allocate(buf, reqCapacity);</div><div class=\"line\">    if (++ allocations &gt;= freeSweepAllocationThreshold) &#123;</div><div class=\"line\">        allocations = 0;</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return allocated;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>若没有该级别的缓存块, 则直接退出。</li>\n<li>若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。</li>\n</ul>\n<p>trim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void trim() &#123;</div><div class=\"line\">    int free = size - allocations;</div><div class=\"line\">    allocations = 0;</div><div class=\"line\"></div><div class=\"line\">    // We not even allocated all the number that are</div><div class=\"line\">     //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次</div><div class=\"line\">    if (free &gt; 0) &#123;</div><div class=\"line\">        free(free);//才不会释放该缓存</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>size</code>表示该16K级别的queue最大能缓存的内存数(默认64个)<br><code>allocations</code>表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。<br>free代表的含义是需要释放16KB级别缓存queue中缓存的个数, 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。</p>\n<h2 id=\"PoolThreadLocalCache\"><a href=\"#PoolThreadLocalCache\" class=\"headerlink\" title=\"PoolThreadLocalCache\"></a>PoolThreadLocalCache</h2><p>文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。<br>PoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadLocalCache。 该类封装了java的ThreadLocal.get()方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get() &#123;</div><div class=\"line\">    return get(InternalThreadLocalMap.get());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public final V get(InternalThreadLocalMap threadLocalMap) &#123;</div><div class=\"line\">     //想得到该层级缓存，发现没有，那么只能去初始话一个</div><div class=\"line\">    Object v = threadLocalMap.indexedVariable(index);</div><div class=\"line\">    if (v != InternalThreadLocalMap.UNSET) &#123;</div><div class=\"line\">        return (V) v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return initialize(threadLocalMap);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">static final ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = new ThreadLocal&lt;InternalThreadLocalMap&gt;();</div></pre></td></tr></table></figure></p>\n<p>若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected synchronized PoolThreadCache initialValue() &#123;</div><div class=\"line\">    final PoolArena&lt;byte[]&gt; heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea</div><div class=\"line\">    final PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</div><div class=\"line\"></div><div class=\"line\">    if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) &#123;</div><div class=\"line\">        return new PoolThreadCache( //为每一级别增加缓存</div><div class=\"line\">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</div><div class=\"line\">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // No caching for non FastThreadLocalThreads.</div><div class=\"line\">    return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。<br>至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。</p>\n<h1 id=\"PoolThreadCache\"><a href=\"#PoolThreadCache\" class=\"headerlink\" title=\"PoolThreadCache\"></a>PoolThreadCache</h1><p>Netty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\"><br>图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32&gt;&gt;4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。<br>下面大致介绍下PoolThreadCache里面的属性作用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">final PoolArena&lt;byte[]&gt; heapArena;</div><div class=\"line\">final PoolArena&lt;ByteBuffer&gt; directArena;</div><div class=\"line\"></div><div class=\"line\">// Hold the caches for the different size classes, which are tiny, small and normal.</div><div class=\"line\">//tiny内存缓存的个数。默认为512</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] tinySubPageHeapCaches;</div><div class=\"line\">//small内存缓存的个数,默认为256个</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] smallSubPageHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</div><div class=\"line\">//normalCacheSize缓存的个数，默认为64</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] normalHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</div><div class=\"line\"></div><div class=\"line\">private final int freeSweepAllocationThreshold;</div><div class=\"line\"></div><div class=\"line\">private final Thread deathWatchThread;</div><div class=\"line\">//线程消亡后，释放资源</div><div class=\"line\">private final Runnable freeTask;</div><div class=\"line\">//freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。</div><div class=\"line\">private int allocations;</div></pre></td></tr></table></figure></p>\n<p><code>heapArena</code>与<code>directArena</code>作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&amp;heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。<code>smallSubPageHeapCaches</code>数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, … , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。<code>normalHeapCaches</code>数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a><br> 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createNormalCaches(</div><div class=\"line\">           int cacheSize, int maxCachedBufferCapacity, PoolArena&lt;T&gt; area) &#123;</div><div class=\"line\">       if (cacheSize &gt; 0) &#123;</div><div class=\"line\">           int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k</div><div class=\"line\">           //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的</div><div class=\"line\">           int arraySize = Math.max(1, log2(max / area.pageSize) + 1);</div><div class=\"line\">           //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住</div><div class=\"line\">           @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">           MemoryRegionCache&lt;T&gt;[] cache = new MemoryRegionCache[arraySize];</div><div class=\"line\">           for (int i = 0; i &lt; cache.length; i++) &#123;</div><div class=\"line\">               cache[i] = new NormalMemoryRegionCache&lt;T&gt;(cacheSize);</div><div class=\"line\">           &#125;</div><div class=\"line\">           return cache;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p> 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。</p>\n<p>以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean allocateNormal(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</div><div class=\"line\">private boolean allocate(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, int reqCapacity) &#123;</div><div class=\"line\">    if (cache == null) &#123;</div><div class=\"line\">        // no cache found so just return false here</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean allocated = cache.allocate(buf, reqCapacity);</div><div class=\"line\">    if (++ allocations &gt;= freeSweepAllocationThreshold) &#123;</div><div class=\"line\">        allocations = 0;</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return allocated;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>若没有该级别的缓存块, 则直接退出。</li>\n<li>若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。</li>\n</ul>\n<p>trim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void trim() &#123;</div><div class=\"line\">    int free = size - allocations;</div><div class=\"line\">    allocations = 0;</div><div class=\"line\"></div><div class=\"line\">    // We not even allocated all the number that are</div><div class=\"line\">     //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次</div><div class=\"line\">    if (free &gt; 0) &#123;</div><div class=\"line\">        free(free);//才不会释放该缓存</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>size</code>表示该16K级别的queue最大能缓存的内存数(默认64个)<br><code>allocations</code>表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。<br>free代表的含义是需要释放16KB级别缓存queue中缓存的个数, 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。</p>\n<h2 id=\"PoolThreadLocalCache\"><a href=\"#PoolThreadLocalCache\" class=\"headerlink\" title=\"PoolThreadLocalCache\"></a>PoolThreadLocalCache</h2><p>文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。<br>PoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadLocalCache。 该类封装了java的ThreadLocal.get()方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get() &#123;</div><div class=\"line\">    return get(InternalThreadLocalMap.get());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public final V get(InternalThreadLocalMap threadLocalMap) &#123;</div><div class=\"line\">     //想得到该层级缓存，发现没有，那么只能去初始话一个</div><div class=\"line\">    Object v = threadLocalMap.indexedVariable(index);</div><div class=\"line\">    if (v != InternalThreadLocalMap.UNSET) &#123;</div><div class=\"line\">        return (V) v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return initialize(threadLocalMap);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">static final ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = new ThreadLocal&lt;InternalThreadLocalMap&gt;();</div></pre></td></tr></table></figure></p>\n<p>若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected synchronized PoolThreadCache initialValue() &#123;</div><div class=\"line\">    final PoolArena&lt;byte[]&gt; heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea</div><div class=\"line\">    final PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</div><div class=\"line\"></div><div class=\"line\">    if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) &#123;</div><div class=\"line\">        return new PoolThreadCache( //为每一级别增加缓存</div><div class=\"line\">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</div><div class=\"line\">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // No caching for non FastThreadLocalThreads.</div><div class=\"line\">    return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。<br>至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。</p>\n"},{"title":"Netty-PoolSubpage原理探究","date":"2018-07-21T17:02:45.000Z","_content":"Netty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolSubpage.png\" height=\"400\" width=\"450\"/>\n每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。\n下面是PoolSubpage的构造函数:\n```\n   PoolSubpage(PoolSubpage<T> head, PoolChunk<T> chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) {\n        this.chunk = chunk;\n        //与PoolChunkPage中哪个节点映射一起来\n        this.memoryMapIdx = memoryMapIdx;\n        this.runOffset = runOffset;\n        //该叶子节点的大小\n        this.pageSize = pageSize;\n        //bitmap的每一位都描述的是一个element的使用情况\n        bitmap = new long[pageSize >>> 10];\n        init(head, elemSize);\n    }\n    //init根据当前需要分配的内存大小，确定需要多少个bitmap元素\n    void init(PoolSubpage<T> head, int elemSize) {   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个\n        doNotDestroy = true;\n        this.elemSize = elemSize;\n        if (elemSize != 0) {\n            maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存\n            nextAvail = 0;\n            bitmapLength = maxNumElems >>> 6;  //6代表着long长度 = 2\n            if ((maxNumElems & 63) != 0) {//低6位\n                bitmapLength ++;\n            }\n\n            for (int i = 0; i < bitmapLength; i ++) {\n                bitmap[i] = 0;\n            }\n        }\n        addToPool(head);\n    }\n```\n有人会有疑问: 为啥bitmap = new long[pageSize >>> 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16\\*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。\n然后再调用init来对PoolSubpage结构进行初始化:\n1. 总共可以分成`pageSize/elemSize`个element。 bitmap所有元素也不一定需要全部用上, 实际会用`maxNumElems >>> 6`个long就可以了。\n2. 然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。\n\n# PoolSubpage的内存分配\n```\n    long allocate() { //找到一位\n        if (elemSize == 0) {\n            return toHandle(0);\n        }\n        if (numAvail == 0 || !doNotDestroy) {\n            return -1;\n        }\n        final int bitmapIdx = getNextAvail(); //64进制\n        int q = bitmapIdx >>> 6;//第几位long\n        int r = bitmapIdx & 63; //这个long第几位\n        assert (bitmap[q] >>> r & 1) == 0;\n        bitmap[q] |= 1L << r;  //将相关位置置为1\n        if (-- numAvail == 0) { //这个page没有再能够提供的bit位\n            removeFromPool(); //从可分配链中去掉\n        }\n        return toHandle(bitmapIdx);\n    }\n\n```\n若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:\n```\n    private int findNextAvail0(int i, long bits) {\n        final int maxNumElems = this.maxNumElems; //包含的段个数\n        final int baseVal = i << 6; //64进制，第2位，最大数也只是8*64 + 64\n\n        for (int j = 0; j < 64; j ++) {\n            if ((bits & 1) == 0) { //bits哪位为0，局说明哪位可用\n                int val = baseVal | j; //第4个long+9  i<<6 + j\n                if (val < maxNumElems) { //不能大于总段数\n                    return val;\n                } else {\n                    break;\n                }\n            }\n            bits >>>= 1;  //一位位找，直到找到某位为0\n        }\n        return -1;\n    }\n```\n主要做了如下事情:\n1. 遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。\n2. 检查该元素每一个bit是否为0, 找到后, 返回值为`i << 6 | j`, 包含第几个元素 + 元素内第几个bit位。\n再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:\n```\n    private long toHandle(int bitmapIdx) {\n        ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n        return 0x4000000000000000L | (long) bitmapIdx << 32 | memoryMapIdx;\n    }\n```\n可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。\n\n# PoolSubpage的内存释放\n```\n    boolean free(PoolSubpage<T> head, int bitmapIdx) {\n        if (elemSize == 0) {\n            return true;\n        }\n        int q = bitmapIdx >>> 6;\n        int r = bitmapIdx & 63;\n        assert (bitmap[q] >>> r & 1) != 0;\n        bitmap[q] ^= 1L << r;\n\n        setNextAvail(bitmapIdx);\n\n        if (numAvail ++ == 0) {\n            addToPool(head);\n            return true;\n        }\n\n        if (numAvail != maxNumElems) {\n            return true;\n        } else {\n            // Subpage not in use (numAvail == maxNumElems)\n            if (prev == next) {\n                // Do not remove if this subpage is the only one left in the pool.\n                return true;\n            }\n\n            // Remove this subpage from the pool if there are other subpages left in the pool.\n            doNotDestroy = false;\n            removeFromPool();\n            return false;\n        }\n    }\n```\n释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:\n1. 若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。\n2. 若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。\n3. 反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。\n\n# 总结\n\nPoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。","source":"_posts/Netty-PoolSubpage原理探究.md","raw":"---\ntitle: Netty-PoolSubpage原理探究\ndate: 2018-07-22 01:02:45\ntags:\n---\nNetty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolSubpage.png\" height=\"400\" width=\"450\"/>\n每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。\n下面是PoolSubpage的构造函数:\n```\n   PoolSubpage(PoolSubpage<T> head, PoolChunk<T> chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) {\n        this.chunk = chunk;\n        //与PoolChunkPage中哪个节点映射一起来\n        this.memoryMapIdx = memoryMapIdx;\n        this.runOffset = runOffset;\n        //该叶子节点的大小\n        this.pageSize = pageSize;\n        //bitmap的每一位都描述的是一个element的使用情况\n        bitmap = new long[pageSize >>> 10];\n        init(head, elemSize);\n    }\n    //init根据当前需要分配的内存大小，确定需要多少个bitmap元素\n    void init(PoolSubpage<T> head, int elemSize) {   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个\n        doNotDestroy = true;\n        this.elemSize = elemSize;\n        if (elemSize != 0) {\n            maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存\n            nextAvail = 0;\n            bitmapLength = maxNumElems >>> 6;  //6代表着long长度 = 2\n            if ((maxNumElems & 63) != 0) {//低6位\n                bitmapLength ++;\n            }\n\n            for (int i = 0; i < bitmapLength; i ++) {\n                bitmap[i] = 0;\n            }\n        }\n        addToPool(head);\n    }\n```\n有人会有疑问: 为啥bitmap = new long[pageSize >>> 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16\\*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。\n然后再调用init来对PoolSubpage结构进行初始化:\n1. 总共可以分成`pageSize/elemSize`个element。 bitmap所有元素也不一定需要全部用上, 实际会用`maxNumElems >>> 6`个long就可以了。\n2. 然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。\n\n# PoolSubpage的内存分配\n```\n    long allocate() { //找到一位\n        if (elemSize == 0) {\n            return toHandle(0);\n        }\n        if (numAvail == 0 || !doNotDestroy) {\n            return -1;\n        }\n        final int bitmapIdx = getNextAvail(); //64进制\n        int q = bitmapIdx >>> 6;//第几位long\n        int r = bitmapIdx & 63; //这个long第几位\n        assert (bitmap[q] >>> r & 1) == 0;\n        bitmap[q] |= 1L << r;  //将相关位置置为1\n        if (-- numAvail == 0) { //这个page没有再能够提供的bit位\n            removeFromPool(); //从可分配链中去掉\n        }\n        return toHandle(bitmapIdx);\n    }\n\n```\n若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:\n```\n    private int findNextAvail0(int i, long bits) {\n        final int maxNumElems = this.maxNumElems; //包含的段个数\n        final int baseVal = i << 6; //64进制，第2位，最大数也只是8*64 + 64\n\n        for (int j = 0; j < 64; j ++) {\n            if ((bits & 1) == 0) { //bits哪位为0，局说明哪位可用\n                int val = baseVal | j; //第4个long+9  i<<6 + j\n                if (val < maxNumElems) { //不能大于总段数\n                    return val;\n                } else {\n                    break;\n                }\n            }\n            bits >>>= 1;  //一位位找，直到找到某位为0\n        }\n        return -1;\n    }\n```\n主要做了如下事情:\n1. 遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。\n2. 检查该元素每一个bit是否为0, 找到后, 返回值为`i << 6 | j`, 包含第几个元素 + 元素内第几个bit位。\n再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:\n```\n    private long toHandle(int bitmapIdx) {\n        ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n        return 0x4000000000000000L | (long) bitmapIdx << 32 | memoryMapIdx;\n    }\n```\n可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。\n\n# PoolSubpage的内存释放\n```\n    boolean free(PoolSubpage<T> head, int bitmapIdx) {\n        if (elemSize == 0) {\n            return true;\n        }\n        int q = bitmapIdx >>> 6;\n        int r = bitmapIdx & 63;\n        assert (bitmap[q] >>> r & 1) != 0;\n        bitmap[q] ^= 1L << r;\n\n        setNextAvail(bitmapIdx);\n\n        if (numAvail ++ == 0) {\n            addToPool(head);\n            return true;\n        }\n\n        if (numAvail != maxNumElems) {\n            return true;\n        } else {\n            // Subpage not in use (numAvail == maxNumElems)\n            if (prev == next) {\n                // Do not remove if this subpage is the only one left in the pool.\n                return true;\n            }\n\n            // Remove this subpage from the pool if there are other subpages left in the pool.\n            doNotDestroy = false;\n            removeFromPool();\n            return false;\n        }\n    }\n```\n释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:\n1. 若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。\n2. 若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。\n3. 反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。\n\n# 总结\n\nPoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。","slug":"Netty-PoolSubpage原理探究","published":1,"updated":"2018-10-17T03:00:55.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvm000cisu5mg459e4l","content":"<p>Netty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolSubpage.png\" height=\"400\" width=\"450\"><br>每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。<br>下面是PoolSubpage的构造函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) &#123;</div><div class=\"line\">     this.chunk = chunk;</div><div class=\"line\">     //与PoolChunkPage中哪个节点映射一起来</div><div class=\"line\">     this.memoryMapIdx = memoryMapIdx;</div><div class=\"line\">     this.runOffset = runOffset;</div><div class=\"line\">     //该叶子节点的大小</div><div class=\"line\">     this.pageSize = pageSize;</div><div class=\"line\">     //bitmap的每一位都描述的是一个element的使用情况</div><div class=\"line\">     bitmap = new long[pageSize &gt;&gt;&gt; 10];</div><div class=\"line\">     init(head, elemSize);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //init根据当前需要分配的内存大小，确定需要多少个bitmap元素</div><div class=\"line\"> void init(PoolSubpage&lt;T&gt; head, int elemSize) &#123;   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个</div><div class=\"line\">     doNotDestroy = true;</div><div class=\"line\">     this.elemSize = elemSize;</div><div class=\"line\">     if (elemSize != 0) &#123;</div><div class=\"line\">         maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存</div><div class=\"line\">         nextAvail = 0;</div><div class=\"line\">         bitmapLength = maxNumElems &gt;&gt;&gt; 6;  //6代表着long长度 = 2</div><div class=\"line\">         if ((maxNumElems &amp; 63) != 0) &#123;//低6位</div><div class=\"line\">             bitmapLength ++;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         for (int i = 0; i &lt; bitmapLength; i ++) &#123;</div><div class=\"line\">             bitmap[i] = 0;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     addToPool(head);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>有人会有疑问: 为啥bitmap = new long[pageSize &gt;&gt;&gt; 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。<br>然后再调用init来对PoolSubpage结构进行初始化:</p>\n<ol>\n<li>总共可以分成<code>pageSize/elemSize</code>个element。 bitmap所有元素也不一定需要全部用上, 实际会用<code>maxNumElems &gt;&gt;&gt; 6</code>个long就可以了。</li>\n<li>然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。</li>\n</ol>\n<h1 id=\"PoolSubpage的内存分配\"><a href=\"#PoolSubpage的内存分配\" class=\"headerlink\" title=\"PoolSubpage的内存分配\"></a>PoolSubpage的内存分配</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate() &#123; //找到一位</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return toHandle(0);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (numAvail == 0 || !doNotDestroy) &#123;</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final int bitmapIdx = getNextAvail(); //64进制</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;//第几位long</div><div class=\"line\">    int r = bitmapIdx &amp; 63; //这个long第几位</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) == 0;</div><div class=\"line\">    bitmap[q] |= 1L &lt;&lt; r;  //将相关位置置为1</div><div class=\"line\">    if (-- numAvail == 0) &#123; //这个page没有再能够提供的bit位</div><div class=\"line\">        removeFromPool(); //从可分配链中去掉</div><div class=\"line\">    &#125;</div><div class=\"line\">    return toHandle(bitmapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int findNextAvail0(int i, long bits) &#123;</div><div class=\"line\">    final int maxNumElems = this.maxNumElems; //包含的段个数</div><div class=\"line\">    final int baseVal = i &lt;&lt; 6; //64进制，第2位，最大数也只是8*64 + 64</div><div class=\"line\"></div><div class=\"line\">    for (int j = 0; j &lt; 64; j ++) &#123;</div><div class=\"line\">        if ((bits &amp; 1) == 0) &#123; //bits哪位为0，局说明哪位可用</div><div class=\"line\">            int val = baseVal | j; //第4个long+9  i&lt;&lt;6 + j</div><div class=\"line\">            if (val &lt; maxNumElems) &#123; //不能大于总段数</div><div class=\"line\">                return val;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        bits &gt;&gt;&gt;= 1;  //一位位找，直到找到某位为0</div><div class=\"line\">    &#125;</div><div class=\"line\">    return -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ol>\n<li>遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。</li>\n<li>检查该元素每一个bit是否为0, 找到后, 返回值为<code>i &lt;&lt; 6 | j</code>, 包含第几个元素 + 元素内第几个bit位。<br>再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long toHandle(int bitmapIdx) &#123;</div><div class=\"line\">    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">    return 0x4000000000000000L | (long) bitmapIdx &lt;&lt; 32 | memoryMapIdx;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。</p>\n<h1 id=\"PoolSubpage的内存释放\"><a href=\"#PoolSubpage的内存释放\" class=\"headerlink\" title=\"PoolSubpage的内存释放\"></a>PoolSubpage的内存释放</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean free(PoolSubpage&lt;T&gt; head, int bitmapIdx) &#123;</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;</div><div class=\"line\">    int r = bitmapIdx &amp; 63;</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) != 0;</div><div class=\"line\">    bitmap[q] ^= 1L &lt;&lt; r;</div><div class=\"line\"></div><div class=\"line\">    setNextAvail(bitmapIdx);</div><div class=\"line\"></div><div class=\"line\">    if (numAvail ++ == 0) &#123;</div><div class=\"line\">        addToPool(head);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (numAvail != maxNumElems) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Subpage not in use (numAvail == maxNumElems)</div><div class=\"line\">        if (prev == next) &#123;</div><div class=\"line\">            // Do not remove if this subpage is the only one left in the pool.</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remove this subpage from the pool if there are other subpages left in the pool.</div><div class=\"line\">        doNotDestroy = false;</div><div class=\"line\">        removeFromPool();</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:</p>\n<ol>\n<li>若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。</li>\n<li>若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。</li>\n<li>反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>PoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Netty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolSubpage.png\" height=\"400\" width=\"450\"><br>每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。<br>下面是PoolSubpage的构造函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) &#123;</div><div class=\"line\">     this.chunk = chunk;</div><div class=\"line\">     //与PoolChunkPage中哪个节点映射一起来</div><div class=\"line\">     this.memoryMapIdx = memoryMapIdx;</div><div class=\"line\">     this.runOffset = runOffset;</div><div class=\"line\">     //该叶子节点的大小</div><div class=\"line\">     this.pageSize = pageSize;</div><div class=\"line\">     //bitmap的每一位都描述的是一个element的使用情况</div><div class=\"line\">     bitmap = new long[pageSize &gt;&gt;&gt; 10];</div><div class=\"line\">     init(head, elemSize);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //init根据当前需要分配的内存大小，确定需要多少个bitmap元素</div><div class=\"line\"> void init(PoolSubpage&lt;T&gt; head, int elemSize) &#123;   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个</div><div class=\"line\">     doNotDestroy = true;</div><div class=\"line\">     this.elemSize = elemSize;</div><div class=\"line\">     if (elemSize != 0) &#123;</div><div class=\"line\">         maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存</div><div class=\"line\">         nextAvail = 0;</div><div class=\"line\">         bitmapLength = maxNumElems &gt;&gt;&gt; 6;  //6代表着long长度 = 2</div><div class=\"line\">         if ((maxNumElems &amp; 63) != 0) &#123;//低6位</div><div class=\"line\">             bitmapLength ++;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         for (int i = 0; i &lt; bitmapLength; i ++) &#123;</div><div class=\"line\">             bitmap[i] = 0;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     addToPool(head);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>有人会有疑问: 为啥bitmap = new long[pageSize &gt;&gt;&gt; 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。<br>然后再调用init来对PoolSubpage结构进行初始化:</p>\n<ol>\n<li>总共可以分成<code>pageSize/elemSize</code>个element。 bitmap所有元素也不一定需要全部用上, 实际会用<code>maxNumElems &gt;&gt;&gt; 6</code>个long就可以了。</li>\n<li>然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。</li>\n</ol>\n<h1 id=\"PoolSubpage的内存分配\"><a href=\"#PoolSubpage的内存分配\" class=\"headerlink\" title=\"PoolSubpage的内存分配\"></a>PoolSubpage的内存分配</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate() &#123; //找到一位</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return toHandle(0);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (numAvail == 0 || !doNotDestroy) &#123;</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final int bitmapIdx = getNextAvail(); //64进制</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;//第几位long</div><div class=\"line\">    int r = bitmapIdx &amp; 63; //这个long第几位</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) == 0;</div><div class=\"line\">    bitmap[q] |= 1L &lt;&lt; r;  //将相关位置置为1</div><div class=\"line\">    if (-- numAvail == 0) &#123; //这个page没有再能够提供的bit位</div><div class=\"line\">        removeFromPool(); //从可分配链中去掉</div><div class=\"line\">    &#125;</div><div class=\"line\">    return toHandle(bitmapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int findNextAvail0(int i, long bits) &#123;</div><div class=\"line\">    final int maxNumElems = this.maxNumElems; //包含的段个数</div><div class=\"line\">    final int baseVal = i &lt;&lt; 6; //64进制，第2位，最大数也只是8*64 + 64</div><div class=\"line\"></div><div class=\"line\">    for (int j = 0; j &lt; 64; j ++) &#123;</div><div class=\"line\">        if ((bits &amp; 1) == 0) &#123; //bits哪位为0，局说明哪位可用</div><div class=\"line\">            int val = baseVal | j; //第4个long+9  i&lt;&lt;6 + j</div><div class=\"line\">            if (val &lt; maxNumElems) &#123; //不能大于总段数</div><div class=\"line\">                return val;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        bits &gt;&gt;&gt;= 1;  //一位位找，直到找到某位为0</div><div class=\"line\">    &#125;</div><div class=\"line\">    return -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ol>\n<li>遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。</li>\n<li>检查该元素每一个bit是否为0, 找到后, 返回值为<code>i &lt;&lt; 6 | j</code>, 包含第几个元素 + 元素内第几个bit位。<br>再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long toHandle(int bitmapIdx) &#123;</div><div class=\"line\">    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">    return 0x4000000000000000L | (long) bitmapIdx &lt;&lt; 32 | memoryMapIdx;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。</p>\n<h1 id=\"PoolSubpage的内存释放\"><a href=\"#PoolSubpage的内存释放\" class=\"headerlink\" title=\"PoolSubpage的内存释放\"></a>PoolSubpage的内存释放</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean free(PoolSubpage&lt;T&gt; head, int bitmapIdx) &#123;</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;</div><div class=\"line\">    int r = bitmapIdx &amp; 63;</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) != 0;</div><div class=\"line\">    bitmap[q] ^= 1L &lt;&lt; r;</div><div class=\"line\"></div><div class=\"line\">    setNextAvail(bitmapIdx);</div><div class=\"line\"></div><div class=\"line\">    if (numAvail ++ == 0) &#123;</div><div class=\"line\">        addToPool(head);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (numAvail != maxNumElems) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Subpage not in use (numAvail == maxNumElems)</div><div class=\"line\">        if (prev == next) &#123;</div><div class=\"line\">            // Do not remove if this subpage is the only one left in the pool.</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remove this subpage from the pool if there are other subpages left in the pool.</div><div class=\"line\">        doNotDestroy = false;</div><div class=\"line\">        removeFromPool();</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:</p>\n<ol>\n<li>若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。</li>\n<li>若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。</li>\n<li>反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>PoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。</p>\n"},{"title":"Netty PoolArea原理探究","date":"2018-05-23T14:31:13.000Z","_content":"# 简介\nNetty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。\n## Pool和Unpool区别\n字面意思, 分别是池化内存和非池化内存。`池化内存`的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。`非池化内存`就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数`Dio.netty.allocator.type`确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。\n这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。\n# 内存分配\n线程调用如下接口来获取内存:\n```\n    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {\n        PoolThreadCache cache = threadCache.get();\n        PoolArena<ByteBuffer> directArena = cache.directArena;\n\n        final ByteBuf buf;\n        if (directArena != null) {\n            buf = directArena.allocate(cache, initialCapacity, maxCapacity);\n        } else {\n            buf = PlatformDependent.hasUnsafe() ?\n                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :\n                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);\n        }\n\n        return toLeakAwareBuffer(buf);\n    }\n```\n主要做的事:\n+ 获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolArea内存原理探究</a>)\n+ 从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。\n\n# PoolArena\nPoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolArea.png\" height=\"400\" width=\"450\"/>\nnetty将池化内存块划分为3个类型:\n```\n    enum SizeClass {\n        Tiny,\n        Small,\n        Normal\n    }\n```\nTiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。\n大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。\n```\n    //tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块\n    static final int numTinySubpagePools = 512 >>> 4;\n    //全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT\n    final PooledByteBufAllocator parent;\n    // log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]\n    private final int maxOrder;\n    //默认8k\n    final int pageSize;\n    //log(8k) =  13\n    final int pageShifts;\n    //默认16M\n    final int chunkSize;\n    //-8192\n    final int subpageOverflowMask;\n    //指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]\n    final int numSmallSubpagePools;\n     //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] tinySubpagePools;\n     //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] smallSubpagePools;//存储1024-8096大小的内存\n     //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中\n    private final PoolChunkList<T> q050;\n    private final PoolChunkList<T> q025;   //存储内存利用率25-75%的chunk\n    private final PoolChunkList<T> q000;   //存储内存利用率1-50%的chunk\n    private final PoolChunkList<T> qInit;  //存储内存利用率0-25%的chunk\n    private final PoolChunkList<T> q075;    //存储内存利用率75-100%的chunk\n    private final PoolChunkList<T> q100;   //存储内存利用率100%的chunk\n\n    // Number of thread caches backed by this arena. 该PoolArea被多少线程引用。\n    final AtomicInteger numThreadCaches = new AtomicInteger();\n\n```\nPoolArea申请内存时根据申请的大小使用不同对象进行分配:\n+ tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。\n+ smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。\n+ q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。\n他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p>\n&nbsp;&nbsp;若q025中某个PoolChunk使用率大于75%之后, 该PoolChunk将别移动到q050中。\n&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。\n&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。\n&nbsp;&nbsp;若q000使用率为0, 会被释放掉。\n\nnumThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n\n## PoolArena的内存分配\n\nnetty真正申请内存时, 首先便是调用PoolArena.allocate()函数:\n```\n private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {\n        final int normCapacity = normalizeCapacity(reqCapacity);\n         // capacity < pageSize   小于8k\n        if (isTinyOrSmall(normCapacity)) {\n            int tableIdx;\n            PoolSubpage<T>[] table;\n            boolean tiny = isTiny(normCapacity);\n            if (tiny) { // < 512\n                 //若从缓冲中取得该值\n                if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = tinyIdx(normCapacity);\n                table = tinySubpagePools;\n            } else {  //small\n                if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = smallIdx(normCapacity);\n                table = smallSubpagePools;\n            }\n\n            final PoolSubpage<T> head = table[tableIdx];\n\n            /**\n             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and\n             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.\n             */\n             //小于8k的\n            synchronized (head) {\n                 //如果分配完会从当前级别链上去掉\n                final PoolSubpage<T> s = head.next;\n                 ///该型号的tiny的内存已经分配的有一个了\n                if (s != head) {\n                    assert s.doNotDestroy && s.elemSize == normCapacity;\n                    long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n                    assert handle >= 0;\n                    s.chunk.initBufWithSubpage(buf, handle, reqCapacity);\n                    incTinySmallAllocation(tiny);\n                    return;//如果从链中找到就返回，\n                }\n            }\n            //没有找到的话，就从Poolpage中分一个\n            synchronized (this) {\n                //说明head并没有分配值，是第一次分配。\n                allocateNormal(buf, reqCapacity, normCapacity);\n            }\n\n            incTinySmallAllocation(tiny);\n            return;\n        }\n        if (normCapacity <= chunkSize) { //小于16M\n            if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {  //cache=PoolThreadCache,本地是否已经有了\n                // was able to allocate out of the cache so move on\n                return;\n            }\n            synchronized (this) {\n                allocateNormal(buf, reqCapacity, normCapacity);\n                ++allocationsNormal;\n            }\n        } else {\n            // Huge allocations are never served via the cache so just call allocateHuge\n            allocateHuge(buf, reqCapacity); //大于16M，则分配大内存\n        }\n    }\n\n```\n\nPoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:\n1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,..., 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。\n2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:\n+ 首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n+ 若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:\n```\n    static int tinyIdx(int normCapacity) {  //申请内容小于512，下标\n        return normCapacity >>> 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了\n    }\n    static int smallIdx(int normCapacity) {\n        int tableIdx = 0;\n        int i = normCapacity >>> 10; //首先是512 = 2^10\n        while (i != 0) {\n            i >>>= 1;\n            tableIdx ++;\n        }\n        return tableIdx;\n```\n可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。\n+ 检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。\n+ 若没有可分配的内存, 则会进入allocateNormal进行分配\n3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。\n4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。\n### 分配[16b, 16m]内存\n接着上述过程, 会进入allocateNormal进行内存分配\n```\nprivate void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||\n            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||\n            q075.allocate(buf, reqCapacity, normCapacity)) {\n            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存\n        }\n        //跑到Direct里面newChunk了, 将 产生第一个chunk\n        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树\n        PoolChunk<T> c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中\n        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256\n        assert handle > 0;\n        c.initBuf(buf, handle, reqCapacity);\n        qInit.add(c); //第一次分配的话，都会放入qInit\n    }\n```\n1. 首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:\n```\n    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (head == null || normCapacity > maxCapacity) { //head是可以直接寸数据的\n            // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can\n            // be handled by the PoolChunks that are contained in this PoolChunkList.\n            return false;\n        }\n        for (PoolChunk<T> cur = head;;) {\n            long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值\n            if (handle < 0) { //在poolchunk中没有找到能装得下的，那么继续找下一个\n                cur = cur.next;\n                if (cur == null) {\n                    return false;\n                }\n            } else {\n                cur.initBuf(buf, handle, reqCapacity);\n                if (cur.usage() >= maxUsage) {//chunked量用超了则移动向下一个链\n                    remove(cur);\n                    nextList.add(cur);\n                }\n                return true;\n            }\n        }\n    }\n```\n会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。\n2. 若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>\n3. 对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。\n这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:\n+ 将PoolChunk分配维持在较高的比例上。\n+ 保存一些空闲度比较大的内存, 以便大内存的分配。\n\n# 总结\n非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.\n","source":"_posts/Netty内存学习.md","raw":"---\ntitle: Netty PoolArea原理探究\ndate: 2018-05-23 22:31:13\ntags:\n---\n# 简介\nNetty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。\n## Pool和Unpool区别\n字面意思, 分别是池化内存和非池化内存。`池化内存`的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。`非池化内存`就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数`Dio.netty.allocator.type`确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。\n这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。\n# 内存分配\n线程调用如下接口来获取内存:\n```\n    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {\n        PoolThreadCache cache = threadCache.get();\n        PoolArena<ByteBuffer> directArena = cache.directArena;\n\n        final ByteBuf buf;\n        if (directArena != null) {\n            buf = directArena.allocate(cache, initialCapacity, maxCapacity);\n        } else {\n            buf = PlatformDependent.hasUnsafe() ?\n                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :\n                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);\n        }\n\n        return toLeakAwareBuffer(buf);\n    }\n```\n主要做的事:\n+ 获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolArea内存原理探究</a>)\n+ 从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。\n\n# PoolArena\nPoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolArea.png\" height=\"400\" width=\"450\"/>\nnetty将池化内存块划分为3个类型:\n```\n    enum SizeClass {\n        Tiny,\n        Small,\n        Normal\n    }\n```\nTiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。\n大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。\n```\n    //tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块\n    static final int numTinySubpagePools = 512 >>> 4;\n    //全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT\n    final PooledByteBufAllocator parent;\n    // log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]\n    private final int maxOrder;\n    //默认8k\n    final int pageSize;\n    //log(8k) =  13\n    final int pageShifts;\n    //默认16M\n    final int chunkSize;\n    //-8192\n    final int subpageOverflowMask;\n    //指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]\n    final int numSmallSubpagePools;\n     //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] tinySubpagePools;\n     //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] smallSubpagePools;//存储1024-8096大小的内存\n     //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中\n    private final PoolChunkList<T> q050;\n    private final PoolChunkList<T> q025;   //存储内存利用率25-75%的chunk\n    private final PoolChunkList<T> q000;   //存储内存利用率1-50%的chunk\n    private final PoolChunkList<T> qInit;  //存储内存利用率0-25%的chunk\n    private final PoolChunkList<T> q075;    //存储内存利用率75-100%的chunk\n    private final PoolChunkList<T> q100;   //存储内存利用率100%的chunk\n\n    // Number of thread caches backed by this arena. 该PoolArea被多少线程引用。\n    final AtomicInteger numThreadCaches = new AtomicInteger();\n\n```\nPoolArea申请内存时根据申请的大小使用不同对象进行分配:\n+ tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。\n+ smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。\n+ q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。\n他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p>\n&nbsp;&nbsp;若q025中某个PoolChunk使用率大于75%之后, 该PoolChunk将别移动到q050中。\n&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。\n&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。\n&nbsp;&nbsp;若q000使用率为0, 会被释放掉。\n\nnumThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n\n## PoolArena的内存分配\n\nnetty真正申请内存时, 首先便是调用PoolArena.allocate()函数:\n```\n private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {\n        final int normCapacity = normalizeCapacity(reqCapacity);\n         // capacity < pageSize   小于8k\n        if (isTinyOrSmall(normCapacity)) {\n            int tableIdx;\n            PoolSubpage<T>[] table;\n            boolean tiny = isTiny(normCapacity);\n            if (tiny) { // < 512\n                 //若从缓冲中取得该值\n                if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = tinyIdx(normCapacity);\n                table = tinySubpagePools;\n            } else {  //small\n                if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = smallIdx(normCapacity);\n                table = smallSubpagePools;\n            }\n\n            final PoolSubpage<T> head = table[tableIdx];\n\n            /**\n             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and\n             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.\n             */\n             //小于8k的\n            synchronized (head) {\n                 //如果分配完会从当前级别链上去掉\n                final PoolSubpage<T> s = head.next;\n                 ///该型号的tiny的内存已经分配的有一个了\n                if (s != head) {\n                    assert s.doNotDestroy && s.elemSize == normCapacity;\n                    long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n                    assert handle >= 0;\n                    s.chunk.initBufWithSubpage(buf, handle, reqCapacity);\n                    incTinySmallAllocation(tiny);\n                    return;//如果从链中找到就返回，\n                }\n            }\n            //没有找到的话，就从Poolpage中分一个\n            synchronized (this) {\n                //说明head并没有分配值，是第一次分配。\n                allocateNormal(buf, reqCapacity, normCapacity);\n            }\n\n            incTinySmallAllocation(tiny);\n            return;\n        }\n        if (normCapacity <= chunkSize) { //小于16M\n            if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {  //cache=PoolThreadCache,本地是否已经有了\n                // was able to allocate out of the cache so move on\n                return;\n            }\n            synchronized (this) {\n                allocateNormal(buf, reqCapacity, normCapacity);\n                ++allocationsNormal;\n            }\n        } else {\n            // Huge allocations are never served via the cache so just call allocateHuge\n            allocateHuge(buf, reqCapacity); //大于16M，则分配大内存\n        }\n    }\n\n```\n\nPoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:\n1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,..., 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。\n2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:\n+ 首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n+ 若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:\n```\n    static int tinyIdx(int normCapacity) {  //申请内容小于512，下标\n        return normCapacity >>> 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了\n    }\n    static int smallIdx(int normCapacity) {\n        int tableIdx = 0;\n        int i = normCapacity >>> 10; //首先是512 = 2^10\n        while (i != 0) {\n            i >>>= 1;\n            tableIdx ++;\n        }\n        return tableIdx;\n```\n可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。\n+ 检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。\n+ 若没有可分配的内存, 则会进入allocateNormal进行分配\n3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。\n4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。\n### 分配[16b, 16m]内存\n接着上述过程, 会进入allocateNormal进行内存分配\n```\nprivate void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||\n            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||\n            q075.allocate(buf, reqCapacity, normCapacity)) {\n            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存\n        }\n        //跑到Direct里面newChunk了, 将 产生第一个chunk\n        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树\n        PoolChunk<T> c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中\n        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256\n        assert handle > 0;\n        c.initBuf(buf, handle, reqCapacity);\n        qInit.add(c); //第一次分配的话，都会放入qInit\n    }\n```\n1. 首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:\n```\n    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (head == null || normCapacity > maxCapacity) { //head是可以直接寸数据的\n            // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can\n            // be handled by the PoolChunks that are contained in this PoolChunkList.\n            return false;\n        }\n        for (PoolChunk<T> cur = head;;) {\n            long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值\n            if (handle < 0) { //在poolchunk中没有找到能装得下的，那么继续找下一个\n                cur = cur.next;\n                if (cur == null) {\n                    return false;\n                }\n            } else {\n                cur.initBuf(buf, handle, reqCapacity);\n                if (cur.usage() >= maxUsage) {//chunked量用超了则移动向下一个链\n                    remove(cur);\n                    nextList.add(cur);\n                }\n                return true;\n            }\n        }\n    }\n```\n会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。\n2. 若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>\n3. 对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。\n这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:\n+ 将PoolChunk分配维持在较高的比例上。\n+ 保存一些空闲度比较大的内存, 以便大内存的分配。\n\n# 总结\n非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.\n","slug":"Netty内存学习","published":1,"updated":"2018-07-23T00:44:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvo000disu5vgj41djp","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Netty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。</p>\n<h2 id=\"Pool和Unpool区别\"><a href=\"#Pool和Unpool区别\" class=\"headerlink\" title=\"Pool和Unpool区别\"></a>Pool和Unpool区别</h2><p>字面意思, 分别是池化内存和非池化内存。<code>池化内存</code>的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。<code>非池化内存</code>就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数<code>Dio.netty.allocator.type</code>确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。<br>这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。</p>\n<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><p>线程调用如下接口来获取内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class=\"line\">    PoolThreadCache cache = threadCache.get();</div><div class=\"line\">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</div><div class=\"line\"></div><div class=\"line\">    final ByteBuf buf;</div><div class=\"line\">    if (directArena != null) &#123;</div><div class=\"line\">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        buf = PlatformDependent.hasUnsafe() ?</div><div class=\"line\">                UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :</div><div class=\"line\">                new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return toLeakAwareBuffer(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolArea内存原理探究</a>)</li>\n<li>从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。</li>\n</ul>\n<h1 id=\"PoolArena\"><a href=\"#PoolArena\" class=\"headerlink\" title=\"PoolArena\"></a>PoolArena</h1><p>PoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolArea.png\" height=\"400\" width=\"450\"><br>netty将池化内存块划分为3个类型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum SizeClass &#123;</div><div class=\"line\">    Tiny,</div><div class=\"line\">    Small,</div><div class=\"line\">    Normal</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Tiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。<br>大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">//tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块</div><div class=\"line\">static final int numTinySubpagePools = 512 &gt;&gt;&gt; 4;</div><div class=\"line\">//全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT</div><div class=\"line\">final PooledByteBufAllocator parent;</div><div class=\"line\">// log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//默认8k</div><div class=\"line\">final int pageSize;</div><div class=\"line\">//log(8k) =  13</div><div class=\"line\">final int pageShifts;</div><div class=\"line\">//默认16M</div><div class=\"line\">final int chunkSize;</div><div class=\"line\">//-8192</div><div class=\"line\">final int subpageOverflowMask;</div><div class=\"line\">//指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]</div><div class=\"line\">final int numSmallSubpagePools;</div><div class=\"line\"> //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] tinySubpagePools;</div><div class=\"line\"> //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] smallSubpagePools;//存储1024-8096大小的内存</div><div class=\"line\"> //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q050;</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q025;   //存储内存利用率25-75%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q000;   //存储内存利用率1-50%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; qInit;  //存储内存利用率0-25%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q075;    //存储内存利用率75-100%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q100;   //存储内存利用率100%的chunk</div><div class=\"line\"></div><div class=\"line\">// Number of thread caches backed by this arena. 该PoolArea被多少线程引用。</div><div class=\"line\">final AtomicInteger numThreadCaches = new AtomicInteger();</div></pre></td></tr></table></figure></p>\n<p>PoolArea申请内存时根据申请的大小使用不同对象进行分配:</p>\n<ul>\n<li>tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。</li>\n<li>smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。</li>\n<li>q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。<br>他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p><br>&nbsp;&nbsp;若q025中某个PoolChunk使用率大于75%之后, 该PoolChunk将别移动到q050中。<br>&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。<br>&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。<br>&nbsp;&nbsp;若q000使用率为0, 会被释放掉。</p></li>\n</ul>\n<p>numThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></p>\n<h2 id=\"PoolArena的内存分配\"><a href=\"#PoolArena的内存分配\" class=\"headerlink\" title=\"PoolArena的内存分配\"></a>PoolArena的内存分配</h2><p>netty真正申请内存时, 首先便是调用PoolArena.allocate()函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) &#123;</div><div class=\"line\">       final int normCapacity = normalizeCapacity(reqCapacity);</div><div class=\"line\">        // capacity &lt; pageSize   小于8k</div><div class=\"line\">       if (isTinyOrSmall(normCapacity)) &#123;</div><div class=\"line\">           int tableIdx;</div><div class=\"line\">           PoolSubpage&lt;T&gt;[] table;</div><div class=\"line\">           boolean tiny = isTiny(normCapacity);</div><div class=\"line\">           if (tiny) &#123; // &lt; 512</div><div class=\"line\">                //若从缓冲中取得该值</div><div class=\"line\">               if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = tinyIdx(normCapacity);</div><div class=\"line\">               table = tinySubpagePools;</div><div class=\"line\">           &#125; else &#123;  //small</div><div class=\"line\">               if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = smallIdx(normCapacity);</div><div class=\"line\">               table = smallSubpagePools;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           final PoolSubpage&lt;T&gt; head = table[tableIdx];</div><div class=\"line\"></div><div class=\"line\">           /**</div><div class=\"line\">            * Synchronize on the head. This is needed as &#123;@link PoolChunk#allocateSubpage(int)&#125; and</div><div class=\"line\">            * &#123;@link PoolChunk#free(long)&#125; may modify the doubly linked list as well.</div><div class=\"line\">            */</div><div class=\"line\">            //小于8k的</div><div class=\"line\">           synchronized (head) &#123;</div><div class=\"line\">                //如果分配完会从当前级别链上去掉</div><div class=\"line\">               final PoolSubpage&lt;T&gt; s = head.next;</div><div class=\"line\">                ///该型号的tiny的内存已经分配的有一个了</div><div class=\"line\">               if (s != head) &#123;</div><div class=\"line\">                   assert s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</div><div class=\"line\">                   long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">                   assert handle &gt;= 0;</div><div class=\"line\">                   s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</div><div class=\"line\">                   incTinySmallAllocation(tiny);</div><div class=\"line\">                   return;//如果从链中找到就返回，</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           //没有找到的话，就从Poolpage中分一个</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               //说明head并没有分配值，是第一次分配。</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           incTinySmallAllocation(tiny);</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (normCapacity &lt;= chunkSize) &#123; //小于16M</div><div class=\"line\">           if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) &#123;  //cache=PoolThreadCache,本地是否已经有了</div><div class=\"line\">               // was able to allocate out of the cache so move on</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">               ++allocationsNormal;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           // Huge allocations are never served via the cache so just call allocateHuge</div><div class=\"line\">           allocateHuge(buf, reqCapacity); //大于16M，则分配大内存</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>PoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:<br>1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,…, 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。<br>2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:</p>\n<ul>\n<li>首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></li>\n<li>若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int tinyIdx(int normCapacity) &#123;  //申请内容小于512，下标</div><div class=\"line\">    return normCapacity &gt;&gt;&gt; 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了</div><div class=\"line\">&#125;</div><div class=\"line\">static int smallIdx(int normCapacity) &#123;</div><div class=\"line\">    int tableIdx = 0;</div><div class=\"line\">    int i = normCapacity &gt;&gt;&gt; 10; //首先是512 = 2^10</div><div class=\"line\">    while (i != 0) &#123;</div><div class=\"line\">        i &gt;&gt;&gt;= 1;</div><div class=\"line\">        tableIdx ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tableIdx;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。</p>\n<ul>\n<li>检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。</li>\n<li>若没有可分配的内存, 则会进入allocateNormal进行分配<br>3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。<br>4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。<h3 id=\"分配-16b-16m-内存\"><a href=\"#分配-16b-16m-内存\" class=\"headerlink\" title=\"分配[16b, 16m]内存\"></a>分配[16b, 16m]内存</h3>接着上述过程, 会进入allocateNormal进行内存分配<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存</div><div class=\"line\">        &#125;</div><div class=\"line\">        //跑到Direct里面newChunk了, 将 产生第一个chunk</div><div class=\"line\">        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树</div><div class=\"line\">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中</div><div class=\"line\">        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256</div><div class=\"line\">        assert handle &gt; 0;</div><div class=\"line\">        c.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">        qInit.add(c); //第一次分配的话，都会放入qInit</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    if (head == null || normCapacity &gt; maxCapacity) &#123; //head是可以直接寸数据的</div><div class=\"line\">        // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</div><div class=\"line\">        // be handled by the PoolChunks that are contained in this PoolChunkList.</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (PoolChunk&lt;T&gt; cur = head;;) &#123;</div><div class=\"line\">        long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值</div><div class=\"line\">        if (handle &lt; 0) &#123; //在poolchunk中没有找到能装得下的，那么继续找下一个</div><div class=\"line\">            cur = cur.next;</div><div class=\"line\">            if (cur == null) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            cur.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">            if (cur.usage() &gt;= maxUsage) &#123;//chunked量用超了则移动向下一个链</div><div class=\"line\">                remove(cur);</div><div class=\"line\">                nextList.add(cur);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。</p>\n<ol>\n<li>若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a></li>\n<li>对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。<br>这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:</li>\n</ol>\n<ul>\n<li>将PoolChunk分配维持在较高的比例上。</li>\n<li>保存一些空闲度比较大的内存, 以便大内存的分配。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Netty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。</p>\n<h2 id=\"Pool和Unpool区别\"><a href=\"#Pool和Unpool区别\" class=\"headerlink\" title=\"Pool和Unpool区别\"></a>Pool和Unpool区别</h2><p>字面意思, 分别是池化内存和非池化内存。<code>池化内存</code>的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。<code>非池化内存</code>就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数<code>Dio.netty.allocator.type</code>确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。<br>这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。</p>\n<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><p>线程调用如下接口来获取内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class=\"line\">    PoolThreadCache cache = threadCache.get();</div><div class=\"line\">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</div><div class=\"line\"></div><div class=\"line\">    final ByteBuf buf;</div><div class=\"line\">    if (directArena != null) &#123;</div><div class=\"line\">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        buf = PlatformDependent.hasUnsafe() ?</div><div class=\"line\">                UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :</div><div class=\"line\">                new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return toLeakAwareBuffer(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolArea内存原理探究</a>)</li>\n<li>从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。</li>\n</ul>\n<h1 id=\"PoolArena\"><a href=\"#PoolArena\" class=\"headerlink\" title=\"PoolArena\"></a>PoolArena</h1><p>PoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolArea.png\" height=\"400\" width=\"450\"><br>netty将池化内存块划分为3个类型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum SizeClass &#123;</div><div class=\"line\">    Tiny,</div><div class=\"line\">    Small,</div><div class=\"line\">    Normal</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Tiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。<br>大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">//tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块</div><div class=\"line\">static final int numTinySubpagePools = 512 &gt;&gt;&gt; 4;</div><div class=\"line\">//全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT</div><div class=\"line\">final PooledByteBufAllocator parent;</div><div class=\"line\">// log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//默认8k</div><div class=\"line\">final int pageSize;</div><div class=\"line\">//log(8k) =  13</div><div class=\"line\">final int pageShifts;</div><div class=\"line\">//默认16M</div><div class=\"line\">final int chunkSize;</div><div class=\"line\">//-8192</div><div class=\"line\">final int subpageOverflowMask;</div><div class=\"line\">//指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]</div><div class=\"line\">final int numSmallSubpagePools;</div><div class=\"line\"> //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] tinySubpagePools;</div><div class=\"line\"> //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] smallSubpagePools;//存储1024-8096大小的内存</div><div class=\"line\"> //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q050;</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q025;   //存储内存利用率25-75%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q000;   //存储内存利用率1-50%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; qInit;  //存储内存利用率0-25%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q075;    //存储内存利用率75-100%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q100;   //存储内存利用率100%的chunk</div><div class=\"line\"></div><div class=\"line\">// Number of thread caches backed by this arena. 该PoolArea被多少线程引用。</div><div class=\"line\">final AtomicInteger numThreadCaches = new AtomicInteger();</div></pre></td></tr></table></figure></p>\n<p>PoolArea申请内存时根据申请的大小使用不同对象进行分配:</p>\n<ul>\n<li>tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。</li>\n<li>smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。</li>\n<li>q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。<br>他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p><br>&nbsp;&nbsp;若q025中某个PoolChunk使用率大于75%之后, 该PoolChunk将别移动到q050中。<br>&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。<br>&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。<br>&nbsp;&nbsp;若q000使用率为0, 会被释放掉。</p></li>\n</ul>\n<p>numThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></p>\n<h2 id=\"PoolArena的内存分配\"><a href=\"#PoolArena的内存分配\" class=\"headerlink\" title=\"PoolArena的内存分配\"></a>PoolArena的内存分配</h2><p>netty真正申请内存时, 首先便是调用PoolArena.allocate()函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) &#123;</div><div class=\"line\">       final int normCapacity = normalizeCapacity(reqCapacity);</div><div class=\"line\">        // capacity &lt; pageSize   小于8k</div><div class=\"line\">       if (isTinyOrSmall(normCapacity)) &#123;</div><div class=\"line\">           int tableIdx;</div><div class=\"line\">           PoolSubpage&lt;T&gt;[] table;</div><div class=\"line\">           boolean tiny = isTiny(normCapacity);</div><div class=\"line\">           if (tiny) &#123; // &lt; 512</div><div class=\"line\">                //若从缓冲中取得该值</div><div class=\"line\">               if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = tinyIdx(normCapacity);</div><div class=\"line\">               table = tinySubpagePools;</div><div class=\"line\">           &#125; else &#123;  //small</div><div class=\"line\">               if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = smallIdx(normCapacity);</div><div class=\"line\">               table = smallSubpagePools;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           final PoolSubpage&lt;T&gt; head = table[tableIdx];</div><div class=\"line\"></div><div class=\"line\">           /**</div><div class=\"line\">            * Synchronize on the head. This is needed as &#123;@link PoolChunk#allocateSubpage(int)&#125; and</div><div class=\"line\">            * &#123;@link PoolChunk#free(long)&#125; may modify the doubly linked list as well.</div><div class=\"line\">            */</div><div class=\"line\">            //小于8k的</div><div class=\"line\">           synchronized (head) &#123;</div><div class=\"line\">                //如果分配完会从当前级别链上去掉</div><div class=\"line\">               final PoolSubpage&lt;T&gt; s = head.next;</div><div class=\"line\">                ///该型号的tiny的内存已经分配的有一个了</div><div class=\"line\">               if (s != head) &#123;</div><div class=\"line\">                   assert s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</div><div class=\"line\">                   long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">                   assert handle &gt;= 0;</div><div class=\"line\">                   s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</div><div class=\"line\">                   incTinySmallAllocation(tiny);</div><div class=\"line\">                   return;//如果从链中找到就返回，</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           //没有找到的话，就从Poolpage中分一个</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               //说明head并没有分配值，是第一次分配。</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           incTinySmallAllocation(tiny);</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (normCapacity &lt;= chunkSize) &#123; //小于16M</div><div class=\"line\">           if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) &#123;  //cache=PoolThreadCache,本地是否已经有了</div><div class=\"line\">               // was able to allocate out of the cache so move on</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">               ++allocationsNormal;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           // Huge allocations are never served via the cache so just call allocateHuge</div><div class=\"line\">           allocateHuge(buf, reqCapacity); //大于16M，则分配大内存</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>PoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:<br>1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,…, 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。<br>2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:</p>\n<ul>\n<li>首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></li>\n<li>若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int tinyIdx(int normCapacity) &#123;  //申请内容小于512，下标</div><div class=\"line\">    return normCapacity &gt;&gt;&gt; 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了</div><div class=\"line\">&#125;</div><div class=\"line\">static int smallIdx(int normCapacity) &#123;</div><div class=\"line\">    int tableIdx = 0;</div><div class=\"line\">    int i = normCapacity &gt;&gt;&gt; 10; //首先是512 = 2^10</div><div class=\"line\">    while (i != 0) &#123;</div><div class=\"line\">        i &gt;&gt;&gt;= 1;</div><div class=\"line\">        tableIdx ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tableIdx;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。</p>\n<ul>\n<li>检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。</li>\n<li>若没有可分配的内存, 则会进入allocateNormal进行分配<br>3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。<br>4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。<h3 id=\"分配-16b-16m-内存\"><a href=\"#分配-16b-16m-内存\" class=\"headerlink\" title=\"分配[16b, 16m]内存\"></a>分配[16b, 16m]内存</h3>接着上述过程, 会进入allocateNormal进行内存分配<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存</div><div class=\"line\">        &#125;</div><div class=\"line\">        //跑到Direct里面newChunk了, 将 产生第一个chunk</div><div class=\"line\">        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树</div><div class=\"line\">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中</div><div class=\"line\">        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256</div><div class=\"line\">        assert handle &gt; 0;</div><div class=\"line\">        c.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">        qInit.add(c); //第一次分配的话，都会放入qInit</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    if (head == null || normCapacity &gt; maxCapacity) &#123; //head是可以直接寸数据的</div><div class=\"line\">        // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</div><div class=\"line\">        // be handled by the PoolChunks that are contained in this PoolChunkList.</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (PoolChunk&lt;T&gt; cur = head;;) &#123;</div><div class=\"line\">        long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值</div><div class=\"line\">        if (handle &lt; 0) &#123; //在poolchunk中没有找到能装得下的，那么继续找下一个</div><div class=\"line\">            cur = cur.next;</div><div class=\"line\">            if (cur == null) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            cur.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">            if (cur.usage() &gt;= maxUsage) &#123;//chunked量用超了则移动向下一个链</div><div class=\"line\">                remove(cur);</div><div class=\"line\">                nextList.add(cur);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。</p>\n<ol>\n<li>若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a></li>\n<li>对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。<br>这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:</li>\n</ol>\n<ul>\n<li>将PoolChunk分配维持在较高的比例上。</li>\n<li>保存一些空闲度比较大的内存, 以便大内存的分配。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.</p>\n"},{"title":"Netty Thrift方式通信编解码源码解读","date":"2018-03-25T03:11:12.000Z","_content":"# 介绍\n## 零拷贝\nNetty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\">参考</a>)：\n1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。\n3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\n\n## 编解码处理器\n编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例\n解码处理器目前接触比较多的两种:\n+ ByteToMessageDecoder\nByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。\n+ MessageToMessageDecoder\nMessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。\n\n## 代码引入\n需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):\n```\n        public final void read() {\n            final ChannelConfig config = config();\n            final ChannelPipeline pipeline = pipeline();\n            final ByteBufAllocator allocator = config.getAllocator();\n            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取\n            allocHandle.reset(config);\n            ByteBuf byteBuf = null;\n            boolean close = false;\n            try {\n                do {\n                    byteBuf = allocHandle.allocate(allocator);\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                    if (allocHandle.lastBytesRead() <= 0) { // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接\n                        // nothing was read. release the buffer.\n                        byteBuf.release();\n                        byteBuf = null;\n                        close = allocHandle.lastBytesRead() < 0;\n                        break;\n                    }\n                    allocHandle.incMessagesRead(1);\n                    readPending = false;\n                    pipeline.fireChannelRead(byteBuf);\n                    byteBuf = null;\n                } while (allocHandle.continueReading());\n                allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）\n                pipeline.fireChannelReadComplete();// 本轮数据读取完毕\n                if (close) {// 如果读取的时候发生错误则关闭连接\n                    closeOnRead(pipeline);\n                }\n            } catch (Throwable t) {\n                handleReadException(pipeline, byteBuf, t, close, allocHandle);\n            } finally {\n\n            }\n        }\n    }\n ```\n这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。\n# ByteToMessageDecoder\n属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。\n回到代码里, 需要关注channelRead:\n```\n@Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ByteBuf) {    //PoolUnsafeDirectByteBuf\n            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合\n            try {\n                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf\n                first = cumulation == null;\n                if (first) {\n                    cumulation = data;\n                } else {\n                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR\n                }\n                callDecode(ctx, cumulation, out);\n            } catch (DecoderException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw new DecoderException(t);\n            } finally {//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)\n                if (cumulation != null && !cumulation.isReadable()) {\n                    numReads = 0;\n                    cumulation.release();\n                    cumulation = null;\n                } else if (++ numReads >= discardAfterReads) {\n                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.\n                    // See https://github.com/netty/netty/issues/4275\n                    numReads = 0;\n                    discardSomeReadBytes();\n                }\n\n                int size = out.size();\n                decodeWasNull = !out.insertSinceRecycled();\n                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message\n                out.recycle();\n            }\n        } else {\n            ctx.fireChannelRead(msg);\n        }\n    }\n```\n主要做的事情:\n1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。\n2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。\n```\n @Override\n        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf\n            final ByteBuf buffer;\n            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()\n                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {\n                // Expand cumulation (by replace it) when either there is not more room in the buffer\n                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or\n                // duplicate().retain() or if its read-only.\n                //\n                // See:\n                // - https://github.com/netty/netty/issues/2327\n                // - https://github.com/netty/netty/issues/1764\n                buffer = expandCumulation(alloc, cumulation, in.readableBytes());\n            } else {\n                buffer = cumulation;\n            }\n            buffer.writeBytes(in); //将新的数据，写入这个cumulation\n            in.release();  //释放资源\n            return buffer;\n        }\n```\n+ 首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation\n```\n   ByteBuf oldCumulation = cumulation;\n        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据\n        cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据\n        oldCumulation.release(); //释放旧的缓冲区\n        return cumulation;\n```\ncumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。\n3) 解码callDecode\n```\n             while (in.isReadable()) {\n                int outSize = out.size();\n                if (outSize > 0) { //out为经过转码形成帧的的数据\n                    fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个\n                    out.clear();\n                    outSize = 0;\n                }\n                int oldInputLength = in.readableBytes();  //24\n                decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode\n                if (outSize == out.size()) { //decode没有解析出东西\n                    if (oldInputLength == in.readableBytes()) { //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐\n                        break;\n                    } else { //还是向前消费了许多东西，可能读到了坏的帧，丢弃了\n                        continue;\n                    }\n                }\n                if (oldInputLength == in.readableBytes()) {  //说明outSize < out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题\n                    throw new DecoderException(\n                            StringUtil.simpleClassName(getClass()) +\n                                    \".decode() did not read anything but decoded a message.\");\n                }\n              }\n```\n+ 首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。\n+ 开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在`LengthFieldBasedFrameDecoder`里实现。\n+ 对这轮解析结果进行分析:\n     若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。\n     若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。\n     若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。\n4) 检查是否还有帧可以继续向上传递。\n```\n static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {\n        if (msgs instanceof CodecOutputList) {   //都单个单个的发送\n            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                ctx.fireChannelRead(msgs.get(i));\n            }\n        }\n    }\n```\n可以看出实际也是每个帧单独向上发送的。\n\n# LengthFieldBasedFrameDecoder\nLengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)即可: 从原始byte in中解析出一个帧, 放入out中。\n我们需要理解几个属性的函数:\n+ maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。\n+ lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。\n+ lengthFieldLength: 定义帧长度的字段本身的长度。\n+ lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉\n+ initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分\n+ failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。\n+ discardingTooLongFrame: 当帧解析出来的帧内容长度 > maxFrameLength时,并且剩余缓存可读字段 < 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。\n+ tooLongFrameLength: 超过长度限制maxFrameLength的帧长度\n+ bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容\n关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"/>\n也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\"> 参考/a>\n其中:\n+ head1和head2可以由用户自定义语义。\n+ 有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength\n解码函数如下:\n```\n       if (discardingTooLongFrame) {//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢\n            long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度\n            int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数\n            in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度\n            bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度\n            this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度\n            failIfNecessary(false);\n        }\n        //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回\n        if (in.readableBytes() < lengthFieldEndOffset) {//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码\n            return null; //当前帧没有value\n        }\n       // 拿到长度字段的起始偏移量index\n        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置\n        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度\n        if (frameLength < 0) {\n            in.skipBytes(lengthFieldEndOffset);\n            throw new CorruptedFrameException(\n                    \"negative pre-adjustment length field: \" + frameLength);\n        }\n        // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)\n        frameLength += lengthAdjustment + lengthFieldEndOffset;\n        if (frameLength < lengthFieldEndOffset) {\n            in.skipBytes(lengthFieldEndOffset);//当前帧忽略过\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than lengthFieldEndOffset: \" + lengthFieldEndOffset);\n        }\n        // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。\n        if (frameLength > maxFrameLength) {\n            long discard = frameLength - in.readableBytes();//前面\n            tooLongFrameLength = frameLength;\n            // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n            if (discard < 0) {// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n                // buffer contains more bytes then the frameLength so we can discard all now\n                in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面\n            } else {\n                // Enter the discard mode and discard everything received so far.\n                discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧\n                bytesToDiscard = discard;\n                in.skipBytes(in.readableBytes());//丢弃整个帧\n            }\n            failIfNecessary(true);\n            return null;\n        }\n        // never overflows because it's less than maxFrameLength\n        int frameLengthInt = (int) frameLength;\n        if (in.readableBytes() < frameLengthInt) {  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环\n            return null;\n        }\n        if (initialBytesToStrip > frameLengthInt) {\n            in.skipBytes(frameLengthInt);\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than initialBytesToStrip: \" + initialBytesToStrip);\n        }\n        in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content\n        // extract frame\n        int readerIndex = in.readerIndex();\n        int actualFrameLength = frameLengthInt - initialBytesToStrip;\n        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);\n        in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置\n        return frame;\n```\n主要操作如下:\n1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:\n```\nprivate void failIfNecessary(boolean firstDetectionOfTooLongFrame) {\n        if (bytesToDiscard == 0) { //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态\n            // Reset to the initial state and tell the handlers that\n            // the frame was too large.\n            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度\n            this.tooLongFrameLength = 0; //主要是复位\n            discardingTooLongFrame = false;\n            if (!failFast || firstDetectionOfTooLongFrame) {// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理\n                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃\n            }\n        } else {  //第一次遇到，发现当前帧长度太长了\n            // Keep discarding and notify handlers if necessary.\n            if (failFast && firstDetectionOfTooLongFrame) {\n                fail(tooLongFrameLength); //是第一次遇到，直接丢失\n            }\n        }\n    }\n```\n+ 当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。\n+ 反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。\n2) 若当前缓存可读byte < 长度偏移量, 直接退出继续, 数据仍然放在了缓存。\n3) 计算出帧整体的长度,包括了length + head2 + content:\n```\nframeLength += lengthAdjustment + lengthFieldEndOffset;\n```\n4) 检查帧frameLength是否超过的阈值,若超过了:\n+ 检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度\n+ 否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。\n并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。\n5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。\n6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。\n","source":"_posts/Netty通信编解码源码解读.md","raw":"---\ntitle: Netty Thrift方式通信编解码源码解读\ndate: 2018-03-25 11:11:12\ntags:\n---\n# 介绍\n## 零拷贝\nNetty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\">参考</a>)：\n1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。\n3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\n\n## 编解码处理器\n编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例\n解码处理器目前接触比较多的两种:\n+ ByteToMessageDecoder\nByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。\n+ MessageToMessageDecoder\nMessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。\n\n## 代码引入\n需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):\n```\n        public final void read() {\n            final ChannelConfig config = config();\n            final ChannelPipeline pipeline = pipeline();\n            final ByteBufAllocator allocator = config.getAllocator();\n            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取\n            allocHandle.reset(config);\n            ByteBuf byteBuf = null;\n            boolean close = false;\n            try {\n                do {\n                    byteBuf = allocHandle.allocate(allocator);\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                    if (allocHandle.lastBytesRead() <= 0) { // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接\n                        // nothing was read. release the buffer.\n                        byteBuf.release();\n                        byteBuf = null;\n                        close = allocHandle.lastBytesRead() < 0;\n                        break;\n                    }\n                    allocHandle.incMessagesRead(1);\n                    readPending = false;\n                    pipeline.fireChannelRead(byteBuf);\n                    byteBuf = null;\n                } while (allocHandle.continueReading());\n                allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）\n                pipeline.fireChannelReadComplete();// 本轮数据读取完毕\n                if (close) {// 如果读取的时候发生错误则关闭连接\n                    closeOnRead(pipeline);\n                }\n            } catch (Throwable t) {\n                handleReadException(pipeline, byteBuf, t, close, allocHandle);\n            } finally {\n\n            }\n        }\n    }\n ```\n这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。\n# ByteToMessageDecoder\n属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。\n回到代码里, 需要关注channelRead:\n```\n@Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ByteBuf) {    //PoolUnsafeDirectByteBuf\n            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合\n            try {\n                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf\n                first = cumulation == null;\n                if (first) {\n                    cumulation = data;\n                } else {\n                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR\n                }\n                callDecode(ctx, cumulation, out);\n            } catch (DecoderException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw new DecoderException(t);\n            } finally {//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)\n                if (cumulation != null && !cumulation.isReadable()) {\n                    numReads = 0;\n                    cumulation.release();\n                    cumulation = null;\n                } else if (++ numReads >= discardAfterReads) {\n                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.\n                    // See https://github.com/netty/netty/issues/4275\n                    numReads = 0;\n                    discardSomeReadBytes();\n                }\n\n                int size = out.size();\n                decodeWasNull = !out.insertSinceRecycled();\n                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message\n                out.recycle();\n            }\n        } else {\n            ctx.fireChannelRead(msg);\n        }\n    }\n```\n主要做的事情:\n1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。\n2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。\n```\n @Override\n        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf\n            final ByteBuf buffer;\n            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()\n                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {\n                // Expand cumulation (by replace it) when either there is not more room in the buffer\n                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or\n                // duplicate().retain() or if its read-only.\n                //\n                // See:\n                // - https://github.com/netty/netty/issues/2327\n                // - https://github.com/netty/netty/issues/1764\n                buffer = expandCumulation(alloc, cumulation, in.readableBytes());\n            } else {\n                buffer = cumulation;\n            }\n            buffer.writeBytes(in); //将新的数据，写入这个cumulation\n            in.release();  //释放资源\n            return buffer;\n        }\n```\n+ 首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation\n```\n   ByteBuf oldCumulation = cumulation;\n        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据\n        cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据\n        oldCumulation.release(); //释放旧的缓冲区\n        return cumulation;\n```\ncumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。\n3) 解码callDecode\n```\n             while (in.isReadable()) {\n                int outSize = out.size();\n                if (outSize > 0) { //out为经过转码形成帧的的数据\n                    fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个\n                    out.clear();\n                    outSize = 0;\n                }\n                int oldInputLength = in.readableBytes();  //24\n                decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode\n                if (outSize == out.size()) { //decode没有解析出东西\n                    if (oldInputLength == in.readableBytes()) { //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐\n                        break;\n                    } else { //还是向前消费了许多东西，可能读到了坏的帧，丢弃了\n                        continue;\n                    }\n                }\n                if (oldInputLength == in.readableBytes()) {  //说明outSize < out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题\n                    throw new DecoderException(\n                            StringUtil.simpleClassName(getClass()) +\n                                    \".decode() did not read anything but decoded a message.\");\n                }\n              }\n```\n+ 首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。\n+ 开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在`LengthFieldBasedFrameDecoder`里实现。\n+ 对这轮解析结果进行分析:\n     若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。\n     若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。\n     若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。\n4) 检查是否还有帧可以继续向上传递。\n```\n static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {\n        if (msgs instanceof CodecOutputList) {   //都单个单个的发送\n            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                ctx.fireChannelRead(msgs.get(i));\n            }\n        }\n    }\n```\n可以看出实际也是每个帧单独向上发送的。\n\n# LengthFieldBasedFrameDecoder\nLengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)即可: 从原始byte in中解析出一个帧, 放入out中。\n我们需要理解几个属性的函数:\n+ maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。\n+ lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。\n+ lengthFieldLength: 定义帧长度的字段本身的长度。\n+ lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉\n+ initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分\n+ failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。\n+ discardingTooLongFrame: 当帧解析出来的帧内容长度 > maxFrameLength时,并且剩余缓存可读字段 < 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。\n+ tooLongFrameLength: 超过长度限制maxFrameLength的帧长度\n+ bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容\n关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"/>\n也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\"> 参考/a>\n其中:\n+ head1和head2可以由用户自定义语义。\n+ 有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength\n解码函数如下:\n```\n       if (discardingTooLongFrame) {//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢\n            long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度\n            int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数\n            in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度\n            bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度\n            this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度\n            failIfNecessary(false);\n        }\n        //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回\n        if (in.readableBytes() < lengthFieldEndOffset) {//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码\n            return null; //当前帧没有value\n        }\n       // 拿到长度字段的起始偏移量index\n        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置\n        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度\n        if (frameLength < 0) {\n            in.skipBytes(lengthFieldEndOffset);\n            throw new CorruptedFrameException(\n                    \"negative pre-adjustment length field: \" + frameLength);\n        }\n        // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)\n        frameLength += lengthAdjustment + lengthFieldEndOffset;\n        if (frameLength < lengthFieldEndOffset) {\n            in.skipBytes(lengthFieldEndOffset);//当前帧忽略过\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than lengthFieldEndOffset: \" + lengthFieldEndOffset);\n        }\n        // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。\n        if (frameLength > maxFrameLength) {\n            long discard = frameLength - in.readableBytes();//前面\n            tooLongFrameLength = frameLength;\n            // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n            if (discard < 0) {// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n                // buffer contains more bytes then the frameLength so we can discard all now\n                in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面\n            } else {\n                // Enter the discard mode and discard everything received so far.\n                discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧\n                bytesToDiscard = discard;\n                in.skipBytes(in.readableBytes());//丢弃整个帧\n            }\n            failIfNecessary(true);\n            return null;\n        }\n        // never overflows because it's less than maxFrameLength\n        int frameLengthInt = (int) frameLength;\n        if (in.readableBytes() < frameLengthInt) {  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环\n            return null;\n        }\n        if (initialBytesToStrip > frameLengthInt) {\n            in.skipBytes(frameLengthInt);\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than initialBytesToStrip: \" + initialBytesToStrip);\n        }\n        in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content\n        // extract frame\n        int readerIndex = in.readerIndex();\n        int actualFrameLength = frameLengthInt - initialBytesToStrip;\n        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);\n        in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置\n        return frame;\n```\n主要操作如下:\n1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:\n```\nprivate void failIfNecessary(boolean firstDetectionOfTooLongFrame) {\n        if (bytesToDiscard == 0) { //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态\n            // Reset to the initial state and tell the handlers that\n            // the frame was too large.\n            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度\n            this.tooLongFrameLength = 0; //主要是复位\n            discardingTooLongFrame = false;\n            if (!failFast || firstDetectionOfTooLongFrame) {// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理\n                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃\n            }\n        } else {  //第一次遇到，发现当前帧长度太长了\n            // Keep discarding and notify handlers if necessary.\n            if (failFast && firstDetectionOfTooLongFrame) {\n                fail(tooLongFrameLength); //是第一次遇到，直接丢失\n            }\n        }\n    }\n```\n+ 当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。\n+ 反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。\n2) 若当前缓存可读byte < 长度偏移量, 直接退出继续, 数据仍然放在了缓存。\n3) 计算出帧整体的长度,包括了length + head2 + content:\n```\nframeLength += lengthAdjustment + lengthFieldEndOffset;\n```\n4) 检查帧frameLength是否超过的阈值,若超过了:\n+ 检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度\n+ 否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。\n并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。\n5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。\n6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。\n","slug":"Netty通信编解码源码解读","published":1,"updated":"2018-05-13T11:48:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvp000eisu5uhonfbcq","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>Netty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\" target=\"_blank\" rel=\"external\">参考</a>)：<br>1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p>\n<h2 id=\"编解码处理器\"><a href=\"#编解码处理器\" class=\"headerlink\" title=\"编解码处理器\"></a>编解码处理器</h2><p>编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例<br>解码处理器目前接触比较多的两种:</p>\n<ul>\n<li>ByteToMessageDecoder<br>ByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。</li>\n<li>MessageToMessageDecoder<br>MessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。</li>\n</ul>\n<h2 id=\"代码引入\"><a href=\"#代码引入\" class=\"headerlink\" title=\"代码引入\"></a>代码引入</h2><p>需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    public final void read() &#123;</div><div class=\"line\">        final ChannelConfig config = config();</div><div class=\"line\">        final ChannelPipeline pipeline = pipeline();</div><div class=\"line\">        final ByteBufAllocator allocator = config.getAllocator();</div><div class=\"line\">        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取</div><div class=\"line\">        allocHandle.reset(config);</div><div class=\"line\">        ByteBuf byteBuf = null;</div><div class=\"line\">        boolean close = false;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                byteBuf = allocHandle.allocate(allocator);</div><div class=\"line\">                allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class=\"line\">                if (allocHandle.lastBytesRead() &lt;= 0) &#123; // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接</div><div class=\"line\">                    // nothing was read. release the buffer.</div><div class=\"line\">                    byteBuf.release();</div><div class=\"line\">                    byteBuf = null;</div><div class=\"line\">                    close = allocHandle.lastBytesRead() &lt; 0;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                allocHandle.incMessagesRead(1);</div><div class=\"line\">                readPending = false;</div><div class=\"line\">                pipeline.fireChannelRead(byteBuf);</div><div class=\"line\">                byteBuf = null;</div><div class=\"line\">            &#125; while (allocHandle.continueReading());</div><div class=\"line\">            allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）</div><div class=\"line\">            pipeline.fireChannelReadComplete();// 本轮数据读取完毕</div><div class=\"line\">            if (close) &#123;// 如果读取的时候发生错误则关闭连接</div><div class=\"line\">                closeOnRead(pipeline);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable t) &#123;</div><div class=\"line\">            handleReadException(pipeline, byteBuf, t, close, allocHandle);</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。</p>\n<h1 id=\"ByteToMessageDecoder\"><a href=\"#ByteToMessageDecoder\" class=\"headerlink\" title=\"ByteToMessageDecoder\"></a>ByteToMessageDecoder</h1><p>属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。<br>回到代码里, 需要关注channelRead:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class=\"line\">        if (msg instanceof ByteBuf) &#123;    //PoolUnsafeDirectByteBuf</div><div class=\"line\">            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf</div><div class=\"line\">                first = cumulation == null;</div><div class=\"line\">                if (first) &#123;</div><div class=\"line\">                    cumulation = data;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR</div><div class=\"line\">                &#125;</div><div class=\"line\">                callDecode(ctx, cumulation, out);</div><div class=\"line\">            &#125; catch (DecoderException e) &#123;</div><div class=\"line\">                throw e;</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                throw new DecoderException(t);</div><div class=\"line\">            &#125; finally &#123;//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)</div><div class=\"line\">                if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    cumulation.release();</div><div class=\"line\">                    cumulation = null;</div><div class=\"line\">                &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</div><div class=\"line\">                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/4275</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    discardSomeReadBytes();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                int size = out.size();</div><div class=\"line\">                decodeWasNull = !out.insertSinceRecycled();</div><div class=\"line\">                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message</div><div class=\"line\">                out.recycle();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.fireChannelRead(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事情:<br>1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。<br>2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">       public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) &#123;  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf</div><div class=\"line\">           final ByteBuf buffer;</div><div class=\"line\">           if (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</div><div class=\"line\">                   || cumulation.refCnt() &gt; 1 || cumulation.isReadOnly()) &#123;</div><div class=\"line\">               // Expand cumulation (by replace it) when either there is not more room in the buffer</div><div class=\"line\">               // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</div><div class=\"line\">               // duplicate().retain() or if its read-only.</div><div class=\"line\">               //</div><div class=\"line\">               // See:</div><div class=\"line\">               // - https://github.com/netty/netty/issues/2327</div><div class=\"line\">               // - https://github.com/netty/netty/issues/1764</div><div class=\"line\">               buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               buffer = cumulation;</div><div class=\"line\">           &#125;</div><div class=\"line\">           buffer.writeBytes(in); //将新的数据，写入这个cumulation</div><div class=\"line\">           in.release();  //释放资源</div><div class=\"line\">           return buffer;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf oldCumulation = cumulation;</div><div class=\"line\">     cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据</div><div class=\"line\">     cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据</div><div class=\"line\">     oldCumulation.release(); //释放旧的缓冲区</div><div class=\"line\">     return cumulation;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>cumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。<br>3) 解码callDecode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (in.isReadable()) &#123;</div><div class=\"line\">   int outSize = out.size();</div><div class=\"line\">   if (outSize &gt; 0) &#123; //out为经过转码形成帧的的数据</div><div class=\"line\">       fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个</div><div class=\"line\">       out.clear();</div><div class=\"line\">       outSize = 0;</div><div class=\"line\">   &#125;</div><div class=\"line\">   int oldInputLength = in.readableBytes();  //24</div><div class=\"line\">   decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode</div><div class=\"line\">   if (outSize == out.size()) &#123; //decode没有解析出东西</div><div class=\"line\">       if (oldInputLength == in.readableBytes()) &#123; //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐</div><div class=\"line\">           break;</div><div class=\"line\">       &#125; else &#123; //还是向前消费了许多东西，可能读到了坏的帧，丢弃了</div><div class=\"line\">           continue;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   if (oldInputLength == in.readableBytes()) &#123;  //说明outSize &lt; out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题</div><div class=\"line\">       throw new DecoderException(</div><div class=\"line\">               StringUtil.simpleClassName(getClass()) +</div><div class=\"line\">                       &quot;.decode() did not read anything but decoded a message.&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。</li>\n<li>开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在<code>LengthFieldBasedFrameDecoder</code>里实现。</li>\n<li>对这轮解析结果进行分析:<br>   若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。<br>   若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。<br>   若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。<br>4) 检查是否还有帧可以继续向上传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements) &#123;</div><div class=\"line\">       if (msgs instanceof CodecOutputList) &#123;   //都单个单个的发送</div><div class=\"line\">           fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           for (int i = 0; i &lt; numElements; i++) &#123;</div><div class=\"line\">               ctx.fireChannelRead(msgs.get(i));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出实际也是每个帧单独向上发送的。</p>\n<h1 id=\"LengthFieldBasedFrameDecoder\"><a href=\"#LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"LengthFieldBasedFrameDecoder\"></a>LengthFieldBasedFrameDecoder</h1><p>LengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<object> out)即可: 从原始byte in中解析出一个帧, 放入out中。<br>我们需要理解几个属性的函数:</object></p>\n<ul>\n<li>maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。</li>\n<li>lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。</li>\n<li>lengthFieldLength: 定义帧长度的字段本身的长度。</li>\n<li>lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉</li>\n<li>initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分</li>\n<li>failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。</li>\n<li>discardingTooLongFrame: 当帧解析出来的帧内容长度 &gt; maxFrameLength时,并且剩余缓存可读字段 &lt; 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。</li>\n<li>tooLongFrameLength: 超过长度限制maxFrameLength的帧长度</li>\n<li>bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容<br>关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"><br>也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\" target=\"_blank\" rel=\"external\"> 参考/a&gt;<br>其中:</a></li>\n<li>head1和head2可以由用户自定义语义。</li>\n<li>有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength<br>解码函数如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (discardingTooLongFrame) &#123;//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢</div><div class=\"line\">     long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度</div><div class=\"line\">     int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数</div><div class=\"line\">     in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度</div><div class=\"line\">     bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度</div><div class=\"line\">     this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度</div><div class=\"line\">     failIfNecessary(false);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回</div><div class=\"line\"> if (in.readableBytes() &lt; lengthFieldEndOffset) &#123;//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码</div><div class=\"line\">     return null; //当前帧没有value</div><div class=\"line\"> &#125;</div><div class=\"line\">// 拿到长度字段的起始偏移量index</div><div class=\"line\"> int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置</div><div class=\"line\"> long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度</div><div class=\"line\"> if (frameLength &lt; 0) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;negative pre-adjustment length field: &quot; + frameLength);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)</div><div class=\"line\"> frameLength += lengthAdjustment + lengthFieldEndOffset;</div><div class=\"line\"> if (frameLength &lt; lengthFieldEndOffset) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);//当前帧忽略过</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than lengthFieldEndOffset: &quot; + lengthFieldEndOffset);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。</div><div class=\"line\"> if (frameLength &gt; maxFrameLength) &#123;</div><div class=\"line\">     long discard = frameLength - in.readableBytes();//前面</div><div class=\"line\">     tooLongFrameLength = frameLength;</div><div class=\"line\">     // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">     if (discard &lt; 0) &#123;// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">         // buffer contains more bytes then the frameLength so we can discard all now</div><div class=\"line\">         in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Enter the discard mode and discard everything received so far.</div><div class=\"line\">         discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧</div><div class=\"line\">         bytesToDiscard = discard;</div><div class=\"line\">         in.skipBytes(in.readableBytes());//丢弃整个帧</div><div class=\"line\">     &#125;</div><div class=\"line\">     failIfNecessary(true);</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> // never overflows because it&apos;s less than maxFrameLength</div><div class=\"line\"> int frameLengthInt = (int) frameLength;</div><div class=\"line\"> if (in.readableBytes() &lt; frameLengthInt) &#123;  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> if (initialBytesToStrip &gt; frameLengthInt) &#123;</div><div class=\"line\">     in.skipBytes(frameLengthInt);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than initialBytesToStrip: &quot; + initialBytesToStrip);</div><div class=\"line\"> &#125;</div><div class=\"line\"> in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content</div><div class=\"line\"> // extract frame</div><div class=\"line\"> int readerIndex = in.readerIndex();</div><div class=\"line\"> int actualFrameLength = frameLengthInt - initialBytesToStrip;</div><div class=\"line\"> ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);</div><div class=\"line\"> in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置</div><div class=\"line\"> return frame;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要操作如下:<br>1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void failIfNecessary(boolean firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">        if (bytesToDiscard == 0) &#123; //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态</div><div class=\"line\">            // Reset to the initial state and tell the handlers that</div><div class=\"line\">            // the frame was too large.</div><div class=\"line\">            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度</div><div class=\"line\">            this.tooLongFrameLength = 0; //主要是复位</div><div class=\"line\">            discardingTooLongFrame = false;</div><div class=\"line\">            if (!failFast || firstDetectionOfTooLongFrame) &#123;// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理</div><div class=\"line\">                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;  //第一次遇到，发现当前帧长度太长了</div><div class=\"line\">            // Keep discarding and notify handlers if necessary.</div><div class=\"line\">            if (failFast &amp;&amp; firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">                fail(tooLongFrameLength); //是第一次遇到，直接丢失</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。</li>\n<li>反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。<br>2) 若当前缓存可读byte &lt; 长度偏移量, 直接退出继续, 数据仍然放在了缓存。<br>3) 计算出帧整体的长度,包括了length + head2 + content:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameLength += lengthAdjustment + lengthFieldEndOffset;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>4) 检查帧frameLength是否超过的阈值,若超过了:</p>\n<ul>\n<li>检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度</li>\n<li>否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。<br>并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。<br>5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。<br>6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>Netty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\" target=\"_blank\" rel=\"external\">参考</a>)：<br>1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p>\n<h2 id=\"编解码处理器\"><a href=\"#编解码处理器\" class=\"headerlink\" title=\"编解码处理器\"></a>编解码处理器</h2><p>编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例<br>解码处理器目前接触比较多的两种:</p>\n<ul>\n<li>ByteToMessageDecoder<br>ByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。</li>\n<li>MessageToMessageDecoder<br>MessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。</li>\n</ul>\n<h2 id=\"代码引入\"><a href=\"#代码引入\" class=\"headerlink\" title=\"代码引入\"></a>代码引入</h2><p>需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    public final void read() &#123;</div><div class=\"line\">        final ChannelConfig config = config();</div><div class=\"line\">        final ChannelPipeline pipeline = pipeline();</div><div class=\"line\">        final ByteBufAllocator allocator = config.getAllocator();</div><div class=\"line\">        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取</div><div class=\"line\">        allocHandle.reset(config);</div><div class=\"line\">        ByteBuf byteBuf = null;</div><div class=\"line\">        boolean close = false;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                byteBuf = allocHandle.allocate(allocator);</div><div class=\"line\">                allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class=\"line\">                if (allocHandle.lastBytesRead() &lt;= 0) &#123; // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接</div><div class=\"line\">                    // nothing was read. release the buffer.</div><div class=\"line\">                    byteBuf.release();</div><div class=\"line\">                    byteBuf = null;</div><div class=\"line\">                    close = allocHandle.lastBytesRead() &lt; 0;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                allocHandle.incMessagesRead(1);</div><div class=\"line\">                readPending = false;</div><div class=\"line\">                pipeline.fireChannelRead(byteBuf);</div><div class=\"line\">                byteBuf = null;</div><div class=\"line\">            &#125; while (allocHandle.continueReading());</div><div class=\"line\">            allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）</div><div class=\"line\">            pipeline.fireChannelReadComplete();// 本轮数据读取完毕</div><div class=\"line\">            if (close) &#123;// 如果读取的时候发生错误则关闭连接</div><div class=\"line\">                closeOnRead(pipeline);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable t) &#123;</div><div class=\"line\">            handleReadException(pipeline, byteBuf, t, close, allocHandle);</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。</p>\n<h1 id=\"ByteToMessageDecoder\"><a href=\"#ByteToMessageDecoder\" class=\"headerlink\" title=\"ByteToMessageDecoder\"></a>ByteToMessageDecoder</h1><p>属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。<br>回到代码里, 需要关注channelRead:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class=\"line\">        if (msg instanceof ByteBuf) &#123;    //PoolUnsafeDirectByteBuf</div><div class=\"line\">            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf</div><div class=\"line\">                first = cumulation == null;</div><div class=\"line\">                if (first) &#123;</div><div class=\"line\">                    cumulation = data;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR</div><div class=\"line\">                &#125;</div><div class=\"line\">                callDecode(ctx, cumulation, out);</div><div class=\"line\">            &#125; catch (DecoderException e) &#123;</div><div class=\"line\">                throw e;</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                throw new DecoderException(t);</div><div class=\"line\">            &#125; finally &#123;//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)</div><div class=\"line\">                if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    cumulation.release();</div><div class=\"line\">                    cumulation = null;</div><div class=\"line\">                &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</div><div class=\"line\">                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/4275</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    discardSomeReadBytes();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                int size = out.size();</div><div class=\"line\">                decodeWasNull = !out.insertSinceRecycled();</div><div class=\"line\">                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message</div><div class=\"line\">                out.recycle();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.fireChannelRead(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事情:<br>1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。<br>2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">       public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) &#123;  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf</div><div class=\"line\">           final ByteBuf buffer;</div><div class=\"line\">           if (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</div><div class=\"line\">                   || cumulation.refCnt() &gt; 1 || cumulation.isReadOnly()) &#123;</div><div class=\"line\">               // Expand cumulation (by replace it) when either there is not more room in the buffer</div><div class=\"line\">               // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</div><div class=\"line\">               // duplicate().retain() or if its read-only.</div><div class=\"line\">               //</div><div class=\"line\">               // See:</div><div class=\"line\">               // - https://github.com/netty/netty/issues/2327</div><div class=\"line\">               // - https://github.com/netty/netty/issues/1764</div><div class=\"line\">               buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               buffer = cumulation;</div><div class=\"line\">           &#125;</div><div class=\"line\">           buffer.writeBytes(in); //将新的数据，写入这个cumulation</div><div class=\"line\">           in.release();  //释放资源</div><div class=\"line\">           return buffer;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf oldCumulation = cumulation;</div><div class=\"line\">     cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据</div><div class=\"line\">     cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据</div><div class=\"line\">     oldCumulation.release(); //释放旧的缓冲区</div><div class=\"line\">     return cumulation;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>cumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。<br>3) 解码callDecode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (in.isReadable()) &#123;</div><div class=\"line\">   int outSize = out.size();</div><div class=\"line\">   if (outSize &gt; 0) &#123; //out为经过转码形成帧的的数据</div><div class=\"line\">       fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个</div><div class=\"line\">       out.clear();</div><div class=\"line\">       outSize = 0;</div><div class=\"line\">   &#125;</div><div class=\"line\">   int oldInputLength = in.readableBytes();  //24</div><div class=\"line\">   decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode</div><div class=\"line\">   if (outSize == out.size()) &#123; //decode没有解析出东西</div><div class=\"line\">       if (oldInputLength == in.readableBytes()) &#123; //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐</div><div class=\"line\">           break;</div><div class=\"line\">       &#125; else &#123; //还是向前消费了许多东西，可能读到了坏的帧，丢弃了</div><div class=\"line\">           continue;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   if (oldInputLength == in.readableBytes()) &#123;  //说明outSize &lt; out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题</div><div class=\"line\">       throw new DecoderException(</div><div class=\"line\">               StringUtil.simpleClassName(getClass()) +</div><div class=\"line\">                       &quot;.decode() did not read anything but decoded a message.&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。</li>\n<li>开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在<code>LengthFieldBasedFrameDecoder</code>里实现。</li>\n<li>对这轮解析结果进行分析:<br>   若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。<br>   若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。<br>   若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。<br>4) 检查是否还有帧可以继续向上传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements) &#123;</div><div class=\"line\">       if (msgs instanceof CodecOutputList) &#123;   //都单个单个的发送</div><div class=\"line\">           fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           for (int i = 0; i &lt; numElements; i++) &#123;</div><div class=\"line\">               ctx.fireChannelRead(msgs.get(i));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出实际也是每个帧单独向上发送的。</p>\n<h1 id=\"LengthFieldBasedFrameDecoder\"><a href=\"#LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"LengthFieldBasedFrameDecoder\"></a>LengthFieldBasedFrameDecoder</h1><p>LengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<object> out)即可: 从原始byte in中解析出一个帧, 放入out中。<br>我们需要理解几个属性的函数:</object></p>\n<ul>\n<li>maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。</li>\n<li>lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。</li>\n<li>lengthFieldLength: 定义帧长度的字段本身的长度。</li>\n<li>lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉</li>\n<li>initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分</li>\n<li>failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。</li>\n<li>discardingTooLongFrame: 当帧解析出来的帧内容长度 &gt; maxFrameLength时,并且剩余缓存可读字段 &lt; 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。</li>\n<li>tooLongFrameLength: 超过长度限制maxFrameLength的帧长度</li>\n<li>bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容<br>关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"><br>也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\" target=\"_blank\" rel=\"external\"> 参考/a&gt;<br>其中:</a></li>\n<li>head1和head2可以由用户自定义语义。</li>\n<li>有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength<br>解码函数如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (discardingTooLongFrame) &#123;//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢</div><div class=\"line\">     long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度</div><div class=\"line\">     int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数</div><div class=\"line\">     in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度</div><div class=\"line\">     bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度</div><div class=\"line\">     this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度</div><div class=\"line\">     failIfNecessary(false);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回</div><div class=\"line\"> if (in.readableBytes() &lt; lengthFieldEndOffset) &#123;//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码</div><div class=\"line\">     return null; //当前帧没有value</div><div class=\"line\"> &#125;</div><div class=\"line\">// 拿到长度字段的起始偏移量index</div><div class=\"line\"> int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置</div><div class=\"line\"> long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度</div><div class=\"line\"> if (frameLength &lt; 0) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;negative pre-adjustment length field: &quot; + frameLength);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)</div><div class=\"line\"> frameLength += lengthAdjustment + lengthFieldEndOffset;</div><div class=\"line\"> if (frameLength &lt; lengthFieldEndOffset) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);//当前帧忽略过</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than lengthFieldEndOffset: &quot; + lengthFieldEndOffset);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。</div><div class=\"line\"> if (frameLength &gt; maxFrameLength) &#123;</div><div class=\"line\">     long discard = frameLength - in.readableBytes();//前面</div><div class=\"line\">     tooLongFrameLength = frameLength;</div><div class=\"line\">     // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">     if (discard &lt; 0) &#123;// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">         // buffer contains more bytes then the frameLength so we can discard all now</div><div class=\"line\">         in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Enter the discard mode and discard everything received so far.</div><div class=\"line\">         discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧</div><div class=\"line\">         bytesToDiscard = discard;</div><div class=\"line\">         in.skipBytes(in.readableBytes());//丢弃整个帧</div><div class=\"line\">     &#125;</div><div class=\"line\">     failIfNecessary(true);</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> // never overflows because it&apos;s less than maxFrameLength</div><div class=\"line\"> int frameLengthInt = (int) frameLength;</div><div class=\"line\"> if (in.readableBytes() &lt; frameLengthInt) &#123;  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> if (initialBytesToStrip &gt; frameLengthInt) &#123;</div><div class=\"line\">     in.skipBytes(frameLengthInt);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than initialBytesToStrip: &quot; + initialBytesToStrip);</div><div class=\"line\"> &#125;</div><div class=\"line\"> in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content</div><div class=\"line\"> // extract frame</div><div class=\"line\"> int readerIndex = in.readerIndex();</div><div class=\"line\"> int actualFrameLength = frameLengthInt - initialBytesToStrip;</div><div class=\"line\"> ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);</div><div class=\"line\"> in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置</div><div class=\"line\"> return frame;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要操作如下:<br>1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void failIfNecessary(boolean firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">        if (bytesToDiscard == 0) &#123; //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态</div><div class=\"line\">            // Reset to the initial state and tell the handlers that</div><div class=\"line\">            // the frame was too large.</div><div class=\"line\">            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度</div><div class=\"line\">            this.tooLongFrameLength = 0; //主要是复位</div><div class=\"line\">            discardingTooLongFrame = false;</div><div class=\"line\">            if (!failFast || firstDetectionOfTooLongFrame) &#123;// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理</div><div class=\"line\">                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;  //第一次遇到，发现当前帧长度太长了</div><div class=\"line\">            // Keep discarding and notify handlers if necessary.</div><div class=\"line\">            if (failFast &amp;&amp; firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">                fail(tooLongFrameLength); //是第一次遇到，直接丢失</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。</li>\n<li>反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。<br>2) 若当前缓存可读byte &lt; 长度偏移量, 直接退出继续, 数据仍然放在了缓存。<br>3) 计算出帧整体的长度,包括了length + head2 + content:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameLength += lengthAdjustment + lengthFieldEndOffset;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>4) 检查帧frameLength是否超过的阈值,若超过了:</p>\n<ul>\n<li>检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度</li>\n<li>否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。<br>并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。<br>5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。<br>6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。</li>\n</ul>\n"},{"title":"NioEventLoop篇","date":"2018-01-22T00:53:40.000Z","_content":"# 介绍\n在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:\n```\n            ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {...}\n            });\n```\n调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:\n```\n public void execute(Runnable task) {\n        boolean inEventLoop = inEventLoop();\n        if (inEventLoop) {\n            addTask(task);\n        } else {\n            startThread();\n            addTask(task);\n            if (isShutdown() && removeTask(task)) {\n                reject();\n            }\n        }\n        if (!addTaskWakesUp && wakesUpForTask(task)) {\n            wakeup(inEventLoop);\n        }\n    }\n```\n首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。\n## startThread\nstartThread用来启动NioEventLoop里面的执行线程,代码如下:\n```\n  executor.execute(new Runnable() { //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动\n            @Override\n            public void run() {\n                thread = Thread.currentThread(); //获取当前这个线程\n                if (interrupted) {\n                    thread.interrupt();\n                }\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环\n                    success = true;\n                } catch (Throwable t) {\n                }\n```\nexecutor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。\n\n\n# NioEventLoop\ntask分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。\n+ 非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头`ch.eventLoop().execute`)\n+ IO型: Accetp、Write、read等从远程节点发送过来的请求。\n\n为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:\n+ 若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。\n+ 若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。\n\nNioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:\n\n```\n  @Override\n    protected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n                        // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                        // before calling 'selector.wakeup()' to reduce the wake-up\n                        // overhead. (Selector.wakeup() is an expensive operation.)\n                        //\n                        // However, there is a race condition in this approach.\n                        // The race condition is triggered when 'wakenUp' is set to\n                        // true too early.\n                        //\n                        // 'wakenUp' is set to true too early if:\n                        // 1) Selector is waken up between 'wakenUp.set(false)' and\n                        //    'selector.select(...)'. (BAD)\n                        // 2) Selector is waken up between 'selector.select(...)' and\n                        //    'if (wakenUp.get()) { ... }'. (OK)\n                        //\n                        // In the first case, 'wakenUp' is set to true and the\n                        // following 'selector.select(...)' will wake up immediately.\n                        // Until 'wakenUp' is set to false again in the next round,\n                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                        // any attempt to wake up the Selector will fail, too, causing\n                        // the following 'selector.select(...)' call to block\n                        // unnecessarily.\n                        //\n                        // To fix this problem, we wake up the selector again if wakenUp\n                        // is true immediately after selector.select(...).\n                        // It is inefficient in that it wakes up the selector for both\n                        // the first case (BAD - wake-up required) and the second case\n                        // (OK - no wake-up required).\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                        // fallthrough\n                }\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\nselector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()\nNioEventLoop.run()部分的逻辑还是比较清楚:\n(1) 检查是否累计有task:\n```\n@Override\n    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {\n        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要\n    }\n```\n进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:\n```\nint selectNow() throws IOException {//相当于复写了NIO的select函数\n        try {\n            return selector.selectNow(); //返回的0, 直接跳出switch循环\n        } finally {\n            // restore wakeup state if needed\n            if (wakenUp.get()) {\n                selector.wakeup();\n            }\n        }\n    }\n```\n若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。\n(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。\nwakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:\n```\nprivate void select(boolean oldWakenUp) throws IOException {\n        Selector selector = this.selector;\n        try {\n            int selectCnt = 0;\n            long currentTimeNanos = System.nanoTime();\n            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间\n            for (;;) {  //timeoutMillis下次等待需要的时间\n                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns\n                if (timeoutMillis <= 0) {//距离第一个执行计划开始时间已经过了（1ms）\n                    if (selectCnt == 0) { //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()\n                        selector.selectNow();\n                        selectCnt = 1;\n                    }\n                    break;\n                }\n                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call\n                // Selector#wakeup. So we need to check task queue again before executing select operation.\n                // If we don't, the task might be pended until select operation was timed out.\n                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.\n                if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                int selectedKeys = selector.select(timeoutMillis);\n                selectCnt ++;\n                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环\n                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                    // - Selected something,\n                    // - waken up by user, or\n                    // - the task queue has a pending task.\n                    // - a scheduled task is ready for processing\n                    break;\n                }\n                long time = System.nanoTime();//selector.select(timeoutMillis);\n                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                    // timeoutMillis elapsed without anything selected.\n                    selectCnt = 1;\n                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                        selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。\n                    // The selector returned prematurely many times in a row.\n                    // Rebuild the selector to work around the problem.\n                    rebuildSelector();\n                    selector = this.selector;\n                    // Select again to populate selectedKeys.\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                currentTimeNanos = time;\n            }\n\n        } catch (CancelledKeyException e) {\n        }\n    }\n\n```\n可以看出代码做了如下事情:\n2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时\n如果当前时间 > 截止时间 + 0.5ms的话,就立刻退出执行task。\n2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。\n+ 此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。\n+ 若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。\n别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:\n ```\nprotected void wakeup(boolean inEventLoop) { //inEventLoop说的是NioEventLoop还没有启动\n        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n            selector.wakeup();\n        }\n    }\n ```\n 当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。\n2.3 执行selector.select(timeoutMillis)\n+ 若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。\n+ 若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。\n+ 若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。\n\n2.4 检查是否需要跳出循环:\n+ 有IO task了\n+ 上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。\n+ 此轮有task处于penging.\n+ 有schedule task截止时间已经到了。\nselect(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。\n这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:\n```\nivate void rebuildSelector0() {\n        newSelectorTuple = openSelector();//打开一个新的Selector\n        // Register all channels to the new Selector.\n        int nChannels = 0;\n        for (SelectionKey key: oldSelector.keys()) {////SelectionKey无效或者已经注册上了则跳过\n            Object a = key.attachment();\n            try {\n                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {\n                    continue;\n                }\n                int interestOps = key.interestOps();\n                key.cancel();//取消SelectionKey\n                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);\n            }\n        }\n        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector\n        unwrappedSelector = newSelectorTuple.unwrappedSelector;\n```\n主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。\n如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过`SELECTOR_AUTO_REBUILD_THRESHOLD`则说明触发了, 默认为512次。\n\nselect(wakenUp.getAndSet(false))完成后,会有这段代码\n```\nif (wakenUp.get()) {\n        selector.wakeup(); //下次\n }\n```\n参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。\n假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:\n```\nif (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n```\n那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -> 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)\n```\n     if (hasTasks() && wakenUp.compareAndSet(false, true)) {//若果当前有task，并且是可以叫醒的，则中断selector.select\n                    selector.selectNow();//selectNow()返回，否则会耽误任务执行\n                    selectCnt = 1;   //\n                    break;\n                }\n```\n\n只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。\n所以说, 那部分代码是没有没有意义的。\n\n(3) 开始执行IO task和非IO task\n前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。\n## IO任务执行processSelectedKeysPlain\nprocessSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:\n```\n        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n        eventLoop = ch.eventLoop();\n        try {\n            int readyOps = k.readyOps();\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n                unsafe.finishConnect();\n            }\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) { //如果是写\n                ch.unsafe().forceFlush();\n            }\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read(); //这里很重要，NioMessageUnsafe\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n```\n这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)\n ###  SelectionKey.OP_ACCEPT部分\n 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面\n```\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config(); //NioServerSocketChannelConf\n            final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline\n            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n            allocHandle.reset(config);\n\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    do { //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法\n                        int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        allocHandle.incMessagesRead(localRead);\n                    } while (allocHandle.continueReading()); //当前连接是否该继续\n                } catch (Throwable t) {\n                    exception = t;\n                }\n\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n                    readPending = false;//// 对每个连接调用pipeline的fireChannelRead\n                    pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面\n                }\n                readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf\n                allocHandle.readComplete();\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    inputShutdown = true;\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                // Check if there is a readPending which was not processed yet.\n                // This could be for two reasons:\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n                //\n                // See https://github.com/netty/netty/issues/2254\n                if (!readPending && !config.isAutoRead()) {\n                    removeReadOp();\n                }\n            }\n```\n1. 循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:\n```\n         SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，\n        try {\n            if (ch != null) {\n                buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel\n                return 1;\n            }\n        } catch (Throwable t) {\n        }\n\n        return 0;\n```\n同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个\nSocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。\nNioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:\n```\n         this.parent = parent; //NioServerSocketChannel\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。\n```\n\n2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。\n初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:\n ```\npublic final ChannelPipeline fireChannelRead(Object msg) { //msg是新建立的SocketChannel\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了\n        return this;\n    }\n```\n读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以`static`注释的。\n```\n static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { ////msg是新建立的NioSocketChannel\n        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next); //pipe是同一个，\n        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为\n        if (executor.inEventLoop()) { //本线程是否是EventLoop线程\n            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类\n        } else {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    next.invokeChannelRead(m);\n                }\n            });\n        }\n    }\n````\n2.1 会以根据HeadContext开始讲起:\n+ 首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。\n```\n public EventExecutor executor() {  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop\n        if (executor == null) {\n            return channel().eventLoop();\n        } else {\n            return executor;\n        }\n    }\n\n```\n+ 确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的`static void invokeChannelRead`\nstatic void invokeChannelRead\n```\n private AbstractChannelHandlerContext findContextInbound() { //从Head当前位置找，直到向后找到一个inbound的，就退出\n        AbstractChannelHandlerContext ctx = this;\n        do {\n            ctx = ctx.next;//直接找下一个\n        } while (!ctx.inbound);\n        return ctx;\n    }\n```\n到第二个Context, 其中会执行`((ChannelInboundHandler) handler()).channelRead(this, msg)`, 即ServerBootstrapAcceptor.channelRead(), 如下所示:\n```\n public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            final Channel child = (Channel) msg; //// child = NioSocketChannel\n            child.pipeline().addLast(childHandler);\n            setChannelOptions(child, childOptions, logger);\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n            try {  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接\n                childGroup.register(child).addListener(new ChannelFutureListener() {   ///这里使用的是childGroup\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) { //如果有连接完成，但是失败的情况下\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n            }\n```\n主要做的事:\n+ 其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.\n+ 从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。\n+ 当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。\n\n其中第二步骤, 注册的代码在`ServerBootStrap初始篇`中已经展示, 为了讲解方便在此再次罗列:\n```\n                 boolean firstRegistration = neverRegistered;\n                doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中\n                neverRegistered = false;\n                registered = true;// register状态设置为true，\n\n                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n                // user may already fire events through the pipeline in the ChannelFutureListener.\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0->accept\n                pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n```\n其中需要注意的是:\n+ invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:\nHeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n+ 会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:\n```\n public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireChannelActive();\n\n            readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性\n        }\n```\nctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin\n```\n@Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。\n### SelectionKey.OP_READ\n 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在`Netty通信编解码源码解读`讲解。\n\n## 执行非IO Task.\n进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:\n```\nprotected boolean runAllTasks(long timeoutNanos) {//处理非I/O任务。\n        fetchFromScheduledTaskQueue();\n        Runnable task = pollTask();//从\n        if (task == null) {\n            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()\n            return false;\n        }\n        //截止时间=ScheduledFutureTask当前相对时间+ 超时\n        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;\n        long runTasks = 0;\n        long lastExecutionTime;\n        for (;;) {\n            safeExecute(task);  //顺序执行所有task\n\n            runTasks ++;\n\n            // Check timeout every 64 tasks because nanoTime() is relatively expensive.\n            // XXX: Hard-coded value - will make it configurable if it is really a problem.\n            if ((runTasks & 0x3F) == 0) {  //当64个task后\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                if (lastExecutionTime >= deadline) {//当前时间超过截止时间，那么就退出\n                    break;\n                }\n            }\n\n            task = pollTask();\n            if (task == null) {\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                break;\n            }\n        }\n\n        afterRunningAllTasks();\n        this.lastExecutionTime = lastExecutionTime;\n        return true;\n    }\n```\n主要做了如下几件事:\n+ 从schedule队列取出任务向taskQueue中存放, 是一个有size<=16的、根据截至时间有优先级的阻塞队列。\n+ 从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.\n\nNioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。","source":"_posts/NioEventLoop篇.md","raw":"---\ntitle: NioEventLoop篇\ndate: 2018-01-22 08:53:40\ntags:\n---\n# 介绍\n在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:\n```\n            ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {...}\n            });\n```\n调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:\n```\n public void execute(Runnable task) {\n        boolean inEventLoop = inEventLoop();\n        if (inEventLoop) {\n            addTask(task);\n        } else {\n            startThread();\n            addTask(task);\n            if (isShutdown() && removeTask(task)) {\n                reject();\n            }\n        }\n        if (!addTaskWakesUp && wakesUpForTask(task)) {\n            wakeup(inEventLoop);\n        }\n    }\n```\n首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。\n## startThread\nstartThread用来启动NioEventLoop里面的执行线程,代码如下:\n```\n  executor.execute(new Runnable() { //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动\n            @Override\n            public void run() {\n                thread = Thread.currentThread(); //获取当前这个线程\n                if (interrupted) {\n                    thread.interrupt();\n                }\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环\n                    success = true;\n                } catch (Throwable t) {\n                }\n```\nexecutor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。\n\n\n# NioEventLoop\ntask分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。\n+ 非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头`ch.eventLoop().execute`)\n+ IO型: Accetp、Write、read等从远程节点发送过来的请求。\n\n为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:\n+ 若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。\n+ 若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。\n\nNioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:\n\n```\n  @Override\n    protected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n                        // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                        // before calling 'selector.wakeup()' to reduce the wake-up\n                        // overhead. (Selector.wakeup() is an expensive operation.)\n                        //\n                        // However, there is a race condition in this approach.\n                        // The race condition is triggered when 'wakenUp' is set to\n                        // true too early.\n                        //\n                        // 'wakenUp' is set to true too early if:\n                        // 1) Selector is waken up between 'wakenUp.set(false)' and\n                        //    'selector.select(...)'. (BAD)\n                        // 2) Selector is waken up between 'selector.select(...)' and\n                        //    'if (wakenUp.get()) { ... }'. (OK)\n                        //\n                        // In the first case, 'wakenUp' is set to true and the\n                        // following 'selector.select(...)' will wake up immediately.\n                        // Until 'wakenUp' is set to false again in the next round,\n                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                        // any attempt to wake up the Selector will fail, too, causing\n                        // the following 'selector.select(...)' call to block\n                        // unnecessarily.\n                        //\n                        // To fix this problem, we wake up the selector again if wakenUp\n                        // is true immediately after selector.select(...).\n                        // It is inefficient in that it wakes up the selector for both\n                        // the first case (BAD - wake-up required) and the second case\n                        // (OK - no wake-up required).\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                        // fallthrough\n                }\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\nselector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()\nNioEventLoop.run()部分的逻辑还是比较清楚:\n(1) 检查是否累计有task:\n```\n@Override\n    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {\n        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要\n    }\n```\n进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:\n```\nint selectNow() throws IOException {//相当于复写了NIO的select函数\n        try {\n            return selector.selectNow(); //返回的0, 直接跳出switch循环\n        } finally {\n            // restore wakeup state if needed\n            if (wakenUp.get()) {\n                selector.wakeup();\n            }\n        }\n    }\n```\n若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。\n(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。\nwakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:\n```\nprivate void select(boolean oldWakenUp) throws IOException {\n        Selector selector = this.selector;\n        try {\n            int selectCnt = 0;\n            long currentTimeNanos = System.nanoTime();\n            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间\n            for (;;) {  //timeoutMillis下次等待需要的时间\n                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns\n                if (timeoutMillis <= 0) {//距离第一个执行计划开始时间已经过了（1ms）\n                    if (selectCnt == 0) { //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()\n                        selector.selectNow();\n                        selectCnt = 1;\n                    }\n                    break;\n                }\n                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call\n                // Selector#wakeup. So we need to check task queue again before executing select operation.\n                // If we don't, the task might be pended until select operation was timed out.\n                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.\n                if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                int selectedKeys = selector.select(timeoutMillis);\n                selectCnt ++;\n                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环\n                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                    // - Selected something,\n                    // - waken up by user, or\n                    // - the task queue has a pending task.\n                    // - a scheduled task is ready for processing\n                    break;\n                }\n                long time = System.nanoTime();//selector.select(timeoutMillis);\n                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                    // timeoutMillis elapsed without anything selected.\n                    selectCnt = 1;\n                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                        selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。\n                    // The selector returned prematurely many times in a row.\n                    // Rebuild the selector to work around the problem.\n                    rebuildSelector();\n                    selector = this.selector;\n                    // Select again to populate selectedKeys.\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                currentTimeNanos = time;\n            }\n\n        } catch (CancelledKeyException e) {\n        }\n    }\n\n```\n可以看出代码做了如下事情:\n2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时\n如果当前时间 > 截止时间 + 0.5ms的话,就立刻退出执行task。\n2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。\n+ 此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。\n+ 若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。\n别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:\n ```\nprotected void wakeup(boolean inEventLoop) { //inEventLoop说的是NioEventLoop还没有启动\n        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n            selector.wakeup();\n        }\n    }\n ```\n 当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。\n2.3 执行selector.select(timeoutMillis)\n+ 若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。\n+ 若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。\n+ 若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。\n\n2.4 检查是否需要跳出循环:\n+ 有IO task了\n+ 上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。\n+ 此轮有task处于penging.\n+ 有schedule task截止时间已经到了。\nselect(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。\n这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:\n```\nivate void rebuildSelector0() {\n        newSelectorTuple = openSelector();//打开一个新的Selector\n        // Register all channels to the new Selector.\n        int nChannels = 0;\n        for (SelectionKey key: oldSelector.keys()) {////SelectionKey无效或者已经注册上了则跳过\n            Object a = key.attachment();\n            try {\n                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {\n                    continue;\n                }\n                int interestOps = key.interestOps();\n                key.cancel();//取消SelectionKey\n                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);\n            }\n        }\n        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector\n        unwrappedSelector = newSelectorTuple.unwrappedSelector;\n```\n主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。\n如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过`SELECTOR_AUTO_REBUILD_THRESHOLD`则说明触发了, 默认为512次。\n\nselect(wakenUp.getAndSet(false))完成后,会有这段代码\n```\nif (wakenUp.get()) {\n        selector.wakeup(); //下次\n }\n```\n参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。\n假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:\n```\nif (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n```\n那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -> 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)\n```\n     if (hasTasks() && wakenUp.compareAndSet(false, true)) {//若果当前有task，并且是可以叫醒的，则中断selector.select\n                    selector.selectNow();//selectNow()返回，否则会耽误任务执行\n                    selectCnt = 1;   //\n                    break;\n                }\n```\n\n只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。\n所以说, 那部分代码是没有没有意义的。\n\n(3) 开始执行IO task和非IO task\n前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。\n## IO任务执行processSelectedKeysPlain\nprocessSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:\n```\n        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n        eventLoop = ch.eventLoop();\n        try {\n            int readyOps = k.readyOps();\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n                unsafe.finishConnect();\n            }\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) { //如果是写\n                ch.unsafe().forceFlush();\n            }\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read(); //这里很重要，NioMessageUnsafe\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n```\n这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)\n ###  SelectionKey.OP_ACCEPT部分\n 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面\n```\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config(); //NioServerSocketChannelConf\n            final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline\n            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n            allocHandle.reset(config);\n\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    do { //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法\n                        int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        allocHandle.incMessagesRead(localRead);\n                    } while (allocHandle.continueReading()); //当前连接是否该继续\n                } catch (Throwable t) {\n                    exception = t;\n                }\n\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n                    readPending = false;//// 对每个连接调用pipeline的fireChannelRead\n                    pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面\n                }\n                readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf\n                allocHandle.readComplete();\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    inputShutdown = true;\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                // Check if there is a readPending which was not processed yet.\n                // This could be for two reasons:\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n                //\n                // See https://github.com/netty/netty/issues/2254\n                if (!readPending && !config.isAutoRead()) {\n                    removeReadOp();\n                }\n            }\n```\n1. 循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:\n```\n         SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，\n        try {\n            if (ch != null) {\n                buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel\n                return 1;\n            }\n        } catch (Throwable t) {\n        }\n\n        return 0;\n```\n同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个\nSocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。\nNioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:\n```\n         this.parent = parent; //NioServerSocketChannel\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。\n```\n\n2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。\n初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:\n ```\npublic final ChannelPipeline fireChannelRead(Object msg) { //msg是新建立的SocketChannel\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了\n        return this;\n    }\n```\n读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以`static`注释的。\n```\n static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { ////msg是新建立的NioSocketChannel\n        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next); //pipe是同一个，\n        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为\n        if (executor.inEventLoop()) { //本线程是否是EventLoop线程\n            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类\n        } else {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    next.invokeChannelRead(m);\n                }\n            });\n        }\n    }\n````\n2.1 会以根据HeadContext开始讲起:\n+ 首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。\n```\n public EventExecutor executor() {  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop\n        if (executor == null) {\n            return channel().eventLoop();\n        } else {\n            return executor;\n        }\n    }\n\n```\n+ 确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的`static void invokeChannelRead`\nstatic void invokeChannelRead\n```\n private AbstractChannelHandlerContext findContextInbound() { //从Head当前位置找，直到向后找到一个inbound的，就退出\n        AbstractChannelHandlerContext ctx = this;\n        do {\n            ctx = ctx.next;//直接找下一个\n        } while (!ctx.inbound);\n        return ctx;\n    }\n```\n到第二个Context, 其中会执行`((ChannelInboundHandler) handler()).channelRead(this, msg)`, 即ServerBootstrapAcceptor.channelRead(), 如下所示:\n```\n public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            final Channel child = (Channel) msg; //// child = NioSocketChannel\n            child.pipeline().addLast(childHandler);\n            setChannelOptions(child, childOptions, logger);\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n            try {  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接\n                childGroup.register(child).addListener(new ChannelFutureListener() {   ///这里使用的是childGroup\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) { //如果有连接完成，但是失败的情况下\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n            }\n```\n主要做的事:\n+ 其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.\n+ 从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。\n+ 当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。\n\n其中第二步骤, 注册的代码在`ServerBootStrap初始篇`中已经展示, 为了讲解方便在此再次罗列:\n```\n                 boolean firstRegistration = neverRegistered;\n                doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中\n                neverRegistered = false;\n                registered = true;// register状态设置为true，\n\n                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n                // user may already fire events through the pipeline in the ChannelFutureListener.\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0->accept\n                pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n```\n其中需要注意的是:\n+ invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:\nHeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n+ 会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:\n```\n public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireChannelActive();\n\n            readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性\n        }\n```\nctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin\n```\n@Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。\n### SelectionKey.OP_READ\n 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在`Netty通信编解码源码解读`讲解。\n\n## 执行非IO Task.\n进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:\n```\nprotected boolean runAllTasks(long timeoutNanos) {//处理非I/O任务。\n        fetchFromScheduledTaskQueue();\n        Runnable task = pollTask();//从\n        if (task == null) {\n            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()\n            return false;\n        }\n        //截止时间=ScheduledFutureTask当前相对时间+ 超时\n        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;\n        long runTasks = 0;\n        long lastExecutionTime;\n        for (;;) {\n            safeExecute(task);  //顺序执行所有task\n\n            runTasks ++;\n\n            // Check timeout every 64 tasks because nanoTime() is relatively expensive.\n            // XXX: Hard-coded value - will make it configurable if it is really a problem.\n            if ((runTasks & 0x3F) == 0) {  //当64个task后\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                if (lastExecutionTime >= deadline) {//当前时间超过截止时间，那么就退出\n                    break;\n                }\n            }\n\n            task = pollTask();\n            if (task == null) {\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                break;\n            }\n        }\n\n        afterRunningAllTasks();\n        this.lastExecutionTime = lastExecutionTime;\n        return true;\n    }\n```\n主要做了如下几件事:\n+ 从schedule队列取出任务向taskQueue中存放, 是一个有size<=16的、根据截至时间有优先级的阻塞队列。\n+ 从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.\n\nNioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。","slug":"NioEventLoop篇","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvr000fisu50zavqgif","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch.eventLoop().execute(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;...&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void execute(Runnable task) &#123;</div><div class=\"line\">       boolean inEventLoop = inEventLoop();</div><div class=\"line\">       if (inEventLoop) &#123;</div><div class=\"line\">           addTask(task);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           startThread();</div><div class=\"line\">           addTask(task);</div><div class=\"line\">           if (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">               reject();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">           wakeup(inEventLoop);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。</p>\n<h2 id=\"startThread\"><a href=\"#startThread\" class=\"headerlink\" title=\"startThread\"></a>startThread</h2><p>startThread用来启动NioEventLoop里面的执行线程,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">executor.execute(new Runnable() &#123; //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动</div><div class=\"line\">          @Override</div><div class=\"line\">          public void run() &#123;</div><div class=\"line\">              thread = Thread.currentThread(); //获取当前这个线程</div><div class=\"line\">              if (interrupted) &#123;</div><div class=\"line\">                  thread.interrupt();</div><div class=\"line\">              &#125;</div><div class=\"line\">              boolean success = false;</div><div class=\"line\">              updateLastExecutionTime();</div><div class=\"line\">              try &#123;</div><div class=\"line\">                  SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环</div><div class=\"line\">                  success = true;</div><div class=\"line\">              &#125; catch (Throwable t) &#123;</div><div class=\"line\">              &#125;</div></pre></td></tr></table></figure></p>\n<p>executor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。</p>\n<h1 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h1><p>task分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。</p>\n<ul>\n<li>非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头<code>ch.eventLoop().execute</code>)</li>\n<li>IO型: Accetp、Write、read等从远程节点发送过来的请求。</li>\n</ul>\n<p>为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:</p>\n<ul>\n<li>若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。</li>\n<li>若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。</li>\n</ul>\n<p>NioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  protected void run() &#123;</div><div class=\"line\">      for (;;) &#123;</div><div class=\"line\">          try &#123;</div><div class=\"line\">              switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) &#123;</div><div class=\"line\">                  case SelectStrategy.CONTINUE:</div><div class=\"line\">                      continue;</div><div class=\"line\">                  case SelectStrategy.SELECT:</div><div class=\"line\">                      select(wakenUp.getAndSet(false));</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</div><div class=\"line\">                      // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</div><div class=\"line\">                      // overhead. (Selector.wakeup() is an expensive operation.)</div><div class=\"line\">                      //</div><div class=\"line\">                      // However, there is a race condition in this approach.</div><div class=\"line\">                      // The race condition is triggered when &apos;wakenUp&apos; is set to</div><div class=\"line\">                      // true too early.</div><div class=\"line\">                      //</div><div class=\"line\">                      // &apos;wakenUp&apos; is set to true too early if:</div><div class=\"line\">                      // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</div><div class=\"line\">                      //    &apos;selector.select(...)&apos;. (BAD)</div><div class=\"line\">                      // 2) Selector is waken up between &apos;selector.select(...)&apos; and</div><div class=\"line\">                      //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</div><div class=\"line\">                      //</div><div class=\"line\">                      // In the first case, &apos;wakenUp&apos; is set to true and the</div><div class=\"line\">                      // following &apos;selector.select(...)&apos; will wake up immediately.</div><div class=\"line\">                      // Until &apos;wakenUp&apos; is set to false again in the next round,</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</div><div class=\"line\">                      // any attempt to wake up the Selector will fail, too, causing</div><div class=\"line\">                      // the following &apos;selector.select(...)&apos; call to block</div><div class=\"line\">                      // unnecessarily.</div><div class=\"line\">                      //</div><div class=\"line\">                      // To fix this problem, we wake up the selector again if wakenUp</div><div class=\"line\">                      // is true immediately after selector.select(...).</div><div class=\"line\">                      // It is inefficient in that it wakes up the selector for both</div><div class=\"line\">                      // the first case (BAD - wake-up required) and the second case</div><div class=\"line\">                      // (OK - no wake-up required).</div><div class=\"line\"></div><div class=\"line\">                      if (wakenUp.get()) &#123;</div><div class=\"line\">                          selector.wakeup();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                  default:</div><div class=\"line\">                      // fallthrough</div><div class=\"line\">              &#125;</div><div class=\"line\">              cancelledKeys = 0;</div><div class=\"line\">              needsToSelectAgain = false;</div><div class=\"line\">              final int ioRatio = this.ioRatio;</div><div class=\"line\">              if (ioRatio == 100) &#123;</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      runAllTasks();</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125; else &#123;</div><div class=\"line\">                  final long ioStartTime = System.nanoTime();</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      final long ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                      runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">          // Always handle shutdown even if the loop processing threw an exception.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              if (isShuttingDown()) &#123;</div><div class=\"line\">                  closeAll();</div><div class=\"line\">                  if (confirmShutdown()) &#123;</div><div class=\"line\">                      return;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>selector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()<br>NioEventLoop.run()部分的逻辑还是比较清楚:<br>(1) 检查是否累计有task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;</div><div class=\"line\">        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int selectNow() throws IOException &#123;//相当于复写了NIO的select函数</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return selector.selectNow(); //返回的0, 直接跳出switch循环</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // restore wakeup state if needed</div><div class=\"line\">            if (wakenUp.get()) &#123;</div><div class=\"line\">                selector.wakeup();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。<br>(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。<br>wakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</div><div class=\"line\">        Selector selector = this.selector;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            int selectCnt = 0;</div><div class=\"line\">            long currentTimeNanos = System.nanoTime();</div><div class=\"line\">            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间</div><div class=\"line\">            for (;;) &#123;  //timeoutMillis下次等待需要的时间</div><div class=\"line\">                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns</div><div class=\"line\">                if (timeoutMillis &lt;= 0) &#123;//距离第一个执行计划开始时间已经过了（1ms）</div><div class=\"line\">                    if (selectCnt == 0) &#123; //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()</div><div class=\"line\">                        selector.selectNow();</div><div class=\"line\">                        selectCnt = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</div><div class=\"line\">                // Selector#wakeup. So we need to check task queue again before executing select operation.</div><div class=\"line\">                // If we don&apos;t, the task might be pended until select operation was timed out.</div><div class=\"line\">                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</div><div class=\"line\">                if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int selectedKeys = selector.select(timeoutMillis);</div><div class=\"line\">                selectCnt ++;</div><div class=\"line\">                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环</div><div class=\"line\">                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class=\"line\">                    // - Selected something,</div><div class=\"line\">                    // - waken up by user, or</div><div class=\"line\">                    // - the task queue has a pending task.</div><div class=\"line\">                    // - a scheduled task is ready for processing</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                long time = System.nanoTime();//selector.select(timeoutMillis);</div><div class=\"line\">                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class=\"line\">                    // timeoutMillis elapsed without anything selected.</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class=\"line\">                        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。</div><div class=\"line\">                    // The selector returned prematurely many times in a row.</div><div class=\"line\">                    // Rebuild the selector to work around the problem.</div><div class=\"line\">                    rebuildSelector();</div><div class=\"line\">                    selector = this.selector;</div><div class=\"line\">                    // Select again to populate selectedKeys.</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentTimeNanos = time;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出代码做了如下事情:<br>2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时<br>如果当前时间 &gt; 截止时间 + 0.5ms的话,就立刻退出执行task。<br>2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。</p>\n<ul>\n<li>此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。</li>\n<li><p>若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。<br>别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void wakeup(boolean inEventLoop) &#123; //inEventLoop说的是NioEventLoop还没有启动</div><div class=\"line\">        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">            selector.wakeup();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。<br>2.3 执行selector.select(timeoutMillis)</p>\n</li>\n<li>若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。</li>\n<li>若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。</li>\n<li>若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。</li>\n</ul>\n<p>2.4 检查是否需要跳出循环:</p>\n<ul>\n<li>有IO task了</li>\n<li>上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。</li>\n<li>此轮有task处于penging.</li>\n<li>有schedule task截止时间已经到了。<br>select(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。<br>这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ivate void rebuildSelector0() &#123;</div><div class=\"line\">        newSelectorTuple = openSelector();//打开一个新的Selector</div><div class=\"line\">        // Register all channels to the new Selector.</div><div class=\"line\">        int nChannels = 0;</div><div class=\"line\">        for (SelectionKey key: oldSelector.keys()) &#123;////SelectionKey无效或者已经注册上了则跳过</div><div class=\"line\">            Object a = key.attachment();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int interestOps = key.interestOps();</div><div class=\"line\">                key.cancel();//取消SelectionKey</div><div class=\"line\">                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector</div><div class=\"line\">        unwrappedSelector = newSelectorTuple.unwrappedSelector;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。<br>如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>则说明触发了, 默认为512次。</p>\n<p>select(wakenUp.getAndSet(false))完成后,会有这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (wakenUp.get()) &#123;</div><div class=\"line\">        selector.wakeup(); //下次</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。<br>假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div></pre></td></tr></table></figure></p>\n<p>那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -&gt; 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;//若果当前有task，并且是可以叫醒的，则中断selector.select</div><div class=\"line\">               selector.selectNow();//selectNow()返回，否则会耽误任务执行</div><div class=\"line\">               selectCnt = 1;   //</div><div class=\"line\">               break;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。<br>所以说, 那部分代码是没有没有意义的。</p>\n<p>(3) 开始执行IO task和非IO task<br>前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。</p>\n<h2 id=\"IO任务执行processSelectedKeysPlain\"><a href=\"#IO任务执行processSelectedKeysPlain\" class=\"headerlink\" title=\"IO任务执行processSelectedKeysPlain\"></a>IO任务执行processSelectedKeysPlain</h2><p>processSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class=\"line\">eventLoop = ch.eventLoop();</div><div class=\"line\">try &#123;</div><div class=\"line\">    int readyOps = k.readyOps();</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class=\"line\">        int ops = k.interestOps();</div><div class=\"line\">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class=\"line\">        k.interestOps(ops);</div><div class=\"line\">        unsafe.finishConnect();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; //如果是写</div><div class=\"line\">        ch.unsafe().forceFlush();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class=\"line\">        unsafe.read(); //这里很重要，NioMessageUnsafe</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (CancelledKeyException ignored) &#123;</div><div class=\"line\">    unsafe.close(unsafe.voidPromise());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)</p>\n<h3 id=\"SelectionKey-OP-ACCEPT部分\"><a href=\"#SelectionKey-OP-ACCEPT部分\" class=\"headerlink\" title=\"SelectionKey.OP_ACCEPT部分\"></a>SelectionKey.OP_ACCEPT部分</h3><p> 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert eventLoop().inEventLoop();</div><div class=\"line\">final ChannelConfig config = config(); //NioServerSocketChannelConf</div><div class=\"line\">final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline</div><div class=\"line\">final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class=\"line\">allocHandle.reset(config);</div><div class=\"line\"></div><div class=\"line\">boolean closed = false;</div><div class=\"line\">Throwable exception = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        do &#123; //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法</div><div class=\"line\">            int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接</div><div class=\"line\">            if (localRead == 0) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localRead &lt; 0) &#123;</div><div class=\"line\">                closed = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            allocHandle.incMessagesRead(localRead);</div><div class=\"line\">        &#125; while (allocHandle.continueReading()); //当前连接是否该继续</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">        exception = t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int size = readBuf.size();</div><div class=\"line\">    for (int i = 0; i &lt; size; i ++) &#123;</div><div class=\"line\">        readPending = false;//// 对每个连接调用pipeline的fireChannelRead</div><div class=\"line\">        pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面</div><div class=\"line\">    &#125;</div><div class=\"line\">    readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf</div><div class=\"line\">    allocHandle.readComplete();</div><div class=\"line\">    pipeline.fireChannelReadComplete();</div><div class=\"line\"></div><div class=\"line\">    if (exception != null) &#123;</div><div class=\"line\">        closed = closeOnReadError(exception);</div><div class=\"line\"></div><div class=\"line\">        pipeline.fireExceptionCaught(exception);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (closed) &#123;</div><div class=\"line\">        inputShutdown = true;</div><div class=\"line\">        if (isOpen()) &#123;</div><div class=\"line\">            close(voidPromise());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    // Check if there is a readPending which was not processed yet.</div><div class=\"line\">    // This could be for two reasons:</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</div><div class=\"line\">    //</div><div class=\"line\">    // See https://github.com/netty/netty/issues/2254</div><div class=\"line\">    if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</div><div class=\"line\">        removeReadOp();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，</div><div class=\"line\">try &#123;</div><div class=\"line\">    if (ch != null) &#123;</div><div class=\"line\">        buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return 0;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个<br>SocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。<br>NioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> this.parent = parent; //NioServerSocketChannel</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。</div></pre></td></tr></table></figure></p>\n<p>2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。<br>初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ChannelPipeline fireChannelRead(Object msg) &#123; //msg是新建立的SocketChannel</div><div class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以<code>static</code>注释的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; ////msg是新建立的NioSocketChannel</div><div class=\"line\">        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next); //pipe是同一个，</div><div class=\"line\">        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为</div><div class=\"line\">        if (executor.inEventLoop()) &#123; //本线程是否是EventLoop线程</div><div class=\"line\">            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            executor.execute(new Runnable() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void run() &#123;</div><div class=\"line\">                    next.invokeChannelRead(m);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>2.1 会以根据HeadContext开始讲起:</p>\n<ul>\n<li><p>首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor executor() &#123;  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop</div><div class=\"line\">       if (executor == null) &#123;</div><div class=\"line\">           return channel().eventLoop();</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return executor;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的<code>static void invokeChannelRead</code><br>static void invokeChannelRead</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AbstractChannelHandlerContext findContextInbound() &#123; //从Head当前位置找，直到向后找到一个inbound的，就退出</div><div class=\"line\">       AbstractChannelHandlerContext ctx = this;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           ctx = ctx.next;//直接找下一个</div><div class=\"line\">       &#125; while (!ctx.inbound);</div><div class=\"line\">       return ctx;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到第二个Context, 其中会执行<code>((ChannelInboundHandler) handler()).channelRead(this, msg)</code>, 即ServerBootstrapAcceptor.channelRead(), 如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</div><div class=\"line\">           final Channel child = (Channel) msg; //// child = NioSocketChannel</div><div class=\"line\">           child.pipeline().addLast(childHandler);</div><div class=\"line\">           setChannelOptions(child, childOptions, logger);</div><div class=\"line\">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</div><div class=\"line\">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class=\"line\">           &#125;</div><div class=\"line\">           try &#123;  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接</div><div class=\"line\">               childGroup.register(child).addListener(new ChannelFutureListener() &#123;   ///这里使用的是childGroup</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                       if (!future.isSuccess()) &#123; //如果有连接完成，但是失败的情况下</div><div class=\"line\">                           forceClose(child, future.cause());</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.</li>\n<li>从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。</li>\n<li>当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。</li>\n</ul>\n<p>其中第二步骤, 注册的代码在<code>ServerBootStrap初始篇</code>中已经展示, 为了讲解方便在此再次罗列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean firstRegistration = neverRegistered;</div><div class=\"line\">doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中</div><div class=\"line\">neverRegistered = false;</div><div class=\"line\">registered = true;// register状态设置为true，</div><div class=\"line\"></div><div class=\"line\">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</div><div class=\"line\">// user may already fire events through the pipeline in the ChannelFutureListener.</div><div class=\"line\">pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0-&gt;accept</div><div class=\"line\">pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，</div><div class=\"line\">// Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">// multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">if (isActive()) &#123;  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用</div><div class=\"line\">    if (firstRegistration) &#123;</div><div class=\"line\">        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()</div><div class=\"line\">    &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">        // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">        // again so that we process inbound data.</div><div class=\"line\">        //</div><div class=\"line\">        // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">        beginRead();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中需要注意的是:</p>\n<ul>\n<li>invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:<br>HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.</li>\n<li>会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">           ctx.fireChannelActive();</div><div class=\"line\"></div><div class=\"line\">           readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">        // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">        final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">        if (!selectionKey.isValid()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        readPending = true;</div><div class=\"line\"></div><div class=\"line\">        final int interestOps = selectionKey.interestOps();</div><div class=\"line\">        if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">            selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。</p>\n<h3 id=\"SelectionKey-OP-READ\"><a href=\"#SelectionKey-OP-READ\" class=\"headerlink\" title=\"SelectionKey.OP_READ\"></a>SelectionKey.OP_READ</h3><p> 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在<code>Netty通信编解码源码解读</code>讲解。</p>\n<h2 id=\"执行非IO-Task\"><a href=\"#执行非IO-Task\" class=\"headerlink\" title=\"执行非IO Task.\"></a>执行非IO Task.</h2><p>进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;//处理非I/O任务。</div><div class=\"line\">        fetchFromScheduledTaskQueue();</div><div class=\"line\">        Runnable task = pollTask();//从</div><div class=\"line\">        if (task == null) &#123;</div><div class=\"line\">            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //截止时间=ScheduledFutureTask当前相对时间+ 超时</div><div class=\"line\">        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class=\"line\">        long runTasks = 0;</div><div class=\"line\">        long lastExecutionTime;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            safeExecute(task);  //顺序执行所有task</div><div class=\"line\"></div><div class=\"line\">            runTasks ++;</div><div class=\"line\"></div><div class=\"line\">            // Check timeout every 64 tasks because nanoTime() is relatively expensive.</div><div class=\"line\">            // XXX: Hard-coded value - will make it configurable if it is really a problem.</div><div class=\"line\">            if ((runTasks &amp; 0x3F) == 0) &#123;  //当64个task后</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                if (lastExecutionTime &gt;= deadline) &#123;//当前时间超过截止时间，那么就退出</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            task = pollTask();</div><div class=\"line\">            if (task == null) &#123;</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        afterRunningAllTasks();</div><div class=\"line\">        this.lastExecutionTime = lastExecutionTime;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几件事:</p>\n<ul>\n<li>从schedule队列取出任务向taskQueue中存放, 是一个有size&lt;=16的、根据截至时间有优先级的阻塞队列。</li>\n<li>从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.</li>\n</ul>\n<p>NioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch.eventLoop().execute(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;...&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void execute(Runnable task) &#123;</div><div class=\"line\">       boolean inEventLoop = inEventLoop();</div><div class=\"line\">       if (inEventLoop) &#123;</div><div class=\"line\">           addTask(task);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           startThread();</div><div class=\"line\">           addTask(task);</div><div class=\"line\">           if (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">               reject();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">           wakeup(inEventLoop);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。</p>\n<h2 id=\"startThread\"><a href=\"#startThread\" class=\"headerlink\" title=\"startThread\"></a>startThread</h2><p>startThread用来启动NioEventLoop里面的执行线程,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">executor.execute(new Runnable() &#123; //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动</div><div class=\"line\">          @Override</div><div class=\"line\">          public void run() &#123;</div><div class=\"line\">              thread = Thread.currentThread(); //获取当前这个线程</div><div class=\"line\">              if (interrupted) &#123;</div><div class=\"line\">                  thread.interrupt();</div><div class=\"line\">              &#125;</div><div class=\"line\">              boolean success = false;</div><div class=\"line\">              updateLastExecutionTime();</div><div class=\"line\">              try &#123;</div><div class=\"line\">                  SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环</div><div class=\"line\">                  success = true;</div><div class=\"line\">              &#125; catch (Throwable t) &#123;</div><div class=\"line\">              &#125;</div></pre></td></tr></table></figure></p>\n<p>executor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。</p>\n<h1 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h1><p>task分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。</p>\n<ul>\n<li>非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头<code>ch.eventLoop().execute</code>)</li>\n<li>IO型: Accetp、Write、read等从远程节点发送过来的请求。</li>\n</ul>\n<p>为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:</p>\n<ul>\n<li>若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。</li>\n<li>若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。</li>\n</ul>\n<p>NioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  protected void run() &#123;</div><div class=\"line\">      for (;;) &#123;</div><div class=\"line\">          try &#123;</div><div class=\"line\">              switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) &#123;</div><div class=\"line\">                  case SelectStrategy.CONTINUE:</div><div class=\"line\">                      continue;</div><div class=\"line\">                  case SelectStrategy.SELECT:</div><div class=\"line\">                      select(wakenUp.getAndSet(false));</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</div><div class=\"line\">                      // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</div><div class=\"line\">                      // overhead. (Selector.wakeup() is an expensive operation.)</div><div class=\"line\">                      //</div><div class=\"line\">                      // However, there is a race condition in this approach.</div><div class=\"line\">                      // The race condition is triggered when &apos;wakenUp&apos; is set to</div><div class=\"line\">                      // true too early.</div><div class=\"line\">                      //</div><div class=\"line\">                      // &apos;wakenUp&apos; is set to true too early if:</div><div class=\"line\">                      // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</div><div class=\"line\">                      //    &apos;selector.select(...)&apos;. (BAD)</div><div class=\"line\">                      // 2) Selector is waken up between &apos;selector.select(...)&apos; and</div><div class=\"line\">                      //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</div><div class=\"line\">                      //</div><div class=\"line\">                      // In the first case, &apos;wakenUp&apos; is set to true and the</div><div class=\"line\">                      // following &apos;selector.select(...)&apos; will wake up immediately.</div><div class=\"line\">                      // Until &apos;wakenUp&apos; is set to false again in the next round,</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</div><div class=\"line\">                      // any attempt to wake up the Selector will fail, too, causing</div><div class=\"line\">                      // the following &apos;selector.select(...)&apos; call to block</div><div class=\"line\">                      // unnecessarily.</div><div class=\"line\">                      //</div><div class=\"line\">                      // To fix this problem, we wake up the selector again if wakenUp</div><div class=\"line\">                      // is true immediately after selector.select(...).</div><div class=\"line\">                      // It is inefficient in that it wakes up the selector for both</div><div class=\"line\">                      // the first case (BAD - wake-up required) and the second case</div><div class=\"line\">                      // (OK - no wake-up required).</div><div class=\"line\"></div><div class=\"line\">                      if (wakenUp.get()) &#123;</div><div class=\"line\">                          selector.wakeup();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                  default:</div><div class=\"line\">                      // fallthrough</div><div class=\"line\">              &#125;</div><div class=\"line\">              cancelledKeys = 0;</div><div class=\"line\">              needsToSelectAgain = false;</div><div class=\"line\">              final int ioRatio = this.ioRatio;</div><div class=\"line\">              if (ioRatio == 100) &#123;</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      runAllTasks();</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125; else &#123;</div><div class=\"line\">                  final long ioStartTime = System.nanoTime();</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      final long ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                      runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">          // Always handle shutdown even if the loop processing threw an exception.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              if (isShuttingDown()) &#123;</div><div class=\"line\">                  closeAll();</div><div class=\"line\">                  if (confirmShutdown()) &#123;</div><div class=\"line\">                      return;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>selector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()<br>NioEventLoop.run()部分的逻辑还是比较清楚:<br>(1) 检查是否累计有task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;</div><div class=\"line\">        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int selectNow() throws IOException &#123;//相当于复写了NIO的select函数</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return selector.selectNow(); //返回的0, 直接跳出switch循环</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // restore wakeup state if needed</div><div class=\"line\">            if (wakenUp.get()) &#123;</div><div class=\"line\">                selector.wakeup();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。<br>(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。<br>wakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</div><div class=\"line\">        Selector selector = this.selector;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            int selectCnt = 0;</div><div class=\"line\">            long currentTimeNanos = System.nanoTime();</div><div class=\"line\">            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间</div><div class=\"line\">            for (;;) &#123;  //timeoutMillis下次等待需要的时间</div><div class=\"line\">                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns</div><div class=\"line\">                if (timeoutMillis &lt;= 0) &#123;//距离第一个执行计划开始时间已经过了（1ms）</div><div class=\"line\">                    if (selectCnt == 0) &#123; //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()</div><div class=\"line\">                        selector.selectNow();</div><div class=\"line\">                        selectCnt = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</div><div class=\"line\">                // Selector#wakeup. So we need to check task queue again before executing select operation.</div><div class=\"line\">                // If we don&apos;t, the task might be pended until select operation was timed out.</div><div class=\"line\">                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</div><div class=\"line\">                if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int selectedKeys = selector.select(timeoutMillis);</div><div class=\"line\">                selectCnt ++;</div><div class=\"line\">                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环</div><div class=\"line\">                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class=\"line\">                    // - Selected something,</div><div class=\"line\">                    // - waken up by user, or</div><div class=\"line\">                    // - the task queue has a pending task.</div><div class=\"line\">                    // - a scheduled task is ready for processing</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                long time = System.nanoTime();//selector.select(timeoutMillis);</div><div class=\"line\">                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class=\"line\">                    // timeoutMillis elapsed without anything selected.</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class=\"line\">                        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。</div><div class=\"line\">                    // The selector returned prematurely many times in a row.</div><div class=\"line\">                    // Rebuild the selector to work around the problem.</div><div class=\"line\">                    rebuildSelector();</div><div class=\"line\">                    selector = this.selector;</div><div class=\"line\">                    // Select again to populate selectedKeys.</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentTimeNanos = time;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出代码做了如下事情:<br>2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时<br>如果当前时间 &gt; 截止时间 + 0.5ms的话,就立刻退出执行task。<br>2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。</p>\n<ul>\n<li>此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。</li>\n<li><p>若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。<br>别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void wakeup(boolean inEventLoop) &#123; //inEventLoop说的是NioEventLoop还没有启动</div><div class=\"line\">        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">            selector.wakeup();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。<br>2.3 执行selector.select(timeoutMillis)</p>\n</li>\n<li>若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。</li>\n<li>若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。</li>\n<li>若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。</li>\n</ul>\n<p>2.4 检查是否需要跳出循环:</p>\n<ul>\n<li>有IO task了</li>\n<li>上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。</li>\n<li>此轮有task处于penging.</li>\n<li>有schedule task截止时间已经到了。<br>select(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。<br>这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ivate void rebuildSelector0() &#123;</div><div class=\"line\">        newSelectorTuple = openSelector();//打开一个新的Selector</div><div class=\"line\">        // Register all channels to the new Selector.</div><div class=\"line\">        int nChannels = 0;</div><div class=\"line\">        for (SelectionKey key: oldSelector.keys()) &#123;////SelectionKey无效或者已经注册上了则跳过</div><div class=\"line\">            Object a = key.attachment();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int interestOps = key.interestOps();</div><div class=\"line\">                key.cancel();//取消SelectionKey</div><div class=\"line\">                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector</div><div class=\"line\">        unwrappedSelector = newSelectorTuple.unwrappedSelector;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。<br>如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>则说明触发了, 默认为512次。</p>\n<p>select(wakenUp.getAndSet(false))完成后,会有这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (wakenUp.get()) &#123;</div><div class=\"line\">        selector.wakeup(); //下次</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。<br>假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div></pre></td></tr></table></figure></p>\n<p>那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -&gt; 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;//若果当前有task，并且是可以叫醒的，则中断selector.select</div><div class=\"line\">               selector.selectNow();//selectNow()返回，否则会耽误任务执行</div><div class=\"line\">               selectCnt = 1;   //</div><div class=\"line\">               break;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。<br>所以说, 那部分代码是没有没有意义的。</p>\n<p>(3) 开始执行IO task和非IO task<br>前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。</p>\n<h2 id=\"IO任务执行processSelectedKeysPlain\"><a href=\"#IO任务执行processSelectedKeysPlain\" class=\"headerlink\" title=\"IO任务执行processSelectedKeysPlain\"></a>IO任务执行processSelectedKeysPlain</h2><p>processSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class=\"line\">eventLoop = ch.eventLoop();</div><div class=\"line\">try &#123;</div><div class=\"line\">    int readyOps = k.readyOps();</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class=\"line\">        int ops = k.interestOps();</div><div class=\"line\">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class=\"line\">        k.interestOps(ops);</div><div class=\"line\">        unsafe.finishConnect();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; //如果是写</div><div class=\"line\">        ch.unsafe().forceFlush();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class=\"line\">        unsafe.read(); //这里很重要，NioMessageUnsafe</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (CancelledKeyException ignored) &#123;</div><div class=\"line\">    unsafe.close(unsafe.voidPromise());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)</p>\n<h3 id=\"SelectionKey-OP-ACCEPT部分\"><a href=\"#SelectionKey-OP-ACCEPT部分\" class=\"headerlink\" title=\"SelectionKey.OP_ACCEPT部分\"></a>SelectionKey.OP_ACCEPT部分</h3><p> 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert eventLoop().inEventLoop();</div><div class=\"line\">final ChannelConfig config = config(); //NioServerSocketChannelConf</div><div class=\"line\">final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline</div><div class=\"line\">final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class=\"line\">allocHandle.reset(config);</div><div class=\"line\"></div><div class=\"line\">boolean closed = false;</div><div class=\"line\">Throwable exception = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        do &#123; //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法</div><div class=\"line\">            int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接</div><div class=\"line\">            if (localRead == 0) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localRead &lt; 0) &#123;</div><div class=\"line\">                closed = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            allocHandle.incMessagesRead(localRead);</div><div class=\"line\">        &#125; while (allocHandle.continueReading()); //当前连接是否该继续</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">        exception = t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int size = readBuf.size();</div><div class=\"line\">    for (int i = 0; i &lt; size; i ++) &#123;</div><div class=\"line\">        readPending = false;//// 对每个连接调用pipeline的fireChannelRead</div><div class=\"line\">        pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面</div><div class=\"line\">    &#125;</div><div class=\"line\">    readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf</div><div class=\"line\">    allocHandle.readComplete();</div><div class=\"line\">    pipeline.fireChannelReadComplete();</div><div class=\"line\"></div><div class=\"line\">    if (exception != null) &#123;</div><div class=\"line\">        closed = closeOnReadError(exception);</div><div class=\"line\"></div><div class=\"line\">        pipeline.fireExceptionCaught(exception);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (closed) &#123;</div><div class=\"line\">        inputShutdown = true;</div><div class=\"line\">        if (isOpen()) &#123;</div><div class=\"line\">            close(voidPromise());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    // Check if there is a readPending which was not processed yet.</div><div class=\"line\">    // This could be for two reasons:</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</div><div class=\"line\">    //</div><div class=\"line\">    // See https://github.com/netty/netty/issues/2254</div><div class=\"line\">    if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</div><div class=\"line\">        removeReadOp();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，</div><div class=\"line\">try &#123;</div><div class=\"line\">    if (ch != null) &#123;</div><div class=\"line\">        buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return 0;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个<br>SocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。<br>NioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> this.parent = parent; //NioServerSocketChannel</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。</div></pre></td></tr></table></figure></p>\n<p>2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。<br>初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ChannelPipeline fireChannelRead(Object msg) &#123; //msg是新建立的SocketChannel</div><div class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以<code>static</code>注释的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; ////msg是新建立的NioSocketChannel</div><div class=\"line\">        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next); //pipe是同一个，</div><div class=\"line\">        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为</div><div class=\"line\">        if (executor.inEventLoop()) &#123; //本线程是否是EventLoop线程</div><div class=\"line\">            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            executor.execute(new Runnable() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void run() &#123;</div><div class=\"line\">                    next.invokeChannelRead(m);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>2.1 会以根据HeadContext开始讲起:</p>\n<ul>\n<li><p>首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor executor() &#123;  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop</div><div class=\"line\">       if (executor == null) &#123;</div><div class=\"line\">           return channel().eventLoop();</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return executor;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的<code>static void invokeChannelRead</code><br>static void invokeChannelRead</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AbstractChannelHandlerContext findContextInbound() &#123; //从Head当前位置找，直到向后找到一个inbound的，就退出</div><div class=\"line\">       AbstractChannelHandlerContext ctx = this;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           ctx = ctx.next;//直接找下一个</div><div class=\"line\">       &#125; while (!ctx.inbound);</div><div class=\"line\">       return ctx;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到第二个Context, 其中会执行<code>((ChannelInboundHandler) handler()).channelRead(this, msg)</code>, 即ServerBootstrapAcceptor.channelRead(), 如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</div><div class=\"line\">           final Channel child = (Channel) msg; //// child = NioSocketChannel</div><div class=\"line\">           child.pipeline().addLast(childHandler);</div><div class=\"line\">           setChannelOptions(child, childOptions, logger);</div><div class=\"line\">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</div><div class=\"line\">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class=\"line\">           &#125;</div><div class=\"line\">           try &#123;  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接</div><div class=\"line\">               childGroup.register(child).addListener(new ChannelFutureListener() &#123;   ///这里使用的是childGroup</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                       if (!future.isSuccess()) &#123; //如果有连接完成，但是失败的情况下</div><div class=\"line\">                           forceClose(child, future.cause());</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.</li>\n<li>从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。</li>\n<li>当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。</li>\n</ul>\n<p>其中第二步骤, 注册的代码在<code>ServerBootStrap初始篇</code>中已经展示, 为了讲解方便在此再次罗列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean firstRegistration = neverRegistered;</div><div class=\"line\">doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中</div><div class=\"line\">neverRegistered = false;</div><div class=\"line\">registered = true;// register状态设置为true，</div><div class=\"line\"></div><div class=\"line\">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</div><div class=\"line\">// user may already fire events through the pipeline in the ChannelFutureListener.</div><div class=\"line\">pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0-&gt;accept</div><div class=\"line\">pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，</div><div class=\"line\">// Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">// multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">if (isActive()) &#123;  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用</div><div class=\"line\">    if (firstRegistration) &#123;</div><div class=\"line\">        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()</div><div class=\"line\">    &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">        // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">        // again so that we process inbound data.</div><div class=\"line\">        //</div><div class=\"line\">        // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">        beginRead();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中需要注意的是:</p>\n<ul>\n<li>invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:<br>HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.</li>\n<li>会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">           ctx.fireChannelActive();</div><div class=\"line\"></div><div class=\"line\">           readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">        // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">        final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">        if (!selectionKey.isValid()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        readPending = true;</div><div class=\"line\"></div><div class=\"line\">        final int interestOps = selectionKey.interestOps();</div><div class=\"line\">        if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">            selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。</p>\n<h3 id=\"SelectionKey-OP-READ\"><a href=\"#SelectionKey-OP-READ\" class=\"headerlink\" title=\"SelectionKey.OP_READ\"></a>SelectionKey.OP_READ</h3><p> 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在<code>Netty通信编解码源码解读</code>讲解。</p>\n<h2 id=\"执行非IO-Task\"><a href=\"#执行非IO-Task\" class=\"headerlink\" title=\"执行非IO Task.\"></a>执行非IO Task.</h2><p>进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;//处理非I/O任务。</div><div class=\"line\">        fetchFromScheduledTaskQueue();</div><div class=\"line\">        Runnable task = pollTask();//从</div><div class=\"line\">        if (task == null) &#123;</div><div class=\"line\">            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //截止时间=ScheduledFutureTask当前相对时间+ 超时</div><div class=\"line\">        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class=\"line\">        long runTasks = 0;</div><div class=\"line\">        long lastExecutionTime;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            safeExecute(task);  //顺序执行所有task</div><div class=\"line\"></div><div class=\"line\">            runTasks ++;</div><div class=\"line\"></div><div class=\"line\">            // Check timeout every 64 tasks because nanoTime() is relatively expensive.</div><div class=\"line\">            // XXX: Hard-coded value - will make it configurable if it is really a problem.</div><div class=\"line\">            if ((runTasks &amp; 0x3F) == 0) &#123;  //当64个task后</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                if (lastExecutionTime &gt;= deadline) &#123;//当前时间超过截止时间，那么就退出</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            task = pollTask();</div><div class=\"line\">            if (task == null) &#123;</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        afterRunningAllTasks();</div><div class=\"line\">        this.lastExecutionTime = lastExecutionTime;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几件事:</p>\n<ul>\n<li>从schedule队列取出任务向taskQueue中存放, 是一个有size&lt;=16的、根据截至时间有优先级的阻塞队列。</li>\n<li>从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.</li>\n</ul>\n<p>NioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。</p>\n"},{"title":"ReentrantLock源码解读","date":"2017-07-23T11:47:30.000Z","_content":"ReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。\n基本使用如下:\n```\nReentrantLock lock = new ReentrantLock(true);\n//尝试获取锁,获取不到就阻塞\nlock.lock();\n//释放锁,获取完了唤醒被阻塞的线程\nlock.unlock();\n```\n# 简介\nAbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。\n## AbstractQueuedSynchronizer详解\n接下来将首先介绍两个重要的属性变量:\n`state`\nAbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了`volatile`关键字，这里没使用Synchronized来保证原子性的原因:\n+ state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。\n+ Synchronized实现互斥的成本要比volatile很高。\n`Node`\nAbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：\n```\n{\n     volatile int waitStatus;\n     volatile Node prev;\n     volatile Node next;\n     volatile Thread thread;\n     Node nextWaiter;\n\n}```\n\n|属性|介绍|\n|:-|:-|\n|waitStatus|当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态\n|prev|当前节点的前一个节点\n|next|当前节点的后继节点|\n|thread|当前节点所拥有的线程|\n|nextWaiter|表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。\nnextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS6.png\" height=\"200\" width=\"600\"/>\n上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。\n\nAQS中等待锁的线程队列与运行线程结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS.png\" height=\"250\" width=\"450\"/>\n### ReentrantLock详解\nReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。\n本文就以公平锁的获取与释放作为主线进行讲解。\n```\n    public static ReentrantLock lock = new ReentrantLock(true);\n    lock.lock()\n```\n这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值`1`的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。\n            selfInterrupt();\n    }\n```\n主要做了如下几个事情:\n+ 尝试去获取锁, 若获取到了, 就直接退出。\n+ 若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)\n### 尝试获取锁\n代码在FairSync中定义了:\n```\n        protected final boolean tryAcquire(int acquires) {\n             final Thread current = Thread.currentThread();\n            int c = getState();//首先读取state变量\n            if (c == 0) {\n                 ////判断sate值是否为0,在这里0就表示初始状态\n                if (!hasQueuedPredecessors() &&\n                    //采用CAS原子操作修改sate的值，\n                    compareAndSetState(0, acquires)) {\n                    //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            //当前线程就是抢占线程，那么是可以直接进入的\n            else if (current == getExclusiveOwnerThread()) {\n                //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            //否则就不能获取到，获取不到锁，但是不会改变state的值\n            return false;\n        }\n```\nFairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:\n1. 若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待\n2. 第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。\n3. 若当前线程获取不到锁, 是不会对status的值产生任何改变的。\n\n#### 加入等待队列\n若没有获取到锁, 则开始将线程加入等待队列addWaiter:\n```\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        //尾插法，尾部不为空\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n```\n首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。\n若目前还没有等待的节点, 那么构造等待队列:\n```\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            //初始化，只要没值，先把头和尾给初始化了再继续\n            if (t == null) { // Must initialize\n                //头部应该是空，这里要设置成new node()\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS1.png\" height=\"200\" width=\"250\"/>\n这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。\n#### 设置等待队列\n线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:\n```\n    //如果在整个等待过程中被中断过，则返回true，否则返回false。\n    final boolean acquireQueued(final Node node, int arg) {\n        //说明没有获取成功，退出时因为发生异常了\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) { //开始自旋\n                final Node p = node.predecessor(); //查找前继节点\n                //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node); //那么设置该节点为头结点\n                    p.next = null; // help GC 抛弃该节点，等待被回收\n                    failed = false;\n                    return interrupted;\n                } //说明没有获取到锁，是否需要睡眠等待\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                   //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的\n                   parkAndCheckInterrupt())\n                    //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)  //这里基本是执行不到的，除非遇到非运行时异常\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始`自旋`, 主要做了如下检查:\n+ 检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。\n+ 否则说明没有获取到锁, 那么检查该线程是否可以睡眠:\n```\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;//头结点，waitState默认为0\n        //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true; //那么本节点可以放心睡眠\n        //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev; //改变链路\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */ //\n             //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:\n1. 当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。\n2. 若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。\n3. 若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。\n在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS2.png\" height=\"200\" width=\"250\"/>\n\n有个问题: 这里为啥在else那里不直接可以去睡眠呢?\n假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。\n+ 若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。\n```\n    private final boolean parkAndCheckInterrupt() {\n        //能否响应中断请求, 从等待中退出，但是不会抛出异常\n        LockSupport.park(this);\n        //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递\n        return Thread.interrupted();\n    }\n```\n这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。\n至此, 获取锁的过程已经全部完成, 整体过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS4.png\" height=\"260\" width=\"800\"/>\n要么获取到锁, 那么线程进入等待队列安心睡眠。\n### 释放锁\n释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两个事情:\n+ 尝试将状态复位, 比如status置为0, 排他线程置为null.\n```\n        protected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) { //释放的时候，把status给清0了\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。\n+ 若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:\n```\n      private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        //置零当前线程所在的结点状态，允许失败。\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        //节点被取消了，cancel 才大于1\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                //从后向前找，找到最近一个有效的节点\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null) //反正叫醒后继节点\n            LockSupport.unpark(s.thread);\n    }\n```\n唤醒后继节点也是比较简单的:\n1. 首先将本节点waitStatus置为0(初始值)\n2. 如果后继节点被取消了(waitStatus>0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。\n释放锁过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS5.png\" height=\"200\" width=\"450\"/>\n### 总结\n线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。","source":"_posts/ReentrantLock源码解读.md","raw":"---\ntitle: ReentrantLock源码解读\ndate: 2017-07-23 19:47:30\ntags: ReentrantLock\n---\nReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。\n基本使用如下:\n```\nReentrantLock lock = new ReentrantLock(true);\n//尝试获取锁,获取不到就阻塞\nlock.lock();\n//释放锁,获取完了唤醒被阻塞的线程\nlock.unlock();\n```\n# 简介\nAbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。\n## AbstractQueuedSynchronizer详解\n接下来将首先介绍两个重要的属性变量:\n`state`\nAbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了`volatile`关键字，这里没使用Synchronized来保证原子性的原因:\n+ state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。\n+ Synchronized实现互斥的成本要比volatile很高。\n`Node`\nAbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：\n```\n{\n     volatile int waitStatus;\n     volatile Node prev;\n     volatile Node next;\n     volatile Thread thread;\n     Node nextWaiter;\n\n}```\n\n|属性|介绍|\n|:-|:-|\n|waitStatus|当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态\n|prev|当前节点的前一个节点\n|next|当前节点的后继节点|\n|thread|当前节点所拥有的线程|\n|nextWaiter|表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。\nnextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS6.png\" height=\"200\" width=\"600\"/>\n上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。\n\nAQS中等待锁的线程队列与运行线程结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS.png\" height=\"250\" width=\"450\"/>\n### ReentrantLock详解\nReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。\n本文就以公平锁的获取与释放作为主线进行讲解。\n```\n    public static ReentrantLock lock = new ReentrantLock(true);\n    lock.lock()\n```\n这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值`1`的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。\n            selfInterrupt();\n    }\n```\n主要做了如下几个事情:\n+ 尝试去获取锁, 若获取到了, 就直接退出。\n+ 若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)\n### 尝试获取锁\n代码在FairSync中定义了:\n```\n        protected final boolean tryAcquire(int acquires) {\n             final Thread current = Thread.currentThread();\n            int c = getState();//首先读取state变量\n            if (c == 0) {\n                 ////判断sate值是否为0,在这里0就表示初始状态\n                if (!hasQueuedPredecessors() &&\n                    //采用CAS原子操作修改sate的值，\n                    compareAndSetState(0, acquires)) {\n                    //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            //当前线程就是抢占线程，那么是可以直接进入的\n            else if (current == getExclusiveOwnerThread()) {\n                //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            //否则就不能获取到，获取不到锁，但是不会改变state的值\n            return false;\n        }\n```\nFairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:\n1. 若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待\n2. 第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。\n3. 若当前线程获取不到锁, 是不会对status的值产生任何改变的。\n\n#### 加入等待队列\n若没有获取到锁, 则开始将线程加入等待队列addWaiter:\n```\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        //尾插法，尾部不为空\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n```\n首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。\n若目前还没有等待的节点, 那么构造等待队列:\n```\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            //初始化，只要没值，先把头和尾给初始化了再继续\n            if (t == null) { // Must initialize\n                //头部应该是空，这里要设置成new node()\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS1.png\" height=\"200\" width=\"250\"/>\n这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。\n#### 设置等待队列\n线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:\n```\n    //如果在整个等待过程中被中断过，则返回true，否则返回false。\n    final boolean acquireQueued(final Node node, int arg) {\n        //说明没有获取成功，退出时因为发生异常了\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) { //开始自旋\n                final Node p = node.predecessor(); //查找前继节点\n                //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node); //那么设置该节点为头结点\n                    p.next = null; // help GC 抛弃该节点，等待被回收\n                    failed = false;\n                    return interrupted;\n                } //说明没有获取到锁，是否需要睡眠等待\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                   //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的\n                   parkAndCheckInterrupt())\n                    //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)  //这里基本是执行不到的，除非遇到非运行时异常\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始`自旋`, 主要做了如下检查:\n+ 检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。\n+ 否则说明没有获取到锁, 那么检查该线程是否可以睡眠:\n```\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;//头结点，waitState默认为0\n        //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true; //那么本节点可以放心睡眠\n        //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev; //改变链路\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */ //\n             //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:\n1. 当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。\n2. 若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。\n3. 若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。\n在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS2.png\" height=\"200\" width=\"250\"/>\n\n有个问题: 这里为啥在else那里不直接可以去睡眠呢?\n假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。\n+ 若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。\n```\n    private final boolean parkAndCheckInterrupt() {\n        //能否响应中断请求, 从等待中退出，但是不会抛出异常\n        LockSupport.park(this);\n        //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递\n        return Thread.interrupted();\n    }\n```\n这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。\n至此, 获取锁的过程已经全部完成, 整体过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS4.png\" height=\"260\" width=\"800\"/>\n要么获取到锁, 那么线程进入等待队列安心睡眠。\n### 释放锁\n释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两个事情:\n+ 尝试将状态复位, 比如status置为0, 排他线程置为null.\n```\n        protected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) { //释放的时候，把status给清0了\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。\n+ 若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:\n```\n      private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        //置零当前线程所在的结点状态，允许失败。\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        //节点被取消了，cancel 才大于1\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                //从后向前找，找到最近一个有效的节点\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null) //反正叫醒后继节点\n            LockSupport.unpark(s.thread);\n    }\n```\n唤醒后继节点也是比较简单的:\n1. 首先将本节点waitStatus置为0(初始值)\n2. 如果后继节点被取消了(waitStatus>0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。\n释放锁过程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/AQS5.png\" height=\"200\" width=\"450\"/>\n### 总结\n线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。","slug":"ReentrantLock源码解读","published":1,"updated":"2018-10-17T02:17:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvs000gisu5dx7rj0jl","content":"<p>ReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">//尝试获取锁,获取不到就阻塞</div><div class=\"line\">lock.lock();</div><div class=\"line\">//释放锁,获取完了唤醒被阻塞的线程</div><div class=\"line\">lock.unlock();</div></pre></td></tr></table></figure></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>AbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。</p>\n<h2 id=\"AbstractQueuedSynchronizer详解\"><a href=\"#AbstractQueuedSynchronizer详解\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer详解\"></a>AbstractQueuedSynchronizer详解</h2><p>接下来将首先介绍两个重要的属性变量:<br><code>state</code><br>AbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了<code>volatile</code>关键字，这里没使用Synchronized来保证原子性的原因:</p>\n<ul>\n<li>state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。</li>\n<li>Synchronized实现互斥的成本要比volatile很高。<br><code>Node</code><br>AbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     volatile int waitStatus;</div><div class=\"line\">     volatile Node prev;</div><div class=\"line\">     volatile Node next;</div><div class=\"line\">     volatile Thread thread;</div><div class=\"line\">     Node nextWaiter;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">waitStatus</td>\n<td style=\"text-align:left\">当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prev</td>\n<td style=\"text-align:left\">当前节点的前一个节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">当前节点的后继节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">当前节点所拥有的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nextWaiter</td>\n<td style=\"text-align:left\">表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。</td>\n</tr>\n</tbody>\n</table>\n<p>nextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS6.png\" height=\"200\" width=\"600\"><br>上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。</p>\n<p>AQS中等待锁的线程队列与运行线程结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS.png\" height=\"250\" width=\"450\"></p>\n<h3 id=\"ReentrantLock详解\"><a href=\"#ReentrantLock详解\" class=\"headerlink\" title=\"ReentrantLock详解\"></a>ReentrantLock详解</h3><p>ReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。<br>本文就以公平锁的获取与释放作为主线进行讲解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">lock.lock()</div></pre></td></tr></table></figure></p>\n<p>这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值<code>1</code>的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几个事情:</p>\n<ul>\n<li>尝试去获取锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁\"></a>尝试获取锁</h3>代码在FairSync中定义了:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">     final Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();//首先读取state变量</div><div class=\"line\">    if (c == 0) &#123;</div><div class=\"line\">         ////判断sate值是否为0,在这里0就表示初始状态</div><div class=\"line\">        if (!hasQueuedPredecessors() &amp;&amp;</div><div class=\"line\">            //采用CAS原子操作修改sate的值，</div><div class=\"line\">            compareAndSetState(0, acquires)) &#123;</div><div class=\"line\">            //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程</div><div class=\"line\">            setExclusiveOwnerThread(current);</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //当前线程就是抢占线程，那么是可以直接进入的</div><div class=\"line\">    else if (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">        //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放</div><div class=\"line\">        int nextc = c + acquires;</div><div class=\"line\">        if (nextc &lt; 0)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        setState(nextc);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //否则就不能获取到，获取不到锁，但是不会改变state的值</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>FairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:</p>\n<ol>\n<li>若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待</li>\n<li>第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。</li>\n<li>若当前线程获取不到锁, 是不会对status的值产生任何改变的。</li>\n</ol>\n<h4 id=\"加入等待队列\"><a href=\"#加入等待队列\" class=\"headerlink\" title=\"加入等待队列\"></a>加入等待队列</h4><p>若没有获取到锁, 则开始将线程加入等待队列addWaiter:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node addWaiter(Node mode) &#123;</div><div class=\"line\">    Node node = new Node(Thread.currentThread(), mode);</div><div class=\"line\">    // Try the fast path of enq; backup to full enq on failure</div><div class=\"line\">    Node pred = tail;</div><div class=\"line\">    //尾插法，尾部不为空</div><div class=\"line\">    if (pred != null) &#123;</div><div class=\"line\">        node.prev = pred;</div><div class=\"line\">        if (compareAndSetTail(pred, node)) &#123;</div><div class=\"line\">            pred.next = node;</div><div class=\"line\">            return node;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    enq(node);</div><div class=\"line\">    return node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。<br>若目前还没有等待的节点, 那么构造等待队列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node enq(final Node node) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node t = tail;</div><div class=\"line\">        //初始化，只要没值，先把头和尾给初始化了再继续</div><div class=\"line\">        if (t == null) &#123; // Must initialize</div><div class=\"line\">            //头部应该是空，这里要设置成new node()</div><div class=\"line\">            if (compareAndSetHead(new Node()))</div><div class=\"line\">                tail = head;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            node.prev = t;</div><div class=\"line\">            //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node</div><div class=\"line\">            if (compareAndSetTail(t, node)) &#123;</div><div class=\"line\">                t.next = node;</div><div class=\"line\">                return t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS1.png\" height=\"200\" width=\"250\"><br>这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。</p>\n<h4 id=\"设置等待队列\"><a href=\"#设置等待队列\" class=\"headerlink\" title=\"设置等待队列\"></a>设置等待队列</h4><p>线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如果在整个等待过程中被中断过，则返回true，否则返回false。</div><div class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class=\"line\">    //说明没有获取成功，退出时因为发生异常了</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        boolean interrupted = false;</div><div class=\"line\">        for (;;) &#123; //开始自旋</div><div class=\"line\">            final Node p = node.predecessor(); //查找前继节点</div><div class=\"line\">            //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去</div><div class=\"line\">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class=\"line\">                setHead(node); //那么设置该节点为头结点</div><div class=\"line\">                p.next = null; // help GC 抛弃该节点，等待被回收</div><div class=\"line\">                failed = false;</div><div class=\"line\">                return interrupted;</div><div class=\"line\">            &#125; //说明没有获取到锁，是否需要睡眠等待</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">               //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的</div><div class=\"line\">               parkAndCheckInterrupt())</div><div class=\"line\">                //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待</div><div class=\"line\">                interrupted = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)  //这里基本是执行不到的，除非遇到非运行时异常</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始<code>自旋</code>, 主要做了如下检查:</p>\n<ul>\n<li>检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。</li>\n<li>否则说明没有获取到锁, 那么检查该线程是否可以睡眠:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class=\"line\">    int ws = pred.waitStatus;//头结点，waitState默认为0</div><div class=\"line\">    //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点</div><div class=\"line\">    if (ws == Node.SIGNAL)</div><div class=\"line\">        /*</div><div class=\"line\">         * This node has already set status asking a release</div><div class=\"line\">         * to signal it, so it can safely park.</div><div class=\"line\">         */</div><div class=\"line\">        return true; //那么本节点可以放心睡眠</div><div class=\"line\">    //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃</div><div class=\"line\">    if (ws &gt; 0) &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * Predecessor was cancelled. Skip over predecessors and</div><div class=\"line\">         * indicate retry.</div><div class=\"line\">         */</div><div class=\"line\">        do &#123;</div><div class=\"line\">            node.prev = pred = pred.prev; //改变链路</div><div class=\"line\">        &#125; while (pred.waitStatus &gt; 0);</div><div class=\"line\">        pred.next = node;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class=\"line\">         * need a signal, but don&apos;t park yet.  Caller will need to</div><div class=\"line\">         * retry to make sure it cannot acquire before parking.</div><div class=\"line\">         */ //</div><div class=\"line\">         //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知</div><div class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:</p>\n<ol>\n<li>当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。</li>\n<li>若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。</li>\n<li>若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。<br>在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS2.png\" height=\"200\" width=\"250\"></li>\n</ol>\n<p>有个问题: 这里为啥在else那里不直接可以去睡眠呢?<br>假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。</p>\n<ul>\n<li>若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</div><div class=\"line\">    //能否响应中断请求, 从等待中退出，但是不会抛出异常</div><div class=\"line\">    LockSupport.park(this);</div><div class=\"line\">    //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递</div><div class=\"line\">    return Thread.interrupted();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。<br>至此, 获取锁的过程已经全部完成, 整体过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS4.png\" height=\"260\" width=\"800\"><br>要么获取到锁, 那么线程进入等待队列安心睡眠。</p>\n<h3 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h3><p>释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了两个事情:</p>\n<ul>\n<li>尝试将状态复位, 比如status置为0, 排他线程置为null.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryRelease(int releases) &#123;</div><div class=\"line\">    int c = getState() - releases;</div><div class=\"line\">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class=\"line\">        throw new IllegalMonitorStateException();</div><div class=\"line\">    boolean free = false;</div><div class=\"line\">    if (c == 0) &#123; //释放的时候，把status给清0了</div><div class=\"line\">        free = true;</div><div class=\"line\">        setExclusiveOwnerThread(null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    setState(c);</div><div class=\"line\">    return free;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。</p>\n<ul>\n<li>若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">  private void unparkSuccessor(Node node) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * If status is negative (i.e., possibly needing signal) try</div><div class=\"line\">     * to clear in anticipation of signalling.  It is OK if this</div><div class=\"line\">     * fails or if status is changed by waiting thread.</div><div class=\"line\">     */</div><div class=\"line\">    int ws = node.waitStatus;</div><div class=\"line\">    //置零当前线程所在的结点状态，允许失败。</div><div class=\"line\">    if (ws &lt; 0)</div><div class=\"line\">        compareAndSetWaitStatus(node, ws, 0);</div><div class=\"line\">    /*</div><div class=\"line\">     * Thread to unpark is held in successor, which is normally</div><div class=\"line\">     * just the next node.  But if cancelled or apparently null,</div><div class=\"line\">     * traverse backwards from tail to find the actual</div><div class=\"line\">     * non-cancelled successor.</div><div class=\"line\">     */</div><div class=\"line\">    Node s = node.next;</div><div class=\"line\">    //节点被取消了，cancel 才大于1</div><div class=\"line\">    if (s == null || s.waitStatus &gt; 0) &#123;</div><div class=\"line\">        s = null;</div><div class=\"line\">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</div><div class=\"line\">            //从后向前找，找到最近一个有效的节点</div><div class=\"line\">            if (t.waitStatus &lt;= 0)</div><div class=\"line\">                s = t;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (s != null) //反正叫醒后继节点</div><div class=\"line\">        LockSupport.unpark(s.thread);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>唤醒后继节点也是比较简单的:</p>\n<ol>\n<li>首先将本节点waitStatus置为0(初始值)</li>\n<li>如果后继节点被取消了(waitStatus&gt;0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。<br>释放锁过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS5.png\" height=\"200\" width=\"450\"><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>ReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">//尝试获取锁,获取不到就阻塞</div><div class=\"line\">lock.lock();</div><div class=\"line\">//释放锁,获取完了唤醒被阻塞的线程</div><div class=\"line\">lock.unlock();</div></pre></td></tr></table></figure></p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>AbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。</p>\n<h2 id=\"AbstractQueuedSynchronizer详解\"><a href=\"#AbstractQueuedSynchronizer详解\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer详解\"></a>AbstractQueuedSynchronizer详解</h2><p>接下来将首先介绍两个重要的属性变量:<br><code>state</code><br>AbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了<code>volatile</code>关键字，这里没使用Synchronized来保证原子性的原因:</p>\n<ul>\n<li>state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。</li>\n<li>Synchronized实现互斥的成本要比volatile很高。<br><code>Node</code><br>AbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     volatile int waitStatus;</div><div class=\"line\">     volatile Node prev;</div><div class=\"line\">     volatile Node next;</div><div class=\"line\">     volatile Thread thread;</div><div class=\"line\">     Node nextWaiter;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">waitStatus</td>\n<td style=\"text-align:left\">当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prev</td>\n<td style=\"text-align:left\">当前节点的前一个节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">当前节点的后继节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">当前节点所拥有的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nextWaiter</td>\n<td style=\"text-align:left\">表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。</td>\n</tr>\n</tbody>\n</table>\n<p>nextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS6.png\" height=\"200\" width=\"600\"><br>上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。</p>\n<p>AQS中等待锁的线程队列与运行线程结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS.png\" height=\"250\" width=\"450\"></p>\n<h3 id=\"ReentrantLock详解\"><a href=\"#ReentrantLock详解\" class=\"headerlink\" title=\"ReentrantLock详解\"></a>ReentrantLock详解</h3><p>ReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。<br>本文就以公平锁的获取与释放作为主线进行讲解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">lock.lock()</div></pre></td></tr></table></figure></p>\n<p>这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值<code>1</code>的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几个事情:</p>\n<ul>\n<li>尝试去获取锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁\"></a>尝试获取锁</h3>代码在FairSync中定义了:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">     final Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();//首先读取state变量</div><div class=\"line\">    if (c == 0) &#123;</div><div class=\"line\">         ////判断sate值是否为0,在这里0就表示初始状态</div><div class=\"line\">        if (!hasQueuedPredecessors() &amp;&amp;</div><div class=\"line\">            //采用CAS原子操作修改sate的值，</div><div class=\"line\">            compareAndSetState(0, acquires)) &#123;</div><div class=\"line\">            //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程</div><div class=\"line\">            setExclusiveOwnerThread(current);</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //当前线程就是抢占线程，那么是可以直接进入的</div><div class=\"line\">    else if (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">        //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放</div><div class=\"line\">        int nextc = c + acquires;</div><div class=\"line\">        if (nextc &lt; 0)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        setState(nextc);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //否则就不能获取到，获取不到锁，但是不会改变state的值</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>FairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:</p>\n<ol>\n<li>若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待</li>\n<li>第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。</li>\n<li>若当前线程获取不到锁, 是不会对status的值产生任何改变的。</li>\n</ol>\n<h4 id=\"加入等待队列\"><a href=\"#加入等待队列\" class=\"headerlink\" title=\"加入等待队列\"></a>加入等待队列</h4><p>若没有获取到锁, 则开始将线程加入等待队列addWaiter:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node addWaiter(Node mode) &#123;</div><div class=\"line\">    Node node = new Node(Thread.currentThread(), mode);</div><div class=\"line\">    // Try the fast path of enq; backup to full enq on failure</div><div class=\"line\">    Node pred = tail;</div><div class=\"line\">    //尾插法，尾部不为空</div><div class=\"line\">    if (pred != null) &#123;</div><div class=\"line\">        node.prev = pred;</div><div class=\"line\">        if (compareAndSetTail(pred, node)) &#123;</div><div class=\"line\">            pred.next = node;</div><div class=\"line\">            return node;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    enq(node);</div><div class=\"line\">    return node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。<br>若目前还没有等待的节点, 那么构造等待队列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node enq(final Node node) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node t = tail;</div><div class=\"line\">        //初始化，只要没值，先把头和尾给初始化了再继续</div><div class=\"line\">        if (t == null) &#123; // Must initialize</div><div class=\"line\">            //头部应该是空，这里要设置成new node()</div><div class=\"line\">            if (compareAndSetHead(new Node()))</div><div class=\"line\">                tail = head;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            node.prev = t;</div><div class=\"line\">            //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node</div><div class=\"line\">            if (compareAndSetTail(t, node)) &#123;</div><div class=\"line\">                t.next = node;</div><div class=\"line\">                return t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS1.png\" height=\"200\" width=\"250\"><br>这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。</p>\n<h4 id=\"设置等待队列\"><a href=\"#设置等待队列\" class=\"headerlink\" title=\"设置等待队列\"></a>设置等待队列</h4><p>线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如果在整个等待过程中被中断过，则返回true，否则返回false。</div><div class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class=\"line\">    //说明没有获取成功，退出时因为发生异常了</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        boolean interrupted = false;</div><div class=\"line\">        for (;;) &#123; //开始自旋</div><div class=\"line\">            final Node p = node.predecessor(); //查找前继节点</div><div class=\"line\">            //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去</div><div class=\"line\">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class=\"line\">                setHead(node); //那么设置该节点为头结点</div><div class=\"line\">                p.next = null; // help GC 抛弃该节点，等待被回收</div><div class=\"line\">                failed = false;</div><div class=\"line\">                return interrupted;</div><div class=\"line\">            &#125; //说明没有获取到锁，是否需要睡眠等待</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">               //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的</div><div class=\"line\">               parkAndCheckInterrupt())</div><div class=\"line\">                //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待</div><div class=\"line\">                interrupted = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)  //这里基本是执行不到的，除非遇到非运行时异常</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始<code>自旋</code>, 主要做了如下检查:</p>\n<ul>\n<li>检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。</li>\n<li>否则说明没有获取到锁, 那么检查该线程是否可以睡眠:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class=\"line\">    int ws = pred.waitStatus;//头结点，waitState默认为0</div><div class=\"line\">    //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点</div><div class=\"line\">    if (ws == Node.SIGNAL)</div><div class=\"line\">        /*</div><div class=\"line\">         * This node has already set status asking a release</div><div class=\"line\">         * to signal it, so it can safely park.</div><div class=\"line\">         */</div><div class=\"line\">        return true; //那么本节点可以放心睡眠</div><div class=\"line\">    //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃</div><div class=\"line\">    if (ws &gt; 0) &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * Predecessor was cancelled. Skip over predecessors and</div><div class=\"line\">         * indicate retry.</div><div class=\"line\">         */</div><div class=\"line\">        do &#123;</div><div class=\"line\">            node.prev = pred = pred.prev; //改变链路</div><div class=\"line\">        &#125; while (pred.waitStatus &gt; 0);</div><div class=\"line\">        pred.next = node;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class=\"line\">         * need a signal, but don&apos;t park yet.  Caller will need to</div><div class=\"line\">         * retry to make sure it cannot acquire before parking.</div><div class=\"line\">         */ //</div><div class=\"line\">         //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知</div><div class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:</p>\n<ol>\n<li>当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。</li>\n<li>若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。</li>\n<li>若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。<br>在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS2.png\" height=\"200\" width=\"250\"></li>\n</ol>\n<p>有个问题: 这里为啥在else那里不直接可以去睡眠呢?<br>假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。</p>\n<ul>\n<li>若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</div><div class=\"line\">    //能否响应中断请求, 从等待中退出，但是不会抛出异常</div><div class=\"line\">    LockSupport.park(this);</div><div class=\"line\">    //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递</div><div class=\"line\">    return Thread.interrupted();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。<br>至此, 获取锁的过程已经全部完成, 整体过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS4.png\" height=\"260\" width=\"800\"><br>要么获取到锁, 那么线程进入等待队列安心睡眠。</p>\n<h3 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h3><p>释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了两个事情:</p>\n<ul>\n<li>尝试将状态复位, 比如status置为0, 排他线程置为null.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryRelease(int releases) &#123;</div><div class=\"line\">    int c = getState() - releases;</div><div class=\"line\">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class=\"line\">        throw new IllegalMonitorStateException();</div><div class=\"line\">    boolean free = false;</div><div class=\"line\">    if (c == 0) &#123; //释放的时候，把status给清0了</div><div class=\"line\">        free = true;</div><div class=\"line\">        setExclusiveOwnerThread(null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    setState(c);</div><div class=\"line\">    return free;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。</p>\n<ul>\n<li>若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">  private void unparkSuccessor(Node node) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * If status is negative (i.e., possibly needing signal) try</div><div class=\"line\">     * to clear in anticipation of signalling.  It is OK if this</div><div class=\"line\">     * fails or if status is changed by waiting thread.</div><div class=\"line\">     */</div><div class=\"line\">    int ws = node.waitStatus;</div><div class=\"line\">    //置零当前线程所在的结点状态，允许失败。</div><div class=\"line\">    if (ws &lt; 0)</div><div class=\"line\">        compareAndSetWaitStatus(node, ws, 0);</div><div class=\"line\">    /*</div><div class=\"line\">     * Thread to unpark is held in successor, which is normally</div><div class=\"line\">     * just the next node.  But if cancelled or apparently null,</div><div class=\"line\">     * traverse backwards from tail to find the actual</div><div class=\"line\">     * non-cancelled successor.</div><div class=\"line\">     */</div><div class=\"line\">    Node s = node.next;</div><div class=\"line\">    //节点被取消了，cancel 才大于1</div><div class=\"line\">    if (s == null || s.waitStatus &gt; 0) &#123;</div><div class=\"line\">        s = null;</div><div class=\"line\">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</div><div class=\"line\">            //从后向前找，找到最近一个有效的节点</div><div class=\"line\">            if (t.waitStatus &lt;= 0)</div><div class=\"line\">                s = t;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (s != null) //反正叫醒后继节点</div><div class=\"line\">        LockSupport.unpark(s.thread);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>唤醒后继节点也是比较简单的:</p>\n<ol>\n<li>首先将本节点waitStatus置为0(初始值)</li>\n<li>如果后继节点被取消了(waitStatus&gt;0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。<br>释放锁过程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/AQS5.png\" height=\"200\" width=\"450\"><h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。</li>\n</ol>\n"},{"title":"ReentrantReadWriteLock源码解读","date":"2017-07-27T22:18:19.000Z","_content":"首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:\n```\nReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n//获取读锁\nreadWriteLock.readLock().lock();\n//释放读锁\nreadWriteLock.readLock().unlock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n```\n根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:\n```\n    public ReentrantReadWriteLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n        readerLock = new ReadLock(this);\n        writerLock = new WriteLock(this);\n    }\n\n```\n这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。\n# 读锁\n## 获取读锁\n通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:\n```\n    public final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\n首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。\n### 尝试获取锁:\n```\n        protected final int tryAcquireShared(int unused) {\n            /*\n             * Walkthrough:\n             * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队\n             * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到\n             *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁\n             *    because of queue policy. If not, try\n             *    to grant by CASing state and updating count.\n             *    Note that step does not check for reentrant\n             *    acquires, which is postponed to full version\n             *    to avoid having to check hold count in\n             *    the more typical non-reentrant case.\n             * 3. If step 2 fails either because thread\n             *    apparently not eligible or CAS fails or count\n             *    saturated, chain to version with full retry loop.\n             */\n            Thread current = Thread.currentThread();\n            int c = getState();\n            //同一个线程先写锁再读锁是可以获取锁的\n            if (exclusiveCount(c) != 0 &&\n                getExclusiveOwnerThread() != current)\n                 //当前获取写锁的线程不是本身\n                return -1;\n            int r = sharedCount(c);\n            //阻塞队列队列第一个不是写锁，\n            if (!readerShouldBlock() &&\n                r < MAX_COUNT &&\n                //会左移动16位\n                compareAndSetState(c, c + SHARED_UNIT)) {\n                if (r == 0) {//若是第一个读锁\n                    firstReader = current;\n                    firstReaderHoldCount = 1;\n                } else if (firstReader == current) {//就是本身线程\n                    firstReaderHoldCount++;\n                } else { //不是第一个获取读锁的线程\n                    HoldCounter rh = cachedHoldCounter;\n                    //上一个节点不存在，或者存在了不是自己的\n                    if (rh == null || rh.tid != getThreadId(current))\n                        //那就生成自己的，并且缓存起来\n                        cachedHoldCounter = rh = readHolds.get();\n                    else if (rh.count == 0) //若上一个获取的节点就是自己，\n                        readHolds.set(rh);\n                    rh.count++; //上一次获取锁+1\n                }\n                return 1;\n            }\n            //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）\n            return fullTryAcquireShared(current);\n        }\n```\n做了做了如下事情:\n+ 首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败\n+ 做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。\n  1.检查等待队列中, head节点不是写线程阻塞\n  2.再检查读锁没有达到65536的上限\n  3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:\n  3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。\n  3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1\n  3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。\n如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。\n```\n        final int fullTryAcquireShared(Thread current) {//（有写锁在等待、读达到最大值，status设置不成功）\n            /*\n             * This code is in part redundant with that in\n             * tryAcquireShared but is simpler overall by not\n             * complicating tryAcquireShared with interactions between\n             * retries and lazily reading hold counts.\n             */\n            HoldCounter rh = null;\n            for (;;) {\n                int c = getState();\n                if (exclusiveCount(c) != 0) {//有写锁\n                    //写锁是本身？\n                    if (getExclusiveOwnerThread() != current)\n                        return -1;\n                        //当前获取写锁的是本线程，那么直接返回（降级锁）\n                    // else we hold the exclusive lock; blocking here\n                    // would cause deadlock.\n                } else if (readerShouldBlock()) { //是否下一个要唤醒的是写锁\n                    // Make sure we're not acquiring read lock reentrantly\n                    if (firstReader == current) {//当前读锁线程第一个获取了读锁，那么继续可以读\n                        // assert firstReaderHoldCount > 0;\n                    } else { //当前有第一个写阻塞，而第一个读锁又不是自己\n                        //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）\n                        if (rh == null) {\n                            //一般最后一次获取所得，就是当前线程\n                            rh = cachedHoldCounter;\n                            if (rh == null || rh.tid != getThreadId(current)) {\n                                rh = readHolds.get();//当前线程信息\n                                //当前线程非可重入，在阻塞之前，要清空记录\n                                if (rh.count == 0)\n                                    readHolds.remove();\n                            }\n                        }\n                        //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧\n                        if (rh.count == 0)\n                            return -1;\n                    }\n                }\n                if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的\n                    throw new Error(\"Maximum lock count exceeded\");\n                if (compareAndSetState(c, c + SHARED_UNIT)) { //那么去设置\n                    if (sharedCount(c) == 0) { //第一次获取读锁\n                        firstReader = current;\n                        firstReaderHoldCount = 1;\n                    } else if (firstReader == current) {\n                        firstReaderHoldCount++;\n                    } else { //不是自己首先申请的读锁\n                        if (rh == null)\n                            rh = cachedHoldCounter;\n                        if (rh == null || rh.tid != getThreadId(current))\n                            rh = readHolds.get(); //获取到本线程的锁记录\n                        else if (rh.count == 0)//为0的时候都已经从线程中删掉了\n                            readHolds.set(rh);\n                        rh.count++;\n                        cachedHoldCounter = rh; // cache for release最后获取锁的线程\n                    }\n                    return 1;\n                }\n            }\n        }\n```\n此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。\n+ 首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。\n+ 反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。\n1. 若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。\n2. 若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。\n+ 检查读锁线程是否超过阈值65536\n+ 设置读锁的state.\n尝试获取流程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"/>\n### 加入阻塞队列\n加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号\n## unlock()\n通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:\n```\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) { //如果status彻底为0， 那么就说明可以唤醒await()了\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两件事:\n+ 首先尝试释放读锁, 并检查读锁线程state是否为0\n+ 若读锁线程state为0, 那么唤醒阻塞队列线程。\n尝试释放锁的过程如下:\n```\n        protected final boolean tryReleaseShared(int unused) {\n            Thread current = Thread.currentThread();\n            if (firstReader == current) { //本节点是第一个读取数据的线程\n                // assert firstReaderHoldCount > 0;\n                if (firstReaderHoldCount == 1)\n                    firstReader = null;  //最开始获取读锁的线程，去掉\n                else\n                    firstReaderHoldCount--;\n            } else {  //不是第一个读取数据的线程\n                HoldCounter rh = cachedHoldCounter;\n                if (rh == null || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                int count = rh.count;\n                if (count <= 1) { //把本线程访问记录从Localhost中去掉\n                    readHolds.remove();\n                    if (count <= 0)\n                        throw unmatchedUnlockException();\n                }\n                --rh.count;\n            }\n            for (;;) {\n                int c = getState();\n                int nextc = c - SHARED_UNIT; //\n                if (compareAndSetState(c, nextc))\n                    // Releasing the read lock has no effect on readers,\n                    // but it may allow waiting writers to proceed if\n                    // both read and write locks are now free.\n                    return nextc == 0;\n            }\n        }\n```\n+ 检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。\n+ 反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。\n+ 开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。\n若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。\n唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。\n可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。\n# 写锁\n## lock()\n写锁获取主要通过 sync.acquire(1)尝试获取:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n该函数主要分为三步:\n+ 尝试去获取写锁, 若获取到了, 就直接退出。\n+ 若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。\n来看第一步:\n```\n        protected final boolean tryAcquire(int acquires) {\n            /*\n             * Walkthrough:\n             * 1. If read count nonzero or write count nonzero\n             *    and owner is a different thread, fail.\n             * 2. If count would saturate, fail. (This can only\n             *    happen if count is already nonzero.)\n             * 3. Otherwise, this thread is eligible for lock if\n             *    it is either a reentrant acquire or\n             *    queue policy allows it. If so, update state\n             *    and set owner.\n             */\n            Thread current = Thread.currentThread();\n            //当前锁个数\n            int c = getState();\n            //写锁个数\n            int w = exclusiveCount(c);\n             ////当前锁个数 != 0（是否已经有线程持有锁），线程重入\n            if (c != 0) {\n                // (Note: if c != 0 and w == 0 then shared count != 0)\n                //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出\n                if (w == 0 || current != getExclusiveOwnerThread())\n                    return false;\n                //当前写锁， 是本身线程，可重入，但是不能超过65536个\n                if (w + exclusiveCount(acquires) > MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                // Reentrant acquire\n                //写锁可重入\n                setState(c + acquires);\n                return true;\n            }   //当前没有锁\n            //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false\n            if (writerShouldBlock() ||\n                !compareAndSetState(c, c + acquires))\n                return false;\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n```\n+ 首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。\n+ 反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。\n再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/28/ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantReadWriteLock源码解读</a>acquireQueued()\n第三步也很简单, 就是把中断信号向外传递。\n## unlock()\n写锁释放时,调用release()方法, 如下:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n+ 释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。\n+ 若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。\n也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。\n\n# 总结\nReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。","source":"_posts/ReentrantReadWriteLock源码解读.md","raw":"---\ntitle: ReentrantReadWriteLock源码解读\ndate: 2017-07-28 06:18:19\ntags:\n---\n首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:\n```\nReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n//获取读锁\nreadWriteLock.readLock().lock();\n//释放读锁\nreadWriteLock.readLock().unlock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n```\n根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:\n```\n    public ReentrantReadWriteLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n        readerLock = new ReadLock(this);\n        writerLock = new WriteLock(this);\n    }\n\n```\n这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。\n# 读锁\n## 获取读锁\n通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:\n```\n    public final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\n首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。\n### 尝试获取锁:\n```\n        protected final int tryAcquireShared(int unused) {\n            /*\n             * Walkthrough:\n             * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队\n             * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到\n             *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁\n             *    because of queue policy. If not, try\n             *    to grant by CASing state and updating count.\n             *    Note that step does not check for reentrant\n             *    acquires, which is postponed to full version\n             *    to avoid having to check hold count in\n             *    the more typical non-reentrant case.\n             * 3. If step 2 fails either because thread\n             *    apparently not eligible or CAS fails or count\n             *    saturated, chain to version with full retry loop.\n             */\n            Thread current = Thread.currentThread();\n            int c = getState();\n            //同一个线程先写锁再读锁是可以获取锁的\n            if (exclusiveCount(c) != 0 &&\n                getExclusiveOwnerThread() != current)\n                 //当前获取写锁的线程不是本身\n                return -1;\n            int r = sharedCount(c);\n            //阻塞队列队列第一个不是写锁，\n            if (!readerShouldBlock() &&\n                r < MAX_COUNT &&\n                //会左移动16位\n                compareAndSetState(c, c + SHARED_UNIT)) {\n                if (r == 0) {//若是第一个读锁\n                    firstReader = current;\n                    firstReaderHoldCount = 1;\n                } else if (firstReader == current) {//就是本身线程\n                    firstReaderHoldCount++;\n                } else { //不是第一个获取读锁的线程\n                    HoldCounter rh = cachedHoldCounter;\n                    //上一个节点不存在，或者存在了不是自己的\n                    if (rh == null || rh.tid != getThreadId(current))\n                        //那就生成自己的，并且缓存起来\n                        cachedHoldCounter = rh = readHolds.get();\n                    else if (rh.count == 0) //若上一个获取的节点就是自己，\n                        readHolds.set(rh);\n                    rh.count++; //上一次获取锁+1\n                }\n                return 1;\n            }\n            //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）\n            return fullTryAcquireShared(current);\n        }\n```\n做了做了如下事情:\n+ 首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败\n+ 做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。\n  1.检查等待队列中, head节点不是写线程阻塞\n  2.再检查读锁没有达到65536的上限\n  3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:\n  3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。\n  3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1\n  3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。\n如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。\n```\n        final int fullTryAcquireShared(Thread current) {//（有写锁在等待、读达到最大值，status设置不成功）\n            /*\n             * This code is in part redundant with that in\n             * tryAcquireShared but is simpler overall by not\n             * complicating tryAcquireShared with interactions between\n             * retries and lazily reading hold counts.\n             */\n            HoldCounter rh = null;\n            for (;;) {\n                int c = getState();\n                if (exclusiveCount(c) != 0) {//有写锁\n                    //写锁是本身？\n                    if (getExclusiveOwnerThread() != current)\n                        return -1;\n                        //当前获取写锁的是本线程，那么直接返回（降级锁）\n                    // else we hold the exclusive lock; blocking here\n                    // would cause deadlock.\n                } else if (readerShouldBlock()) { //是否下一个要唤醒的是写锁\n                    // Make sure we're not acquiring read lock reentrantly\n                    if (firstReader == current) {//当前读锁线程第一个获取了读锁，那么继续可以读\n                        // assert firstReaderHoldCount > 0;\n                    } else { //当前有第一个写阻塞，而第一个读锁又不是自己\n                        //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）\n                        if (rh == null) {\n                            //一般最后一次获取所得，就是当前线程\n                            rh = cachedHoldCounter;\n                            if (rh == null || rh.tid != getThreadId(current)) {\n                                rh = readHolds.get();//当前线程信息\n                                //当前线程非可重入，在阻塞之前，要清空记录\n                                if (rh.count == 0)\n                                    readHolds.remove();\n                            }\n                        }\n                        //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧\n                        if (rh.count == 0)\n                            return -1;\n                    }\n                }\n                if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的\n                    throw new Error(\"Maximum lock count exceeded\");\n                if (compareAndSetState(c, c + SHARED_UNIT)) { //那么去设置\n                    if (sharedCount(c) == 0) { //第一次获取读锁\n                        firstReader = current;\n                        firstReaderHoldCount = 1;\n                    } else if (firstReader == current) {\n                        firstReaderHoldCount++;\n                    } else { //不是自己首先申请的读锁\n                        if (rh == null)\n                            rh = cachedHoldCounter;\n                        if (rh == null || rh.tid != getThreadId(current))\n                            rh = readHolds.get(); //获取到本线程的锁记录\n                        else if (rh.count == 0)//为0的时候都已经从线程中删掉了\n                            readHolds.set(rh);\n                        rh.count++;\n                        cachedHoldCounter = rh; // cache for release最后获取锁的线程\n                    }\n                    return 1;\n                }\n            }\n        }\n```\n此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。\n+ 首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。\n+ 反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。\n1. 若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。\n2. 若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。\n+ 检查读锁线程是否超过阈值65536\n+ 设置读锁的state.\n尝试获取流程如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"/>\n### 加入阻塞队列\n加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号\n## unlock()\n通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:\n```\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) { //如果status彻底为0， 那么就说明可以唤醒await()了\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两件事:\n+ 首先尝试释放读锁, 并检查读锁线程state是否为0\n+ 若读锁线程state为0, 那么唤醒阻塞队列线程。\n尝试释放锁的过程如下:\n```\n        protected final boolean tryReleaseShared(int unused) {\n            Thread current = Thread.currentThread();\n            if (firstReader == current) { //本节点是第一个读取数据的线程\n                // assert firstReaderHoldCount > 0;\n                if (firstReaderHoldCount == 1)\n                    firstReader = null;  //最开始获取读锁的线程，去掉\n                else\n                    firstReaderHoldCount--;\n            } else {  //不是第一个读取数据的线程\n                HoldCounter rh = cachedHoldCounter;\n                if (rh == null || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                int count = rh.count;\n                if (count <= 1) { //把本线程访问记录从Localhost中去掉\n                    readHolds.remove();\n                    if (count <= 0)\n                        throw unmatchedUnlockException();\n                }\n                --rh.count;\n            }\n            for (;;) {\n                int c = getState();\n                int nextc = c - SHARED_UNIT; //\n                if (compareAndSetState(c, nextc))\n                    // Releasing the read lock has no effect on readers,\n                    // but it may allow waiting writers to proceed if\n                    // both read and write locks are now free.\n                    return nextc == 0;\n            }\n        }\n```\n+ 检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。\n+ 反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。\n+ 开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。\n若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。\n唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。\n可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。\n# 写锁\n## lock()\n写锁获取主要通过 sync.acquire(1)尝试获取:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n该函数主要分为三步:\n+ 尝试去获取写锁, 若获取到了, 就直接退出。\n+ 若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。\n来看第一步:\n```\n        protected final boolean tryAcquire(int acquires) {\n            /*\n             * Walkthrough:\n             * 1. If read count nonzero or write count nonzero\n             *    and owner is a different thread, fail.\n             * 2. If count would saturate, fail. (This can only\n             *    happen if count is already nonzero.)\n             * 3. Otherwise, this thread is eligible for lock if\n             *    it is either a reentrant acquire or\n             *    queue policy allows it. If so, update state\n             *    and set owner.\n             */\n            Thread current = Thread.currentThread();\n            //当前锁个数\n            int c = getState();\n            //写锁个数\n            int w = exclusiveCount(c);\n             ////当前锁个数 != 0（是否已经有线程持有锁），线程重入\n            if (c != 0) {\n                // (Note: if c != 0 and w == 0 then shared count != 0)\n                //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出\n                if (w == 0 || current != getExclusiveOwnerThread())\n                    return false;\n                //当前写锁， 是本身线程，可重入，但是不能超过65536个\n                if (w + exclusiveCount(acquires) > MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                // Reentrant acquire\n                //写锁可重入\n                setState(c + acquires);\n                return true;\n            }   //当前没有锁\n            //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false\n            if (writerShouldBlock() ||\n                !compareAndSetState(c, c + acquires))\n                return false;\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n```\n+ 首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。\n+ 反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。\n再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/28/ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantReadWriteLock源码解读</a>acquireQueued()\n第三步也很简单, 就是把中断信号向外传递。\n## unlock()\n写锁释放时,调用release()方法, 如下:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n+ 释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。\n+ 若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。\n也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。\n\n# 总结\nReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。","slug":"ReentrantReadWriteLock源码解读","published":1,"updated":"2018-10-28T15:02:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lvt000hisu59us8a7kq","content":"<p>首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</div><div class=\"line\">//获取读锁</div><div class=\"line\">readWriteLock.readLock().lock();</div><div class=\"line\">//释放读锁</div><div class=\"line\">readWriteLock.readLock().unlock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div></pre></td></tr></table></figure></p>\n<p>根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ReentrantReadWriteLock(boolean fair) &#123;</div><div class=\"line\">    sync = fair ? new FairSync() : new NonfairSync();</div><div class=\"line\">    readerLock = new ReadLock(this);</div><div class=\"line\">    writerLock = new WriteLock(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。</p>\n<h1 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h1><h2 id=\"获取读锁\"><a href=\"#获取读锁\" class=\"headerlink\" title=\"获取读锁\"></a>获取读锁</h2><p>通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireShared(int arg) &#123;</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireShared(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。</p>\n<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁:\"></a>尝试获取锁:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final int tryAcquireShared(int unused) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队</div><div class=\"line\">     * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到</div><div class=\"line\">     *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁</div><div class=\"line\">     *    because of queue policy. If not, try</div><div class=\"line\">     *    to grant by CASing state and updating count.</div><div class=\"line\">     *    Note that step does not check for reentrant</div><div class=\"line\">     *    acquires, which is postponed to full version</div><div class=\"line\">     *    to avoid having to check hold count in</div><div class=\"line\">     *    the more typical non-reentrant case.</div><div class=\"line\">     * 3. If step 2 fails either because thread</div><div class=\"line\">     *    apparently not eligible or CAS fails or count</div><div class=\"line\">     *    saturated, chain to version with full retry loop.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //同一个线程先写锁再读锁是可以获取锁的</div><div class=\"line\">    if (exclusiveCount(c) != 0 &amp;&amp;</div><div class=\"line\">        getExclusiveOwnerThread() != current)</div><div class=\"line\">         //当前获取写锁的线程不是本身</div><div class=\"line\">        return -1;</div><div class=\"line\">    int r = sharedCount(c);</div><div class=\"line\">    //阻塞队列队列第一个不是写锁，</div><div class=\"line\">    if (!readerShouldBlock() &amp;&amp;</div><div class=\"line\">        r &lt; MAX_COUNT &amp;&amp;</div><div class=\"line\">        //会左移动16位</div><div class=\"line\">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class=\"line\">        if (r == 0) &#123;//若是第一个读锁</div><div class=\"line\">            firstReader = current;</div><div class=\"line\">            firstReaderHoldCount = 1;</div><div class=\"line\">        &#125; else if (firstReader == current) &#123;//就是本身线程</div><div class=\"line\">            firstReaderHoldCount++;</div><div class=\"line\">        &#125; else &#123; //不是第一个获取读锁的线程</div><div class=\"line\">            HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">            //上一个节点不存在，或者存在了不是自己的</div><div class=\"line\">            if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                //那就生成自己的，并且缓存起来</div><div class=\"line\">                cachedHoldCounter = rh = readHolds.get();</div><div class=\"line\">            else if (rh.count == 0) //若上一个获取的节点就是自己，</div><div class=\"line\">                readHolds.set(rh);</div><div class=\"line\">            rh.count++; //上一次获取锁+1</div><div class=\"line\">        &#125;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）</div><div class=\"line\">    return fullTryAcquireShared(current);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>做了做了如下事情:</p>\n<ul>\n<li>首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败</li>\n<li>做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。<br>1.检查等待队列中, head节点不是写线程阻塞<br>2.再检查读锁没有达到65536的上限<br>3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:<br>3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。<br>3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1<br>3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。<br>如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int fullTryAcquireShared(Thread current) &#123;//（有写锁在等待、读达到最大值，status设置不成功）</div><div class=\"line\">    /*</div><div class=\"line\">     * This code is in part redundant with that in</div><div class=\"line\">     * tryAcquireShared but is simpler overall by not</div><div class=\"line\">     * complicating tryAcquireShared with interactions between</div><div class=\"line\">     * retries and lazily reading hold counts.</div><div class=\"line\">     */</div><div class=\"line\">    HoldCounter rh = null;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        if (exclusiveCount(c) != 0) &#123;//有写锁</div><div class=\"line\">            //写锁是本身？</div><div class=\"line\">            if (getExclusiveOwnerThread() != current)</div><div class=\"line\">                return -1;</div><div class=\"line\">                //当前获取写锁的是本线程，那么直接返回（降级锁）</div><div class=\"line\">            // else we hold the exclusive lock; blocking here</div><div class=\"line\">            // would cause deadlock.</div><div class=\"line\">        &#125; else if (readerShouldBlock()) &#123; //是否下一个要唤醒的是写锁</div><div class=\"line\">            // Make sure we&apos;re not acquiring read lock reentrantly</div><div class=\"line\">            if (firstReader == current) &#123;//当前读锁线程第一个获取了读锁，那么继续可以读</div><div class=\"line\">                // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">            &#125; else &#123; //当前有第一个写阻塞，而第一个读锁又不是自己</div><div class=\"line\">                //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）</div><div class=\"line\">                if (rh == null) &#123;</div><div class=\"line\">                    //一般最后一次获取所得，就是当前线程</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class=\"line\">                        rh = readHolds.get();//当前线程信息</div><div class=\"line\">                        //当前线程非可重入，在阻塞之前，要清空记录</div><div class=\"line\">                        if (rh.count == 0)</div><div class=\"line\">                            readHolds.remove();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧</div><div class=\"line\">                if (rh.count == 0)</div><div class=\"line\">                    return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123; //那么去设置</div><div class=\"line\">            if (sharedCount(c) == 0) &#123; //第一次获取读锁</div><div class=\"line\">                firstReader = current;</div><div class=\"line\">                firstReaderHoldCount = 1;</div><div class=\"line\">            &#125; else if (firstReader == current) &#123;</div><div class=\"line\">                firstReaderHoldCount++;</div><div class=\"line\">            &#125; else &#123; //不是自己首先申请的读锁</div><div class=\"line\">                if (rh == null)</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                    rh = readHolds.get(); //获取到本线程的锁记录</div><div class=\"line\">                else if (rh.count == 0)//为0的时候都已经从线程中删掉了</div><div class=\"line\">                    readHolds.set(rh);</div><div class=\"line\">                rh.count++;</div><div class=\"line\">                cachedHoldCounter = rh; // cache for release最后获取锁的线程</div><div class=\"line\">            &#125;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。</p>\n<ul>\n<li>首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。</li>\n<li>反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。</li>\n</ul>\n<ol>\n<li>若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。</li>\n<li>若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。</li>\n</ol>\n<ul>\n<li>检查读锁线程是否超过阈值65536</li>\n<li>设置读锁的state.<br>尝试获取流程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"><h3 id=\"加入阻塞队列\"><a href=\"#加入阻塞队列\" class=\"headerlink\" title=\"加入阻塞队列\"></a>加入阻塞队列</h3>加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号<h2 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2>通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123; //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了两件事:</p>\n<ul>\n<li>首先尝试释放读锁, 并检查读锁线程state是否为0</li>\n<li><p>若读锁线程state为0, 那么唤醒阻塞队列线程。<br>尝试释放锁的过程如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryReleaseShared(int unused) &#123;</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    if (firstReader == current) &#123; //本节点是第一个读取数据的线程</div><div class=\"line\">        // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">        if (firstReaderHoldCount == 1)</div><div class=\"line\">            firstReader = null;  //最开始获取读锁的线程，去掉</div><div class=\"line\">        else</div><div class=\"line\">            firstReaderHoldCount--;</div><div class=\"line\">    &#125; else &#123;  //不是第一个读取数据的线程</div><div class=\"line\">        HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">        if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">            rh = readHolds.get();</div><div class=\"line\">        int count = rh.count;</div><div class=\"line\">        if (count &lt;= 1) &#123; //把本线程访问记录从Localhost中去掉</div><div class=\"line\">            readHolds.remove();</div><div class=\"line\">            if (count &lt;= 0)</div><div class=\"line\">                throw unmatchedUnlockException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        --rh.count;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        int nextc = c - SHARED_UNIT; //</div><div class=\"line\">        if (compareAndSetState(c, nextc))</div><div class=\"line\">            // Releasing the read lock has no effect on readers,</div><div class=\"line\">            // but it may allow waiting writers to proceed if</div><div class=\"line\">            // both read and write locks are now free.</div><div class=\"line\">            return nextc == 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。</p>\n</li>\n<li>反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。</li>\n<li>开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。<br>若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。<br>唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。<br>可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。<h1 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h1><h2 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h2>写锁获取主要通过 sync.acquire(1)尝试获取:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp;</div><div class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该函数主要分为三步:</p>\n<ul>\n<li>尝试去获取写锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li><p>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。<br>来看第一步:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If read count nonzero or write count nonzero</div><div class=\"line\">     *    and owner is a different thread, fail.</div><div class=\"line\">     * 2. If count would saturate, fail. (This can only</div><div class=\"line\">     *    happen if count is already nonzero.)</div><div class=\"line\">     * 3. Otherwise, this thread is eligible for lock if</div><div class=\"line\">     *    it is either a reentrant acquire or</div><div class=\"line\">     *    queue policy allows it. If so, update state</div><div class=\"line\">     *    and set owner.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    //当前锁个数</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //写锁个数</div><div class=\"line\">    int w = exclusiveCount(c);</div><div class=\"line\">     ////当前锁个数 != 0（是否已经有线程持有锁），线程重入</div><div class=\"line\">    if (c != 0) &#123;</div><div class=\"line\">        // (Note: if c != 0 and w == 0 then shared count != 0)</div><div class=\"line\">        //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出</div><div class=\"line\">        if (w == 0 || current != getExclusiveOwnerThread())</div><div class=\"line\">            return false;</div><div class=\"line\">        //当前写锁， 是本身线程，可重入，但是不能超过65536个</div><div class=\"line\">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        // Reentrant acquire</div><div class=\"line\">        //写锁可重入</div><div class=\"line\">        setState(c + acquires);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;   //当前没有锁</div><div class=\"line\">    //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false</div><div class=\"line\">    if (writerShouldBlock() ||</div><div class=\"line\">        !compareAndSetState(c, c + acquires))</div><div class=\"line\">        return false;</div><div class=\"line\">    setExclusiveOwnerThread(current);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。</p>\n</li>\n<li><p>反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。<br>再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/28/ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantReadWriteLock源码解读</a>acquireQueued()<br>第三步也很简单, 就是把中断信号向外传递。</p>\n<h2 id=\"unlock-1\"><a href=\"#unlock-1\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2><p>写锁释放时,调用release()方法, 如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。</p>\n</li>\n<li>若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。<br>也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</div><div class=\"line\">//获取读锁</div><div class=\"line\">readWriteLock.readLock().lock();</div><div class=\"line\">//释放读锁</div><div class=\"line\">readWriteLock.readLock().unlock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div></pre></td></tr></table></figure></p>\n<p>根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ReentrantReadWriteLock(boolean fair) &#123;</div><div class=\"line\">    sync = fair ? new FairSync() : new NonfairSync();</div><div class=\"line\">    readerLock = new ReadLock(this);</div><div class=\"line\">    writerLock = new WriteLock(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。</p>\n<h1 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h1><h2 id=\"获取读锁\"><a href=\"#获取读锁\" class=\"headerlink\" title=\"获取读锁\"></a>获取读锁</h2><p>通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireShared(int arg) &#123;</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireShared(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。</p>\n<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁:\"></a>尝试获取锁:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final int tryAcquireShared(int unused) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队</div><div class=\"line\">     * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到</div><div class=\"line\">     *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁</div><div class=\"line\">     *    because of queue policy. If not, try</div><div class=\"line\">     *    to grant by CASing state and updating count.</div><div class=\"line\">     *    Note that step does not check for reentrant</div><div class=\"line\">     *    acquires, which is postponed to full version</div><div class=\"line\">     *    to avoid having to check hold count in</div><div class=\"line\">     *    the more typical non-reentrant case.</div><div class=\"line\">     * 3. If step 2 fails either because thread</div><div class=\"line\">     *    apparently not eligible or CAS fails or count</div><div class=\"line\">     *    saturated, chain to version with full retry loop.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //同一个线程先写锁再读锁是可以获取锁的</div><div class=\"line\">    if (exclusiveCount(c) != 0 &amp;&amp;</div><div class=\"line\">        getExclusiveOwnerThread() != current)</div><div class=\"line\">         //当前获取写锁的线程不是本身</div><div class=\"line\">        return -1;</div><div class=\"line\">    int r = sharedCount(c);</div><div class=\"line\">    //阻塞队列队列第一个不是写锁，</div><div class=\"line\">    if (!readerShouldBlock() &amp;&amp;</div><div class=\"line\">        r &lt; MAX_COUNT &amp;&amp;</div><div class=\"line\">        //会左移动16位</div><div class=\"line\">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class=\"line\">        if (r == 0) &#123;//若是第一个读锁</div><div class=\"line\">            firstReader = current;</div><div class=\"line\">            firstReaderHoldCount = 1;</div><div class=\"line\">        &#125; else if (firstReader == current) &#123;//就是本身线程</div><div class=\"line\">            firstReaderHoldCount++;</div><div class=\"line\">        &#125; else &#123; //不是第一个获取读锁的线程</div><div class=\"line\">            HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">            //上一个节点不存在，或者存在了不是自己的</div><div class=\"line\">            if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                //那就生成自己的，并且缓存起来</div><div class=\"line\">                cachedHoldCounter = rh = readHolds.get();</div><div class=\"line\">            else if (rh.count == 0) //若上一个获取的节点就是自己，</div><div class=\"line\">                readHolds.set(rh);</div><div class=\"line\">            rh.count++; //上一次获取锁+1</div><div class=\"line\">        &#125;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）</div><div class=\"line\">    return fullTryAcquireShared(current);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>做了做了如下事情:</p>\n<ul>\n<li>首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败</li>\n<li>做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。<br>1.检查等待队列中, head节点不是写线程阻塞<br>2.再检查读锁没有达到65536的上限<br>3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:<br>3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。<br>3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1<br>3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。<br>如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int fullTryAcquireShared(Thread current) &#123;//（有写锁在等待、读达到最大值，status设置不成功）</div><div class=\"line\">    /*</div><div class=\"line\">     * This code is in part redundant with that in</div><div class=\"line\">     * tryAcquireShared but is simpler overall by not</div><div class=\"line\">     * complicating tryAcquireShared with interactions between</div><div class=\"line\">     * retries and lazily reading hold counts.</div><div class=\"line\">     */</div><div class=\"line\">    HoldCounter rh = null;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        if (exclusiveCount(c) != 0) &#123;//有写锁</div><div class=\"line\">            //写锁是本身？</div><div class=\"line\">            if (getExclusiveOwnerThread() != current)</div><div class=\"line\">                return -1;</div><div class=\"line\">                //当前获取写锁的是本线程，那么直接返回（降级锁）</div><div class=\"line\">            // else we hold the exclusive lock; blocking here</div><div class=\"line\">            // would cause deadlock.</div><div class=\"line\">        &#125; else if (readerShouldBlock()) &#123; //是否下一个要唤醒的是写锁</div><div class=\"line\">            // Make sure we&apos;re not acquiring read lock reentrantly</div><div class=\"line\">            if (firstReader == current) &#123;//当前读锁线程第一个获取了读锁，那么继续可以读</div><div class=\"line\">                // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">            &#125; else &#123; //当前有第一个写阻塞，而第一个读锁又不是自己</div><div class=\"line\">                //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）</div><div class=\"line\">                if (rh == null) &#123;</div><div class=\"line\">                    //一般最后一次获取所得，就是当前线程</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class=\"line\">                        rh = readHolds.get();//当前线程信息</div><div class=\"line\">                        //当前线程非可重入，在阻塞之前，要清空记录</div><div class=\"line\">                        if (rh.count == 0)</div><div class=\"line\">                            readHolds.remove();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧</div><div class=\"line\">                if (rh.count == 0)</div><div class=\"line\">                    return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123; //那么去设置</div><div class=\"line\">            if (sharedCount(c) == 0) &#123; //第一次获取读锁</div><div class=\"line\">                firstReader = current;</div><div class=\"line\">                firstReaderHoldCount = 1;</div><div class=\"line\">            &#125; else if (firstReader == current) &#123;</div><div class=\"line\">                firstReaderHoldCount++;</div><div class=\"line\">            &#125; else &#123; //不是自己首先申请的读锁</div><div class=\"line\">                if (rh == null)</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                    rh = readHolds.get(); //获取到本线程的锁记录</div><div class=\"line\">                else if (rh.count == 0)//为0的时候都已经从线程中删掉了</div><div class=\"line\">                    readHolds.set(rh);</div><div class=\"line\">                rh.count++;</div><div class=\"line\">                cachedHoldCounter = rh; // cache for release最后获取锁的线程</div><div class=\"line\">            &#125;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。</p>\n<ul>\n<li>首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。</li>\n<li>反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。</li>\n</ul>\n<ol>\n<li>若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。</li>\n<li>若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。</li>\n</ol>\n<ul>\n<li>检查读锁线程是否超过阈值65536</li>\n<li>设置读锁的state.<br>尝试获取流程如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"><h3 id=\"加入阻塞队列\"><a href=\"#加入阻塞队列\" class=\"headerlink\" title=\"加入阻塞队列\"></a>加入阻塞队列</h3>加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号<h2 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2>通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123; //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了两件事:</p>\n<ul>\n<li>首先尝试释放读锁, 并检查读锁线程state是否为0</li>\n<li><p>若读锁线程state为0, 那么唤醒阻塞队列线程。<br>尝试释放锁的过程如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryReleaseShared(int unused) &#123;</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    if (firstReader == current) &#123; //本节点是第一个读取数据的线程</div><div class=\"line\">        // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">        if (firstReaderHoldCount == 1)</div><div class=\"line\">            firstReader = null;  //最开始获取读锁的线程，去掉</div><div class=\"line\">        else</div><div class=\"line\">            firstReaderHoldCount--;</div><div class=\"line\">    &#125; else &#123;  //不是第一个读取数据的线程</div><div class=\"line\">        HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">        if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">            rh = readHolds.get();</div><div class=\"line\">        int count = rh.count;</div><div class=\"line\">        if (count &lt;= 1) &#123; //把本线程访问记录从Localhost中去掉</div><div class=\"line\">            readHolds.remove();</div><div class=\"line\">            if (count &lt;= 0)</div><div class=\"line\">                throw unmatchedUnlockException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        --rh.count;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        int nextc = c - SHARED_UNIT; //</div><div class=\"line\">        if (compareAndSetState(c, nextc))</div><div class=\"line\">            // Releasing the read lock has no effect on readers,</div><div class=\"line\">            // but it may allow waiting writers to proceed if</div><div class=\"line\">            // both read and write locks are now free.</div><div class=\"line\">            return nextc == 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。</p>\n</li>\n<li>反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。</li>\n<li>开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。<br>若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。<br>唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。<br>可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。<h1 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h1><h2 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h2>写锁获取主要通过 sync.acquire(1)尝试获取:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp;</div><div class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该函数主要分为三步:</p>\n<ul>\n<li>尝试去获取写锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li><p>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。<br>来看第一步:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If read count nonzero or write count nonzero</div><div class=\"line\">     *    and owner is a different thread, fail.</div><div class=\"line\">     * 2. If count would saturate, fail. (This can only</div><div class=\"line\">     *    happen if count is already nonzero.)</div><div class=\"line\">     * 3. Otherwise, this thread is eligible for lock if</div><div class=\"line\">     *    it is either a reentrant acquire or</div><div class=\"line\">     *    queue policy allows it. If so, update state</div><div class=\"line\">     *    and set owner.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    //当前锁个数</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //写锁个数</div><div class=\"line\">    int w = exclusiveCount(c);</div><div class=\"line\">     ////当前锁个数 != 0（是否已经有线程持有锁），线程重入</div><div class=\"line\">    if (c != 0) &#123;</div><div class=\"line\">        // (Note: if c != 0 and w == 0 then shared count != 0)</div><div class=\"line\">        //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出</div><div class=\"line\">        if (w == 0 || current != getExclusiveOwnerThread())</div><div class=\"line\">            return false;</div><div class=\"line\">        //当前写锁， 是本身线程，可重入，但是不能超过65536个</div><div class=\"line\">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        // Reentrant acquire</div><div class=\"line\">        //写锁可重入</div><div class=\"line\">        setState(c + acquires);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;   //当前没有锁</div><div class=\"line\">    //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false</div><div class=\"line\">    if (writerShouldBlock() ||</div><div class=\"line\">        !compareAndSetState(c, c + acquires))</div><div class=\"line\">        return false;</div><div class=\"line\">    setExclusiveOwnerThread(current);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。</p>\n</li>\n<li><p>反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。<br>再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/28/ReentrantReadWriteLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantReadWriteLock源码解读</a>acquireQueued()<br>第三步也很简单, 就是把中断信号向外传递。</p>\n<h2 id=\"unlock-1\"><a href=\"#unlock-1\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2><p>写锁释放时,调用release()方法, 如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。</p>\n</li>\n<li>若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。<br>也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。</p>\n"},{"title":"Semaphore源码解读","date":"2017-08-15T09:56:32.000Z","_content":"Semaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\n基本使用如下:\n```\nSemaphore semp = new Semaphore(2, fasle);\n//若被别的线程通过中断唤醒了, 那么就直接抛出异常\npublic void acquire();\n//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出\npublic void acquireUninterruptibly()\n//尝试获取锁, 若获取不到就直接退出\npublic boolean tryAcquire()\n//再unit内等待获取锁, 获取不到就直接抛出异常\npublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n\n//释放一个锁。\npublic void release()\n```\nSemaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数\n|锁类型|介绍|\n|:-|:-|\n|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|\n|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|\n|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|\n|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|\n# acquire获取过程\n锁获取与其他几个AQS获取过程一样:\n```\n     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n            //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n+ 首先该线程是否有中断信号, 若有的话,直接退出\n+ 尝试获取锁, 若获取到了, 那么就回退\n+ 否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。\n唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。\n```\n        protected int tryAcquireShared(int acquires) {\n            for (;;) {\n                if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长\n                    return -1;\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n```\n示例展示的是公平锁锁, 做了如下检查:\n+ 检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)\n+ 若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。\n我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。\n\n# 释放锁release\n释放锁会调用releaseShared:\n```\n    public final boolean releaseShared(int arg) {\n         //如果status彻底为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。\n\n# 总结\nSemaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。\n","source":"_posts/Semaphore源码解读.md","raw":"---\ntitle: Semaphore源码解读\ndate: 2017-08-15 17:56:32\ntags:\n---\nSemaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\n基本使用如下:\n```\nSemaphore semp = new Semaphore(2, fasle);\n//若被别的线程通过中断唤醒了, 那么就直接抛出异常\npublic void acquire();\n//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出\npublic void acquireUninterruptibly()\n//尝试获取锁, 若获取不到就直接退出\npublic boolean tryAcquire()\n//再unit内等待获取锁, 获取不到就直接抛出异常\npublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n\n//释放一个锁。\npublic void release()\n```\nSemaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数\n|锁类型|介绍|\n|:-|:-|\n|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|\n|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|\n|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|\n|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|\n# acquire获取过程\n锁获取与其他几个AQS获取过程一样:\n```\n     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n            //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n+ 首先该线程是否有中断信号, 若有的话,直接退出\n+ 尝试获取锁, 若获取到了, 那么就回退\n+ 否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。\n唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。\n```\n        protected int tryAcquireShared(int acquires) {\n            for (;;) {\n                if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长\n                    return -1;\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n```\n示例展示的是公平锁锁, 做了如下检查:\n+ 检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)\n+ 若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。\n我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。\n\n# 释放锁release\n释放锁会调用releaseShared:\n```\n    public final boolean releaseShared(int arg) {\n         //如果status彻底为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。\n\n# 总结\nSemaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。\n","slug":"Semaphore源码解读","published":1,"updated":"2018-10-28T15:00:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lw1000jisu59sxsgfqk","content":"<p>Semaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Semaphore semp = new Semaphore(2, fasle);</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么就直接抛出异常</div><div class=\"line\">public void acquire();</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出</div><div class=\"line\">public void acquireUninterruptibly()</div><div class=\"line\">//尝试获取锁, 若获取不到就直接退出</div><div class=\"line\">public boolean tryAcquire()</div><div class=\"line\">//再unit内等待获取锁, 获取不到就直接抛出异常</div><div class=\"line\">public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</div><div class=\"line\"></div><div class=\"line\">//释放一个锁。</div><div class=\"line\">public void release()</div></pre></td></tr></table></figure></p>\n<p>Semaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数<br>|锁类型|介绍|<br>|:-|:-|<br>|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|<br>|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|<br>|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|<br>|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|</p>\n<h1 id=\"acquire获取过程\"><a href=\"#acquire获取过程\" class=\"headerlink\" title=\"acquire获取过程\"></a>acquire获取过程</h1><p>锁获取与其他几个AQS获取过程一样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">        //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先该线程是否有中断信号, 若有的话,直接退出</li>\n<li>尝试获取锁, 若获取到了, 那么就回退</li>\n<li>否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。<br>唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected int tryAcquireShared(int acquires) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长</div><div class=\"line\">            return -1;</div><div class=\"line\">        int available = getState();</div><div class=\"line\">        int remaining = available - acquires;</div><div class=\"line\">        if (remaining &lt; 0 ||</div><div class=\"line\">            compareAndSetState(available, remaining))</div><div class=\"line\">            return remaining;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例展示的是公平锁锁, 做了如下检查:</p>\n<ul>\n<li>检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)</li>\n<li>若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。<br>我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。</li>\n</ul>\n<h1 id=\"释放锁release\"><a href=\"#释放锁release\" class=\"headerlink\" title=\"释放锁release\"></a>释放锁release</h1><p>释放锁会调用releaseShared:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">     //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Semaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Semaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Semaphore semp = new Semaphore(2, fasle);</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么就直接抛出异常</div><div class=\"line\">public void acquire();</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出</div><div class=\"line\">public void acquireUninterruptibly()</div><div class=\"line\">//尝试获取锁, 若获取不到就直接退出</div><div class=\"line\">public boolean tryAcquire()</div><div class=\"line\">//再unit内等待获取锁, 获取不到就直接抛出异常</div><div class=\"line\">public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</div><div class=\"line\"></div><div class=\"line\">//释放一个锁。</div><div class=\"line\">public void release()</div></pre></td></tr></table></figure></p>\n<p>Semaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数<br>|锁类型|介绍|<br>|:-|:-|<br>|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|<br>|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|<br>|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|<br>|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|</p>\n<h1 id=\"acquire获取过程\"><a href=\"#acquire获取过程\" class=\"headerlink\" title=\"acquire获取过程\"></a>acquire获取过程</h1><p>锁获取与其他几个AQS获取过程一样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">        //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先该线程是否有中断信号, 若有的话,直接退出</li>\n<li>尝试获取锁, 若获取到了, 那么就回退</li>\n<li>否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。<br>唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected int tryAcquireShared(int acquires) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长</div><div class=\"line\">            return -1;</div><div class=\"line\">        int available = getState();</div><div class=\"line\">        int remaining = available - acquires;</div><div class=\"line\">        if (remaining &lt; 0 ||</div><div class=\"line\">            compareAndSetState(available, remaining))</div><div class=\"line\">            return remaining;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例展示的是公平锁锁, 做了如下检查:</p>\n<ul>\n<li>检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)</li>\n<li>若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。<br>我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。</li>\n</ul>\n<h1 id=\"释放锁release\"><a href=\"#释放锁release\" class=\"headerlink\" title=\"释放锁release\"></a>释放锁release</h1><p>释放锁会调用releaseShared:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">     //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Semaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。</p>\n"},{"title":"ServerBootstrap初始篇","date":"2018-01-14T10:32:43.000Z","_content":"&emsp;本文将以一个最简单的netty服务器端代码进行讲解。\n# 服务器示例\n ```\n public class HelloServer {\n    /**\n     * 服务端监听的端口地址\n     */\n    private static final int portNumber = 7878;\n    public static void main(String[] args) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup,WorkGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.childHandler(new HelloServerInitializer());\n            ChannelFuture f = b.bind(portNumber).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nclass HelloServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override       //  ch = NioSocketChannel\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n        pipeline.addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n        // 自己的逻辑Handler\n        pipeline.addLast(\"handler\", new HelloServerHandler());\n    }\n}\n\nclass HelloServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n        // 收到消息直接打印输出\n        System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);\n        // 返回客户端消息 - 我已经接收到了你的消息\n        ctx.writeAndFlush(\"Received your message !\\n\");\n    }\n    /*\n     *\n     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)\n     *\n     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述\n     * */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");\n        super.channelActive(ctx);\n    }\n}\n ```\n # NioEventLoop和NioEventLoopGroup分析\n  + NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为`NettyRuntime.availableProcessors() * 2)`\n  + NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。\n\n# 一些概念对应关系\n  + 一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。\n  + NioEventLoop里面处理task的线程唯一。\n  + Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。\n<img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\" />\n\n\n# 具体过程分析\n ## 首先分析AbstractBootstrap.doBind()\n ```\n     final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel(); //NioServerSocketChannel\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            // At this point we know that the registration was complete and successful.\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            // Registration future is almost always fulfilled already, but just in case it's not.\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                        // IllegalStateException once we try to access the EventLoop of the Channel.\n                        promise.setFailure(cause);\n                    } else {\n                        // Registration was successful, so set the correct executor to use.\n                        // See https://github.com/netty/netty/issues/2586\n                        promise.registered();\n\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n```\n主要干的事:\n1. 生成并初始化NioServerSocketChannel,见initAndRegister():\n2. 检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见`doBind0`)。\n\ninitAndRegister()主要作用:\n(1) 生成一个NioServerSocketChannel, 实际使用的`SelectorProvider.provider().openServerSocketChannel()`;\nNioServerSocketChannel构造函数如下:\n```\n        this.parent = parent;\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline，\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false); //\n        } catch (IOException e) {\n            try {\n                ch.close();\n            } catch (IOException e2) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Failed to close a partially initialized socket.\", e2);\n                }\n            }\n            throw new ChannelException(\"Failed to enter non-blocking mode.\", e);\n        }\n```\n+ 每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:\n```\nthis.channel = ObjectUtil.checkNotNull(channel, \"channel\");\ntail = new TailContext(this);   //只是in\nhead = new HeadContext(this);  //只是out\n\nhead.next = tail;\ntail.prev = head;\n```\n基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。\n+ TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身\n+ ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())\n+ 将该channel设置为非block类型,这里是不是与NIO很像。\n(2) 对channel初始化(见`分析init(channel)`)\n(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。\n\n&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。\n\n<font size=6>分析init(channel)</font>\n<p>代码实际会跑到ServerBootstrap.init():\n```\n            ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine\n            p.addLast(new ChannelInitializer<Channel>() { //新建的ChannelInitializer.initChannel\n            @Override\n            public void initChannel(final Channel ch) throws Exception {//NioServerSocketChannel\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n                ch.eventLoop().execute(new Runnable() {//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n```\n\n主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>\n<font size=6>p.addLast</font>\n<p>具体添加代码操作如下:\n```\n        synchronized (this) {\n            newCtx = newContext(group, filterName(name, handler), handler);\n            addLast0(newCtx);\n            if (!registered) {//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的\n                newCtx.setAddPending();\n                callHandlerCallbackLater(newCtx, true);\n                return this;\n            }\n            EventExecutor executor = newCtx.executor();\n            if (!executor.inEventLoop()) {\n                newCtx.setAddPending();\n                executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        callHandlerAdded0(newCtx);\n                    }\n                });\n                return this;\n            }\n        }\n        callHandlerAdded0(newCtx);\n        return this;\n```\n\n主要操作就是:\n+ 新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。\n+ 将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。\n+ 如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());\n  若注册了, 那么调用callHandlerAdded0()->ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:\n  ```\n  @SuppressWarnings(\"unchecked\")\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.\n            try {\n                initChannel((C) ctx.channel());\n            } catch (Throwable cause) {\n                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).\n                // We do so to prevent multiple calls to initChannel(...).\n                exceptionCaught(ctx, cause);\n            } finally {\n                remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型\n            }\n            return true;\n        }\n        return false;\n    }\n  ```\n  + 这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。\n  + 这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head->tail),和可能已经放进来的的ServerBootstrapAcceptor。\n\n<font size=6>register</font><p>\n根据`config().group().register(channel)`进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:\n当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。\n```\npublic EventExecutor next() {\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n```\n如何判断一个数是否为2^n呢, 方法如下:\n```\nprivate static boolean isPowerOfTwo(int val) {\n    return (val & -val) == val;\n}\n```\n选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:\n```\n            try {\n                // check if the channel is still open as it could be closed in the mean time when the register\n                // call was outside of the eventLoop\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n                doRegister();\n                neverRegistered = false;\n                registered = true;\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise);\n                pipeline.fireChannelRegistered();\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                // Close the channel directly to avoid FD leak.\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n```\ndoRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:\n```\n        for (;;) {\n            try {\n                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                    // cached and not removed because no Select.select(..) operation was called yet.\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    // We forced a select operation on the selector before but the SelectionKey is still cached\n                    // for whatever reason. JDK bug ?\n                    throw e;\n                }\n            }\n        }\n```\n这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。\n\n继续回到register()上,  channel与selector完成register之后:\n1. 执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD->ServerBootstrapAcceptor->TAIL\n2. 执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:\n```\n boolean wasActive = isActive();\n            try {\n                doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n            if (!wasActive && isActive()) { //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性\n                    }\n                });\n            }\n```\n\n\n自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\" />\n其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:\n```\nnew ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)\n```\ncurrentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。\n\n","source":"_posts/ServerBootstrap初始篇.md","raw":"---\ntitle: ServerBootstrap初始篇\ndate: 2018-01-14 18:32:43\ntags: netty4, ServerBootstrap, Initiale\n---\n&emsp;本文将以一个最简单的netty服务器端代码进行讲解。\n# 服务器示例\n ```\n public class HelloServer {\n    /**\n     * 服务端监听的端口地址\n     */\n    private static final int portNumber = 7878;\n    public static void main(String[] args) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup,WorkGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.childHandler(new HelloServerInitializer());\n            ChannelFuture f = b.bind(portNumber).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nclass HelloServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override       //  ch = NioSocketChannel\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n        pipeline.addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n        // 自己的逻辑Handler\n        pipeline.addLast(\"handler\", new HelloServerHandler());\n    }\n}\n\nclass HelloServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n        // 收到消息直接打印输出\n        System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);\n        // 返回客户端消息 - 我已经接收到了你的消息\n        ctx.writeAndFlush(\"Received your message !\\n\");\n    }\n    /*\n     *\n     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)\n     *\n     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述\n     * */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");\n        super.channelActive(ctx);\n    }\n}\n ```\n # NioEventLoop和NioEventLoopGroup分析\n  + NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为`NettyRuntime.availableProcessors() * 2)`\n  + NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。\n\n# 一些概念对应关系\n  + 一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。\n  + NioEventLoop里面处理task的线程唯一。\n  + Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。\n<img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\" />\n\n\n# 具体过程分析\n ## 首先分析AbstractBootstrap.doBind()\n ```\n     final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel(); //NioServerSocketChannel\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            // At this point we know that the registration was complete and successful.\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            // Registration future is almost always fulfilled already, but just in case it's not.\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                        // IllegalStateException once we try to access the EventLoop of the Channel.\n                        promise.setFailure(cause);\n                    } else {\n                        // Registration was successful, so set the correct executor to use.\n                        // See https://github.com/netty/netty/issues/2586\n                        promise.registered();\n\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n```\n主要干的事:\n1. 生成并初始化NioServerSocketChannel,见initAndRegister():\n2. 检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见`doBind0`)。\n\ninitAndRegister()主要作用:\n(1) 生成一个NioServerSocketChannel, 实际使用的`SelectorProvider.provider().openServerSocketChannel()`;\nNioServerSocketChannel构造函数如下:\n```\n        this.parent = parent;\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline，\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false); //\n        } catch (IOException e) {\n            try {\n                ch.close();\n            } catch (IOException e2) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Failed to close a partially initialized socket.\", e2);\n                }\n            }\n            throw new ChannelException(\"Failed to enter non-blocking mode.\", e);\n        }\n```\n+ 每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:\n```\nthis.channel = ObjectUtil.checkNotNull(channel, \"channel\");\ntail = new TailContext(this);   //只是in\nhead = new HeadContext(this);  //只是out\n\nhead.next = tail;\ntail.prev = head;\n```\n基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。\n+ TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身\n+ ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())\n+ 将该channel设置为非block类型,这里是不是与NIO很像。\n(2) 对channel初始化(见`分析init(channel)`)\n(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。\n\n&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。\n\n<font size=6>分析init(channel)</font>\n<p>代码实际会跑到ServerBootstrap.init():\n```\n            ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine\n            p.addLast(new ChannelInitializer<Channel>() { //新建的ChannelInitializer.initChannel\n            @Override\n            public void initChannel(final Channel ch) throws Exception {//NioServerSocketChannel\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n                ch.eventLoop().execute(new Runnable() {//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n```\n\n主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>\n<font size=6>p.addLast</font>\n<p>具体添加代码操作如下:\n```\n        synchronized (this) {\n            newCtx = newContext(group, filterName(name, handler), handler);\n            addLast0(newCtx);\n            if (!registered) {//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的\n                newCtx.setAddPending();\n                callHandlerCallbackLater(newCtx, true);\n                return this;\n            }\n            EventExecutor executor = newCtx.executor();\n            if (!executor.inEventLoop()) {\n                newCtx.setAddPending();\n                executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        callHandlerAdded0(newCtx);\n                    }\n                });\n                return this;\n            }\n        }\n        callHandlerAdded0(newCtx);\n        return this;\n```\n\n主要操作就是:\n+ 新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。\n+ 将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。\n+ 如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());\n  若注册了, 那么调用callHandlerAdded0()->ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:\n  ```\n  @SuppressWarnings(\"unchecked\")\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.\n            try {\n                initChannel((C) ctx.channel());\n            } catch (Throwable cause) {\n                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).\n                // We do so to prevent multiple calls to initChannel(...).\n                exceptionCaught(ctx, cause);\n            } finally {\n                remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型\n            }\n            return true;\n        }\n        return false;\n    }\n  ```\n  + 这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。\n  + 这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head->tail),和可能已经放进来的的ServerBootstrapAcceptor。\n\n<font size=6>register</font><p>\n根据`config().group().register(channel)`进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:\n当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。\n```\npublic EventExecutor next() {\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n```\n如何判断一个数是否为2^n呢, 方法如下:\n```\nprivate static boolean isPowerOfTwo(int val) {\n    return (val & -val) == val;\n}\n```\n选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:\n```\n            try {\n                // check if the channel is still open as it could be closed in the mean time when the register\n                // call was outside of the eventLoop\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n                doRegister();\n                neverRegistered = false;\n                registered = true;\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise);\n                pipeline.fireChannelRegistered();\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                // Close the channel directly to avoid FD leak.\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n```\ndoRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:\n```\n        for (;;) {\n            try {\n                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                    // cached and not removed because no Select.select(..) operation was called yet.\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    // We forced a select operation on the selector before but the SelectionKey is still cached\n                    // for whatever reason. JDK bug ?\n                    throw e;\n                }\n            }\n        }\n```\n这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。\n\n继续回到register()上,  channel与selector完成register之后:\n1. 执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD->ServerBootstrapAcceptor->TAIL\n2. 执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:\n```\n boolean wasActive = isActive();\n            try {\n                doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n            if (!wasActive && isActive()) { //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性\n                    }\n                });\n            }\n```\n\n\n自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\" />\n其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:\n```\nnew ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)\n```\ncurrentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。\n\n","slug":"ServerBootstrap初始篇","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lw2000kisu5x101pi59","content":"<p>&emsp;本文将以一个最简单的netty服务器端代码进行讲解。</p>\n<h1 id=\"服务器示例\"><a href=\"#服务器示例\" class=\"headerlink\" title=\"服务器示例\"></a>服务器示例</h1> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class HelloServer &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * 服务端监听的端口地址</div><div class=\"line\">     */</div><div class=\"line\">    private static final int portNumber = 7878;</div><div class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</div><div class=\"line\">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</div><div class=\"line\">        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ServerBootstrap b = new ServerBootstrap();</div><div class=\"line\">            b.group(bossGroup,WorkGroup);</div><div class=\"line\">            b.channel(NioServerSocketChannel.class);</div><div class=\"line\">            b.childHandler(new HelloServerInitializer());</div><div class=\"line\">            ChannelFuture f = b.bind(portNumber).sync();</div><div class=\"line\">            f.channel().closeFuture().sync();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            bossGroup.shutdownGracefully();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</div><div class=\"line\">    @Override       //  ch = NioSocketChannel</div><div class=\"line\">    protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</div><div class=\"line\">        pipeline.addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(4));</div><div class=\"line\">        pipeline.addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.UTF_8));</div><div class=\"line\">        pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</div><div class=\"line\">        // 自己的逻辑Handler</div><div class=\"line\">        pipeline.addLast(&quot;handler&quot;, new HelloServerHandler());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</div><div class=\"line\">        // 收到消息直接打印输出</div><div class=\"line\">        System.out.println(ctx.channel().remoteAddress() + &quot; Say : &quot; + msg);</div><div class=\"line\">        // 返回客户端消息 - 我已经接收到了你的消息</div><div class=\"line\">        ctx.writeAndFlush(&quot;Received your message !\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">     *</div><div class=\"line\">     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)</div><div class=\"line\">     *</div><div class=\"line\">     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述</div><div class=\"line\">     * */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">        ctx.writeAndFlush(&quot;Welcome to &quot; + InetAddress.getLocalHost().getHostName() + &quot; service!\\n&quot;);</div><div class=\"line\">        super.channelActive(ctx);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"NioEventLoop和NioEventLoopGroup分析\"><a href=\"#NioEventLoop和NioEventLoopGroup分析\" class=\"headerlink\" title=\"NioEventLoop和NioEventLoopGroup分析\"></a>NioEventLoop和NioEventLoopGroup分析</h1><ul>\n<li>NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为<code>NettyRuntime.availableProcessors() * 2)</code></li>\n<li>NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。</li>\n</ul>\n<h1 id=\"一些概念对应关系\"><a href=\"#一些概念对应关系\" class=\"headerlink\" title=\"一些概念对应关系\"></a>一些概念对应关系</h1><ul>\n<li>一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。</li>\n<li>NioEventLoop里面处理task的线程唯一。</li>\n<li>Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。<br><img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\"></li>\n</ul>\n<h1 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h1><h2 id=\"首先分析AbstractBootstrap-doBind\"><a href=\"#首先分析AbstractBootstrap-doBind\" class=\"headerlink\" title=\"首先分析AbstractBootstrap.doBind()\"></a>首先分析AbstractBootstrap.doBind()</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ChannelFuture regFuture = initAndRegister();</div><div class=\"line\">   final Channel channel = regFuture.channel(); //NioServerSocketChannel</div><div class=\"line\">   if (regFuture.cause() != null) &#123;</div><div class=\"line\">       return regFuture;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   if (regFuture.isDone()) &#123;</div><div class=\"line\">       // At this point we know that the registration was complete and successful.</div><div class=\"line\">       ChannelPromise promise = channel.newPromise();</div><div class=\"line\">       doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">       // Registration future is almost always fulfilled already, but just in case it&apos;s not.</div><div class=\"line\">       final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</div><div class=\"line\">       regFuture.addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">               Throwable cause = future.cause();</div><div class=\"line\">               if (cause != null) &#123;</div><div class=\"line\">                   // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</div><div class=\"line\">                   // IllegalStateException once we try to access the EventLoop of the Channel.</div><div class=\"line\">                   promise.setFailure(cause);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Registration was successful, so set the correct executor to use.</div><div class=\"line\">                   // See https://github.com/netty/netty/issues/2586</div><div class=\"line\">                   promise.registered();</div><div class=\"line\"></div><div class=\"line\">                   doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>主要干的事:</p>\n<ol>\n<li>生成并初始化NioServerSocketChannel,见initAndRegister():</li>\n<li>检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见<code>doBind0</code>)。</li>\n</ol>\n<p>initAndRegister()主要作用:<br>(1) 生成一个NioServerSocketChannel, 实际使用的<code>SelectorProvider.provider().openServerSocketChannel()</code>;<br>NioServerSocketChannel构造函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.parent = parent;</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline，</div><div class=\"line\">this.ch = ch;</div><div class=\"line\">this.readInterestOp = readInterestOp;</div><div class=\"line\">try &#123;</div><div class=\"line\">    ch.configureBlocking(false); //</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        ch.close();</div><div class=\"line\">    &#125; catch (IOException e2) &#123;</div><div class=\"line\">        if (logger.isWarnEnabled()) &#123;</div><div class=\"line\">            logger.warn(</div><div class=\"line\">                    &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class=\"line\">tail = new TailContext(this);   //只是in</div><div class=\"line\">head = new HeadContext(this);  //只是out</div><div class=\"line\"></div><div class=\"line\">head.next = tail;</div><div class=\"line\">tail.prev = head;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。</p>\n<ul>\n<li>TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身</li>\n<li>ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())</li>\n<li>将该channel设置为非block类型,这里是不是与NIO很像。<br>(2) 对channel初始化(见<code>分析init(channel)</code>)<br>(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。</li>\n</ul>\n<p>&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。</p>\n<p><font size=\"6\">分析init(channel)</font></p>\n<p></p><p>代码实际会跑到ServerBootstrap.init():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine</div><div class=\"line\">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; //新建的ChannelInitializer.initChannel</div><div class=\"line\">    @Override</div><div class=\"line\">    public void initChannel(final Channel ch) throws Exception &#123;//NioServerSocketChannel</div><div class=\"line\">        final ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        ChannelHandler handler = config.handler();</div><div class=\"line\">        if (handler != null) &#123;</div><div class=\"line\">            pipeline.addLast(handler);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ch.eventLoop().execute(new Runnable() &#123;//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                pipeline.addLast(new ServerBootstrapAcceptor(</div><div class=\"line\">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br></p>\n<p><font size=\"6\">p.addLast</font></p>\n<p></p><p>具体添加代码操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">    newCtx = newContext(group, filterName(name, handler), handler);</div><div class=\"line\">    addLast0(newCtx);</div><div class=\"line\">    if (!registered) &#123;//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        callHandlerCallbackLater(newCtx, true);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    EventExecutor executor = newCtx.executor();</div><div class=\"line\">    if (!executor.inEventLoop()) &#123;</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        executor.execute(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                callHandlerAdded0(newCtx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">callHandlerAdded0(newCtx);</div><div class=\"line\">return this;</div></pre></td></tr></table></figure></p>\n<p>主要操作就是:</p>\n<ul>\n<li>新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。</li>\n<li>将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。</li>\n<li><p>如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());<br>若注册了, 那么调用callHandlerAdded0()-&gt;ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">  private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">      if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              initChannel((C) ctx.channel());</div><div class=\"line\">          &#125; catch (Throwable cause) &#123;</div><div class=\"line\">              // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</div><div class=\"line\">              // We do so to prevent multiple calls to initChannel(...).</div><div class=\"line\">              exceptionCaught(ctx, cause);</div><div class=\"line\">          &#125; finally &#123;</div><div class=\"line\">              remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型</div><div class=\"line\">          &#125;</div><div class=\"line\">          return true;</div><div class=\"line\">      &#125;</div><div class=\"line\">      return false;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。</li>\n<li>这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head-&gt;tail),和可能已经放进来的的ServerBootstrapAcceptor。</li>\n</ul>\n</li>\n</ul>\n<p><font size=\"6\">register</font></p><p><br>根据<code>config().group().register(channel)</code>进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:<br>当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor next() &#123;</div><div class=\"line\">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如何判断一个数是否为2^n呢, 方法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isPowerOfTwo(int val) &#123;</div><div class=\"line\">    return (val &amp; -val) == val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    // check if the channel is still open as it could be closed in the mean time when the register</div><div class=\"line\">    // call was outside of the eventLoop</div><div class=\"line\">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean firstRegistration = neverRegistered;</div><div class=\"line\">    doRegister();</div><div class=\"line\">    neverRegistered = false;</div><div class=\"line\">    registered = true;</div><div class=\"line\">    pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">    safeSetSuccess(promise);</div><div class=\"line\">    pipeline.fireChannelRegistered();</div><div class=\"line\">    // Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">    // multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">    if (isActive()) &#123;</div><div class=\"line\">        if (firstRegistration) &#123;</div><div class=\"line\">            pipeline.fireChannelActive();</div><div class=\"line\">        &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">            // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">            // again so that we process inbound data.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">            beginRead();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">    // Close the channel directly to avoid FD leak.</div><div class=\"line\">    closeForcibly();</div><div class=\"line\">    closeFuture.setClosed();</div><div class=\"line\">    safeSetFailure(promise, t);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>doRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        if (!selected) &#123;</div><div class=\"line\">            // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</div><div class=\"line\">            // cached and not removed because no Select.select(..) operation was called yet.</div><div class=\"line\">            eventLoop().selectNow();</div><div class=\"line\">            selected = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We forced a select operation on the selector before but the SelectionKey is still cached</div><div class=\"line\">            // for whatever reason. JDK bug ?</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。</p>\n<p>继续回到register()上,  channel与selector完成register之后:</p>\n<ol>\n<li>执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD-&gt;ServerBootstrapAcceptor-&gt;TAIL</li>\n<li>执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean wasActive = isActive();</div><div class=\"line\">           try &#123;</div><div class=\"line\">               doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">               safeSetFailure(promise, t);</div><div class=\"line\">               closeIfClosed();</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           if (!wasActive &amp;&amp; isActive()) &#123; //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了</div><div class=\"line\">               invokeLater(new Runnable() &#123;</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void run() &#123;</div><div class=\"line\">                       pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\"><br>其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)</div></pre></td></tr></table></figure></p>\n<p>currentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&emsp;本文将以一个最简单的netty服务器端代码进行讲解。</p>\n<h1 id=\"服务器示例\"><a href=\"#服务器示例\" class=\"headerlink\" title=\"服务器示例\"></a>服务器示例</h1> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class HelloServer &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * 服务端监听的端口地址</div><div class=\"line\">     */</div><div class=\"line\">    private static final int portNumber = 7878;</div><div class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</div><div class=\"line\">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</div><div class=\"line\">        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ServerBootstrap b = new ServerBootstrap();</div><div class=\"line\">            b.group(bossGroup,WorkGroup);</div><div class=\"line\">            b.channel(NioServerSocketChannel.class);</div><div class=\"line\">            b.childHandler(new HelloServerInitializer());</div><div class=\"line\">            ChannelFuture f = b.bind(portNumber).sync();</div><div class=\"line\">            f.channel().closeFuture().sync();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            bossGroup.shutdownGracefully();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</div><div class=\"line\">    @Override       //  ch = NioSocketChannel</div><div class=\"line\">    protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</div><div class=\"line\">        pipeline.addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(4));</div><div class=\"line\">        pipeline.addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.UTF_8));</div><div class=\"line\">        pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</div><div class=\"line\">        // 自己的逻辑Handler</div><div class=\"line\">        pipeline.addLast(&quot;handler&quot;, new HelloServerHandler());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</div><div class=\"line\">        // 收到消息直接打印输出</div><div class=\"line\">        System.out.println(ctx.channel().remoteAddress() + &quot; Say : &quot; + msg);</div><div class=\"line\">        // 返回客户端消息 - 我已经接收到了你的消息</div><div class=\"line\">        ctx.writeAndFlush(&quot;Received your message !\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">     *</div><div class=\"line\">     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)</div><div class=\"line\">     *</div><div class=\"line\">     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述</div><div class=\"line\">     * */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">        ctx.writeAndFlush(&quot;Welcome to &quot; + InetAddress.getLocalHost().getHostName() + &quot; service!\\n&quot;);</div><div class=\"line\">        super.channelActive(ctx);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"NioEventLoop和NioEventLoopGroup分析\"><a href=\"#NioEventLoop和NioEventLoopGroup分析\" class=\"headerlink\" title=\"NioEventLoop和NioEventLoopGroup分析\"></a>NioEventLoop和NioEventLoopGroup分析</h1><ul>\n<li>NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为<code>NettyRuntime.availableProcessors() * 2)</code></li>\n<li>NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。</li>\n</ul>\n<h1 id=\"一些概念对应关系\"><a href=\"#一些概念对应关系\" class=\"headerlink\" title=\"一些概念对应关系\"></a>一些概念对应关系</h1><ul>\n<li>一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。</li>\n<li>NioEventLoop里面处理task的线程唯一。</li>\n<li>Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。<br><img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\"></li>\n</ul>\n<h1 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h1><h2 id=\"首先分析AbstractBootstrap-doBind\"><a href=\"#首先分析AbstractBootstrap-doBind\" class=\"headerlink\" title=\"首先分析AbstractBootstrap.doBind()\"></a>首先分析AbstractBootstrap.doBind()</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ChannelFuture regFuture = initAndRegister();</div><div class=\"line\">   final Channel channel = regFuture.channel(); //NioServerSocketChannel</div><div class=\"line\">   if (regFuture.cause() != null) &#123;</div><div class=\"line\">       return regFuture;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   if (regFuture.isDone()) &#123;</div><div class=\"line\">       // At this point we know that the registration was complete and successful.</div><div class=\"line\">       ChannelPromise promise = channel.newPromise();</div><div class=\"line\">       doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">       // Registration future is almost always fulfilled already, but just in case it&apos;s not.</div><div class=\"line\">       final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</div><div class=\"line\">       regFuture.addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">               Throwable cause = future.cause();</div><div class=\"line\">               if (cause != null) &#123;</div><div class=\"line\">                   // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</div><div class=\"line\">                   // IllegalStateException once we try to access the EventLoop of the Channel.</div><div class=\"line\">                   promise.setFailure(cause);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Registration was successful, so set the correct executor to use.</div><div class=\"line\">                   // See https://github.com/netty/netty/issues/2586</div><div class=\"line\">                   promise.registered();</div><div class=\"line\"></div><div class=\"line\">                   doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>主要干的事:</p>\n<ol>\n<li>生成并初始化NioServerSocketChannel,见initAndRegister():</li>\n<li>检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见<code>doBind0</code>)。</li>\n</ol>\n<p>initAndRegister()主要作用:<br>(1) 生成一个NioServerSocketChannel, 实际使用的<code>SelectorProvider.provider().openServerSocketChannel()</code>;<br>NioServerSocketChannel构造函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.parent = parent;</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline，</div><div class=\"line\">this.ch = ch;</div><div class=\"line\">this.readInterestOp = readInterestOp;</div><div class=\"line\">try &#123;</div><div class=\"line\">    ch.configureBlocking(false); //</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        ch.close();</div><div class=\"line\">    &#125; catch (IOException e2) &#123;</div><div class=\"line\">        if (logger.isWarnEnabled()) &#123;</div><div class=\"line\">            logger.warn(</div><div class=\"line\">                    &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class=\"line\">tail = new TailContext(this);   //只是in</div><div class=\"line\">head = new HeadContext(this);  //只是out</div><div class=\"line\"></div><div class=\"line\">head.next = tail;</div><div class=\"line\">tail.prev = head;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。</p>\n<ul>\n<li>TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身</li>\n<li>ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())</li>\n<li>将该channel设置为非block类型,这里是不是与NIO很像。<br>(2) 对channel初始化(见<code>分析init(channel)</code>)<br>(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。</li>\n</ul>\n<p>&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。</p>\n<p><font size=\"6\">分析init(channel)</font></p>\n<p></p><p>代码实际会跑到ServerBootstrap.init():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine</div><div class=\"line\">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; //新建的ChannelInitializer.initChannel</div><div class=\"line\">    @Override</div><div class=\"line\">    public void initChannel(final Channel ch) throws Exception &#123;//NioServerSocketChannel</div><div class=\"line\">        final ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        ChannelHandler handler = config.handler();</div><div class=\"line\">        if (handler != null) &#123;</div><div class=\"line\">            pipeline.addLast(handler);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ch.eventLoop().execute(new Runnable() &#123;//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                pipeline.addLast(new ServerBootstrapAcceptor(</div><div class=\"line\">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br></p>\n<p><font size=\"6\">p.addLast</font></p>\n<p></p><p>具体添加代码操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">    newCtx = newContext(group, filterName(name, handler), handler);</div><div class=\"line\">    addLast0(newCtx);</div><div class=\"line\">    if (!registered) &#123;//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        callHandlerCallbackLater(newCtx, true);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    EventExecutor executor = newCtx.executor();</div><div class=\"line\">    if (!executor.inEventLoop()) &#123;</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        executor.execute(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                callHandlerAdded0(newCtx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">callHandlerAdded0(newCtx);</div><div class=\"line\">return this;</div></pre></td></tr></table></figure></p>\n<p>主要操作就是:</p>\n<ul>\n<li>新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。</li>\n<li>将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。</li>\n<li><p>如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());<br>若注册了, 那么调用callHandlerAdded0()-&gt;ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">  private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">      if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              initChannel((C) ctx.channel());</div><div class=\"line\">          &#125; catch (Throwable cause) &#123;</div><div class=\"line\">              // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</div><div class=\"line\">              // We do so to prevent multiple calls to initChannel(...).</div><div class=\"line\">              exceptionCaught(ctx, cause);</div><div class=\"line\">          &#125; finally &#123;</div><div class=\"line\">              remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型</div><div class=\"line\">          &#125;</div><div class=\"line\">          return true;</div><div class=\"line\">      &#125;</div><div class=\"line\">      return false;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。</li>\n<li>这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head-&gt;tail),和可能已经放进来的的ServerBootstrapAcceptor。</li>\n</ul>\n</li>\n</ul>\n<p><font size=\"6\">register</font></p><p><br>根据<code>config().group().register(channel)</code>进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:<br>当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor next() &#123;</div><div class=\"line\">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如何判断一个数是否为2^n呢, 方法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isPowerOfTwo(int val) &#123;</div><div class=\"line\">    return (val &amp; -val) == val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    // check if the channel is still open as it could be closed in the mean time when the register</div><div class=\"line\">    // call was outside of the eventLoop</div><div class=\"line\">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean firstRegistration = neverRegistered;</div><div class=\"line\">    doRegister();</div><div class=\"line\">    neverRegistered = false;</div><div class=\"line\">    registered = true;</div><div class=\"line\">    pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">    safeSetSuccess(promise);</div><div class=\"line\">    pipeline.fireChannelRegistered();</div><div class=\"line\">    // Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">    // multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">    if (isActive()) &#123;</div><div class=\"line\">        if (firstRegistration) &#123;</div><div class=\"line\">            pipeline.fireChannelActive();</div><div class=\"line\">        &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">            // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">            // again so that we process inbound data.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">            beginRead();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">    // Close the channel directly to avoid FD leak.</div><div class=\"line\">    closeForcibly();</div><div class=\"line\">    closeFuture.setClosed();</div><div class=\"line\">    safeSetFailure(promise, t);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>doRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        if (!selected) &#123;</div><div class=\"line\">            // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</div><div class=\"line\">            // cached and not removed because no Select.select(..) operation was called yet.</div><div class=\"line\">            eventLoop().selectNow();</div><div class=\"line\">            selected = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We forced a select operation on the selector before but the SelectionKey is still cached</div><div class=\"line\">            // for whatever reason. JDK bug ?</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。</p>\n<p>继续回到register()上,  channel与selector完成register之后:</p>\n<ol>\n<li>执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD-&gt;ServerBootstrapAcceptor-&gt;TAIL</li>\n<li>执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean wasActive = isActive();</div><div class=\"line\">           try &#123;</div><div class=\"line\">               doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">               safeSetFailure(promise, t);</div><div class=\"line\">               closeIfClosed();</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           if (!wasActive &amp;&amp; isActive()) &#123; //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了</div><div class=\"line\">               invokeLater(new Runnable() &#123;</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void run() &#123;</div><div class=\"line\">                       pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\"><br>其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)</div></pre></td></tr></table></figure></p>\n<p>currentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。</p>\n"},{"title":"SimpleDateFormat非线程安全分析","date":"2018-10-31T04:09:51.000Z","_content":"","source":"_posts/SimpleDateFormat非线程安全分析.md","raw":"---\ntitle: SimpleDateFormat非线程安全分析\ndate: 2018-10-31 12:09:51\ntags:\n---\n","slug":"SimpleDateFormat非线程安全分析","published":1,"updated":"2018-10-31T04:09:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lw4000lisu537u9llsp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"CopyOnWriteArrayList原理解读","date":"2017-09-17T02:14:15.000Z","_content":"CopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。\n## 成员变量\n+ lock\nfinal transient ReentrantLock lock = new ReentrantLock();\n使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。\n+ array\nprivate transient volatile Object[] array;\n真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。\n## 添加数据add\n```\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n主要做了如下事情:\n+ 首先获取互斥可重入锁。 若获取不到, 则被阻塞。\n+ 将原来数组元素copy到新的数组\n+ 将新添加元素都放到数组newElements最后。\n+ 替换原来数组elements\n过程如下:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"/>\n## 总结\nCopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。","source":"_posts/copyOnWriteArrayListy原理解读.md","raw":"---\ntitle: CopyOnWriteArrayList原理解读\ndate: 2017-09-17 10:14:15\ntags:\n---\nCopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。\n## 成员变量\n+ lock\nfinal transient ReentrantLock lock = new ReentrantLock();\n使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。\n+ array\nprivate transient volatile Object[] array;\n真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。\n## 添加数据add\n```\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n主要做了如下事情:\n+ 首先获取互斥可重入锁。 若获取不到, 则被阻塞。\n+ 将原来数组元素copy到新的数组\n+ 将新添加元素都放到数组newElements最后。\n+ 替换原来数组elements\n过程如下:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"/>\n## 总结\nCopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。","slug":"copyOnWriteArrayListy原理解读","published":1,"updated":"2018-10-17T03:01:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lw6000oisu55gf3elky","content":"<p>CopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。</p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><ul>\n<li>lock<br>final transient ReentrantLock lock = new ReentrantLock();<br>使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。</li>\n<li>array<br>private transient volatile Object[] array;<br>真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。<h2 id=\"添加数据add\"><a href=\"#添加数据add\" class=\"headerlink\" title=\"添加数据add\"></a>添加数据add</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean add(E e) &#123;</div><div class=\"line\">    final ReentrantLock lock = this.lock;</div><div class=\"line\">    lock.lock();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Object[] elements = getArray();</div><div class=\"line\">        int len = elements.length;</div><div class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class=\"line\">        newElements[len] = e;</div><div class=\"line\">        setArray(newElements);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        lock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先获取互斥可重入锁。 若获取不到, 则被阻塞。</li>\n<li>将原来数组元素copy到新的数组</li>\n<li>将新添加元素都放到数组newElements最后。</li>\n<li>替换原来数组elements<br>过程如下:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>CopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>CopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。</p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><ul>\n<li>lock<br>final transient ReentrantLock lock = new ReentrantLock();<br>使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。</li>\n<li>array<br>private transient volatile Object[] array;<br>真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。<h2 id=\"添加数据add\"><a href=\"#添加数据add\" class=\"headerlink\" title=\"添加数据add\"></a>添加数据add</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean add(E e) &#123;</div><div class=\"line\">    final ReentrantLock lock = this.lock;</div><div class=\"line\">    lock.lock();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Object[] elements = getArray();</div><div class=\"line\">        int len = elements.length;</div><div class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class=\"line\">        newElements[len] = e;</div><div class=\"line\">        setArray(newElements);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        lock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先获取互斥可重入锁。 若获取不到, 则被阻塞。</li>\n<li>将原来数组元素copy到新的数组</li>\n<li>将新添加元素都放到数组newElements最后。</li>\n<li>替换原来数组elements<br>过程如下:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>CopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。</li>\n</ul>\n"},{"title":"git 基本命令学习心得-1","date":"2017-03-08T04:46:57.000Z","_content":"rebase, cherry-pick、merge等都有一个概念:提交commit, 就以下图为例, 把当一次提交D合并到另外一个提交E, 产生E', 这里的提交D指的当前D的所有全量代码, 去和E合并, 并不是由C commit到D时产生的增量代码去和E合并。\n# rebase\ngit rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase3.png\" height=\"300\" width=\"500\"/>\n`git:(dev) git rebase master`,变基是以共同祖先节点开始变的。 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D', 基于D'与F合并变成F', 基于F'和G合并变成G'。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。\n用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase --continue继续解决下一个冲突\n注意: 并没有要求修改comment, commit不变\n\n## rebase -i 参数\n-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。\n`git:(dev): git rebase -i master`之后, 将弹出这样的界面:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"/>\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"/>\n\n红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:\n+ 操作action\n+ commit hash值\n+ commit commit\n其中action介绍在红框2中, 主要分为这几种类型:\n1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。\ngit rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。\n2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)\ngit rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。\n3) e, edit = use commit, but stop for amending\ngit rebase -i master: 和p参数没啥区别, 能修改所有提交的comment\ngit rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用--continue才能继续\n4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。\n执行以下命令:`git:(dev): git rebase -i HEAD~3`, 并且修改action如下:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\n```\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase6.png\" height=\"350\" width=\"450\"/>\ngit log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。\ngit rebase -i master也能和描述也是一致的。\n5) f, fixup = like \"squash\", but discard this commit's log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。\ngit rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。\ngit rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。\n6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用\n7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)\n\n## i参数控制复制、删除、重置提交顺序等\nrebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\npick 159f932 d1\n```\n该提交将重复提交第一次提交, 提交结果如下:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase7.png\" height=\"350\" width=\"450\"/>\n本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push --force origin mybranch分支。 master一般不允许直接这么弄\n\n# cherry-pick\ncherry-pick主要是将单独的两次提交合并到一起, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交合并到当前master分支上, 那么就执行:\n`git:(master D提交): git cherry-pick G`, 提交完成后, G提交出的本地全部代码就会和master分支D处全部代码合并, 产生提交D'。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D'和G毫无关联。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase10.png\" height=\"350\" width=\"450\"/>\n\ncherry-pick与rebase使用上的区别:\nrebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。\ncherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。\n\n# revert\nrevert的含义是撤销某次提交, 下图为例, 比如想撤销G提交: `git:(master D提交): git revert G`, 实际就是将G提交的父提交F的全部代码与D合并, 然后产生新的提交D'。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_revert1.png\" height=\"350\" width=\"450\"/>\n同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D'与G提交没有任何关系。\n比如`git:(master D提交): git revert HEAD`, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert --continue来完成此次操作。\n\n\n# checkout\ncheckout主要是从`对象库中(仓库)`拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从`暂存区(索引)`中检出文件来重置工作区的文件, 使用示例如下:\n+ git:(master D提交): git checkout G\n将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致\n+ git:(master D提交): git checkout -- file1\n用`暂存区`的文件file1来重置`工作区`的file1, 而不是从本地代码仓库来恢复。\n+ git:(master D提交): git checkout G -- file1\n用G提交的代码`暂存区`的文件file1来重置`工作区`的file1。\ncheckout不会去修改提交记录, 仅仅是修改了HEAD。\n\n# reset\nreset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。\n+ 在切换到某一次提交时, 可使用 三个参数:\n---soft: 仅仅是将当前master、HEAD指针指向commit3\n---mixed: 在---soft的基础上, 用commit3的提交来重置暂存区。(默认)\n---hard: 在---hard的集群上, 用commit3的提交来重置暂存区、工作区。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_reset.png\" height=\"250\" width=\"700\"/>\n+ git:(master D提交): git reset HEAD file1\n用`本地代码仓库`的文件file1来重置`暂存区`(索引)的file1。\n","source":"_posts/git-基本命令学习心得.md","raw":"---\ntitle: git 基本命令学习心得-1\ndate: 2017-03-08 12:46:57\ntags: git, rebase, cherry-pick, reset, checkout\n---\nrebase, cherry-pick、merge等都有一个概念:提交commit, 就以下图为例, 把当一次提交D合并到另外一个提交E, 产生E', 这里的提交D指的当前D的所有全量代码, 去和E合并, 并不是由C commit到D时产生的增量代码去和E合并。\n# rebase\ngit rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase3.png\" height=\"300\" width=\"500\"/>\n`git:(dev) git rebase master`,变基是以共同祖先节点开始变的。 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D', 基于D'与F合并变成F', 基于F'和G合并变成G'。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。\n用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase --continue继续解决下一个冲突\n注意: 并没有要求修改comment, commit不变\n\n## rebase -i 参数\n-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。\n`git:(dev): git rebase -i master`之后, 将弹出这样的界面:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"/>\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"/>\n\n红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:\n+ 操作action\n+ commit hash值\n+ commit commit\n其中action介绍在红框2中, 主要分为这几种类型:\n1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。\ngit rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。\n2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)\ngit rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。\n3) e, edit = use commit, but stop for amending\ngit rebase -i master: 和p参数没啥区别, 能修改所有提交的comment\ngit rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用--continue才能继续\n4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。\n执行以下命令:`git:(dev): git rebase -i HEAD~3`, 并且修改action如下:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\n```\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase6.png\" height=\"350\" width=\"450\"/>\ngit log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。\ngit rebase -i master也能和描述也是一致的。\n5) f, fixup = like \"squash\", but discard this commit's log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。\ngit rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。\ngit rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。\n6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用\n7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)\n\n## i参数控制复制、删除、重置提交顺序等\nrebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\npick 159f932 d1\n```\n该提交将重复提交第一次提交, 提交结果如下:\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase7.png\" height=\"350\" width=\"450\"/>\n本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push --force origin mybranch分支。 master一般不允许直接这么弄\n\n# cherry-pick\ncherry-pick主要是将单独的两次提交合并到一起, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交合并到当前master分支上, 那么就执行:\n`git:(master D提交): git cherry-pick G`, 提交完成后, G提交出的本地全部代码就会和master分支D处全部代码合并, 产生提交D'。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D'和G毫无关联。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase10.png\" height=\"350\" width=\"450\"/>\n\ncherry-pick与rebase使用上的区别:\nrebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。\ncherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。\n\n# revert\nrevert的含义是撤销某次提交, 下图为例, 比如想撤销G提交: `git:(master D提交): git revert G`, 实际就是将G提交的父提交F的全部代码与D合并, 然后产生新的提交D'。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_revert1.png\" height=\"350\" width=\"450\"/>\n同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D'与G提交没有任何关系。\n比如`git:(master D提交): git revert HEAD`, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert --continue来完成此次操作。\n\n\n# checkout\ncheckout主要是从`对象库中(仓库)`拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从`暂存区(索引)`中检出文件来重置工作区的文件, 使用示例如下:\n+ git:(master D提交): git checkout G\n将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致\n+ git:(master D提交): git checkout -- file1\n用`暂存区`的文件file1来重置`工作区`的file1, 而不是从本地代码仓库来恢复。\n+ git:(master D提交): git checkout G -- file1\n用G提交的代码`暂存区`的文件file1来重置`工作区`的file1。\ncheckout不会去修改提交记录, 仅仅是修改了HEAD。\n\n# reset\nreset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。\n+ 在切换到某一次提交时, 可使用 三个参数:\n---soft: 仅仅是将当前master、HEAD指针指向commit3\n---mixed: 在---soft的基础上, 用commit3的提交来重置暂存区。(默认)\n---hard: 在---hard的集群上, 用commit3的提交来重置暂存区、工作区。\n<img src=\"http://pgagp8vnu.bkt.clouddn.com/git_reset.png\" height=\"250\" width=\"700\"/>\n+ git:(master D提交): git reset HEAD file1\n用`本地代码仓库`的文件file1来重置`暂存区`(索引)的file1。\n","slug":"git-基本命令学习心得","published":1,"updated":"2018-11-19T12:09:45.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjop17lw8000pisu596t809kz","content":"<p>rebase, cherry-pick、merge等都有一个概念:提交commit, 就以下图为例, 把当一次提交D合并到另外一个提交E, 产生E’, 这里的提交D指的当前D的所有全量代码, 去和E合并, 并不是由C commit到D时产生的增量代码去和E合并。</p>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>git rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase3.png\" height=\"300\" width=\"500\"><br><code>git:(dev) git rebase master</code>,变基是以共同祖先节点开始变的。 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D’, 基于D’与F合并变成F’, 基于F’和G合并变成G’。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。<br>用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase –continue继续解决下一个冲突<br>注意: 并没有要求修改comment, commit不变</p>\n<h2 id=\"rebase-i-参数\"><a href=\"#rebase-i-参数\" class=\"headerlink\" title=\"rebase -i 参数\"></a>rebase -i 参数</h2><p>-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。<br><code>git:(dev): git rebase -i master</code>之后, 将弹出这样的界面:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"><br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"></p>\n<p>红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:</p>\n<ul>\n<li>操作action</li>\n<li>commit hash值</li>\n<li>commit commit<br>其中action介绍在红框2中, 主要分为这几种类型:<br>1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。<br>git rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。<br>2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)<br>git rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。<br>3) e, edit = use commit, but stop for amending<br>git rebase -i master: 和p参数没啥区别, 能修改所有提交的comment<br>git rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用–continue才能继续<br>4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。<br>执行以下命令:<code>git:(dev): git rebase -i HEAD~3</code>, 并且修改action如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase6.png\" height=\"350\" width=\"450\"><br>git log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。<br>git rebase -i master也能和描述也是一致的。<br>5) f, fixup = like “squash”, but discard this commit’s log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。<br>git rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。<br>git rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。<br>6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用<br>7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)</p>\n<h2 id=\"i参数控制复制、删除、重置提交顺序等\"><a href=\"#i参数控制复制、删除、重置提交顺序等\" class=\"headerlink\" title=\"i参数控制复制、删除、重置提交顺序等\"></a>i参数控制复制、删除、重置提交顺序等</h2><p>rebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div><div class=\"line\">pick 159f932 d1</div></pre></td></tr></table></figure></p>\n<p>该提交将重复提交第一次提交, 提交结果如下:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase7.png\" height=\"350\" width=\"450\"><br>本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push –force origin mybranch分支。 master一般不允许直接这么弄</p>\n<h1 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h1><p>cherry-pick主要是将单独的两次提交合并到一起, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交合并到当前master分支上, 那么就执行:<br><code>git:(master D提交): git cherry-pick G</code>, 提交完成后, G提交出的本地全部代码就会和master分支D处全部代码合并, 产生提交D’。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D’和G毫无关联。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase10.png\" height=\"350\" width=\"450\"></p>\n<p>cherry-pick与rebase使用上的区别:<br>rebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。<br>cherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。</p>\n<h1 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h1><p>revert的含义是撤销某次提交, 下图为例, 比如想撤销G提交: <code>git:(master D提交): git revert G</code>, 实际就是将G提交的父提交F的全部代码与D合并, 然后产生新的提交D’。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_revert1.png\" height=\"350\" width=\"450\"><br>同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D’与G提交没有任何关系。<br>比如<code>git:(master D提交): git revert HEAD</code>, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert –continue来完成此次操作。</p>\n<h1 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h1><p>checkout主要是从<code>对象库中(仓库)</code>拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从<code>暂存区(索引)</code>中检出文件来重置工作区的文件, 使用示例如下:</p>\n<ul>\n<li>git:(master D提交): git checkout G<br>将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致</li>\n<li>git:(master D提交): git checkout – file1<br>用<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1, 而不是从本地代码仓库来恢复。</li>\n<li>git:(master D提交): git checkout G – file1<br>用G提交的代码<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1。<br>checkout不会去修改提交记录, 仅仅是修改了HEAD。</li>\n</ul>\n<h1 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h1><p>reset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。</p>\n<ul>\n<li>在切换到某一次提交时, 可使用 三个参数:<br>—soft: 仅仅是将当前master、HEAD指针指向commit3<br>—mixed: 在—soft的基础上, 用commit3的提交来重置暂存区。(默认)<br>—hard: 在—hard的集群上, 用commit3的提交来重置暂存区、工作区。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_reset.png\" height=\"250\" width=\"700\"></li>\n<li>git:(master D提交): git reset HEAD file1<br>用<code>本地代码仓库</code>的文件file1来重置<code>暂存区</code>(索引)的file1。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>rebase, cherry-pick、merge等都有一个概念:提交commit, 就以下图为例, 把当一次提交D合并到另外一个提交E, 产生E’, 这里的提交D指的当前D的所有全量代码, 去和E合并, 并不是由C commit到D时产生的增量代码去和E合并。</p>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>git rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase3.png\" height=\"300\" width=\"500\"><br><code>git:(dev) git rebase master</code>,变基是以共同祖先节点开始变的。 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D’, 基于D’与F合并变成F’, 基于F’和G合并变成G’。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。<br>用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase –continue继续解决下一个冲突<br>注意: 并没有要求修改comment, commit不变</p>\n<h2 id=\"rebase-i-参数\"><a href=\"#rebase-i-参数\" class=\"headerlink\" title=\"rebase -i 参数\"></a>rebase -i 参数</h2><p>-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。<br><code>git:(dev): git rebase -i master</code>之后, 将弹出这样的界面:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"><br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase5.png\" height=\"350\" width=\"450\"></p>\n<p>红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:</p>\n<ul>\n<li>操作action</li>\n<li>commit hash值</li>\n<li>commit commit<br>其中action介绍在红框2中, 主要分为这几种类型:<br>1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。<br>git rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。<br>2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)<br>git rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。<br>3) e, edit = use commit, but stop for amending<br>git rebase -i master: 和p参数没啥区别, 能修改所有提交的comment<br>git rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用–continue才能继续<br>4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。<br>执行以下命令:<code>git:(dev): git rebase -i HEAD~3</code>, 并且修改action如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase6.png\" height=\"350\" width=\"450\"><br>git log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。<br>git rebase -i master也能和描述也是一致的。<br>5) f, fixup = like “squash”, but discard this commit’s log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。<br>git rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。<br>git rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。<br>6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用<br>7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)</p>\n<h2 id=\"i参数控制复制、删除、重置提交顺序等\"><a href=\"#i参数控制复制、删除、重置提交顺序等\" class=\"headerlink\" title=\"i参数控制复制、删除、重置提交顺序等\"></a>i参数控制复制、删除、重置提交顺序等</h2><p>rebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div><div class=\"line\">pick 159f932 d1</div></pre></td></tr></table></figure></p>\n<p>该提交将重复提交第一次提交, 提交结果如下:<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase7.png\" height=\"350\" width=\"450\"><br>本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push –force origin mybranch分支。 master一般不允许直接这么弄</p>\n<h1 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h1><p>cherry-pick主要是将单独的两次提交合并到一起, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交合并到当前master分支上, 那么就执行:<br><code>git:(master D提交): git cherry-pick G</code>, 提交完成后, G提交出的本地全部代码就会和master分支D处全部代码合并, 产生提交D’。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D’和G毫无关联。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_rebase10.png\" height=\"350\" width=\"450\"></p>\n<p>cherry-pick与rebase使用上的区别:<br>rebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。<br>cherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。</p>\n<h1 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h1><p>revert的含义是撤销某次提交, 下图为例, 比如想撤销G提交: <code>git:(master D提交): git revert G</code>, 实际就是将G提交的父提交F的全部代码与D合并, 然后产生新的提交D’。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_revert1.png\" height=\"350\" width=\"450\"><br>同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D’与G提交没有任何关系。<br>比如<code>git:(master D提交): git revert HEAD</code>, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert –continue来完成此次操作。</p>\n<h1 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h1><p>checkout主要是从<code>对象库中(仓库)</code>拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从<code>暂存区(索引)</code>中检出文件来重置工作区的文件, 使用示例如下:</p>\n<ul>\n<li>git:(master D提交): git checkout G<br>将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致</li>\n<li>git:(master D提交): git checkout – file1<br>用<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1, 而不是从本地代码仓库来恢复。</li>\n<li>git:(master D提交): git checkout G – file1<br>用G提交的代码<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1。<br>checkout不会去修改提交记录, 仅仅是修改了HEAD。</li>\n</ul>\n<h1 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h1><p>reset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。</p>\n<ul>\n<li>在切换到某一次提交时, 可使用 三个参数:<br>—soft: 仅仅是将当前master、HEAD指针指向commit3<br>—mixed: 在—soft的基础上, 用commit3的提交来重置暂存区。(默认)<br>—hard: 在—hard的集群上, 用commit3的提交来重置暂存区、工作区。<br><img src=\"http://pgagp8vnu.bkt.clouddn.com/git_reset.png\" height=\"250\" width=\"700\"></li>\n<li>git:(master D提交): git reset HEAD file1<br>用<code>本地代码仓库</code>的文件file1来重置<code>暂存区</code>(索引)的file1。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjop17lvs000gisu5dx7rj0jl","tag_id":"cjop17lvu000iisu5o5s6h21x","_id":"cjop17lw6000nisu5ydp1bi8w"},{"post_id":"cjop17lw2000kisu5x101pi59","tag_id":"cjop17lw5000misu5jfs8y4ij","_id":"cjop17lw9000risu57wt9qmxr"},{"post_id":"cjop17lw8000pisu596t809kz","tag_id":"cjop17lw8000qisu50ebn65hx","_id":"cjop17lw9000sisu506ted2dy"}],"Tag":[{"name":"ReentrantLock","_id":"cjop17lvu000iisu5o5s6h21x"},{"name":"netty4, ServerBootstrap, Initiale","_id":"cjop17lw5000misu5jfs8y4ij"},{"name":"git, rebase, cherry-pick, reset, checkout","_id":"cjop17lw8000qisu50ebn65hx"}]}}