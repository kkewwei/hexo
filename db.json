{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/picture1.jpg","path":"picture1.jpg","modified":1,"renderable":0},{"_id":"source/img/AQS.png","path":"img/AQS.png","modified":1,"renderable":0},{"_id":"source/img/AQS2.png","path":"img/AQS2.png","modified":1,"renderable":0},{"_id":"source/img/AQS1.png","path":"img/AQS1.png","modified":1,"renderable":0},{"_id":"source/img/AQS5.png","path":"img/AQS5.png","modified":1,"renderable":0},{"_id":"source/img/ChannelOutboundBuffer.png","path":"img/ChannelOutboundBuffer.png","modified":1,"renderable":0},{"_id":"source/img/AQS6.png","path":"img/AQS6.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap10.png","path":"img/ConcurrentHashMap10.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap11.png","path":"img/ConcurrentHashMap11.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap12.png","path":"img/ConcurrentHashMap12.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap13.png","path":"img/ConcurrentHashMap13.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap14.png","path":"img/ConcurrentHashMap14.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap15.png","path":"img/ConcurrentHashMap15.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap2.png","path":"img/ConcurrentHashMap2.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap3.png","path":"img/ConcurrentHashMap3.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap5.png","path":"img/ConcurrentHashMap5.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap6.png","path":"img/ConcurrentHashMap6.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap7.png","path":"img/ConcurrentHashMap7.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap8.png","path":"img/ConcurrentHashMap8.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap9.png","path":"img/ConcurrentHashMap9.png","modified":1,"renderable":0},{"_id":"source/img/Condition2.png","path":"img/Condition2.png","modified":1,"renderable":0},{"_id":"source/img/Condition3.png","path":"img/Condition3.png","modified":1,"renderable":0},{"_id":"source/img/CopyOnWriteArrayList.png","path":"img/CopyOnWriteArrayList.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch1.png","path":"img/CountDownLatch1.png","modified":1,"renderable":0},{"_id":"source/img/DefaultFullHttpResponse.png","path":"img/DefaultFullHttpResponse.png","modified":1,"renderable":0},{"_id":"source/img/GzipPipline.png","path":"img/GzipPipline.png","modified":1,"renderable":0},{"_id":"source/img/HttpOutPutResponse.png","path":"img/HttpOutPutResponse.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue1.png","path":"img/LinkedTransferQueue1.png","modified":1,"renderable":0},{"_id":"source/img/HttpResponse_Byte.png","path":"img/HttpResponse_Byte.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue2.png","path":"img/LinkedTransferQueue2.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue4.png","path":"img/LinkedTransferQueue4.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue3.png","path":"img/LinkedTransferQueue3.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue8.png","path":"img/LinkedTransferQueue8.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue9.png","path":"img/LinkedTransferQueue9.png","modified":1,"renderable":0},{"_id":"source/img/Netty_Cycler2.png","path":"img/Netty_Cycler2.png","modified":1,"renderable":0},{"_id":"source/img/Netty堆外内存回收1.png","path":"img/Netty堆外内存回收1.png","modified":1,"renderable":0},{"_id":"source/img/Page_allocation.png","path":"img/Page_allocation.png","modified":1,"renderable":0},{"_id":"source/img/NioEventLoop1.png","path":"img/NioEventLoop1.png","modified":1,"renderable":0},{"_id":"source/img/PipeLine.png","path":"img/PipeLine.png","modified":1,"renderable":0},{"_id":"source/img/PipeLine1.png","path":"img/PipeLine1.png","modified":1,"renderable":0},{"_id":"source/img/PipeLine2.png","path":"img/PipeLine2.png","modified":1,"renderable":0},{"_id":"source/img/PoolChunk2.png","path":"img/PoolChunk2.png","modified":1,"renderable":0},{"_id":"source/img/PoolChunke_allocation_select.png","path":"img/PoolChunke_allocation_select.png","modified":1,"renderable":0},{"_id":"source/img/PoolSubpage.png","path":"img/PoolSubpage.png","modified":1,"renderable":0},{"_id":"source/img/Thrift帧.png","path":"img/Thrift帧.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase10.png","path":"img/git_rebase10.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase9.png","path":"img/git_rebase9.png","modified":1,"renderable":0},{"_id":"source/img/ico.png","path":"img/ico.png","modified":1,"renderable":0},{"_id":"source/img/git_reset.png","path":"img/git_reset.png","modified":1,"renderable":0},{"_id":"source/img/git_revert1.png","path":"img/git_revert1.png","modified":1,"renderable":0},{"_id":"source/img/mysql.jpeg","path":"img/mysql.jpeg","modified":1,"renderable":0},{"_id":"source/img/picture.jpg","path":"img/picture.jpg","modified":1,"renderable":0},{"_id":"source/img/日志没有数据","path":"img/日志没有数据","modified":1,"renderable":0},{"_id":"source/img/日志中心整体升级计划","path":"img/日志中心整体升级计划","modified":1,"renderable":0},{"_id":"source/图片xml/AQS","path":"图片xml/AQS","modified":1,"renderable":0},{"_id":"source/图片xml/Agent流程.xml","path":"图片xml/Agent流程.xml","modified":1,"renderable":0},{"_id":"source/图片xml/ASQ.xml","path":"图片xml/ASQ.xml","modified":1,"renderable":0},{"_id":"source/图片xml/AbstractOwnableSynchronizer _node队列.xml","path":"图片xml/AbstractOwnableSynchronizer _node队列.xml","modified":1,"renderable":0},{"_id":"source/图片xml/CopyOnWriteArrayList.xml","path":"图片xml/CopyOnWriteArrayList.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Condition.xml","path":"图片xml/Condition.xml","modified":1,"renderable":0},{"_id":"source/图片xml/ChannelOutboundBuffer","path":"图片xml/ChannelOutboundBuffer","modified":1,"renderable":0},{"_id":"source/图片xml/ES proxy分享.drawio","path":"图片xml/ES proxy分享.drawio","modified":1,"renderable":0},{"_id":"source/图片xml/CountDownLatch","path":"图片xml/CountDownLatch","modified":1,"renderable":0},{"_id":"source/图片xml/DefaultFullHttpResponse.xml","path":"图片xml/DefaultFullHttpResponse.xml","modified":1,"renderable":0},{"_id":"source/图片xml/CurrentHashMap.xml","path":"图片xml/CurrentHashMap.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Flink_slot_allocate","path":"图片xml/Flink_slot_allocate","modified":1,"renderable":0},{"_id":"source/图片xml/ES_cluster.xml","path":"图片xml/ES_cluster.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Flink_slot_allocate.drawio","path":"图片xml/Flink_slot_allocate.drawio","modified":1,"renderable":0},{"_id":"source/图片xml/GzipPipeline","path":"图片xml/GzipPipeline","modified":1,"renderable":0},{"_id":"source/图片xml/HttpOutPutResponse","path":"图片xml/HttpOutPutResponse","modified":1,"renderable":0},{"_id":"source/图片xml/Index_create.xml","path":"图片xml/Index_create.xml","modified":1,"renderable":0},{"_id":"source/图片xml/LinkedTransferQueue.xml","path":"图片xml/LinkedTransferQueue.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Netty Recycler.xml","path":"图片xml/Netty Recycler.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Netty内存回收.xml","path":"图片xml/Netty内存回收.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Netty图片xml.xml","path":"图片xml/Netty图片xml.xml","modified":1,"renderable":0},{"_id":"source/图片xml/NioEventLoop.xml","path":"图片xml/NioEventLoop.xml","modified":1,"renderable":0},{"_id":"source/图片xml/PipeLine.xml","path":"图片xml/PipeLine.xml","modified":1,"renderable":0},{"_id":"source/图片xml/PoolArea","path":"图片xml/PoolArea","modified":1,"renderable":0},{"_id":"source/图片xml/PoolChunk","path":"图片xml/PoolChunk","modified":1,"renderable":0},{"_id":"source/图片xml/PoolSubpage","path":"图片xml/PoolSubpage","modified":1,"renderable":0},{"_id":"source/图片xml/PoolThreadCache","path":"图片xml/PoolThreadCache","modified":1,"renderable":0},{"_id":"source/图片xml/Proxya框架","path":"图片xml/Proxya框架","modified":1,"renderable":0},{"_id":"source/图片xml/Proxy数据流","path":"图片xml/Proxy数据流","modified":1,"renderable":0},{"_id":"source/图片xml/ReetrantReadWriterLock","path":"图片xml/ReetrantReadWriterLock","modified":1,"renderable":0},{"_id":"source/图片xml/ServerBootStrap1.xml","path":"图片xml/ServerBootStrap1.xml","modified":1,"renderable":0},{"_id":"source/图片xml/Response_Byte.xml","path":"图片xml/Response_Byte.xml","modified":1,"renderable":0},{"_id":"source/图片xml/ServerBootstrap.xml","path":"图片xml/ServerBootstrap.xml","modified":1,"renderable":0},{"_id":"source/图片xml/TaskManager1.drawio","path":"图片xml/TaskManager1.drawio","modified":1,"renderable":0},{"_id":"source/图片xml/Transport_Http.xml","path":"图片xml/Transport_Http.xml","modified":1,"renderable":0},{"_id":"source/图片xml/allocation+recovery","path":"图片xml/allocation+recovery","modified":1,"renderable":0},{"_id":"source/图片xml/data struct","path":"图片xml/data struct","modified":1,"renderable":0},{"_id":"source/图片xml/bulk_index_all.xml","path":"图片xml/bulk_index_all.xml","modified":1,"renderable":0},{"_id":"source/图片xml/cluster_meta_update_module.xml","path":"图片xml/cluster_meta_update_module.xml","modified":1,"renderable":0},{"_id":"source/图片xml/create_index.xml","path":"图片xml/create_index.xml","modified":1,"renderable":0},{"_id":"source/图片xml/es_Netty_http.xml","path":"图片xml/es_Netty_http.xml","modified":1,"renderable":0},{"_id":"source/图片xml/es优先级.xml","path":"图片xml/es优先级.xml","modified":1,"renderable":0},{"_id":"source/图片xml/git rebase.xml","path":"图片xml/git rebase.xml","modified":1,"renderable":0},{"_id":"source/图片xml/master.xml","path":"图片xml/master.xml","modified":1,"renderable":0},{"_id":"source/图片xml/select_master.xml","path":"图片xml/select_master.xml","modified":1,"renderable":0},{"_id":"source/图片xml/proxy查询限流.drawio","path":"图片xml/proxy查询限流.drawio","modified":1,"renderable":0},{"_id":"source/图片xml/thrift帧的格式.xml","path":"图片xml/thrift帧的格式.xml","modified":1,"renderable":0},{"_id":"source/图片xml/wait_notift.xml","path":"图片xml/wait_notift.xml","modified":1,"renderable":0},{"_id":"source/图片xml/实时方向架构改变.drawio","path":"图片xml/实时方向架构改变.drawio","modified":1,"renderable":0},{"_id":"source/图片xml/分片状态转变","path":"图片xml/分片状态转变","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"source/img/1506269128432DX_IM_FILE_0.png","path":"img/1506269128432DX_IM_FILE_0.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap16.png","path":"img/ConcurrentHashMap16.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap17.png","path":"img/ConcurrentHashMap17.png","modified":1,"renderable":0},{"_id":"source/img/ConcurrentHashMap18.png","path":"img/ConcurrentHashMap18.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch0.png","path":"img/CountDownLatch0.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch3.png","path":"img/CountDownLatch3.png","modified":1,"renderable":0},{"_id":"source/img/Flink_slot_allocate.png","path":"img/Flink_slot_allocate.png","modified":1,"renderable":0},{"_id":"source/img/Flink_slot_allocate1.png","path":"img/Flink_slot_allocate1.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue10.png","path":"img/LinkedTransferQueue10.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue5.png","path":"img/LinkedTransferQueue5.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue7.png","path":"img/LinkedTransferQueue7.png","modified":1,"renderable":0},{"_id":"source/img/LinkedTransferQueue6.png","path":"img/LinkedTransferQueue6.png","modified":1,"renderable":0},{"_id":"source/img/LockSupport1.png","path":"img/LockSupport1.png","modified":1,"renderable":0},{"_id":"source/img/Netty_Cycler1.png","path":"img/Netty_Cycler1.png","modified":1,"renderable":0},{"_id":"source/img/Netty概念.png","path":"img/Netty概念.png","modified":1,"renderable":0},{"_id":"source/img/PoolArea1.png","path":"img/PoolArea1.png","modified":1,"renderable":0},{"_id":"source/img/PoolChunk1.png","path":"img/PoolChunk1.png","modified":1,"renderable":0},{"_id":"source/img/PoolThreadCache2.png","path":"img/PoolThreadCache2.png","modified":1,"renderable":0},{"_id":"source/img/ReetrantReadWriteLock1.png","path":"img/ReetrantReadWriteLock1.png","modified":1,"renderable":0},{"_id":"source/img/ServerBootstrap1.png","path":"img/ServerBootstrap1.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase2.png","path":"img/git_rebase2.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase3.png","path":"img/git_rebase3.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase6.png","path":"img/git_rebase6.png","modified":1,"renderable":0},{"_id":"source/img/wait_notify.png","path":"img/wait_notify.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/img/AQS3.png","path":"img/AQS3.png","modified":1,"renderable":0},{"_id":"source/img/AQS4.png","path":"img/AQS4.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch2.png","path":"img/CountDownLatch2.png","modified":1,"renderable":0},{"_id":"source/img/CountDownLatch4.png","path":"img/CountDownLatch4.png","modified":1,"renderable":0},{"_id":"source/img/PoolArea.png","path":"img/PoolArea.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase5.png","path":"img/git_rebase5.png","modified":1,"renderable":0},{"_id":"source/img/git_rebase7.png","path":"img/git_rebase7.png","modified":1,"renderable":0},{"_id":"source/img/jvm_memory_leak1.png","path":"img/jvm_memory_leak1.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/picture.jpg","path":"img/picture.jpg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"source/img/Condition1.png","path":"img/Condition1.png","modified":1,"renderable":0},{"_id":"source/img/Netty堆外内存回收.png","path":"img/Netty堆外内存回收.png","modified":1,"renderable":0},{"_id":"source/img/jvm_memory_leak.png","path":"img/jvm_memory_leak.png","modified":1,"renderable":0},{"_id":"source/img/myself.png","path":"img/myself.png","modified":1,"renderable":0},{"_id":"source/img/Flink_Graph.png","path":"img/Flink_Graph.png","modified":1,"renderable":0},{"_id":"source/img/Hackathon5.0 - A05 - 识途.pdf","path":"img/Hackathon5.0 - A05 - 识途.pdf","modified":1,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"f25196fa14cc69e4eab2fb37aaac368c65dda5ae","modified":1547984980000},{"_id":"source/picture1.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263650000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1525263651000},{"_id":"themes/yilia/.DS_Store","hash":"fe4c6dc77d2c896f41c82d607eb8feeaf9fa50c5","modified":1525263651000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1525263651000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1525263651000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1525263651000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1525263651000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1525263651000},{"_id":"themes/yilia/_config.yml","hash":"a1d160d512df69a99656dcdb3b3957e91516c88c","modified":1544153219000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1525263651000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1525263651000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1525263651000},{"_id":"source/_posts/.DS_Store","hash":"d63a533cba18ccba7c6e42c836671be347f8f907","modified":1542640500000},{"_id":"source/_posts/ConcurrentHashMap-put过程介绍.md","hash":"eef67bc053af000ddc05abb0391757eaf7ff2f31","modified":1559751857000},{"_id":"source/_posts/ConcurrentHashMap扩容过程介绍.md","hash":"7a1993ec6a6b16acb14553552d704d54d5e17652","modified":1559751857000},{"_id":"source/_posts/ConcurrentHashMap红黑树原理介绍.md","hash":"c8414c9d15a25469a5a8ee364a383c27fa52e1f7","modified":1559751857000},{"_id":"source/_posts/Condition原理解读.md","hash":"34caa4b9fd079ec8f0ce73cc6f30da10f5e8302e","modified":1559751857000},{"_id":"source/_posts/CountDownLatch源码解读.md","hash":"c048401e253ce42362224fb996deb01f02ec276c","modified":1559751857000},{"_id":"source/_posts/DirectByteBuffer堆外内存详解.md","hash":"9b856db6925db5e922a91d6aa0a44a9cd0f853e9","modified":1559751857000},{"_id":"source/_posts/ES原理-下线节点时分片并发rebalance的思考.md","hash":"9601276116ac9fe5318b7e6ae99f4bfafc0de208","modified":1561337029000},{"_id":"source/_posts/ES索引创建流程.md","hash":"ce9f0bdd339ed2db67081091ebf0e081cc16a8ec","modified":1559732452000},{"_id":"source/_posts/Flink原理-Akka通信模块.md","hash":"f2b93aa1def9da880792da6c27a37ce732d36a80","modified":1559784144000},{"_id":"source/_posts/Flink原理-Container启动命令内存参数分析.md","hash":"8224ac1f24a93517448c4d63e2a687f716cdfecb","modified":1561343152000},{"_id":"source/_posts/Flink原理-TaskManager处理SubTask.md","hash":"3fce647969bf457128c1d0fd628f88702ecb07be","modified":1559918763000},{"_id":"source/_posts/JAVA-JNI实现hello-world.md","hash":"bf1eedfbc6c09e57b594f26364936b745950a961","modified":1559752683000},{"_id":"source/_posts/Flink原理-slot分配.md","hash":"7c987ba36856227fde5b7d4ff2d754fed4eea16c","modified":1559844216000},{"_id":"source/_posts/Java线程知识小结.md","hash":"5a4bb87f3c5fa362a339638876b0e0054944b08a","modified":1559752683000},{"_id":"source/_posts/LinkedTransferQueue原理解读.md","hash":"4142c89a20bc451865bf921bf979151642870001","modified":1559752683000},{"_id":"source/_posts/LockSupport源码解读.md","hash":"c9bb07c92e419b0cf8fd4e0ea2d30fbb2859c8be","modified":1559752683000},{"_id":"source/_posts/Netty-Http通信编码源码阅读.md","hash":"4da1159b54536b29572fc174dbb8fef141c513f0","modified":1559752683000},{"_id":"source/_posts/Netty-Http通信解码源码阅读.md","hash":"c1d1de74c123a65fcf7e803eb09739db56006058","modified":1559732452000},{"_id":"source/_posts/Netty-PoolChunk原理探究.md","hash":"d37fd2e56eee1ee6e1e8456f2694faf322fdf45c","modified":1559752683000},{"_id":"source/_posts/Netty-PoolSubpage原理探究.md","hash":"7807007d8f43d7a5b7cbefbdc17b6f9cf30b668f","modified":1559752683000},{"_id":"source/_posts/Netty-PoolThreadCache源码探究.md","hash":"31f6a37ed6778478a58ae482e574444b2dfab342","modified":1559752683000},{"_id":"source/_posts/Netty内存回收原理解读.md","hash":"16404de143e284d41b6695db964023a97271b81c","modified":1559752683000},{"_id":"source/_posts/Netty内存学习.md","hash":"3634df6fa2681d5c19c9b5b1c2319b7a902c0ac1","modified":1559752683000},{"_id":"source/_posts/Netty对象回收池Recycler原理详解.md","hash":"379043306ad2cc82b4ce270a016779fa9108218f","modified":1559752683000},{"_id":"source/_posts/Netty通信编解码源码解读.md","hash":"1cff6f23453032a04c7224523c8f8770fa37eb87","modified":1559752683000},{"_id":"source/_posts/NioEventLoop篇.md","hash":"d1cf2329e4e33dd0325ebddb07b2dd6211abb74d","modified":1559752683000},{"_id":"source/_posts/ReentrantLock源码解读.md","hash":"ef6bde8edb23d8de9bef4f0950c0252cd7ece42b","modified":1561194608000},{"_id":"source/_posts/ReentrantReadWriteLock源码解读.md","hash":"574495ba907d5e0ff64a4b76b03396ec86b990eb","modified":1559752683000},{"_id":"source/_posts/Semaphore源码解读.md","hash":"af3c8f1defa41c43ac902334bdcac863ad7ced5f","modified":1559752683000},{"_id":"source/_posts/copyOnWriteArrayListy原理解读.md","hash":"9635d2a781c8f3fa10c40d9967cfcad0bf144bfe","modified":1559751857000},{"_id":"source/_posts/ServerBootstrap初始篇.md","hash":"02b952b6f51cd1c3c72b75aa7e88dad6a85ec00f","modified":1559752683000},{"_id":"source/_posts/maven插件学习.md","hash":"57e09a9c020b411c0543806b83179c9b91143475","modified":1562391156000},{"_id":"source/_posts/gdb调试java基本用法.md","hash":"27a097b44ac4219359b88e9ffd5557c9ce64f632","modified":1559752683000},{"_id":"source/_posts/git-基本命令学习心得.md","hash":"161fc0d009a2b32e061d78185f8167efc809bd23","modified":1559752683000},{"_id":"source/_posts/jvm内存泄露排查工具.md","hash":"7a314fcfd74a021640822d7820c00f7af82a30a9","modified":1559751857000},{"_id":"source/img/.DS_Store","hash":"081e9b850a4f68652fe7b3c739c5f6bc8fa42178","modified":1547980396000},{"_id":"source/img/AQS.png","hash":"989a1b6f6d49fb5bf52e16dfd42a8bbea8ae7605","modified":1544493564000},{"_id":"source/img/AQS2.png","hash":"2e28e6c282db6fa9596d06696ab8ec183a24c394","modified":1537758111000},{"_id":"source/img/AQS1.png","hash":"3b2ebf04a5ebb9e309c3c9ac8f0d5bcf652493c1","modified":1537717695000},{"_id":"source/img/AQS5.png","hash":"07113ccc55381606f449bb5563cbd5e20f92e3b4","modified":1538090746000},{"_id":"source/img/ChannelOutboundBuffer.png","hash":"5e011bf9c26769a55a925277115e7e41716fdf62","modified":1546505658000},{"_id":"source/img/AQS6.png","hash":"c3b91f5c74a13f08fa638ebf244e3f3415839f91","modified":1538294485000},{"_id":"source/img/ConcurrentHashMap10.png","hash":"62d222084f0009e60409d8d3d8cef951f51f0470","modified":1538848298000},{"_id":"source/gitment.browser.js","hash":"b15dfd8a35c949cbe1f23f2b49e78905c7525c82","modified":1544150460000},{"_id":"source/img/ConcurrentHashMap11.png","hash":"84ae8806f7facf54cfdad41ba372a266ac3e6c0f","modified":1538849160000},{"_id":"source/img/ConcurrentHashMap12.png","hash":"1a44be80d89b99ae0bd93d25ee0551ba61ad1221","modified":1538879505000},{"_id":"source/img/ConcurrentHashMap13.png","hash":"f2fd896539ba2ed55cbd04d6af398a019e9424a9","modified":1538879602000},{"_id":"source/img/ConcurrentHashMap14.png","hash":"62d222084f0009e60409d8d3d8cef951f51f0470","modified":1538879634000},{"_id":"source/img/ConcurrentHashMap15.png","hash":"84ae8806f7facf54cfdad41ba372a266ac3e6c0f","modified":1538879653000},{"_id":"source/img/ConcurrentHashMap2.png","hash":"4822efe2340a4ec75f2f8129dead79cea0f01fa5","modified":1538824583000},{"_id":"source/img/ConcurrentHashMap3.png","hash":"cd1a4ae600f039599f6e87d35366ec559f8b300a","modified":1538824582000},{"_id":"source/img/ConcurrentHashMap5.png","hash":"52606d03071fb517a7cfd14ac9db880cd426fa3c","modified":1538844568000},{"_id":"source/img/ConcurrentHashMap6.png","hash":"6cb3a8aac8e39a35057592489fe7a83a069541bd","modified":1538844576000},{"_id":"source/img/ConcurrentHashMap7.png","hash":"dfdbf02f811a3ac2d2e4fda3aaab30352674c5f9","modified":1538844582000},{"_id":"source/img/ConcurrentHashMap8.png","hash":"1a44be80d89b99ae0bd93d25ee0551ba61ad1221","modified":1538848700000},{"_id":"source/img/ConcurrentHashMap9.png","hash":"f2fd896539ba2ed55cbd04d6af398a019e9424a9","modified":1538848290000},{"_id":"source/img/Condition2.png","hash":"7ee6bd76950187978fd4632dd49324df42ee6497","modified":1544494056000},{"_id":"source/img/Condition3.png","hash":"a2245e050217f6eec29588eededbb70d4e3c60cd","modified":1546392946000},{"_id":"source/img/CopyOnWriteArrayList.png","hash":"0274b31135dded04d2971f45fbf6af64312ed4b6","modified":1539743940000},{"_id":"source/img/CountDownLatch1.png","hash":"10dbb17f285dcd8d8498191ff900fef64123207b","modified":1537805620000},{"_id":"source/img/DefaultFullHttpResponse.png","hash":"ca2d1ce85bede2d1216ccf85a740a2e9df964473","modified":1542680748000},{"_id":"source/img/GzipPipline.png","hash":"7727bdc8ce605cfd1ed29803cdc57a743da7a3f1","modified":1542682932000},{"_id":"source/img/HttpOutPutResponse.png","hash":"8eac083b80000158db62a67c3901a0c6073b39c3","modified":1542683101000},{"_id":"source/img/LinkedTransferQueue1.png","hash":"4c36bad88992e532329e8a0ba3a44fe840df6c31","modified":1545565484000},{"_id":"source/img/HttpResponse_Byte.png","hash":"c6832fadd65d192d253d714b970049e6a361555e","modified":1542683844000},{"_id":"source/img/LinkedTransferQueue2.png","hash":"fbf89284e9369970b3fd27adfc940086136a3b45","modified":1545565516000},{"_id":"source/img/LinkedTransferQueue4.png","hash":"24337b0a5fc0dde8fa02098649c47268c511fe95","modified":1545565580000},{"_id":"source/img/LinkedTransferQueue3.png","hash":"a799665d8f5cc523487145c2e7c2aa1495536ba8","modified":1545565554000},{"_id":"source/img/LinkedTransferQueue8.png","hash":"a12827f25cef6de0af942dfe2ddbde7e3bd6ec39","modified":1545616618000},{"_id":"source/img/LinkedTransferQueue9.png","hash":"bf9b639fe51b7394d9b531da2894a89c6f96809d","modified":1545616629000},{"_id":"source/img/Netty_Cycler2.png","hash":"b33db536946a73e76ef6504499e7203fdc090892","modified":1547980387000},{"_id":"source/img/Netty堆外内存回收1.png","hash":"eab662121b87d94347bb659e225b8e1562479377","modified":1547517836000},{"_id":"source/img/Page_allocation.png","hash":"02abe6207fb3435aab54d6bb82116591220c45ea","modified":1532150655000},{"_id":"source/img/NioEventLoop1.png","hash":"6445b614900beabeccb8ebd09ee33332e568b389","modified":1545963867000},{"_id":"source/img/PipeLine.png","hash":"9198da105676d6a430eb9794d280842f27b62750","modified":1545787886000},{"_id":"source/img/PipeLine1.png","hash":"7567757a37dc91098eb57e73c8df44f60eb4e514","modified":1545787901000},{"_id":"source/img/PipeLine2.png","hash":"baa141b784f75be102f10c74942fb3eeb0585311","modified":1545792144000},{"_id":"source/img/PoolChunk2.png","hash":"d9b05860debefb8ec3a11a43f89cfd8e5513a8a3","modified":1546606344000},{"_id":"source/img/PoolChunke_allocation_select.png","hash":"15f3e21c8a2c3d801ced1c7477b30de62378522a","modified":1542680444000},{"_id":"source/img/PoolSubpage.png","hash":"06a66ab03ef681fc02f18161c8a62eb211ce4029","modified":1532247980000},{"_id":"source/img/README.md","hash":"43bcbcd7caa4c9975f674f7af32ac9e8316e1dcb","modified":1526210825000},{"_id":"source/img/Thrift帧.png","hash":"aa82dc974d7acf2ddbdb619738dc3a123f49a7af","modified":1542685342000},{"_id":"source/img/git_rebase10.png","hash":"5fe73b8d5690e82b5aa1fcf7c0e532715f6a8c8b","modified":1539228026000},{"_id":"source/img/git_rebase9.png","hash":"5de038d1ba99f4687f0fdd8f06584a6d8c347989","modified":1539227643000},{"_id":"source/img/ico.png","hash":"bd609189ddff823f048092b680a3b8d5b886bb97","modified":1531651163000},{"_id":"source/img/git_reset.png","hash":"d7080a0012ef3691f104551621446f994f84d290","modified":1539498325000},{"_id":"source/img/git_revert1.png","hash":"b8b39bad790edea30086f8af454448231633d148","modified":1539445726000},{"_id":"source/img/mysql.jpeg","hash":"6f50b4c867d0f125e9d32856b2b85b2197534dd4","modified":1542640449000},{"_id":"source/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263650000},{"_id":"source/img/日志没有数据","hash":"69bb10328b6d304c863450f0e01a0715987efcc6","modified":1542347180000},{"_id":"source/img/日志中心整体升级计划","hash":"adda3a7f647f36a2763b87893d7f4299bb625b50","modified":1536644944000},{"_id":"source/图片xml/AQS","hash":"daa3a34c6b5bee10f47ad69182175e2fe28013ad","modified":1544493534000},{"_id":"source/图片xml/Agent流程.xml","hash":"6ef1493cc9c571f7059a8deb750d59b29bd7534e","modified":1526210825000},{"_id":"source/图片xml/ASQ.xml","hash":"4fa732511725aa041ef3d7cd841ac60a997ef6c8","modified":1538294355000},{"_id":"source/图片xml/AbstractOwnableSynchronizer _node队列.xml","hash":"bb7bc7879db5251ccdfd4a00decfef19115ad406","modified":1526210825000},{"_id":"source/图片xml/CopyOnWriteArrayList.xml","hash":"32665a262bfc0ff292bea085672da216558f3ef8","modified":1539743925000},{"_id":"source/图片xml/Condition.xml","hash":"bbf36bdf0ded5ca87378727c13c7c30c2a5b2488","modified":1546391803000},{"_id":"source/图片xml/ChannelOutboundBuffer","hash":"f42b476e392bc1e638ab93bd781bda70b6a7a62e","modified":1546505634000},{"_id":"source/图片xml/ES proxy分享.drawio","hash":"629226ff75de5510aad88217becc4855c732e2a3","modified":1562230394000},{"_id":"source/图片xml/CountDownLatch","hash":"821b13717b469805c61d9dfc55103765f7815583","modified":1538151977000},{"_id":"source/图片xml/DefaultFullHttpResponse.xml","hash":"5140cf74570518ecc4ccda58a537a9d89cecd44b","modified":1542680718000},{"_id":"source/图片xml/CurrentHashMap.xml","hash":"65279ee05bc8362b999f9143d598cd9ddcaec118","modified":1539000282000},{"_id":"source/图片xml/Flink_slot_allocate","hash":"c965e21ffc53e615945fcc7656dbbc9282daa4d2","modified":1559319871000},{"_id":"source/图片xml/ES_cluster.xml","hash":"8963b3182fb60c8677e0809e7d5dc4a9bd08c54d","modified":1526210825000},{"_id":"source/图片xml/Flink_slot_allocate.drawio","hash":"dcceec9ece9994cd32c349fece65501c60773f27","modified":1559526354000},{"_id":"source/图片xml/GzipPipeline","hash":"6490a1dc212f290408373be760c83a1c2cf96d55","modified":1542682903000},{"_id":"source/图片xml/HttpOutPutResponse","hash":"c376e0aa69c3b49ac6811edc41826410031aa0db","modified":1542683069000},{"_id":"source/图片xml/Index_create.xml","hash":"8e4c1013a296e264a64d466fa05a92498f02524d","modified":1526210825000},{"_id":"source/图片xml/LinkedTransferQueue.xml","hash":"785e3da00164a76d18101c7363bcc8c073fab9c6","modified":1545616652000},{"_id":"source/图片xml/Netty Recycler.xml","hash":"0b15c744c073ffbccd6b9933937238bcb66caf85","modified":1547980326000},{"_id":"source/图片xml/Netty内存回收.xml","hash":"3661197b74e9ac2500a426018940461dd590ffad","modified":1547517814000},{"_id":"source/图片xml/Netty图片xml.xml","hash":"a7ce4300bae665a69a8150993b51f41db6fc4229","modified":1546514208000},{"_id":"source/图片xml/NioEventLoop.xml","hash":"88fd6d3f77211982c2c6720030882b8d14eb041d","modified":1546011418000},{"_id":"source/图片xml/PipeLine.xml","hash":"ce5edb10b9fdbaf14f70c9d691f480fcd5162e30","modified":1526210825000},{"_id":"source/图片xml/PoolArea","hash":"473f4d46559e6649ada601e03d51067ea8f80acd","modified":1546656230000},{"_id":"source/图片xml/PoolChunk","hash":"042448156e1da66c754b28edd2fbed786db37951","modified":1546608446000},{"_id":"source/图片xml/PoolSubpage","hash":"67fadcc2c78230c0593df3607d2c5f8bf940fa5d","modified":1532247933000},{"_id":"source/图片xml/PoolThreadCache","hash":"88baa049d4df1dc95f2bb62c3ab6250cc8a17952","modified":1546615253000},{"_id":"source/图片xml/Proxya框架","hash":"eff92a88891deb1cb824d637f563b496c77eb3db","modified":1546392117000},{"_id":"source/图片xml/Proxy数据流","hash":"f3423b0ee860a827b691b8ac042f132ebee58e1b","modified":1533795329000},{"_id":"source/图片xml/ReetrantReadWriterLock","hash":"f1f33555b5302a1a89ec5bbecedad854eaee4e8b","modified":1538224150000},{"_id":"source/图片xml/ServerBootStrap1.xml","hash":"72fb7c7ddbaa8e4eeaa3f857b132fea17fbbf4b8","modified":1526210825000},{"_id":"source/图片xml/Response_Byte.xml","hash":"d1e764165d31a9b21ff3cbc522b42dc8a0693a7c","modified":1561964976000},{"_id":"source/图片xml/ServerBootstrap.xml","hash":"c2c79fe6f7e79d13809da475ad37af112e8155c2","modified":1546013971000},{"_id":"source/图片xml/TaskManager1.drawio","hash":"3b36938563dbdf26cad209c065cf85aa43cd6485","modified":1559754050000},{"_id":"source/图片xml/Transport_Http.xml","hash":"aa294d5ddf1825da58ae5d78719948ad1090b03b","modified":1526210825000},{"_id":"source/图片xml/allocation+recovery","hash":"547661e058bd444edea0ff6f6f9179a3293013ff","modified":1528482541000},{"_id":"source/图片xml/data struct","hash":"464d4fbbdd34ebdfb38a2c7571fba7f7ddee3f44","modified":1562036384000},{"_id":"source/图片xml/bulk_index_all.xml","hash":"7468b9e1e9a29423aec554aaf15fe7f149b8b8fe","modified":1526210825000},{"_id":"source/图片xml/cluster_meta_update_module.xml","hash":"e0ff2be14eb879ebf80635ecffbca26729ae48dd","modified":1526210825000},{"_id":"source/图片xml/create_index.xml","hash":"71fa7a14d15d44f9f40db465b0ec7d6e2ebf5981","modified":1526210825000},{"_id":"source/图片xml/es_Netty_http.xml","hash":"03afe5bf6d36a0a560f7c83c1fc11cee7ccc9ed1","modified":1526210825000},{"_id":"source/图片xml/es优先级.xml","hash":"14a9ee45077ed5350daa1c49f65b15ce03c3c4a5","modified":1526210825000},{"_id":"source/图片xml/git rebase.xml","hash":"5d202a8cfa469395a97a9087b63981f1778e1cb4","modified":1546834737000},{"_id":"source/图片xml/master.xml","hash":"881bb015256acb3d76375fc225336263bedd8a98","modified":1526210825000},{"_id":"source/图片xml/select_master.xml","hash":"c7d79610bb04a1040e9fcb4f73653445cd9e000b","modified":1526210825000},{"_id":"source/图片xml/proxy查询限流.drawio","hash":"a110039b78334663fe357f484b65569fba352c42","modified":1555990404000},{"_id":"source/图片xml/thrift帧的格式.xml","hash":"105123edb9a3c1d452f76a52d88483791689c036","modified":1542685323000},{"_id":"source/图片xml/wait_notift.xml","hash":"73a916e7fe81f104e680f104c97115406be16b1e","modified":1540737136000},{"_id":"source/图片xml/实时方向架构改变.drawio","hash":"f918428bbb6fd193d1a443e7a5df7daf96293dd7","modified":1553591818000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1525263651000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525263651000},{"_id":"source/图片xml/分片状态转变","hash":"27337beceac91caabaa5aa1b5e275188a47945b8","modified":1526210825000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525263651000},{"_id":"themes/yilia/.git/index","hash":"17dc582f429cb43dfcbb8f3b60b9a96a4f89d907","modified":1525266725000},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1525263651000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1525263651000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1525263651000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1525263651000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1525263651000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1525263651000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1525263651000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1525263651000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1525263651000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1525263651000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1525263651000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1525263651000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1525263651000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1525263651000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1525263651000},{"_id":"themes/yilia/source/.DS_Store","hash":"2e125b278324bee8e26c58283773ccf57ca50f62","modified":1525263651000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"921bc17621c63162b58b2493d6d9237177b3b5ac","modified":1559317536000},{"_id":"themes/yilia/source-src/.DS_Store","hash":"eb59082b0722091794ca7702b8f86389094ac262","modified":1525263651000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1525263651000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1525263651000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1525263651000},{"_id":"source/img/1506269128432DX_IM_FILE_0.png","hash":"ca117a42810f1564752b2622cd2485ae15e9e186","modified":1525263650000},{"_id":"source/img/ConcurrentHashMap16.png","hash":"ec6b7fc33bc976ad37f0cd69f65964c63bc5a821","modified":1538922429000},{"_id":"source/img/ConcurrentHashMap17.png","hash":"66ec63acad7a0e78f73b9c30991f886d82edd069","modified":1538966493000},{"_id":"source/img/ConcurrentHashMap18.png","hash":"0fc5024b45d9fa616646f42f2db97709c86e3782","modified":1539000280000},{"_id":"source/img/CountDownLatch0.png","hash":"3097e7ab3284c9960317c13a6bfb9af5afa3aaea","modified":1538151451000},{"_id":"source/img/CountDownLatch3.png","hash":"8307e47a0185e27b3bc1ab2f84d8400bb6449aee","modified":1538152076000},{"_id":"source/img/Flink_slot_allocate.png","hash":"f1d2c113b2e6b82f685bf539cc4c1f714cf6414c","modified":1559404077000},{"_id":"source/img/Flink_slot_allocate1.png","hash":"db84afa9d93ce1f5d16726f1df141f01799edddb","modified":1559526407000},{"_id":"source/img/LinkedTransferQueue10.png","hash":"00bc4a75ed9d01b01593156851e6d892155fcf79","modified":1545616638000},{"_id":"source/img/LinkedTransferQueue5.png","hash":"44cdc91142384715e747fc78a2e64180997e08db","modified":1545565678000},{"_id":"source/img/LinkedTransferQueue7.png","hash":"c7687ff8021f6b61f59152ffc5fa179ef0b098b8","modified":1545566073000},{"_id":"source/img/LinkedTransferQueue6.png","hash":"6ee42f8ca4c7474574f55604f079e5b2c73d1c0d","modified":1545566043000},{"_id":"source/img/LockSupport1.png","hash":"8820bd94196d4983406ae076736d0f2243df235c","modified":1543936135000},{"_id":"source/img/Netty_Cycler1.png","hash":"998419e9e89c6258b8d0b36e4437d5b567d64ee5","modified":1547880335000},{"_id":"source/img/Netty概念.png","hash":"99244a9371b8d5bf29d01cc103f79441ead35765","modified":1525263650000},{"_id":"source/img/PoolArea1.png","hash":"0b3a104302c26465c676c11c8d4355b210041b55","modified":1546615289000},{"_id":"source/img/PoolChunk1.png","hash":"237bddfafe82f1f28bcda1f139bbf68ca27a9dd7","modified":1542680364000},{"_id":"source/img/PoolThreadCache2.png","hash":"6a239ec0847ba0b679b9e4f7125ceccea50b6593","modified":1542680514000},{"_id":"source/img/ReetrantReadWriteLock1.png","hash":"3d991d2ad556be4e64a58f9826074ef2a501dd20","modified":1538224311000},{"_id":"source/img/ServerBootstrap1.png","hash":"1c87215286add8936d6576c26e3ffffac6cc1fec","modified":1546014262000},{"_id":"source/img/git_rebase2.png","hash":"e4edffd5c99694218a6d50f929ec2f59a7a4fcd2","modified":1546834791000},{"_id":"source/img/git_rebase3.png","hash":"e432a6e20b0d4e633b169f3435dac2c9d11dcd2a","modified":1539017753000},{"_id":"source/img/git_rebase6.png","hash":"4c9d4815796eda540c30e7eed5156cd0b7f50335","modified":1539020224000},{"_id":"source/img/wait_notify.png","hash":"03c21ae8b0dd5c9e32a8916a464f09653a7dc023","modified":1540737189000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525263651000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1525263651000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1525263651000},{"_id":"source/img/AQS3.png","hash":"4e4d461d8702318103dd106d1bdd57bc8f407f9c","modified":1537760136000},{"_id":"source/img/AQS4.png","hash":"665b486a14443998e5447fe7543ed5ad4a78efb5","modified":1538090743000},{"_id":"source/img/CountDownLatch2.png","hash":"d5e4bb7080fc88f1854a360b02f2058974a1da82","modified":1538151460000},{"_id":"source/img/CountDownLatch4.png","hash":"e505b3f12f273bae92e03ca32f95f7c31ef888c5","modified":1538152081000},{"_id":"source/img/PoolArea.png","hash":"256c59a0435e0a7ce361182e2599f79da8ca79e0","modified":1546656727000},{"_id":"source/img/git_rebase5.png","hash":"2ab765ef7ecdd5bdcdfa66d3e7590a70ca79f7a2","modified":1539018526000},{"_id":"source/img/git_rebase7.png","hash":"00bec1a241ccfaa1f978a9266441708e492c5ef1","modified":1539055570000},{"_id":"source/img/jvm_memory_leak1.png","hash":"28c75d8c18f2cea1b0ba90b31227510a9e6be800","modified":1548724322000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525263651000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1525263651000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"fb596195f6dd34b2996d95076fc1cda8073dc73a","modified":1559317819000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"899793bb3a75b4058b6aee41d3ca043e35774f7d","modified":1540621268000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"5e66afb25890f891563549bcd8d761690f89ec8b","modified":1532085014000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"6db9a57437b52023ae655d38e26c7031ffd63b34","modified":1542678182000},{"_id":"themes/yilia/layout/_partial/left-col.ejs_tmp","hash":"25ce2169f8516d90a9ddd6f268f2f6a71172916b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1525263651000},{"_id":"themes/yilia/source/img/.DS_Store","hash":"9a730f22af5f133f1235459006bbcf9661e6099b","modified":1525263651000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1525263651000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1525263651000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1525263651000},{"_id":"themes/yilia/source/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263651000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1525263651000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1525263651000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1525263651000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1525263651000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1525263651000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1525263651000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1525263651000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1525263651000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1525263651000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1525263651000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1525263651000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1525263651000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1525263651000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1525263651000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1525263651000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1525263651000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1525263651000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1525263651000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1525263651000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1525263651000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1525263651000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1525263651000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1525263651000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1525263651000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1525263651000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1525263651000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1525263651000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1525263651000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1525263651000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1525263651000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1525263651000},{"_id":"source/img/Condition1.png","hash":"ba7bc6d83fa576d303d5ff1daf636592b07073a4","modified":1544356308000},{"_id":"source/img/Netty堆外内存回收.png","hash":"0fc152bdf287895a9b51bce921208dc1a1f66cc6","modified":1547516061000},{"_id":"source/img/jvm_memory_leak.png","hash":"1ceb4fcb2ee4bc4d890838f874983c9ab6578441","modified":1548641512000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1525263651000},{"_id":"source/img/myself.png","hash":"4cce9a791da592a5407ce7c363172e0f11be23f4","modified":1542675478000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1525263651000},{"_id":"themes/yilia/.git/objects/pack/pack-81482136cf6b522e44e787dc9c868acfcb7c25a6.idx","hash":"192241e09a6504ede0484bccfdb070cc40a2907a","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e2aa1c00b6eae28e4dfd211a91a8a2f77ff1d644","modified":1544152826000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs_tmp","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1531665823000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1525263651000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1525263651000},{"_id":"source/img/Flink_Graph.png","hash":"7f8b44a003076927cf8e7fc7081fdad7126e8b47","modified":1558533886000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"source/img/Hackathon5.0 - A05 - 识途.pdf","hash":"8b2982a00acd93a738dcce33da25d82ad36f2d48","modified":1560167357000},{"_id":"themes/yilia/.git/objects/pack/pack-81482136cf6b522e44e787dc9c868acfcb7c25a6.pack","hash":"a3546a4602f8b7a5a61f5bdc6ff14c6523cf6441","modified":1525263651000},{"_id":"public/gitment.browser.js","hash":"1be27d8b3731bcbda03276dc13b39d9fbb9d3584","modified":1562391180613},{"_id":"public/baidusitemap.xml","hash":"90f0a9fe24117a705123bd19968b0042736d2491","modified":1562391181746},{"_id":"public/content.json","hash":"b7336860c9c196df407708ab7f23126d48f0e57a","modified":1562391181871},{"_id":"public/sitemap.xml","hash":"32e05f2540976d408e7e33e9711891ec049e648d","modified":1562391181871},{"_id":"public/img/README.html","hash":"a84035c50ceed321f89a80dc70bfe53fd7c16dca","modified":1562391181916},{"_id":"public/2019/07/06/maven插件学习/index.html","hash":"259374634e470fbf0cacfd4b745ab8d520a10a4a","modified":1562391181916},{"_id":"public/2019/06/16/ES原理-下线节点时分片并发rebalance的思考/index.html","hash":"81388ab805ab0afe544c5958c6a1a072db2762d5","modified":1562391181916},{"_id":"public/2019/06/08/Flink原理-Container启动命令内存参数分析/index.html","hash":"3f5c72b3ee2180abd1c81dcea817cad606910853","modified":1562391181916},{"_id":"public/2019/04/20/Flink原理-Akka通信模块/index.html","hash":"24f44a9a65223390748acaa003c44ce3878ebb88","modified":1562391181917},{"_id":"public/2019/04/03/Flink原理-TaskManager处理SubTask/index.html","hash":"2b3f06bae3c69c8b0866b623bcd9b213074cf26f","modified":1562391181917},{"_id":"public/2019/03/12/Flink原理-slot分配/index.html","hash":"304f5f466b205eedd675abce805a05a58a3c029e","modified":1562391181917},{"_id":"public/2019/01/16/Netty对象回收池Recycler原理详解/index.html","hash":"a4cb4bb5c99553c4b6eeca669ad0b5e5178e807c","modified":1562391181917},{"_id":"public/2019/01/12/Netty内存回收原理解读/index.html","hash":"87783033b2fc26048b81abeb6d85e049109b8a82","modified":1562391181918},{"_id":"public/2018/12/15/LinkedTransferQueue原理解读/index.html","hash":"e08e991310f4c16f0315632148b9d8a4262c4389","modified":1562391181918},{"_id":"public/2018/11/10/LockSupport源码解读/index.html","hash":"56a674162c311846914f50025ad51caaaadcdd5c","modified":1562391181918},{"_id":"public/2018/07/27/DirectByteBuffer堆外内存详解/index.html","hash":"b740d5ce371a86aa1527bd35b45ac635c4aaa819","modified":1562391181919},{"_id":"public/2018/07/22/Netty-PoolSubpage原理探究/index.html","hash":"1f8cec409186e2bbb8bcaa9c60cc7bc33214e111","modified":1562391181919},{"_id":"public/2018/07/20/Netty-PoolChunk原理探究/index.html","hash":"22c3cba29800832fd488abeaea1de584754fc449","modified":1562391181920},{"_id":"public/2018/07/14/Netty-PoolThreadCache源码探究/index.html","hash":"c7a1e25967fa27a1653d6dc5bad63ac1ea7f3392","modified":1562391181920},{"_id":"public/2018/05/23/Netty内存学习/index.html","hash":"909e2122b1c28bb9be69fb4bd312025ee59119bb","modified":1562391181920},{"_id":"public/2018/05/04/Netty-Http通信编码源码阅读/index.html","hash":"ec1fb85bb70619e874c4d09bfaa6735deeb529e7","modified":1562391181920},{"_id":"public/2018/04/16/Netty-Http通信解码源码阅读/index.html","hash":"4527116d443d3b75d03a5af6907ec9285e866d33","modified":1562391181921},{"_id":"public/2018/03/25/Netty通信编解码源码解读/index.html","hash":"70dc73c14a2b73a4ef40afffdc1c0ee9ae7105b5","modified":1562391181921},{"_id":"public/2018/01/22/NioEventLoop篇/index.html","hash":"c46fa8d0020fdd12122775f359372506eb3043e1","modified":1562391181922},{"_id":"public/2018/01/14/ServerBootstrap初始篇/index.html","hash":"59d0489406681ed6b5a550e110db59fe2878c511","modified":1562391181922},{"_id":"public/2017/12/17/ES索引创建流程/index.html","hash":"7e576506413bc2d20a4f0c0c6faabf590dfc9906","modified":1562391181922},{"_id":"public/2017/11/14/ConcurrentHashMap扩容过程介绍/index.html","hash":"7481ad4e760bb32f5937817df9dd359102b2837b","modified":1562391181922},{"_id":"public/2017/11/06/ConcurrentHashMap红黑树原理介绍/index.html","hash":"aa6e499e385eb59f285795c7c68a11ea36cd7367","modified":1562391181922},{"_id":"public/2017/11/05/ConcurrentHashMap-put过程介绍/index.html","hash":"dbe2d3f28d5f8ba011a06590eb9837ce280929eb","modified":1562391181922},{"_id":"public/2017/10/02/Condition原理解读/index.html","hash":"df6d78519943d72f633ea78d9f365cad30b2dd80","modified":1562391181923},{"_id":"public/2017/09/17/copyOnWriteArrayListy原理解读/index.html","hash":"a67603fcad47312e5cc9119cd25a0a843957f671","modified":1562391181923},{"_id":"public/2017/08/24/CountDownLatch源码解读/index.html","hash":"8f639cc7ba294c197c2b84bdadd9dcfdf57d6716","modified":1562391181923},{"_id":"public/2017/08/15/Semaphore源码解读/index.html","hash":"7c1082e3be87bbc979e6b75e8a1583362445fbfd","modified":1562391181923},{"_id":"public/2017/07/28/ReentrantReadWriteLock源码解读/index.html","hash":"40cd04a27ce8d1d05b3325c3eb784491243f09d3","modified":1562391181923},{"_id":"public/2017/07/23/ReentrantLock源码解读/index.html","hash":"b7d4bed46399cdbac6de49062d2d1bc8b90e7556","modified":1562391181923},{"_id":"public/2017/06/15/JAVA-JNI实现hello-world/index.html","hash":"4852a4db0afd3349394b61e042ea82d7c3b1a34a","modified":1562391181923},{"_id":"public/2017/03/08/git-基本命令学习心得/index.html","hash":"206094898041cd077d7fe1fee3d4ee3071188e77","modified":1562391181923},{"_id":"public/2016/12/20/gdb调试java基本用法/index.html","hash":"e1b19527770a1c5dffbc25fd2cd1eba0548a826c","modified":1562391181924},{"_id":"public/2016/12/15/jvm内存泄露排查工具/index.html","hash":"5577e8598265a636184339313097dfe012e32870","modified":1562391181924},{"_id":"public/2016/10/27/Java线程知识小结/index.html","hash":"8bd1fe6c68543ada075d69a6bf0d51e08b47da88","modified":1562391181924},{"_id":"public/archives/index.html","hash":"92791f9e2e45806856579751c47e0a78d4a3e1c2","modified":1562391181924},{"_id":"public/archives/page/2/index.html","hash":"9809313562869cc2cdb05907c5bc598902339a95","modified":1562391181924},{"_id":"public/archives/page/3/index.html","hash":"0b648e4252b1e9af13d82e14ccfaecf47d9ca3cd","modified":1562391181924},{"_id":"public/archives/2016/10/index.html","hash":"f6a8cc89705493ddc52d71d52793cbecf102d8b2","modified":1562391181925},{"_id":"public/archives/page/4/index.html","hash":"25bc07e6ba4b131d511701a885d95c1a3ad0eaeb","modified":1562391181925},{"_id":"public/archives/2016/index.html","hash":"b1979b4925cec4265444f827216605e8377c09cf","modified":1562391181925},{"_id":"public/archives/2016/12/index.html","hash":"6c2ea2bc3dcc35de6829bfd8b3b26d1d2aed6313","modified":1562391181925},{"_id":"public/archives/2017/index.html","hash":"db0173c46063c0d8ea1a3ae913e84abd1561a967","modified":1562391181925},{"_id":"public/archives/2017/page/2/index.html","hash":"5b6f4f9bc86eeedadbe125204dc8cb355ec147d0","modified":1562391181925},{"_id":"public/archives/2017/03/index.html","hash":"50ab0c9212f7cfcd19a3edd620fc97de45169f8a","modified":1562391181925},{"_id":"public/archives/2017/06/index.html","hash":"27ba2317c52ec386663af6a33234fb1fc4f93976","modified":1562391181926},{"_id":"public/archives/2017/07/index.html","hash":"423d12564ecdab6388eecb7fdafa196657d799bb","modified":1562391181926},{"_id":"public/archives/2017/08/index.html","hash":"41d203160e11c3d5f84ff0eb1a45dc6b6caab104","modified":1562391181926},{"_id":"public/archives/2017/09/index.html","hash":"009f30793306da755dcce340c375bf9dec62be16","modified":1562391181926},{"_id":"public/archives/2017/10/index.html","hash":"49fca68011b4ec1379469aa55aa0cb1307f5a14e","modified":1562391181926},{"_id":"public/archives/2017/11/index.html","hash":"ac6d79fb6fae626c89e230fc9da6a5d39395cd58","modified":1562391181926},{"_id":"public/archives/2017/12/index.html","hash":"bb72cd0e55aa340aea942a4ba54761198e399092","modified":1562391181926},{"_id":"public/archives/2018/index.html","hash":"ce0f7f1fc139b95ff0017063acefab3325770cde","modified":1562391181926},{"_id":"public/archives/2018/page/2/index.html","hash":"1e59fc5d2fee68b70c79493154b0be5c39788d67","modified":1562391181926},{"_id":"public/archives/2018/01/index.html","hash":"14b7c907d9758723a522be197b2eb474555e1bb7","modified":1562391181927},{"_id":"public/archives/2018/03/index.html","hash":"e0d0d3d513305aa2b2d6e4026ace7770075f836b","modified":1562391181927},{"_id":"public/archives/2018/04/index.html","hash":"832b69bdc7687e3b899ddf8dcf54b431802c9bad","modified":1562391181927},{"_id":"public/archives/2018/05/index.html","hash":"5a48048cd12b579e16b348056741ad0efdda5995","modified":1562391181927},{"_id":"public/archives/2018/07/index.html","hash":"f4ad9217c214907ef721400a56add0571f108882","modified":1562391181927},{"_id":"public/archives/2018/11/index.html","hash":"29f6a4cbbd4e3e1a205ed9a40aeecc26f4373184","modified":1562391181927},{"_id":"public/archives/2018/12/index.html","hash":"d8338aed1f7cc8fdfc4c6918b9decb5fa934119e","modified":1562391181928},{"_id":"public/archives/2019/index.html","hash":"8d102b9c73583ce2ed0ad82c9458aa8a8ca4c459","modified":1562391181928},{"_id":"public/archives/2019/01/index.html","hash":"bce9e92cacf3f14d5e04dd8826f4ae72d21ff0b9","modified":1562391181928},{"_id":"public/archives/2019/03/index.html","hash":"4356a91b6941fa0dd4753c4a3da6de183d9034af","modified":1562391181928},{"_id":"public/archives/2019/04/index.html","hash":"c8eef798dc4702acb9d112ee44057575257c35bf","modified":1562391181928},{"_id":"public/archives/2019/06/index.html","hash":"2011835f2131c81d0fb0bc78cc2bb97d44f4196e","modified":1562391181928},{"_id":"public/archives/2019/07/index.html","hash":"54d97931653018cf3c1bd00de35da73d8ba3d6b3","modified":1562391181928},{"_id":"public/index.html","hash":"a6c86e07768d80ca025913b3546004b40dac1f9d","modified":1562391181928},{"_id":"public/page/3/index.html","hash":"8e69a8791baae5a9d409526a8116ace1d7538425","modified":1562391181928},{"_id":"public/page/2/index.html","hash":"2018fcc27bc0255e977ed4c901ef123857f6237f","modified":1562391181929},{"_id":"public/page/4/index.html","hash":"50f7661cb9447570d7de33637ca2f0dea53ec50d","modified":1562391181929},{"_id":"public/tags/Flink、Slot分配、SubTask申请slot-SubTask部署/index.html","hash":"d76bf9cb10dc5ec910536827167469a0ccde4cb1","modified":1562391181929},{"_id":"public/tags/LockSupport/index.html","hash":"ce8334f4bca29bed9a7f8c0f8ead46db025b882b","modified":1562391181929},{"_id":"public/tags/PoolArena/index.html","hash":"f6e17c2fb2aa4af4337243db8c5a74ad45ab8d20","modified":1562391181929},{"_id":"public/tags/Cycler/index.html","hash":"e6553df531e9521512f6710365c4e4a0503050e6","modified":1562391181930},{"_id":"public/tags/NioEventLoop/index.html","hash":"1d9d0c2f0c71cb299131d4389294ad30725c8235","modified":1562391181930},{"_id":"public/tags/ReentrantLock/index.html","hash":"5adba415835e4bfdd1c186f50d3450fd08c9961a","modified":1562391181930},{"_id":"public/tags/netty4-ServerBootstrap-Initiale/index.html","hash":"d9caba053ad80319864aa6864016012d427adf06","modified":1562391181930},{"_id":"public/tags/gdb/index.html","hash":"ba45efd2b4bd9ff563560fbe3d41f7157d7f0cc5","modified":1562391181930},{"_id":"public/tags/perftools、jcmd、pmap/index.html","hash":"ea1de36f73330e09095023f20318ee581a7d6c3e","modified":1562391181930},{"_id":"public/tags/git-rebase-cherry-pick-reset-checkout/index.html","hash":"33f0cafaf41a0b39f4e94cffd9ccacc3072dc4b8","modified":1562391181931},{"_id":"public/picture1.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1562391181954},{"_id":"public/img/AQS.png","hash":"989a1b6f6d49fb5bf52e16dfd42a8bbea8ae7605","modified":1562391181954},{"_id":"public/img/AQS2.png","hash":"2e28e6c282db6fa9596d06696ab8ec183a24c394","modified":1562391181954},{"_id":"public/img/AQS1.png","hash":"3b2ebf04a5ebb9e309c3c9ac8f0d5bcf652493c1","modified":1562391181955},{"_id":"public/img/AQS5.png","hash":"07113ccc55381606f449bb5563cbd5e20f92e3b4","modified":1562391181955},{"_id":"public/img/ChannelOutboundBuffer.png","hash":"5e011bf9c26769a55a925277115e7e41716fdf62","modified":1562391181955},{"_id":"public/img/AQS6.png","hash":"c3b91f5c74a13f08fa638ebf244e3f3415839f91","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap10.png","hash":"62d222084f0009e60409d8d3d8cef951f51f0470","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap11.png","hash":"84ae8806f7facf54cfdad41ba372a266ac3e6c0f","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap12.png","hash":"1a44be80d89b99ae0bd93d25ee0551ba61ad1221","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap13.png","hash":"f2fd896539ba2ed55cbd04d6af398a019e9424a9","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap14.png","hash":"62d222084f0009e60409d8d3d8cef951f51f0470","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap15.png","hash":"84ae8806f7facf54cfdad41ba372a266ac3e6c0f","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap2.png","hash":"4822efe2340a4ec75f2f8129dead79cea0f01fa5","modified":1562391181955},{"_id":"public/img/ConcurrentHashMap3.png","hash":"cd1a4ae600f039599f6e87d35366ec559f8b300a","modified":1562391181956},{"_id":"public/img/ConcurrentHashMap5.png","hash":"52606d03071fb517a7cfd14ac9db880cd426fa3c","modified":1562391181956},{"_id":"public/img/ConcurrentHashMap6.png","hash":"6cb3a8aac8e39a35057592489fe7a83a069541bd","modified":1562391181956},{"_id":"public/img/ConcurrentHashMap7.png","hash":"dfdbf02f811a3ac2d2e4fda3aaab30352674c5f9","modified":1562391181956},{"_id":"public/img/ConcurrentHashMap8.png","hash":"1a44be80d89b99ae0bd93d25ee0551ba61ad1221","modified":1562391181956},{"_id":"public/img/ConcurrentHashMap9.png","hash":"f2fd896539ba2ed55cbd04d6af398a019e9424a9","modified":1562391181956},{"_id":"public/img/Condition2.png","hash":"7ee6bd76950187978fd4632dd49324df42ee6497","modified":1562391181956},{"_id":"public/img/Condition3.png","hash":"a2245e050217f6eec29588eededbb70d4e3c60cd","modified":1562391181956},{"_id":"public/img/CopyOnWriteArrayList.png","hash":"0274b31135dded04d2971f45fbf6af64312ed4b6","modified":1562391181956},{"_id":"public/img/CountDownLatch1.png","hash":"10dbb17f285dcd8d8498191ff900fef64123207b","modified":1562391181956},{"_id":"public/img/DefaultFullHttpResponse.png","hash":"ca2d1ce85bede2d1216ccf85a740a2e9df964473","modified":1562391181956},{"_id":"public/img/GzipPipline.png","hash":"7727bdc8ce605cfd1ed29803cdc57a743da7a3f1","modified":1562391181957},{"_id":"public/img/HttpOutPutResponse.png","hash":"8eac083b80000158db62a67c3901a0c6073b39c3","modified":1562391181957},{"_id":"public/img/LinkedTransferQueue1.png","hash":"4c36bad88992e532329e8a0ba3a44fe840df6c31","modified":1562391181957},{"_id":"public/img/HttpResponse_Byte.png","hash":"c6832fadd65d192d253d714b970049e6a361555e","modified":1562391181957},{"_id":"public/img/LinkedTransferQueue2.png","hash":"fbf89284e9369970b3fd27adfc940086136a3b45","modified":1562391181957},{"_id":"public/img/LinkedTransferQueue3.png","hash":"a799665d8f5cc523487145c2e7c2aa1495536ba8","modified":1562391181957},{"_id":"public/img/LinkedTransferQueue8.png","hash":"a12827f25cef6de0af942dfe2ddbde7e3bd6ec39","modified":1562391181957},{"_id":"public/img/LinkedTransferQueue4.png","hash":"24337b0a5fc0dde8fa02098649c47268c511fe95","modified":1562391181957},{"_id":"public/img/LinkedTransferQueue9.png","hash":"bf9b639fe51b7394d9b531da2894a89c6f96809d","modified":1562391181957},{"_id":"public/img/Netty_Cycler2.png","hash":"b33db536946a73e76ef6504499e7203fdc090892","modified":1562391181957},{"_id":"public/img/Netty堆外内存回收1.png","hash":"eab662121b87d94347bb659e225b8e1562479377","modified":1562391181957},{"_id":"public/img/Page_allocation.png","hash":"02abe6207fb3435aab54d6bb82116591220c45ea","modified":1562391181957},{"_id":"public/img/NioEventLoop1.png","hash":"6445b614900beabeccb8ebd09ee33332e568b389","modified":1562391181958},{"_id":"public/img/PipeLine.png","hash":"9198da105676d6a430eb9794d280842f27b62750","modified":1562391181958},{"_id":"public/img/PipeLine1.png","hash":"7567757a37dc91098eb57e73c8df44f60eb4e514","modified":1562391181958},{"_id":"public/img/PipeLine2.png","hash":"baa141b784f75be102f10c74942fb3eeb0585311","modified":1562391181958},{"_id":"public/img/PoolChunk2.png","hash":"d9b05860debefb8ec3a11a43f89cfd8e5513a8a3","modified":1562391181958},{"_id":"public/img/PoolChunke_allocation_select.png","hash":"15f3e21c8a2c3d801ced1c7477b30de62378522a","modified":1562391181958},{"_id":"public/img/Thrift帧.png","hash":"aa82dc974d7acf2ddbdb619738dc3a123f49a7af","modified":1562391181958},{"_id":"public/img/PoolSubpage.png","hash":"06a66ab03ef681fc02f18161c8a62eb211ce4029","modified":1562391181958},{"_id":"public/img/git_rebase10.png","hash":"5fe73b8d5690e82b5aa1fcf7c0e532715f6a8c8b","modified":1562391181958},{"_id":"public/img/ico.png","hash":"bd609189ddff823f048092b680a3b8d5b886bb97","modified":1562391181958},{"_id":"public/img/git_rebase9.png","hash":"5de038d1ba99f4687f0fdd8f06584a6d8c347989","modified":1562391181958},{"_id":"public/img/git_revert1.png","hash":"b8b39bad790edea30086f8af454448231633d148","modified":1562391181958},{"_id":"public/img/mysql.jpeg","hash":"6f50b4c867d0f125e9d32856b2b85b2197534dd4","modified":1562391181958},{"_id":"public/img/日志没有数据","hash":"69bb10328b6d304c863450f0e01a0715987efcc6","modified":1562391181958},{"_id":"public/图片xml/Agent流程.xml","hash":"6ef1493cc9c571f7059a8deb750d59b29bd7534e","modified":1562391181959},{"_id":"public/img/日志中心整体升级计划","hash":"adda3a7f647f36a2763b87893d7f4299bb625b50","modified":1562391181959},{"_id":"public/图片xml/AQS","hash":"daa3a34c6b5bee10f47ad69182175e2fe28013ad","modified":1562391181959},{"_id":"public/图片xml/ASQ.xml","hash":"4fa732511725aa041ef3d7cd841ac60a997ef6c8","modified":1562391181959},{"_id":"public/图片xml/AbstractOwnableSynchronizer _node队列.xml","hash":"bb7bc7879db5251ccdfd4a00decfef19115ad406","modified":1562391181959},{"_id":"public/图片xml/CopyOnWriteArrayList.xml","hash":"32665a262bfc0ff292bea085672da216558f3ef8","modified":1562391181959},{"_id":"public/图片xml/Condition.xml","hash":"bbf36bdf0ded5ca87378727c13c7c30c2a5b2488","modified":1562391181959},{"_id":"public/图片xml/ChannelOutboundBuffer","hash":"f42b476e392bc1e638ab93bd781bda70b6a7a62e","modified":1562391181959},{"_id":"public/图片xml/CountDownLatch","hash":"821b13717b469805c61d9dfc55103765f7815583","modified":1562391181959},{"_id":"public/img/git_reset.png","hash":"d7080a0012ef3691f104551621446f994f84d290","modified":1562391181959},{"_id":"public/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1562391181959},{"_id":"public/图片xml/ES proxy分享.drawio","hash":"629226ff75de5510aad88217becc4855c732e2a3","modified":1562391181959},{"_id":"public/图片xml/DefaultFullHttpResponse.xml","hash":"5140cf74570518ecc4ccda58a537a9d89cecd44b","modified":1562391181959},{"_id":"public/图片xml/CurrentHashMap.xml","hash":"65279ee05bc8362b999f9143d598cd9ddcaec118","modified":1562391181959},{"_id":"public/图片xml/Flink_slot_allocate","hash":"c965e21ffc53e615945fcc7656dbbc9282daa4d2","modified":1562391181959},{"_id":"public/图片xml/ES_cluster.xml","hash":"8963b3182fb60c8677e0809e7d5dc4a9bd08c54d","modified":1562391181959},{"_id":"public/图片xml/Flink_slot_allocate.drawio","hash":"dcceec9ece9994cd32c349fece65501c60773f27","modified":1562391181959},{"_id":"public/图片xml/HttpOutPutResponse","hash":"c376e0aa69c3b49ac6811edc41826410031aa0db","modified":1562391181959},{"_id":"public/图片xml/GzipPipeline","hash":"6490a1dc212f290408373be760c83a1c2cf96d55","modified":1562391181959},{"_id":"public/图片xml/Index_create.xml","hash":"8e4c1013a296e264a64d466fa05a92498f02524d","modified":1562391181959},{"_id":"public/图片xml/Netty Recycler.xml","hash":"0b15c744c073ffbccd6b9933937238bcb66caf85","modified":1562391181959},{"_id":"public/图片xml/LinkedTransferQueue.xml","hash":"785e3da00164a76d18101c7363bcc8c073fab9c6","modified":1562391181959},{"_id":"public/图片xml/Netty内存回收.xml","hash":"3661197b74e9ac2500a426018940461dd590ffad","modified":1562391181959},{"_id":"public/图片xml/Netty图片xml.xml","hash":"a7ce4300bae665a69a8150993b51f41db6fc4229","modified":1562391181959},{"_id":"public/图片xml/NioEventLoop.xml","hash":"88fd6d3f77211982c2c6720030882b8d14eb041d","modified":1562391181959},{"_id":"public/图片xml/PoolArea","hash":"473f4d46559e6649ada601e03d51067ea8f80acd","modified":1562391181959},{"_id":"public/图片xml/PipeLine.xml","hash":"ce5edb10b9fdbaf14f70c9d691f480fcd5162e30","modified":1562391181959},{"_id":"public/图片xml/PoolChunk","hash":"042448156e1da66c754b28edd2fbed786db37951","modified":1562391181960},{"_id":"public/图片xml/PoolSubpage","hash":"67fadcc2c78230c0593df3607d2c5f8bf940fa5d","modified":1562391181960},{"_id":"public/图片xml/PoolThreadCache","hash":"88baa049d4df1dc95f2bb62c3ab6250cc8a17952","modified":1562391181960},{"_id":"public/图片xml/Proxya框架","hash":"eff92a88891deb1cb824d637f563b496c77eb3db","modified":1562391181960},{"_id":"public/图片xml/Proxy数据流","hash":"f3423b0ee860a827b691b8ac042f132ebee58e1b","modified":1562391181960},{"_id":"public/图片xml/ReetrantReadWriterLock","hash":"f1f33555b5302a1a89ec5bbecedad854eaee4e8b","modified":1562391181960},{"_id":"public/图片xml/ServerBootStrap1.xml","hash":"72fb7c7ddbaa8e4eeaa3f857b132fea17fbbf4b8","modified":1562391181960},{"_id":"public/图片xml/Response_Byte.xml","hash":"d1e764165d31a9b21ff3cbc522b42dc8a0693a7c","modified":1562391181960},{"_id":"public/图片xml/ServerBootstrap.xml","hash":"c2c79fe6f7e79d13809da475ad37af112e8155c2","modified":1562391181960},{"_id":"public/图片xml/TaskManager1.drawio","hash":"3b36938563dbdf26cad209c065cf85aa43cd6485","modified":1562391181960},{"_id":"public/图片xml/Transport_Http.xml","hash":"aa294d5ddf1825da58ae5d78719948ad1090b03b","modified":1562391181960},{"_id":"public/图片xml/allocation+recovery","hash":"547661e058bd444edea0ff6f6f9179a3293013ff","modified":1562391181960},{"_id":"public/图片xml/data struct","hash":"464d4fbbdd34ebdfb38a2c7571fba7f7ddee3f44","modified":1562391181960},{"_id":"public/图片xml/bulk_index_all.xml","hash":"7468b9e1e9a29423aec554aaf15fe7f149b8b8fe","modified":1562391181960},{"_id":"public/图片xml/cluster_meta_update_module.xml","hash":"e0ff2be14eb879ebf80635ecffbca26729ae48dd","modified":1562391181960},{"_id":"public/图片xml/create_index.xml","hash":"71fa7a14d15d44f9f40db465b0ec7d6e2ebf5981","modified":1562391181960},{"_id":"public/图片xml/es_Netty_http.xml","hash":"03afe5bf6d36a0a560f7c83c1fc11cee7ccc9ed1","modified":1562391181960},{"_id":"public/图片xml/es优先级.xml","hash":"14a9ee45077ed5350daa1c49f65b15ce03c3c4a5","modified":1562391181960},{"_id":"public/图片xml/git rebase.xml","hash":"5d202a8cfa469395a97a9087b63981f1778e1cb4","modified":1562391181960},{"_id":"public/图片xml/master.xml","hash":"881bb015256acb3d76375fc225336263bedd8a98","modified":1562391181960},{"_id":"public/图片xml/select_master.xml","hash":"c7d79610bb04a1040e9fcb4f73653445cd9e000b","modified":1562391181960},{"_id":"public/图片xml/proxy查询限流.drawio","hash":"a110039b78334663fe357f484b65569fba352c42","modified":1562391181960},{"_id":"public/图片xml/thrift帧的格式.xml","hash":"105123edb9a3c1d452f76a52d88483791689c036","modified":1562391181960},{"_id":"public/图片xml/wait_notift.xml","hash":"73a916e7fe81f104e680f104c97115406be16b1e","modified":1562391181960},{"_id":"public/图片xml/实时方向架构改变.drawio","hash":"f918428bbb6fd193d1a443e7a5df7daf96293dd7","modified":1562391181960},{"_id":"public/图片xml/分片状态转变","hash":"27337beceac91caabaa5aa1b5e275188a47945b8","modified":1562391181960},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1562391181960},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1562391181960},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1562391181960},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1562391181960},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1562391181960},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1562391181960},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1562391181961},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1562391181961},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1562391181961},{"_id":"public/img/ConcurrentHashMap16.png","hash":"ec6b7fc33bc976ad37f0cd69f65964c63bc5a821","modified":1562391181972},{"_id":"public/img/1506269128432DX_IM_FILE_0.png","hash":"ca117a42810f1564752b2622cd2485ae15e9e186","modified":1562391181973},{"_id":"public/img/ConcurrentHashMap17.png","hash":"66ec63acad7a0e78f73b9c30991f886d82edd069","modified":1562391181974},{"_id":"public/img/ConcurrentHashMap18.png","hash":"0fc5024b45d9fa616646f42f2db97709c86e3782","modified":1562391181974},{"_id":"public/img/CountDownLatch0.png","hash":"3097e7ab3284c9960317c13a6bfb9af5afa3aaea","modified":1562391181974},{"_id":"public/img/CountDownLatch3.png","hash":"8307e47a0185e27b3bc1ab2f84d8400bb6449aee","modified":1562391181974},{"_id":"public/img/Flink_slot_allocate1.png","hash":"db84afa9d93ce1f5d16726f1df141f01799edddb","modified":1562391181974},{"_id":"public/img/Flink_slot_allocate.png","hash":"f1d2c113b2e6b82f685bf539cc4c1f714cf6414c","modified":1562391181974},{"_id":"public/img/LinkedTransferQueue10.png","hash":"00bc4a75ed9d01b01593156851e6d892155fcf79","modified":1562391181974},{"_id":"public/img/LinkedTransferQueue5.png","hash":"44cdc91142384715e747fc78a2e64180997e08db","modified":1562391181974},{"_id":"public/img/LinkedTransferQueue7.png","hash":"c7687ff8021f6b61f59152ffc5fa179ef0b098b8","modified":1562391181974},{"_id":"public/img/LinkedTransferQueue6.png","hash":"6ee42f8ca4c7474574f55604f079e5b2c73d1c0d","modified":1562391181974},{"_id":"public/img/LockSupport1.png","hash":"8820bd94196d4983406ae076736d0f2243df235c","modified":1562391181974},{"_id":"public/img/Netty_Cycler1.png","hash":"998419e9e89c6258b8d0b36e4437d5b567d64ee5","modified":1562391181974},{"_id":"public/img/Netty概念.png","hash":"99244a9371b8d5bf29d01cc103f79441ead35765","modified":1562391181974},{"_id":"public/img/PoolArea1.png","hash":"0b3a104302c26465c676c11c8d4355b210041b55","modified":1562391181974},{"_id":"public/img/PoolThreadCache2.png","hash":"6a239ec0847ba0b679b9e4f7125ceccea50b6593","modified":1562391181974},{"_id":"public/img/ReetrantReadWriteLock1.png","hash":"3d991d2ad556be4e64a58f9826074ef2a501dd20","modified":1562391181974},{"_id":"public/img/PoolChunk1.png","hash":"237bddfafe82f1f28bcda1f139bbf68ca27a9dd7","modified":1562391181975},{"_id":"public/img/ServerBootstrap1.png","hash":"1c87215286add8936d6576c26e3ffffac6cc1fec","modified":1562391181975},{"_id":"public/img/git_rebase2.png","hash":"e4edffd5c99694218a6d50f929ec2f59a7a4fcd2","modified":1562391181975},{"_id":"public/img/git_rebase3.png","hash":"e432a6e20b0d4e633b169f3435dac2c9d11dcd2a","modified":1562391181975},{"_id":"public/img/wait_notify.png","hash":"03c21ae8b0dd5c9e32a8916a464f09653a7dc023","modified":1562391181975},{"_id":"public/img/git_rebase6.png","hash":"4c9d4815796eda540c30e7eed5156cd0b7f50335","modified":1562391181975},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1562391181979},{"_id":"public/main.0cf68a.css","hash":"921bc17621c63162b58b2493d6d9237177b3b5ac","modified":1562391181979},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1562391181980},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1562391181980},{"_id":"public/img/AQS3.png","hash":"4e4d461d8702318103dd106d1bdd57bc8f407f9c","modified":1562391181980},{"_id":"public/img/CountDownLatch2.png","hash":"d5e4bb7080fc88f1854a360b02f2058974a1da82","modified":1562391181981},{"_id":"public/img/CountDownLatch4.png","hash":"e505b3f12f273bae92e03ca32f95f7c31ef888c5","modified":1562391181981},{"_id":"public/img/AQS4.png","hash":"665b486a14443998e5447fe7543ed5ad4a78efb5","modified":1562391181981},{"_id":"public/img/PoolArea.png","hash":"256c59a0435e0a7ce361182e2599f79da8ca79e0","modified":1562391181981},{"_id":"public/img/git_rebase5.png","hash":"2ab765ef7ecdd5bdcdfa66d3e7590a70ca79f7a2","modified":1562391181981},{"_id":"public/img/git_rebase7.png","hash":"00bec1a241ccfaa1f978a9266441708e492c5ef1","modified":1562391181981},{"_id":"public/img/jvm_memory_leak1.png","hash":"28c75d8c18f2cea1b0ba90b31227510a9e6be800","modified":1562391181982},{"_id":"public/img/Netty堆外内存回收.png","hash":"0fc152bdf287895a9b51bce921208dc1a1f66cc6","modified":1562391181983},{"_id":"public/img/Condition1.png","hash":"ba7bc6d83fa576d303d5ff1daf636592b07073a4","modified":1562391181984},{"_id":"public/img/jvm_memory_leak.png","hash":"1ceb4fcb2ee4bc4d890838f874983c9ab6578441","modified":1562391181984},{"_id":"public/img/myself.png","hash":"4cce9a791da592a5407ce7c363172e0f11be23f4","modified":1562391181993},{"_id":"public/img/Flink_Graph.png","hash":"7f8b44a003076927cf8e7fc7081fdad7126e8b47","modified":1562391182051},{"_id":"public/img/Hackathon5.0 - A05 - 识途.pdf","hash":"8b2982a00acd93a738dcce33da25d82ad36f2d48","modified":1562391182083}],"Category":[],"Data":[],"Page":[{"_content":"# picture\n使用draw.io画图保存的地方\n","source":"img/README.md","raw":"# picture\n使用draw.io画图保存的地方\n","date":"2019-01-02T01:20:05.000Z","updated":"2018-05-13T11:27:05.000Z","path":"img/README.html","title":"","comments":1,"layout":"page","_id":"cjxr3d8vk0001phu5eajrf6bx","content":"<h1 id=\"picture\"><a href=\"#picture\" class=\"headerlink\" title=\"picture\"></a>picture</h1><p>使用draw.io画图保存的地方</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"picture\"><a href=\"#picture\" class=\"headerlink\" title=\"picture\"></a>picture</h1><p>使用draw.io画图保存的地方</p>\n"},{"_content":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","source":"gitment.browser.js","raw":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action>\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action>\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet bound action>\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action>\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1, getMessage(\"m021\"));\n    invariant(!isModifierDescriptor(v), getMessage(\"m020\"));\n    if (isObservable(v)) return v;\n    var res = deepEnhancer(v, undefined, undefined);\n    if (res !== v) return res;\n    return observable.box(v);\n}\nvar IObservableFactories = function () {\n    function IObservableFactories() {}\n    IObservableFactories.prototype.box = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\"/>\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pageCount; i++) {\n        _loop(i);\n      }\n\n      if (currentPage < pageCount) {\n        var nextButton = document.createElement('li');\n        nextButton.className = 'gitment-comments-page-item';\n        nextButton.innerText = 'Next';\n        nextButton.onclick = function () {\n          return instance.goto(currentPage + 1);\n        };\n        pagination.appendChild(nextButton);\n      }\n\n      container.appendChild(pagination);\n    }\n  }\n\n  return container;\n}\n\nfunction renderEditor(_ref3, instance) {\n  var user = _ref3.user,\n      error = _ref3.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-editor-container';\n\n  var shouldDisable = user.login && !error ? '' : 'disabled';\n  var disabledTip = user.login ? '' : 'Login to Comment';\n  container.innerHTML = '\\n      ' + (user.login ? '<a class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\"/>\\n          </a>' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    </a>\\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" ' + shouldDisable + '></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" ' + shouldDisable + '>Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map","date":"2018-12-07T02:41:00.000Z","updated":"2018-12-07T02:41:00.000Z","path":"gitment.browser.js","layout":"false","title":"","comments":1,"_id":"cjxr3d8vp0003phu5locn4d79","content":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action=\"\">\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action=\"\">\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet=\"\" bound=\"\" action=\"\">\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action=\"\">\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1,=\"\" getmessage(\"m021\"));=\"\" invariant(!ismodifierdescriptor(v),=\"\" getmessage(\"m020\"));=\"\" if=\"\" (isobservable(v))=\"\" return=\"\" v;=\"\" var=\"\" res=\"deepEnhancer(v,\" undefined,=\"\" undefined);=\"\" (res=\"\" !=\"=\" v)=\"\" res;=\"\" observable.box(v);=\"\" }=\"\" iobservablefactories=\"function\" ()=\"\" {=\"\" function=\"\" iobservablefactories()=\"\" {}=\"\" iobservablefactories.prototype.box=\"function\" (value,=\"\" name)=\"\" (arguments.length=\"\"> 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\">\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pagecount;=\"\" i++)=\"\" {=\"\" _loop(i);=\"\" }=\"\" if=\"\" (currentpage=\"\" <=\"\" pagecount)=\"\" var=\"\" nextbutton=\"document.createElement('li');\" nextbutton.classname=\"gitment-comments-page-item\" ;=\"\" nextbutton.innertext=\"Next\" nextbutton.onclick=\"function\" ()=\"\" return=\"\" instance.goto(currentpage=\"\" +=\"\" 1);=\"\" };=\"\" pagination.appendchild(nextbutton);=\"\" container.appendchild(pagination);=\"\" container;=\"\" function=\"\" rendereditor(_ref3,=\"\" instance)=\"\" user=\"_ref3.user,\" error=\"_ref3.error;\" container=\"document.createElement('div');\" container.lang=\"en-US\" container.classname=\"gitment-container gitment-editor-container\" shoulddisable=\"user.login\" &&=\"\" !error=\"\" ?=\"\" ''=\"\" :=\"\" 'disabled';=\"\" disabledtip=\"user.login\" 'login=\"\" to=\"\" comment';=\"\" container.innerhtml=\"\\n      \" (user.login=\"\" '<a=\"\" class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\">\\n          ' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    \\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" '=\"\" +=\"\" shoulddisable=\"\"></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" '=\"\" +=\"\" shoulddisable=\"\">Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map</=></=></unnamed></not></unnamed></unnamed>","site":{"data":{}},"excerpt":"","more":"var Gitment =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar LS_ACCESS_TOKEN_KEY = exports.LS_ACCESS_TOKEN_KEY = 'gitment-comments-token';\nvar LS_USER_KEY = exports.LS_USER_KEY = 'gitment-user-info';\n\nvar NOT_INITIALIZED_ERROR = exports.NOT_INITIALIZED_ERROR = new Error('Comments Not Initialized');\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar __extends = undefined && undefined.__extends || function () {\n    var extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (d, b) {\n        d.__proto__ = b;\n    } || function (d, b) {\n        for (var p in b) {\n            if (b.hasOwnProperty(p)) d[p] = b[p];\n        }\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() {\n            this.constructor = d;\n        }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n}();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nregisterGlobals();\nexports.extras = {\n    allowStateChanges: allowStateChanges,\n    deepEqual: deepEqual,\n    getAtom: getAtom,\n    getDebugName: getDebugName,\n    getDependencyTree: getDependencyTree,\n    getAdministration: getAdministration,\n    getGlobalState: getGlobalState,\n    getObserverTree: getObserverTree,\n    isComputingDerivation: isComputingDerivation,\n    isSpyEnabled: isSpyEnabled,\n    onReactionError: onReactionError,\n    resetGlobalState: resetGlobalState,\n    shareGlobalState: shareGlobalState,\n    spyReport: spyReport,\n    spyReportEnd: spyReportEnd,\n    spyReportStart: spyReportStart,\n    setReactionScheduler: setReactionScheduler\n};\nif ((typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === \"undefined\" ? \"undefined\" : _typeof(__MOBX_DEVTOOLS_GLOBAL_HOOK__)) === \"object\") {\n    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx(module.exports);\n}\nmodule.exports.default = module.exports;\nvar actionFieldDecorator = createClassPropertyDecorator(function (target, key, value, args, originalDescriptor) {\n    var actionName = args && args.length === 1 ? args[0] : value.name || key || \"<unnamed action=\"\">\";\n    var wrappedAction = action(actionName, value);\n    addHiddenProp(target, key, wrappedAction);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, true);\nvar boundActionDecorator = createClassPropertyDecorator(function (target, key, value) {\n    defineBoundAction(target, key, value);\n}, function (key) {\n    return this[key];\n}, function () {\n    invariant(false, getMessage(\"m001\"));\n}, false, false);\nvar action = function action(arg1, arg2, arg3, arg4) {\n    if (arguments.length === 1 && typeof arg1 === \"function\") return createAction(arg1.name || \"<unnamed action=\"\">\", arg1);\n    if (arguments.length === 2 && typeof arg2 === \"function\") return createAction(arg1, arg2);\n    if (arguments.length === 1 && typeof arg1 === \"string\") return namedActionDecorator(arg1);\n    return namedActionDecorator(arg2).apply(null, arguments);\n};\nexports.action = action;\naction.bound = function boundAction(arg1, arg2, arg3) {\n    if (typeof arg1 === \"function\") {\n        var action_1 = createAction(\"<not yet=\"\" bound=\"\" action=\"\">\", arg1);\n        action_1.autoBind = true;\n        return action_1;\n    }\n    return boundActionDecorator.apply(null, arguments);\n};\nfunction namedActionDecorator(name) {\n    return function (target, prop, descriptor) {\n        if (descriptor && typeof descriptor.value === \"function\") {\n            descriptor.value = createAction(name, descriptor.value);\n            descriptor.enumerable = false;\n            descriptor.configurable = true;\n            return descriptor;\n        }\n        return actionFieldDecorator(name).apply(this, arguments);\n    };\n}\nfunction runInAction(arg1, arg2, arg3) {\n    var actionName = typeof arg1 === \"string\" ? arg1 : arg1.name || \"<unnamed action=\"\">\";\n    var fn = typeof arg1 === \"function\" ? arg1 : arg2;\n    var scope = typeof arg1 === \"function\" ? arg2 : arg3;\n    invariant(typeof fn === \"function\", getMessage(\"m002\"));\n    invariant(fn.length === 0, getMessage(\"m003\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    return executeAction(actionName, fn, scope, undefined);\n}\nexports.runInAction = runInAction;\nfunction isAction(thing) {\n    return typeof thing === \"function\" && thing.isMobxAction === true;\n}\nexports.isAction = isAction;\nfunction defineBoundAction(target, propertyName, fn) {\n    var res = function res() {\n        return executeAction(propertyName, fn, target, arguments);\n    };\n    res.isMobxAction = true;\n    addHiddenProp(target, propertyName, res);\n}\nfunction autorun(arg1, arg2, arg3) {\n    var name, view, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        view = arg2;\n        scope = arg3;\n    } else {\n        name = arg1.name || \"Autorun@\" + getNextId();\n        view = arg1;\n        scope = arg2;\n    }\n    invariant(typeof view === \"function\", getMessage(\"m004\"));\n    invariant(isAction(view) === false, getMessage(\"m005\"));\n    if (scope) view = view.bind(scope);\n    var reaction = new Reaction(name, function () {\n        this.track(reactionRunner);\n    });\n    function reactionRunner() {\n        view(reaction);\n    }\n    reaction.schedule();\n    return reaction.getDisposer();\n}\nexports.autorun = autorun;\nfunction when(arg1, arg2, arg3, arg4) {\n    var name, predicate, effect, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        predicate = arg2;\n        effect = arg3;\n        scope = arg4;\n    } else {\n        name = \"When@\" + getNextId();\n        predicate = arg1;\n        effect = arg2;\n        scope = arg3;\n    }\n    var disposer = autorun(name, function (r) {\n        if (predicate.call(scope)) {\n            r.dispose();\n            var prevUntracked = untrackedStart();\n            effect.call(scope);\n            untrackedEnd(prevUntracked);\n        }\n    });\n    return disposer;\n}\nexports.when = when;\nfunction autorunAsync(arg1, arg2, arg3, arg4) {\n    var name, func, delay, scope;\n    if (typeof arg1 === \"string\") {\n        name = arg1;\n        func = arg2;\n        delay = arg3;\n        scope = arg4;\n    } else {\n        name = arg1.name || \"AutorunAsync@\" + getNextId();\n        func = arg1;\n        delay = arg2;\n        scope = arg3;\n    }\n    invariant(isAction(func) === false, getMessage(\"m006\"));\n    if (delay === void 0) delay = 1;\n    if (scope) func = func.bind(scope);\n    var isScheduled = false;\n    var r = new Reaction(name, function () {\n        if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                if (!r.isDisposed) r.track(reactionRunner);\n            }, delay);\n        }\n    });\n    function reactionRunner() {\n        func(r);\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.autorunAsync = autorunAsync;\nfunction reaction(expression, effect, arg3) {\n    if (arguments.length > 3) {\n        fail(getMessage(\"m007\"));\n    }\n    if (isModifierDescriptor(expression)) {\n        fail(getMessage(\"m008\"));\n    }\n    var opts;\n    if ((typeof arg3 === \"undefined\" ? \"undefined\" : _typeof(arg3)) === \"object\") {\n        opts = arg3;\n    } else {\n        opts = {};\n    }\n    opts.name = opts.name || expression.name || effect.name || \"Reaction@\" + getNextId();\n    opts.fireImmediately = arg3 === true || opts.fireImmediately === true;\n    opts.delay = opts.delay || 0;\n    opts.compareStructural = opts.compareStructural || opts.struct || false;\n    effect = action(opts.name, opts.context ? effect.bind(opts.context) : effect);\n    if (opts.context) {\n        expression = expression.bind(opts.context);\n    }\n    var firstTime = true;\n    var isScheduled = false;\n    var nextValue;\n    var r = new Reaction(opts.name, function () {\n        if (firstTime || opts.delay < 1) {\n            reactionRunner();\n        } else if (!isScheduled) {\n            isScheduled = true;\n            setTimeout(function () {\n                isScheduled = false;\n                reactionRunner();\n            }, opts.delay);\n        }\n    });\n    function reactionRunner() {\n        if (r.isDisposed) return;\n        var changed = false;\n        r.track(function () {\n            var v = expression(r);\n            changed = valueDidChange(opts.compareStructural, nextValue, v);\n            nextValue = v;\n        });\n        if (firstTime && opts.fireImmediately) effect(nextValue, r);\n        if (!firstTime && changed === true) effect(nextValue, r);\n        if (firstTime) firstTime = false;\n    }\n    r.schedule();\n    return r.getDisposer();\n}\nexports.reaction = reaction;\nfunction createComputedDecorator(compareStructural) {\n    return createClassPropertyDecorator(function (target, name, _, __, originalDescriptor) {\n        invariant(typeof originalDescriptor !== \"undefined\", getMessage(\"m009\"));\n        invariant(typeof originalDescriptor.get === \"function\", getMessage(\"m010\"));\n        var adm = asObservableObject(target, \"\");\n        defineComputedProperty(adm, name, originalDescriptor.get, originalDescriptor.set, compareStructural, false);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        this.$mobx.values[name].set(value);\n    }, false, false);\n}\nvar computedDecorator = createComputedDecorator(false);\nvar computedStructDecorator = createComputedDecorator(true);\nvar computed = function computed(arg1, arg2, arg3) {\n    if (typeof arg2 === \"string\") {\n        return computedDecorator.apply(null, arguments);\n    }\n    invariant(typeof arg1 === \"function\", getMessage(\"m011\"));\n    invariant(arguments.length < 3, getMessage(\"m012\"));\n    var opts = (typeof arg2 === \"undefined\" ? \"undefined\" : _typeof(arg2)) === \"object\" ? arg2 : {};\n    opts.setter = typeof arg2 === \"function\" ? arg2 : opts.setter;\n    return new ComputedValue(arg1, opts.context, opts.compareStructural || opts.struct || false, opts.name || arg1.name || \"\", opts.setter);\n};\nexports.computed = computed;\ncomputed.struct = computedStructDecorator;\nfunction createTransformer(transformer, onCleanup) {\n    invariant(typeof transformer === \"function\" && transformer.length < 2, \"createTransformer expects a function that accepts one argument\");\n    var objectCache = {};\n    var resetId = globalState.resetId;\n    var Transformer = function (_super) {\n        __extends(Transformer, _super);\n        function Transformer(sourceIdentifier, sourceObject) {\n            var _this = _super.call(this, function () {\n                return transformer(sourceObject);\n            }, undefined, false, \"Transformer-\" + transformer.name + \"-\" + sourceIdentifier, undefined) || this;\n            _this.sourceIdentifier = sourceIdentifier;\n            _this.sourceObject = sourceObject;\n            return _this;\n        }\n        Transformer.prototype.onBecomeUnobserved = function () {\n            var lastValue = this.value;\n            _super.prototype.onBecomeUnobserved.call(this);\n            delete objectCache[this.sourceIdentifier];\n            if (onCleanup) onCleanup(lastValue, this.sourceObject);\n        };\n        return Transformer;\n    }(ComputedValue);\n    return function (object) {\n        if (resetId !== globalState.resetId) {\n            objectCache = {};\n            resetId = globalState.resetId;\n        }\n        var identifier = getMemoizationId(object);\n        var reactiveTransformer = objectCache[identifier];\n        if (reactiveTransformer) return reactiveTransformer.get();\n        reactiveTransformer = objectCache[identifier] = new Transformer(identifier, object);\n        return reactiveTransformer.get();\n    };\n}\nexports.createTransformer = createTransformer;\nfunction getMemoizationId(object) {\n    if (object === null || (typeof object === \"undefined\" ? \"undefined\" : _typeof(object)) !== \"object\") throw new Error(\"[mobx] transform expected some kind of object, got: \" + object);\n    var tid = object.$transformId;\n    if (tid === undefined) {\n        tid = getNextId();\n        addHiddenProp(object, \"$transformId\", tid);\n    }\n    return tid;\n}\nfunction expr(expr, scope) {\n    if (!isComputingDerivation()) console.warn(getMessage(\"m013\"));\n    return computed(expr, { context: scope }).get();\n}\nexports.expr = expr;\nfunction extendObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, deepEnhancer, properties);\n}\nexports.extendObservable = extendObservable;\nfunction extendShallowObservable(target) {\n    var properties = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        properties[_i - 1] = arguments[_i];\n    }\n    return extendObservableHelper(target, referenceEnhancer, properties);\n}\nexports.extendShallowObservable = extendShallowObservable;\nfunction extendObservableHelper(target, defaultEnhancer, properties) {\n    invariant(arguments.length >= 2, getMessage(\"m014\"));\n    invariant((typeof target === \"undefined\" ? \"undefined\" : _typeof(target)) === \"object\", getMessage(\"m015\"));\n    invariant(!isObservableMap(target), getMessage(\"m016\"));\n    properties.forEach(function (propSet) {\n        invariant((typeof propSet === \"undefined\" ? \"undefined\" : _typeof(propSet)) === \"object\", getMessage(\"m017\"));\n        invariant(!isObservable(propSet), getMessage(\"m018\"));\n    });\n    var adm = asObservableObject(target);\n    var definedProps = {};\n    for (var i = properties.length - 1; i >= 0; i--) {\n        var propSet = properties[i];\n        for (var key in propSet) {\n            if (definedProps[key] !== true && hasOwnProperty(propSet, key)) {\n                definedProps[key] = true;\n                if (target === propSet && !isPropertyConfigurable(target, key)) continue;\n                var descriptor = Object.getOwnPropertyDescriptor(propSet, key);\n                defineObservablePropertyFromDescriptor(adm, key, descriptor, defaultEnhancer);\n            }\n        }\n    }\n    return target;\n}\nfunction getDependencyTree(thing, property) {\n    return nodeToDependencyTree(getAtom(thing, property));\n}\nfunction nodeToDependencyTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (node.observing && node.observing.length > 0) result.dependencies = unique(node.observing).map(nodeToDependencyTree);\n    return result;\n}\nfunction getObserverTree(thing, property) {\n    return nodeToObserverTree(getAtom(thing, property));\n}\nfunction nodeToObserverTree(node) {\n    var result = {\n        name: node.name\n    };\n    if (hasObservers(node)) result.observers = getObservers(node).map(nodeToObserverTree);\n    return result;\n}\nfunction intercept(thing, propOrHandler, handler) {\n    if (typeof handler === \"function\") return interceptProperty(thing, propOrHandler, handler);else return interceptInterceptable(thing, propOrHandler);\n}\nexports.intercept = intercept;\nfunction interceptInterceptable(thing, handler) {\n    return getAdministration(thing).intercept(handler);\n}\nfunction interceptProperty(thing, property, handler) {\n    return getAdministration(thing, property).intercept(handler);\n}\nfunction isComputed(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableObject(value) === false) return false;\n        var atom = getAtom(value, property);\n        return isComputedValue(atom);\n    }\n    return isComputedValue(value);\n}\nexports.isComputed = isComputed;\nfunction isObservable(value, property) {\n    if (value === null || value === undefined) return false;\n    if (property !== undefined) {\n        if (isObservableArray(value) || isObservableMap(value)) throw new Error(getMessage(\"m019\"));else if (isObservableObject(value)) {\n            var o = value.$mobx;\n            return o.values && !!o.values[property];\n        }\n        return false;\n    }\n    return isObservableObject(value) || !!value.$mobx || isAtom(value) || isReaction(value) || isComputedValue(value);\n}\nexports.isObservable = isObservable;\nvar deepDecorator = createDecoratorForEnhancer(deepEnhancer);\nvar shallowDecorator = createDecoratorForEnhancer(shallowEnhancer);\nvar refDecorator = createDecoratorForEnhancer(referenceEnhancer);\nvar deepStructDecorator = createDecoratorForEnhancer(deepStructEnhancer);\nvar refStructDecorator = createDecoratorForEnhancer(refStructEnhancer);\nfunction createObservable(v) {\n    if (v === void 0) {\n        v = undefined;\n    }\n    if (typeof arguments[1] === \"string\") return deepDecorator.apply(null, arguments);\n    invariant(arguments.length <= 1,=\"\" getmessage(\"m021\"));=\"\" invariant(!ismodifierdescriptor(v),=\"\" getmessage(\"m020\"));=\"\" if=\"\" (isobservable(v))=\"\" return=\"\" v;=\"\" var=\"\" res=\"deepEnhancer(v,\" undefined,=\"\" undefined);=\"\" (res=\"\" !=\"=\" v)=\"\" res;=\"\" observable.box(v);=\"\" }=\"\" iobservablefactories=\"function\" ()=\"\" {=\"\" function=\"\" iobservablefactories()=\"\" {}=\"\" iobservablefactories.prototype.box=\"function\" (value,=\"\" name)=\"\" (arguments.length=\"\"> 2) incorrectlyUsedAsDecorator(\"box\");\n        return new ObservableValue(value, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowBox = function (value, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowBox\");\n        return new ObservableValue(value, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.array = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"array\");\n        return new ObservableArray(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowArray = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowArray\");\n        return new ObservableArray(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.map = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"map\");\n        return new ObservableMap(initialValues, deepEnhancer, name);\n    };\n    IObservableFactories.prototype.shallowMap = function (initialValues, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowMap\");\n        return new ObservableMap(initialValues, referenceEnhancer, name);\n    };\n    IObservableFactories.prototype.object = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"object\");\n        var res = {};\n        asObservableObject(res, name);\n        extendObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.shallowObject = function (props, name) {\n        if (arguments.length > 2) incorrectlyUsedAsDecorator(\"shallowObject\");\n        var res = {};\n        asObservableObject(res, name);\n        extendShallowObservable(res, props);\n        return res;\n    };\n    IObservableFactories.prototype.ref = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(referenceEnhancer, arguments[0]);\n        } else {\n            return refDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.shallow = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(shallowEnhancer, arguments[0]);\n        } else {\n            return shallowDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.deep = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepEnhancer, arguments[0]);\n        } else {\n            return deepDecorator.apply(null, arguments);\n        }\n    };\n    IObservableFactories.prototype.struct = function () {\n        if (arguments.length < 2) {\n            return createModifierDescriptor(deepStructEnhancer, arguments[0]);\n        } else {\n            return deepStructDecorator.apply(null, arguments);\n        }\n    };\n    return IObservableFactories;\n}();\nexports.IObservableFactories = IObservableFactories;\nvar observable = createObservable;\nexports.observable = observable;\nObject.keys(IObservableFactories.prototype).forEach(function (key) {\n    return observable[key] = IObservableFactories.prototype[key];\n});\nobservable.deep.struct = observable.struct;\nobservable.ref.struct = function () {\n    if (arguments.length < 2) {\n        return createModifierDescriptor(refStructEnhancer, arguments[0]);\n    } else {\n        return refStructDecorator.apply(null, arguments);\n    }\n};\nfunction incorrectlyUsedAsDecorator(methodName) {\n    fail(\"Expected one or two arguments to observable.\" + methodName + \". Did you accidentally try to use observable.\" + methodName + \" as decorator?\");\n}\nfunction createDecoratorForEnhancer(enhancer) {\n    invariant(!!enhancer, \":(\");\n    return createClassPropertyDecorator(function (target, name, baseValue, _, baseDescriptor) {\n        assertPropertyConfigurable(target, name);\n        invariant(!baseDescriptor || !baseDescriptor.get, getMessage(\"m022\"));\n        var adm = asObservableObject(target, undefined);\n        defineObservableProperty(adm, name, baseValue, enhancer);\n    }, function (name) {\n        var observable = this.$mobx.values[name];\n        if (observable === undefined) return undefined;\n        return observable.get();\n    }, function (name, value) {\n        setPropertyValue(this, name, value);\n    }, true, false);\n}\nfunction observe(thing, propOrCb, cbOrFire, fireImmediately) {\n    if (typeof cbOrFire === \"function\") return observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately);else return observeObservable(thing, propOrCb, cbOrFire);\n}\nexports.observe = observe;\nfunction observeObservable(thing, listener, fireImmediately) {\n    return getAdministration(thing).observe(listener, fireImmediately);\n}\nfunction observeObservableProperty(thing, property, listener, fireImmediately) {\n    return getAdministration(thing, property).observe(listener, fireImmediately);\n}\nfunction toJS(source, detectCycles, __alreadySeen) {\n    if (detectCycles === void 0) {\n        detectCycles = true;\n    }\n    if (__alreadySeen === void 0) {\n        __alreadySeen = [];\n    }\n    function cache(value) {\n        if (detectCycles) __alreadySeen.push([source, value]);\n        return value;\n    }\n    if (isObservable(source)) {\n        if (detectCycles && __alreadySeen === null) __alreadySeen = [];\n        if (detectCycles && source !== null && (typeof source === \"undefined\" ? \"undefined\" : _typeof(source)) === \"object\") {\n            for (var i = 0, l = __alreadySeen.length; i < l; i++) {\n                if (__alreadySeen[i][0] === source) return __alreadySeen[i][1];\n            }\n        }\n        if (isObservableArray(source)) {\n            var res = cache([]);\n            var toAdd = source.map(function (value) {\n                return toJS(value, detectCycles, __alreadySeen);\n            });\n            res.length = toAdd.length;\n            for (var i = 0, l = toAdd.length; i < l; i++) {\n                res[i] = toAdd[i];\n            }return res;\n        }\n        if (isObservableObject(source)) {\n            var res = cache({});\n            for (var key in source) {\n                res[key] = toJS(source[key], detectCycles, __alreadySeen);\n            }return res;\n        }\n        if (isObservableMap(source)) {\n            var res_1 = cache({});\n            source.forEach(function (value, key) {\n                return res_1[key] = toJS(value, detectCycles, __alreadySeen);\n            });\n            return res_1;\n        }\n        if (isObservableValue(source)) return toJS(source.get(), detectCycles, __alreadySeen);\n    }\n    return source;\n}\nexports.toJS = toJS;\nfunction transaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    deprecated(getMessage(\"m023\"));\n    return runInTransaction.apply(undefined, arguments);\n}\nexports.transaction = transaction;\nfunction runInTransaction(action, thisArg) {\n    if (thisArg === void 0) {\n        thisArg = undefined;\n    }\n    return executeAction(\"\", action);\n}\nfunction log(msg) {\n    console.log(msg);\n    return msg;\n}\nfunction whyRun(thing, prop) {\n    switch (arguments.length) {\n        case 0:\n            thing = globalState.trackingDerivation;\n            if (!thing) return log(getMessage(\"m024\"));\n            break;\n        case 2:\n            thing = getAtom(thing, prop);\n            break;\n    }\n    thing = getAtom(thing);\n    if (isComputedValue(thing)) return log(thing.whyRun());else if (isReaction(thing)) return log(thing.whyRun());\n    return fail(getMessage(\"m025\"));\n}\nexports.whyRun = whyRun;\nfunction createAction(actionName, fn) {\n    invariant(typeof fn === \"function\", getMessage(\"m026\"));\n    invariant(typeof actionName === \"string\" && actionName.length > 0, \"actions should have valid names, got: '\" + actionName + \"'\");\n    var res = function res() {\n        return executeAction(actionName, fn, this, arguments);\n    };\n    res.originalFn = fn;\n    res.isMobxAction = true;\n    return res;\n}\nfunction executeAction(actionName, fn, scope, args) {\n    var runInfo = startAction(actionName, fn, scope, args);\n    try {\n        return fn.apply(scope, args);\n    } finally {\n        endAction(runInfo);\n    }\n}\nfunction startAction(actionName, fn, scope, args) {\n    var notifySpy = isSpyEnabled() && !!actionName;\n    var startTime = 0;\n    if (notifySpy) {\n        startTime = Date.now();\n        var l = args && args.length || 0;\n        var flattendArgs = new Array(l);\n        if (l > 0) for (var i = 0; i < l; i++) {\n            flattendArgs[i] = args[i];\n        }spyReportStart({\n            type: \"action\",\n            name: actionName,\n            fn: fn,\n            object: scope,\n            arguments: flattendArgs\n        });\n    }\n    var prevDerivation = untrackedStart();\n    startBatch();\n    var prevAllowStateChanges = allowStateChangesStart(true);\n    return {\n        prevDerivation: prevDerivation,\n        prevAllowStateChanges: prevAllowStateChanges,\n        notifySpy: notifySpy,\n        startTime: startTime\n    };\n}\nfunction endAction(runInfo) {\n    allowStateChangesEnd(runInfo.prevAllowStateChanges);\n    endBatch();\n    untrackedEnd(runInfo.prevDerivation);\n    if (runInfo.notifySpy) spyReportEnd({ time: Date.now() - runInfo.startTime });\n}\nfunction useStrict(strict) {\n    invariant(globalState.trackingDerivation === null, getMessage(\"m028\"));\n    globalState.strictMode = strict;\n    globalState.allowStateChanges = !strict;\n}\nexports.useStrict = useStrict;\nfunction isStrictModeEnabled() {\n    return globalState.strictMode;\n}\nexports.isStrictModeEnabled = isStrictModeEnabled;\nfunction allowStateChanges(allowStateChanges, func) {\n    var prev = allowStateChangesStart(allowStateChanges);\n    var res;\n    try {\n        res = func();\n    } finally {\n        allowStateChangesEnd(prev);\n    }\n    return res;\n}\nfunction allowStateChangesStart(allowStateChanges) {\n    var prev = globalState.allowStateChanges;\n    globalState.allowStateChanges = allowStateChanges;\n    return prev;\n}\nfunction allowStateChangesEnd(prev) {\n    globalState.allowStateChanges = prev;\n}\nvar BaseAtom = function () {\n    function BaseAtom(name) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        this.name = name;\n        this.isPendingUnobservation = true;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.NOT_TRACKING;\n    }\n    BaseAtom.prototype.onBecomeUnobserved = function () {};\n    BaseAtom.prototype.reportObserved = function () {\n        reportObserved(this);\n    };\n    BaseAtom.prototype.reportChanged = function () {\n        startBatch();\n        propagateChanged(this);\n        endBatch();\n    };\n    BaseAtom.prototype.toString = function () {\n        return this.name;\n    };\n    return BaseAtom;\n}();\nexports.BaseAtom = BaseAtom;\nvar Atom = function (_super) {\n    __extends(Atom, _super);\n    function Atom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {\n        if (name === void 0) {\n            name = \"Atom@\" + getNextId();\n        }\n        if (onBecomeObservedHandler === void 0) {\n            onBecomeObservedHandler = noop;\n        }\n        if (onBecomeUnobservedHandler === void 0) {\n            onBecomeUnobservedHandler = noop;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.name = name;\n        _this.onBecomeObservedHandler = onBecomeObservedHandler;\n        _this.onBecomeUnobservedHandler = onBecomeUnobservedHandler;\n        _this.isPendingUnobservation = false;\n        _this.isBeingTracked = false;\n        return _this;\n    }\n    Atom.prototype.reportObserved = function () {\n        startBatch();\n        _super.prototype.reportObserved.call(this);\n        if (!this.isBeingTracked) {\n            this.isBeingTracked = true;\n            this.onBecomeObservedHandler();\n        }\n        endBatch();\n        return !!globalState.trackingDerivation;\n    };\n    Atom.prototype.onBecomeUnobserved = function () {\n        this.isBeingTracked = false;\n        this.onBecomeUnobservedHandler();\n    };\n    return Atom;\n}(BaseAtom);\nexports.Atom = Atom;\nvar isAtom = createInstanceofPredicate(\"Atom\", BaseAtom);\nvar ComputedValue = function () {\n    function ComputedValue(derivation, scope, compareStructural, name, setter) {\n        this.derivation = derivation;\n        this.scope = scope;\n        this.compareStructural = compareStructural;\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.observing = [];\n        this.newObserving = null;\n        this.isPendingUnobservation = false;\n        this.observers = [];\n        this.observersIndexes = {};\n        this.diffValue = 0;\n        this.runId = 0;\n        this.lastAccessedBy = 0;\n        this.lowestObserverState = IDerivationState.UP_TO_DATE;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.value = undefined;\n        this.isComputing = false;\n        this.isRunningSetter = false;\n        this.name = name || \"ComputedValue@\" + getNextId();\n        if (setter) this.setter = createAction(name + \"-setter\", setter);\n    }\n    ComputedValue.prototype.onBecomeStale = function () {\n        propagateMaybeChanged(this);\n    };\n    ComputedValue.prototype.onBecomeUnobserved = function () {\n        invariant(this.dependenciesState !== IDerivationState.NOT_TRACKING, getMessage(\"m029\"));\n        clearObserving(this);\n        this.value = undefined;\n    };\n    ComputedValue.prototype.get = function () {\n        invariant(!this.isComputing, \"Cycle detected in computation \" + this.name, this.derivation);\n        if (globalState.inBatch === 0) {\n            startBatch();\n            if (shouldCompute(this)) this.value = this.computeValue(false);\n            endBatch();\n        } else {\n            reportObserved(this);\n            if (shouldCompute(this)) if (this.trackAndCompute()) propagateChangeConfirmed(this);\n        }\n        var result = this.value;\n        if (isCaughtException(result)) throw result.cause;\n        return result;\n    };\n    ComputedValue.prototype.peek = function () {\n        var res = this.computeValue(false);\n        if (isCaughtException(res)) throw res.cause;\n        return res;\n    };\n    ComputedValue.prototype.set = function (value) {\n        if (this.setter) {\n            invariant(!this.isRunningSetter, \"The setter of computed value '\" + this.name + \"' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?\");\n            this.isRunningSetter = true;\n            try {\n                this.setter.call(this.scope, value);\n            } finally {\n                this.isRunningSetter = false;\n            }\n        } else invariant(false, \"[ComputedValue '\" + this.name + \"'] It is not possible to assign a new value to a computed value.\");\n    };\n    ComputedValue.prototype.trackAndCompute = function () {\n        if (isSpyEnabled()) {\n            spyReport({\n                object: this.scope,\n                type: \"compute\",\n                fn: this.derivation\n            });\n        }\n        var oldValue = this.value;\n        var newValue = this.value = this.computeValue(true);\n        return isCaughtException(newValue) || valueDidChange(this.compareStructural, newValue, oldValue);\n    };\n    ComputedValue.prototype.computeValue = function (track) {\n        this.isComputing = true;\n        globalState.computationDepth++;\n        var res;\n        if (track) {\n            res = trackDerivedFunction(this, this.derivation, this.scope);\n        } else {\n            try {\n                res = this.derivation.call(this.scope);\n            } catch (e) {\n                res = new CaughtException(e);\n            }\n        }\n        globalState.computationDepth--;\n        this.isComputing = false;\n        return res;\n    };\n    ;\n    ComputedValue.prototype.observe = function (listener, fireImmediately) {\n        var _this = this;\n        var firstTime = true;\n        var prevValue = undefined;\n        return autorun(function () {\n            var newValue = _this.get();\n            if (!firstTime || fireImmediately) {\n                var prevU = untrackedStart();\n                listener({\n                    type: \"update\",\n                    object: _this,\n                    newValue: newValue,\n                    oldValue: prevValue\n                });\n                untrackedEnd(prevU);\n            }\n            firstTime = false;\n            prevValue = newValue;\n        });\n    };\n    ComputedValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ComputedValue.prototype.toString = function () {\n        return this.name + \"[\" + this.derivation.toString() + \"]\";\n    };\n    ComputedValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    ;\n    ComputedValue.prototype.whyRun = function () {\n        var isTracking = Boolean(globalState.trackingDerivation);\n        var observing = unique(this.isComputing ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        var observers = unique(getObservers(this).map(function (dep) {\n            return dep.name;\n        }));\n        return \"\\nWhyRun? computation '\" + this.name + \"':\\n * Running because: \" + (isTracking ? \"[active] the value of this computation is needed by a reaction\" : this.isComputing ? \"[get] The value of this computed was requested outside a reaction\" : \"[idle] not running at the moment\") + \"\\n\" + (this.dependenciesState === IDerivationState.NOT_TRACKING ? getMessage(\"m032\") : \" * This computation will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this.isComputing && isTracking ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\\n  * If the outcome of this computation changes, the following observers will be re-run:\\n    \" + joinStrings(observers) + \"\\n\");\n    };\n    return ComputedValue;\n}();\nComputedValue.prototype[primitiveSymbol()] = ComputedValue.prototype.valueOf;\nvar isComputedValue = createInstanceofPredicate(\"ComputedValue\", ComputedValue);\nvar IDerivationState;\n(function (IDerivationState) {\n    IDerivationState[IDerivationState[\"NOT_TRACKING\"] = -1] = \"NOT_TRACKING\";\n    IDerivationState[IDerivationState[\"UP_TO_DATE\"] = 0] = \"UP_TO_DATE\";\n    IDerivationState[IDerivationState[\"POSSIBLY_STALE\"] = 1] = \"POSSIBLY_STALE\";\n    IDerivationState[IDerivationState[\"STALE\"] = 2] = \"STALE\";\n})(IDerivationState || (IDerivationState = {}));\nexports.IDerivationState = IDerivationState;\nvar CaughtException = function () {\n    function CaughtException(cause) {\n        this.cause = cause;\n    }\n    return CaughtException;\n}();\nfunction isCaughtException(e) {\n    return e instanceof CaughtException;\n}\nfunction shouldCompute(derivation) {\n    switch (derivation.dependenciesState) {\n        case IDerivationState.UP_TO_DATE:\n            return false;\n        case IDerivationState.NOT_TRACKING:\n        case IDerivationState.STALE:\n            return true;\n        case IDerivationState.POSSIBLY_STALE:\n            {\n                var prevUntracked = untrackedStart();\n                var obs = derivation.observing,\n                    l = obs.length;\n                for (var i = 0; i < l; i++) {\n                    var obj = obs[i];\n                    if (isComputedValue(obj)) {\n                        try {\n                            obj.get();\n                        } catch (e) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                        if (derivation.dependenciesState === IDerivationState.STALE) {\n                            untrackedEnd(prevUntracked);\n                            return true;\n                        }\n                    }\n                }\n                changeDependenciesStateTo0(derivation);\n                untrackedEnd(prevUntracked);\n                return false;\n            }\n    }\n}\nfunction isComputingDerivation() {\n    return globalState.trackingDerivation !== null;\n}\nfunction checkIfStateModificationsAreAllowed(atom) {\n    var hasObservers = atom.observers.length > 0;\n    if (globalState.computationDepth > 0 && hasObservers) fail(getMessage(\"m031\") + atom.name);\n    if (!globalState.allowStateChanges && hasObservers) fail(getMessage(globalState.strictMode ? \"m030a\" : \"m030b\") + atom.name);\n}\nfunction trackDerivedFunction(derivation, f, context) {\n    changeDependenciesStateTo0(derivation);\n    derivation.newObserving = new Array(derivation.observing.length + 100);\n    derivation.unboundDepsCount = 0;\n    derivation.runId = ++globalState.runId;\n    var prevTracking = globalState.trackingDerivation;\n    globalState.trackingDerivation = derivation;\n    var result;\n    try {\n        result = f.call(context);\n    } catch (e) {\n        result = new CaughtException(e);\n    }\n    globalState.trackingDerivation = prevTracking;\n    bindDependencies(derivation);\n    return result;\n}\nfunction bindDependencies(derivation) {\n    var prevObserving = derivation.observing;\n    var observing = derivation.observing = derivation.newObserving;\n    derivation.newObserving = null;\n    var i0 = 0,\n        l = derivation.unboundDepsCount;\n    for (var i = 0; i < l; i++) {\n        var dep = observing[i];\n        if (dep.diffValue === 0) {\n            dep.diffValue = 1;\n            if (i0 !== i) observing[i0] = dep;\n            i0++;\n        }\n    }\n    observing.length = i0;\n    l = prevObserving.length;\n    while (l--) {\n        var dep = prevObserving[l];\n        if (dep.diffValue === 0) {\n            removeObserver(dep, derivation);\n        }\n        dep.diffValue = 0;\n    }\n    while (i0--) {\n        var dep = observing[i0];\n        if (dep.diffValue === 1) {\n            dep.diffValue = 0;\n            addObserver(dep, derivation);\n        }\n    }\n}\nfunction clearObserving(derivation) {\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        removeObserver(obs[i], derivation);\n    }derivation.dependenciesState = IDerivationState.NOT_TRACKING;\n    obs.length = 0;\n}\nfunction untracked(action) {\n    var prev = untrackedStart();\n    var res = action();\n    untrackedEnd(prev);\n    return res;\n}\nexports.untracked = untracked;\nfunction untrackedStart() {\n    var prev = globalState.trackingDerivation;\n    globalState.trackingDerivation = null;\n    return prev;\n}\nfunction untrackedEnd(prev) {\n    globalState.trackingDerivation = prev;\n}\nfunction changeDependenciesStateTo0(derivation) {\n    if (derivation.dependenciesState === IDerivationState.UP_TO_DATE) return;\n    derivation.dependenciesState = IDerivationState.UP_TO_DATE;\n    var obs = derivation.observing;\n    var i = obs.length;\n    while (i--) {\n        obs[i].lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nvar persistentKeys = [\"mobxGuid\", \"resetId\", \"spyListeners\", \"strictMode\", \"runId\"];\nvar MobXGlobals = function () {\n    function MobXGlobals() {\n        this.version = 5;\n        this.trackingDerivation = null;\n        this.computationDepth = 0;\n        this.runId = 0;\n        this.mobxGuid = 0;\n        this.inBatch = 0;\n        this.pendingUnobservations = [];\n        this.pendingReactions = [];\n        this.isRunningReactions = false;\n        this.allowStateChanges = true;\n        this.strictMode = false;\n        this.resetId = 0;\n        this.spyListeners = [];\n        this.globalReactionErrorHandlers = [];\n    }\n    return MobXGlobals;\n}();\nvar globalState = new MobXGlobals();\nfunction shareGlobalState() {\n    var global = getGlobal();\n    var ownState = globalState;\n    if (global.__mobservableTrackingStack || global.__mobservableViewStack) throw new Error(\"[mobx] An incompatible version of mobservable is already loaded.\");\n    if (global.__mobxGlobal && global.__mobxGlobal.version !== ownState.version) throw new Error(\"[mobx] An incompatible version of mobx is already loaded.\");\n    if (global.__mobxGlobal) globalState = global.__mobxGlobal;else global.__mobxGlobal = ownState;\n}\nfunction getGlobalState() {\n    return globalState;\n}\nfunction registerGlobals() {}\nfunction resetGlobalState() {\n    globalState.resetId++;\n    var defaultGlobals = new MobXGlobals();\n    for (var key in defaultGlobals) {\n        if (persistentKeys.indexOf(key) === -1) globalState[key] = defaultGlobals[key];\n    }globalState.allowStateChanges = !globalState.strictMode;\n}\nfunction hasObservers(observable) {\n    return observable.observers && observable.observers.length > 0;\n}\nfunction getObservers(observable) {\n    return observable.observers;\n}\nfunction invariantObservers(observable) {\n    var list = observable.observers;\n    var map = observable.observersIndexes;\n    var l = list.length;\n    for (var i = 0; i < l; i++) {\n        var id = list[i].__mapid;\n        if (i) {\n            invariant(map[id] === i, \"INTERNAL ERROR maps derivation.__mapid to index in list\");\n        } else {\n            invariant(!(id in map), \"INTERNAL ERROR observer on index 0 shouldnt be held in map.\");\n        }\n    }\n    invariant(list.length === 0 || Object.keys(map).length === list.length - 1, \"INTERNAL ERROR there is no junk in map\");\n}\nfunction addObserver(observable, node) {\n    var l = observable.observers.length;\n    if (l) {\n        observable.observersIndexes[node.__mapid] = l;\n    }\n    observable.observers[l] = node;\n    if (observable.lowestObserverState > node.dependenciesState) observable.lowestObserverState = node.dependenciesState;\n}\nfunction removeObserver(observable, node) {\n    if (observable.observers.length === 1) {\n        observable.observers.length = 0;\n        queueForUnobservation(observable);\n    } else {\n        var list = observable.observers;\n        var map_1 = observable.observersIndexes;\n        var filler = list.pop();\n        if (filler !== node) {\n            var index = map_1[node.__mapid] || 0;\n            if (index) {\n                map_1[filler.__mapid] = index;\n            } else {\n                delete map_1[filler.__mapid];\n            }\n            list[index] = filler;\n        }\n        delete map_1[node.__mapid];\n    }\n}\nfunction queueForUnobservation(observable) {\n    if (!observable.isPendingUnobservation) {\n        observable.isPendingUnobservation = true;\n        globalState.pendingUnobservations.push(observable);\n    }\n}\nfunction startBatch() {\n    globalState.inBatch++;\n}\nfunction endBatch() {\n    if (--globalState.inBatch === 0) {\n        runReactions();\n        var list = globalState.pendingUnobservations;\n        for (var i = 0; i < list.length; i++) {\n            var observable_1 = list[i];\n            observable_1.isPendingUnobservation = false;\n            if (observable_1.observers.length === 0) {\n                observable_1.onBecomeUnobserved();\n            }\n        }\n        globalState.pendingUnobservations = [];\n    }\n}\nfunction reportObserved(observable) {\n    var derivation = globalState.trackingDerivation;\n    if (derivation !== null) {\n        if (derivation.runId !== observable.lastAccessedBy) {\n            observable.lastAccessedBy = derivation.runId;\n            derivation.newObserving[derivation.unboundDepsCount++] = observable;\n        }\n    } else if (observable.observers.length === 0) {\n        queueForUnobservation(observable);\n    }\n}\nfunction invariantLOS(observable, msg) {\n    var min = getObservers(observable).reduce(function (a, b) {\n        return Math.min(a, b.dependenciesState);\n    }, 2);\n    if (min >= observable.lowestObserverState) return;\n    throw new Error(\"lowestObserverState is wrong for \" + msg + \" because \" + min + \" < \" + observable.lowestObserverState);\n}\nfunction propagateChanged(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) d.onBecomeStale();\n        d.dependenciesState = IDerivationState.STALE;\n    }\n}\nfunction propagateChangeConfirmed(observable) {\n    if (observable.lowestObserverState === IDerivationState.STALE) return;\n    observable.lowestObserverState = IDerivationState.STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.POSSIBLY_STALE) d.dependenciesState = IDerivationState.STALE;else if (d.dependenciesState === IDerivationState.UP_TO_DATE) observable.lowestObserverState = IDerivationState.UP_TO_DATE;\n    }\n}\nfunction propagateMaybeChanged(observable) {\n    if (observable.lowestObserverState !== IDerivationState.UP_TO_DATE) return;\n    observable.lowestObserverState = IDerivationState.POSSIBLY_STALE;\n    var observers = observable.observers;\n    var i = observers.length;\n    while (i--) {\n        var d = observers[i];\n        if (d.dependenciesState === IDerivationState.UP_TO_DATE) {\n            d.dependenciesState = IDerivationState.POSSIBLY_STALE;\n            d.onBecomeStale();\n        }\n    }\n}\nvar Reaction = function () {\n    function Reaction(name, onInvalidate) {\n        if (name === void 0) {\n            name = \"Reaction@\" + getNextId();\n        }\n        this.name = name;\n        this.onInvalidate = onInvalidate;\n        this.observing = [];\n        this.newObserving = [];\n        this.dependenciesState = IDerivationState.NOT_TRACKING;\n        this.diffValue = 0;\n        this.runId = 0;\n        this.unboundDepsCount = 0;\n        this.__mapid = \"#\" + getNextId();\n        this.isDisposed = false;\n        this._isScheduled = false;\n        this._isTrackPending = false;\n        this._isRunning = false;\n    }\n    Reaction.prototype.onBecomeStale = function () {\n        this.schedule();\n    };\n    Reaction.prototype.schedule = function () {\n        if (!this._isScheduled) {\n            this._isScheduled = true;\n            globalState.pendingReactions.push(this);\n            runReactions();\n        }\n    };\n    Reaction.prototype.isScheduled = function () {\n        return this._isScheduled;\n    };\n    Reaction.prototype.runReaction = function () {\n        if (!this.isDisposed) {\n            startBatch();\n            this._isScheduled = false;\n            if (shouldCompute(this)) {\n                this._isTrackPending = true;\n                this.onInvalidate();\n                if (this._isTrackPending && isSpyEnabled()) {\n                    spyReport({\n                        object: this,\n                        type: \"scheduled-reaction\"\n                    });\n                }\n            }\n            endBatch();\n        }\n    };\n    Reaction.prototype.track = function (fn) {\n        startBatch();\n        var notify = isSpyEnabled();\n        var startTime;\n        if (notify) {\n            startTime = Date.now();\n            spyReportStart({\n                object: this,\n                type: \"reaction\",\n                fn: fn\n            });\n        }\n        this._isRunning = true;\n        var result = trackDerivedFunction(this, fn, undefined);\n        this._isRunning = false;\n        this._isTrackPending = false;\n        if (this.isDisposed) {\n            clearObserving(this);\n        }\n        if (isCaughtException(result)) this.reportExceptionInDerivation(result.cause);\n        if (notify) {\n            spyReportEnd({\n                time: Date.now() - startTime\n            });\n        }\n        endBatch();\n    };\n    Reaction.prototype.reportExceptionInDerivation = function (error) {\n        var _this = this;\n        if (this.errorHandler) {\n            this.errorHandler(error, this);\n            return;\n        }\n        var message = \"[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '\" + this;\n        var messageToUser = getMessage(\"m037\");\n        console.error(message || messageToUser, error);\n        if (isSpyEnabled()) {\n            spyReport({\n                type: \"error\",\n                message: message,\n                error: error,\n                object: this\n            });\n        }\n        globalState.globalReactionErrorHandlers.forEach(function (f) {\n            return f(error, _this);\n        });\n    };\n    Reaction.prototype.dispose = function () {\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (!this._isRunning) {\n                startBatch();\n                clearObserving(this);\n                endBatch();\n            }\n        }\n    };\n    Reaction.prototype.getDisposer = function () {\n        var r = this.dispose.bind(this);\n        r.$mobx = this;\n        r.onError = registerErrorHandler;\n        return r;\n    };\n    Reaction.prototype.toString = function () {\n        return \"Reaction[\" + this.name + \"]\";\n    };\n    Reaction.prototype.whyRun = function () {\n        var observing = unique(this._isRunning ? this.newObserving : this.observing).map(function (dep) {\n            return dep.name;\n        });\n        return \"\\nWhyRun? reaction '\" + this.name + \"':\\n * Status: [\" + (this.isDisposed ? \"stopped\" : this._isRunning ? \"running\" : this.isScheduled() ? \"scheduled\" : \"idle\") + \"]\\n * This reaction will re-run if any of the following observables changes:\\n    \" + joinStrings(observing) + \"\\n    \" + (this._isRunning ? \" (... or any observable accessed during the remainder of the current run)\" : \"\") + \"\\n\\t\" + getMessage(\"m038\") + \"\\n\";\n    };\n    return Reaction;\n}();\nexports.Reaction = Reaction;\nfunction registerErrorHandler(handler) {\n    invariant(this && this.$mobx && isReaction(this.$mobx), \"Invalid `this`\");\n    invariant(!this.$mobx.errorHandler, \"Only one onErrorHandler can be registered\");\n    this.$mobx.errorHandler = handler;\n}\nfunction onReactionError(handler) {\n    globalState.globalReactionErrorHandlers.push(handler);\n    return function () {\n        var idx = globalState.globalReactionErrorHandlers.indexOf(handler);\n        if (idx >= 0) globalState.globalReactionErrorHandlers.splice(idx, 1);\n    };\n}\nvar MAX_REACTION_ITERATIONS = 100;\nvar reactionScheduler = function reactionScheduler(f) {\n    return f();\n};\nfunction runReactions() {\n    if (globalState.inBatch > 0 || globalState.isRunningReactions) return;\n    reactionScheduler(runReactionsHelper);\n}\nfunction runReactionsHelper() {\n    globalState.isRunningReactions = true;\n    var allReactions = globalState.pendingReactions;\n    var iterations = 0;\n    while (allReactions.length > 0) {\n        if (++iterations === MAX_REACTION_ITERATIONS) {\n            console.error(\"Reaction doesn't converge to a stable state after \" + MAX_REACTION_ITERATIONS + \" iterations.\" + (\" Probably there is a cycle in the reactive function: \" + allReactions[0]));\n            allReactions.splice(0);\n        }\n        var remainingReactions = allReactions.splice(0);\n        for (var i = 0, l = remainingReactions.length; i < l; i++) {\n            remainingReactions[i].runReaction();\n        }\n    }\n    globalState.isRunningReactions = false;\n}\nvar isReaction = createInstanceofPredicate(\"Reaction\", Reaction);\nfunction setReactionScheduler(fn) {\n    var baseScheduler = reactionScheduler;\n    reactionScheduler = function reactionScheduler(f) {\n        return fn(function () {\n            return baseScheduler(f);\n        });\n    };\n}\nfunction isSpyEnabled() {\n    return !!globalState.spyListeners.length;\n}\nfunction spyReport(event) {\n    if (!globalState.spyListeners.length) return;\n    var listeners = globalState.spyListeners;\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](event);\n    }\n}\nfunction spyReportStart(event) {\n    var change = objectAssign({}, event, { spyReportStart: true });\n    spyReport(change);\n}\nvar END_EVENT = { spyReportEnd: true };\nfunction spyReportEnd(change) {\n    if (change) spyReport(objectAssign({}, change, END_EVENT));else spyReport(END_EVENT);\n}\nfunction spy(listener) {\n    globalState.spyListeners.push(listener);\n    return once(function () {\n        var idx = globalState.spyListeners.indexOf(listener);\n        if (idx !== -1) globalState.spyListeners.splice(idx, 1);\n    });\n}\nexports.spy = spy;\nfunction hasInterceptors(interceptable) {\n    return interceptable.interceptors && interceptable.interceptors.length > 0;\n}\nfunction registerInterceptor(interceptable, handler) {\n    var interceptors = interceptable.interceptors || (interceptable.interceptors = []);\n    interceptors.push(handler);\n    return once(function () {\n        var idx = interceptors.indexOf(handler);\n        if (idx !== -1) interceptors.splice(idx, 1);\n    });\n}\nfunction interceptChange(interceptable, change) {\n    var prevU = untrackedStart();\n    try {\n        var interceptors = interceptable.interceptors;\n        if (interceptors) for (var i = 0, l = interceptors.length; i < l; i++) {\n            change = interceptors[i](change);\n            invariant(!change || change.type, \"Intercept handlers should return nothing or a change object\");\n            if (!change) break;\n        }\n        return change;\n    } finally {\n        untrackedEnd(prevU);\n    }\n}\nfunction hasListeners(listenable) {\n    return listenable.changeListeners && listenable.changeListeners.length > 0;\n}\nfunction registerListener(listenable, handler) {\n    var listeners = listenable.changeListeners || (listenable.changeListeners = []);\n    listeners.push(handler);\n    return once(function () {\n        var idx = listeners.indexOf(handler);\n        if (idx !== -1) listeners.splice(idx, 1);\n    });\n}\nfunction notifyListeners(listenable, change) {\n    var prevU = untrackedStart();\n    var listeners = listenable.changeListeners;\n    if (!listeners) return;\n    listeners = listeners.slice();\n    for (var i = 0, l = listeners.length; i < l; i++) {\n        listeners[i](change);\n    }\n    untrackedEnd(prevU);\n}\nfunction asReference(value) {\n    deprecated(\"asReference is deprecated, use observable.ref instead\");\n    return observable.ref(value);\n}\nexports.asReference = asReference;\nfunction asStructure(value) {\n    deprecated(\"asStructure is deprecated. Use observable.struct, computed.struct or reaction options instead.\");\n    return observable.struct(value);\n}\nexports.asStructure = asStructure;\nfunction asFlat(value) {\n    deprecated(\"asFlat is deprecated, use observable.shallow instead\");\n    return observable.shallow(value);\n}\nexports.asFlat = asFlat;\nfunction asMap(data) {\n    deprecated(\"asMap is deprecated, use observable.map or observable.shallowMap instead\");\n    return observable.map(data || {});\n}\nexports.asMap = asMap;\nfunction isModifierDescriptor(thing) {\n    return (typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null && thing.isMobxModifierDescriptor === true;\n}\nexports.isModifierDescriptor = isModifierDescriptor;\nfunction createModifierDescriptor(enhancer, initialValue) {\n    invariant(!isModifierDescriptor(initialValue), \"Modifiers cannot be nested\");\n    return {\n        isMobxModifierDescriptor: true,\n        initialValue: initialValue,\n        enhancer: enhancer\n    };\n}\nfunction deepEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return observable.array(v, name);\n    if (isPlainObject(v)) return observable.object(v, name);\n    if (isES6Map(v)) return observable.map(v, name);\n    return v;\n}\nfunction shallowEnhancer(v, _, name) {\n    if (isModifierDescriptor(v)) fail(\"You tried to assign a modifier wrapped value to a collection, please define modifiers when creating the collection, not when modifying it\");\n    if (v === undefined || v === null) return v;\n    if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v)) return v;\n    if (Array.isArray(v)) return observable.shallowArray(v, name);\n    if (isPlainObject(v)) return observable.shallowObject(v, name);\n    if (isES6Map(v)) return observable.shallowMap(v, name);\n    return fail(\"The shallow modifier / decorator can only used in combination with arrays, objects and maps\");\n}\nfunction referenceEnhancer(newValue) {\n    return newValue;\n}\nfunction deepStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    if (isObservable(v)) return v;\n    if (Array.isArray(v)) return new ObservableArray(v, deepStructEnhancer, name);\n    if (isES6Map(v)) return new ObservableMap(v, deepStructEnhancer, name);\n    if (isPlainObject(v)) {\n        var res = {};\n        asObservableObject(res, name);\n        extendObservableHelper(res, deepStructEnhancer, [v]);\n        return res;\n    }\n    return v;\n}\nfunction refStructEnhancer(v, oldValue, name) {\n    if (deepEqual(v, oldValue)) return oldValue;\n    return v;\n}\nvar MAX_SPLICE_SIZE = 10000;\nvar safariPrototypeSetterInheritanceBug = function () {\n    var v = false;\n    var p = {};\n    Object.defineProperty(p, \"0\", { set: function set() {\n            v = true;\n        } });\n    Object.create(p)[\"0\"] = 1;\n    return v === false;\n}();\nvar OBSERVABLE_ARRAY_BUFFER_SIZE = 0;\nvar StubArray = function () {\n    function StubArray() {}\n    return StubArray;\n}();\nStubArray.prototype = [];\nvar ObservableArrayAdministration = function () {\n    function ObservableArrayAdministration(name, enhancer, array, owned) {\n        this.array = array;\n        this.owned = owned;\n        this.lastKnownLength = 0;\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.atom = new BaseAtom(name || \"ObservableArray@\" + getNextId());\n        this.enhancer = function (newV, oldV) {\n            return enhancer(newV, oldV, name + \"[..]\");\n        };\n    }\n    ObservableArrayAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableArrayAdministration.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        if (fireImmediately) {\n            listener({\n                object: this.array,\n                type: \"splice\",\n                index: 0,\n                added: this.values.slice(),\n                addedCount: this.values.length,\n                removed: [],\n                removedCount: 0\n            });\n        }\n        return registerListener(this, listener);\n    };\n    ObservableArrayAdministration.prototype.getArrayLength = function () {\n        this.atom.reportObserved();\n        return this.values.length;\n    };\n    ObservableArrayAdministration.prototype.setArrayLength = function (newLength) {\n        if (typeof newLength !== \"number\" || newLength < 0) throw new Error(\"[mobx.array] Out of range: \" + newLength);\n        var currentLength = this.values.length;\n        if (newLength === currentLength) return;else if (newLength > currentLength) {\n            var newItems = new Array(newLength - currentLength);\n            for (var i = 0; i < newLength - currentLength; i++) {\n                newItems[i] = undefined;\n            }this.spliceWithArray(currentLength, 0, newItems);\n        } else this.spliceWithArray(newLength, currentLength - newLength);\n    };\n    ObservableArrayAdministration.prototype.updateArrayLength = function (oldLength, delta) {\n        if (oldLength !== this.lastKnownLength) throw new Error(\"[mobx] Modification exception: the internal structure of an observable array was changed. Did you use peek() to change it?\");\n        this.lastKnownLength += delta;\n        if (delta > 0 && oldLength + delta + 1 > OBSERVABLE_ARRAY_BUFFER_SIZE) reserveArrayBuffer(oldLength + delta + 1);\n    };\n    ObservableArrayAdministration.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        var _this = this;\n        checkIfStateModificationsAreAllowed(this.atom);\n        var length = this.values.length;\n        if (index === undefined) index = 0;else if (index > length) index = length;else if (index < 0) index = Math.max(0, length + index);\n        if (arguments.length === 1) deleteCount = length - index;else if (deleteCount === undefined || deleteCount === null) deleteCount = 0;else deleteCount = Math.max(0, Math.min(deleteCount, length - index));\n        if (newItems === undefined) newItems = [];\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                object: this.array,\n                type: \"splice\",\n                index: index,\n                removedCount: deleteCount,\n                added: newItems\n            });\n            if (!change) return EMPTY_ARRAY;\n            deleteCount = change.removedCount;\n            newItems = change.added;\n        }\n        newItems = newItems.map(function (v) {\n            return _this.enhancer(v, undefined);\n        });\n        var lengthDelta = newItems.length - deleteCount;\n        this.updateArrayLength(length, lengthDelta);\n        var res = this.spliceItemsIntoValues(index, deleteCount, newItems);\n        if (deleteCount !== 0 || newItems.length !== 0) this.notifyArraySplice(index, newItems, res);\n        return res;\n    };\n    ObservableArrayAdministration.prototype.spliceItemsIntoValues = function (index, deleteCount, newItems) {\n        if (newItems.length < MAX_SPLICE_SIZE) {\n            return (_a = this.values).splice.apply(_a, [index, deleteCount].concat(newItems));\n        } else {\n            var res = this.values.slice(index, index + deleteCount);\n            this.values = this.values.slice(0, index).concat(newItems, this.values.slice(index + deleteCount));\n            return res;\n        }\n        var _a;\n    };\n    ObservableArrayAdministration.prototype.notifyArrayChildUpdate = function (index, newValue, oldValue) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"update\",\n            index: index, newValue: newValue, oldValue: oldValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableArrayAdministration.prototype.notifyArraySplice = function (index, added, removed) {\n        var notifySpy = !this.owned && isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            object: this.array,\n            type: \"splice\",\n            index: index, removed: removed, added: added,\n            removedCount: removed.length,\n            addedCount: added.length\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        this.atom.reportChanged();\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    return ObservableArrayAdministration;\n}();\nvar ObservableArray = function (_super) {\n    __extends(ObservableArray, _super);\n    function ObservableArray(initialValues, enhancer, name, owned) {\n        if (name === void 0) {\n            name = \"ObservableArray@\" + getNextId();\n        }\n        if (owned === void 0) {\n            owned = false;\n        }\n        var _this = _super.call(this) || this;\n        var adm = new ObservableArrayAdministration(name, enhancer, _this, owned);\n        addHiddenFinalProp(_this, \"$mobx\", adm);\n        if (initialValues && initialValues.length) {\n            adm.updateArrayLength(0, initialValues.length);\n            adm.values = initialValues.map(function (v) {\n                return enhancer(v, undefined, name + \"[..]\");\n            });\n            adm.notifyArraySplice(0, adm.values.slice(), EMPTY_ARRAY);\n        } else {\n            adm.values = [];\n        }\n        if (safariPrototypeSetterInheritanceBug) {\n            Object.defineProperty(adm.array, \"0\", ENTRY_0);\n        }\n        return _this;\n    }\n    ObservableArray.prototype.intercept = function (handler) {\n        return this.$mobx.intercept(handler);\n    };\n    ObservableArray.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately === void 0) {\n            fireImmediately = false;\n        }\n        return this.$mobx.observe(listener, fireImmediately);\n    };\n    ObservableArray.prototype.clear = function () {\n        return this.splice(0);\n    };\n    ObservableArray.prototype.concat = function () {\n        var arrays = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            arrays[_i] = arguments[_i];\n        }\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.concat.apply(this.peek(), arrays.map(function (a) {\n            return isObservableArray(a) ? a.peek() : a;\n        }));\n    };\n    ObservableArray.prototype.replace = function (newItems) {\n        return this.$mobx.spliceWithArray(0, this.$mobx.values.length, newItems);\n    };\n    ObservableArray.prototype.toJS = function () {\n        return this.slice();\n    };\n    ObservableArray.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableArray.prototype.peek = function () {\n        return this.$mobx.values;\n    };\n    ObservableArray.prototype.find = function (predicate, thisArg, fromIndex) {\n        if (fromIndex === void 0) {\n            fromIndex = 0;\n        }\n        this.$mobx.atom.reportObserved();\n        var items = this.$mobx.values,\n            l = items.length;\n        for (var i = fromIndex; i < l; i++) {\n            if (predicate.call(thisArg, items[i], i, this)) return items[i];\n        }return undefined;\n    };\n    ObservableArray.prototype.splice = function (index, deleteCount) {\n        var newItems = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            newItems[_i - 2] = arguments[_i];\n        }\n        switch (arguments.length) {\n            case 0:\n                return [];\n            case 1:\n                return this.$mobx.spliceWithArray(index);\n            case 2:\n                return this.$mobx.spliceWithArray(index, deleteCount);\n        }\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.spliceWithArray = function (index, deleteCount, newItems) {\n        return this.$mobx.spliceWithArray(index, deleteCount, newItems);\n    };\n    ObservableArray.prototype.push = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(adm.values.length, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.pop = function () {\n        return this.splice(Math.max(this.$mobx.values.length - 1, 0), 1)[0];\n    };\n    ObservableArray.prototype.shift = function () {\n        return this.splice(0, 1)[0];\n    };\n    ObservableArray.prototype.unshift = function () {\n        var items = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            items[_i] = arguments[_i];\n        }\n        var adm = this.$mobx;\n        adm.spliceWithArray(0, 0, items);\n        return adm.values.length;\n    };\n    ObservableArray.prototype.reverse = function () {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.reverse.apply(clone, arguments);\n    };\n    ObservableArray.prototype.sort = function (compareFn) {\n        this.$mobx.atom.reportObserved();\n        var clone = this.slice();\n        return clone.sort.apply(clone, arguments);\n    };\n    ObservableArray.prototype.remove = function (value) {\n        var idx = this.$mobx.values.indexOf(value);\n        if (idx > -1) {\n            this.splice(idx, 1);\n            return true;\n        }\n        return false;\n    };\n    ObservableArray.prototype.move = function (fromIndex, toIndex) {\n        function checkIndex(index) {\n            if (index < 0) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is negative\");\n            }\n            var length = this.$mobx.values.length;\n            if (index >= length) {\n                throw new Error(\"[mobx.array] Index out of bounds: \" + index + \" is not smaller than \" + length);\n            }\n        }\n        checkIndex.call(this, fromIndex);\n        checkIndex.call(this, toIndex);\n        if (fromIndex === toIndex) {\n            return;\n        }\n        var oldItems = this.$mobx.values;\n        var newItems;\n        if (fromIndex < toIndex) {\n            newItems = oldItems.slice(0, fromIndex).concat(oldItems.slice(fromIndex + 1, toIndex + 1), [oldItems[fromIndex]], oldItems.slice(toIndex + 1));\n        } else {\n            newItems = oldItems.slice(0, toIndex).concat([oldItems[fromIndex]], oldItems.slice(toIndex, fromIndex), oldItems.slice(fromIndex + 1));\n        }\n        this.replace(newItems);\n    };\n    ObservableArray.prototype.toString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toString.apply(this.$mobx.values, arguments);\n    };\n    ObservableArray.prototype.toLocaleString = function () {\n        this.$mobx.atom.reportObserved();\n        return Array.prototype.toLocaleString.apply(this.$mobx.values, arguments);\n    };\n    return ObservableArray;\n}(StubArray);\ndeclareIterator(ObservableArray.prototype, function () {\n    return arrayAsIterator(this.slice());\n});\nmakeNonEnumerable(ObservableArray.prototype, [\"constructor\", \"intercept\", \"observe\", \"clear\", \"concat\", \"replace\", \"toJS\", \"toJSON\", \"peek\", \"find\", \"splice\", \"spliceWithArray\", \"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"remove\", \"move\", \"toString\", \"toLocaleString\"]);\nObject.defineProperty(ObservableArray.prototype, \"length\", {\n    enumerable: false,\n    configurable: true,\n    get: function get() {\n        return this.$mobx.getArrayLength();\n    },\n    set: function set(newLength) {\n        this.$mobx.setArrayLength(newLength);\n    }\n});\n[\"every\", \"filter\", \"forEach\", \"indexOf\", \"join\", \"lastIndexOf\", \"map\", \"reduce\", \"reduceRight\", \"slice\", \"some\"].forEach(function (funcName) {\n    var baseFunc = Array.prototype[funcName];\n    invariant(typeof baseFunc === \"function\", \"Base function not defined on Array prototype: '\" + funcName + \"'\");\n    addHiddenProp(ObservableArray.prototype, funcName, function () {\n        this.$mobx.atom.reportObserved();\n        return baseFunc.apply(this.$mobx.values, arguments);\n    });\n});\nvar ENTRY_0 = {\n    configurable: true,\n    enumerable: false,\n    set: createArraySetter(0),\n    get: createArrayGetter(0)\n};\nfunction createArrayBufferItem(index) {\n    var set = createArraySetter(index);\n    var get = createArrayGetter(index);\n    Object.defineProperty(ObservableArray.prototype, \"\" + index, {\n        enumerable: false,\n        configurable: true,\n        set: set, get: get\n    });\n}\nfunction createArraySetter(index) {\n    return function (newValue) {\n        var adm = this.$mobx;\n        var values = adm.values;\n        if (index < values.length) {\n            checkIfStateModificationsAreAllowed(adm.atom);\n            var oldValue = values[index];\n            if (hasInterceptors(adm)) {\n                var change = interceptChange(adm, {\n                    type: \"update\",\n                    object: adm.array,\n                    index: index, newValue: newValue\n                });\n                if (!change) return;\n                newValue = change.newValue;\n            }\n            newValue = adm.enhancer(newValue, oldValue);\n            var changed = newValue !== oldValue;\n            if (changed) {\n                values[index] = newValue;\n                adm.notifyArrayChildUpdate(index, newValue, oldValue);\n            }\n        } else if (index === values.length) {\n            adm.spliceWithArray(index, 0, [newValue]);\n        } else throw new Error(\"[mobx.array] Index out of bounds, \" + index + \" is larger than \" + values.length);\n    };\n}\nfunction createArrayGetter(index) {\n    return function () {\n        var impl = this.$mobx;\n        if (impl) {\n            if (index < impl.values.length) {\n                impl.atom.reportObserved();\n                return impl.values[index];\n            }\n            console.warn(\"[mobx.array] Attempt to read an array index (\" + index + \") that is out of bounds (\" + impl.values.length + \"). Please check length first. Out of bound indices will not be tracked by MobX\");\n        }\n        return undefined;\n    };\n}\nfunction reserveArrayBuffer(max) {\n    for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max; index++) {\n        createArrayBufferItem(index);\n    }OBSERVABLE_ARRAY_BUFFER_SIZE = max;\n}\nreserveArrayBuffer(1000);\nvar isObservableArrayAdministration = createInstanceofPredicate(\"ObservableArrayAdministration\", ObservableArrayAdministration);\nfunction isObservableArray(thing) {\n    return isObject(thing) && isObservableArrayAdministration(thing.$mobx);\n}\nexports.isObservableArray = isObservableArray;\nvar ObservableMapMarker = {};\nvar ObservableMap = function () {\n    function ObservableMap(initialData, enhancer, name) {\n        if (enhancer === void 0) {\n            enhancer = deepEnhancer;\n        }\n        if (name === void 0) {\n            name = \"ObservableMap@\" + getNextId();\n        }\n        this.enhancer = enhancer;\n        this.name = name;\n        this.$mobx = ObservableMapMarker;\n        this._data = {};\n        this._hasMap = {};\n        this._keys = new ObservableArray(undefined, referenceEnhancer, this.name + \".keys()\", true);\n        this.interceptors = null;\n        this.changeListeners = null;\n        this.merge(initialData);\n    }\n    ObservableMap.prototype._has = function (key) {\n        return typeof this._data[key] !== \"undefined\";\n    };\n    ObservableMap.prototype.has = function (key) {\n        if (!this.isValidKey(key)) return false;\n        key = \"\" + key;\n        if (this._hasMap[key]) return this._hasMap[key].get();\n        return this._updateHasMapEntry(key, false).get();\n    };\n    ObservableMap.prototype.set = function (key, value) {\n        this.assertValidKey(key);\n        key = \"\" + key;\n        var hasKey = this._has(key);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: hasKey ? \"update\" : \"add\",\n                object: this,\n                newValue: value,\n                name: key\n            });\n            if (!change) return this;\n            value = change.newValue;\n        }\n        if (hasKey) {\n            this._updateValue(key, value);\n        } else {\n            this._addValue(key, value);\n        }\n        return this;\n    };\n    ObservableMap.prototype.delete = function (key) {\n        var _this = this;\n        this.assertValidKey(key);\n        key = \"\" + key;\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, {\n                type: \"delete\",\n                object: this,\n                name: key\n            });\n            if (!change) return false;\n        }\n        if (this._has(key)) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"delete\",\n                object: this,\n                oldValue: this._data[key].value,\n                name: key\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            runInTransaction(function () {\n                _this._keys.remove(key);\n                _this._updateHasMapEntry(key, false);\n                var observable = _this._data[key];\n                observable.setNewValue(undefined);\n                _this._data[key] = undefined;\n            });\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n            return true;\n        }\n        return false;\n    };\n    ObservableMap.prototype._updateHasMapEntry = function (key, value) {\n        var entry = this._hasMap[key];\n        if (entry) {\n            entry.setNewValue(value);\n        } else {\n            entry = this._hasMap[key] = new ObservableValue(value, referenceEnhancer, this.name + \".\" + key + \"?\", false);\n        }\n        return entry;\n    };\n    ObservableMap.prototype._updateValue = function (name, newValue) {\n        var observable = this._data[name];\n        newValue = observable.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            var notify = hasListeners(this);\n            var change = notify || notifySpy ? {\n                type: \"update\",\n                object: this,\n                oldValue: observable.value,\n                name: name, newValue: newValue\n            } : null;\n            if (notifySpy) spyReportStart(change);\n            observable.setNewValue(newValue);\n            if (notify) notifyListeners(this, change);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableMap.prototype._addValue = function (name, newValue) {\n        var _this = this;\n        runInTransaction(function () {\n            var observable = _this._data[name] = new ObservableValue(newValue, _this.enhancer, _this.name + \".\" + name, false);\n            newValue = observable.value;\n            _this._updateHasMapEntry(name, true);\n            _this._keys.push(name);\n        });\n        var notifySpy = isSpyEnabled();\n        var notify = hasListeners(this);\n        var change = notify || notifySpy ? {\n            type: \"add\",\n            object: this,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        if (notify) notifyListeners(this, change);\n        if (notifySpy) spyReportEnd();\n    };\n    ObservableMap.prototype.get = function (key) {\n        key = \"\" + key;\n        if (this.has(key)) return this._data[key].get();\n        return undefined;\n    };\n    ObservableMap.prototype.keys = function () {\n        return arrayAsIterator(this._keys.slice());\n    };\n    ObservableMap.prototype.values = function () {\n        return arrayAsIterator(this._keys.map(this.get, this));\n    };\n    ObservableMap.prototype.entries = function () {\n        var _this = this;\n        return arrayAsIterator(this._keys.map(function (key) {\n            return [key, _this.get(key)];\n        }));\n    };\n    ObservableMap.prototype.forEach = function (callback, thisArg) {\n        var _this = this;\n        this.keys().forEach(function (key) {\n            return callback.call(thisArg, _this.get(key), key, _this);\n        });\n    };\n    ObservableMap.prototype.merge = function (other) {\n        var _this = this;\n        if (isObservableMap(other)) {\n            other = other.toJS();\n        }\n        runInTransaction(function () {\n            if (isPlainObject(other)) Object.keys(other).forEach(function (key) {\n                return _this.set(key, other[key]);\n            });else if (Array.isArray(other)) other.forEach(function (_a) {\n                var key = _a[0],\n                    value = _a[1];\n                return _this.set(key, value);\n            });else if (isES6Map(other)) other.forEach(function (value, key) {\n                return _this.set(key, value);\n            });else if (other !== null && other !== undefined) fail(\"Cannot initialize map from \" + other);\n        });\n        return this;\n    };\n    ObservableMap.prototype.clear = function () {\n        var _this = this;\n        runInTransaction(function () {\n            untracked(function () {\n                _this.keys().forEach(_this.delete, _this);\n            });\n        });\n    };\n    ObservableMap.prototype.replace = function (values) {\n        var _this = this;\n        runInTransaction(function () {\n            _this.clear();\n            _this.merge(values);\n        });\n        return this;\n    };\n    Object.defineProperty(ObservableMap.prototype, \"size\", {\n        get: function get() {\n            return this._keys.length;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    ObservableMap.prototype.toJS = function () {\n        var _this = this;\n        var res = {};\n        this.keys().forEach(function (key) {\n            return res[key] = _this.get(key);\n        });\n        return res;\n    };\n    ObservableMap.prototype.toJSON = function () {\n        return this.toJS();\n    };\n    ObservableMap.prototype.isValidKey = function (key) {\n        if (key === null || key === undefined) return false;\n        if (typeof key === \"string\" || typeof key === \"number\" || typeof key === \"boolean\") return true;\n        return false;\n    };\n    ObservableMap.prototype.assertValidKey = function (key) {\n        if (!this.isValidKey(key)) throw new Error(\"[mobx.map] Invalid key: '\" + key + \"', only strings, numbers and booleans are accepted as key in observable maps.\");\n    };\n    ObservableMap.prototype.toString = function () {\n        var _this = this;\n        return this.name + \"[{ \" + this.keys().map(function (key) {\n            return key + \": \" + (\"\" + _this.get(key));\n        }).join(\", \") + \" }]\";\n    };\n    ObservableMap.prototype.observe = function (listener, fireImmediately) {\n        invariant(fireImmediately !== true, getMessage(\"m033\"));\n        return registerListener(this, listener);\n    };\n    ObservableMap.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableMap;\n}();\nexports.ObservableMap = ObservableMap;\ndeclareIterator(ObservableMap.prototype, function () {\n    return this.entries();\n});\nfunction map(initialValues) {\n    deprecated(\"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\");\n    return observable.map(initialValues);\n}\nexports.map = map;\nvar isObservableMap = createInstanceofPredicate(\"ObservableMap\", ObservableMap);\nexports.isObservableMap = isObservableMap;\nvar ObservableObjectAdministration = function () {\n    function ObservableObjectAdministration(target, name) {\n        this.target = target;\n        this.name = name;\n        this.values = {};\n        this.changeListeners = null;\n        this.interceptors = null;\n    }\n    ObservableObjectAdministration.prototype.observe = function (callback, fireImmediately) {\n        invariant(fireImmediately !== true, \"`observe` doesn't support the fire immediately property for observable objects.\");\n        return registerListener(this, callback);\n    };\n    ObservableObjectAdministration.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    return ObservableObjectAdministration;\n}();\nfunction asObservableObject(target, name) {\n    if (isObservableObject(target)) return target.$mobx;\n    invariant(Object.isExtensible(target), getMessage(\"m035\"));\n    if (!isPlainObject(target)) name = (target.constructor.name || \"ObservableObject\") + \"@\" + getNextId();\n    if (!name) name = \"ObservableObject@\" + getNextId();\n    var adm = new ObservableObjectAdministration(target, name);\n    addHiddenFinalProp(target, \"$mobx\", adm);\n    return adm;\n}\nfunction defineObservablePropertyFromDescriptor(adm, propName, descriptor, defaultEnhancer) {\n    if (adm.values[propName]) {\n        invariant(\"value\" in descriptor, \"The property \" + propName + \" in \" + adm.name + \" is already observable, cannot redefine it as computed property\");\n        adm.target[propName] = descriptor.value;\n        return;\n    }\n    if (\"value\" in descriptor) {\n        if (isModifierDescriptor(descriptor.value)) {\n            var modifierDescriptor = descriptor.value;\n            defineObservableProperty(adm, propName, modifierDescriptor.initialValue, modifierDescriptor.enhancer);\n        } else if (isAction(descriptor.value) && descriptor.value.autoBind === true) {\n            defineBoundAction(adm.target, propName, descriptor.value.originalFn);\n        } else if (isComputedValue(descriptor.value)) {\n            defineComputedPropertyFromComputedValue(adm, propName, descriptor.value);\n        } else {\n            defineObservableProperty(adm, propName, descriptor.value, defaultEnhancer);\n        }\n    } else {\n        defineComputedProperty(adm, propName, descriptor.get, descriptor.set, false, true);\n    }\n}\nfunction defineObservableProperty(adm, propName, newValue, enhancer) {\n    assertPropertyConfigurable(adm.target, propName);\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            object: adm.target,\n            name: propName,\n            type: \"add\",\n            newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    var observable = adm.values[propName] = new ObservableValue(newValue, enhancer, adm.name + \".\" + propName, false);\n    newValue = observable.value;\n    Object.defineProperty(adm.target, propName, generateObservablePropConfig(propName));\n    notifyPropertyAddition(adm, adm.target, propName, newValue);\n}\nfunction defineComputedProperty(adm, propName, getter, setter, compareStructural, asInstanceProperty) {\n    if (asInstanceProperty) assertPropertyConfigurable(adm.target, propName);\n    adm.values[propName] = new ComputedValue(getter, adm.target, compareStructural, adm.name + \".\" + propName, setter);\n    if (asInstanceProperty) {\n        Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n    }\n}\nfunction defineComputedPropertyFromComputedValue(adm, propName, computedValue) {\n    var name = adm.name + \".\" + propName;\n    computedValue.name = name;\n    if (!computedValue.scope) computedValue.scope = adm.target;\n    adm.values[propName] = computedValue;\n    Object.defineProperty(adm.target, propName, generateComputedPropConfig(propName));\n}\nvar observablePropertyConfigs = {};\nvar computedPropertyConfigs = {};\nfunction generateObservablePropConfig(propName) {\n    return observablePropertyConfigs[propName] || (observablePropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: true,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            setPropertyValue(this, propName, v);\n        }\n    });\n}\nfunction generateComputedPropConfig(propName) {\n    return computedPropertyConfigs[propName] || (computedPropertyConfigs[propName] = {\n        configurable: true,\n        enumerable: false,\n        get: function get() {\n            return this.$mobx.values[propName].get();\n        },\n        set: function set(v) {\n            return this.$mobx.values[propName].set(v);\n        }\n    });\n}\nfunction setPropertyValue(instance, name, newValue) {\n    var adm = instance.$mobx;\n    var observable = adm.values[name];\n    if (hasInterceptors(adm)) {\n        var change = interceptChange(adm, {\n            type: \"update\",\n            object: instance,\n            name: name, newValue: newValue\n        });\n        if (!change) return;\n        newValue = change.newValue;\n    }\n    newValue = observable.prepareNewValue(newValue);\n    if (newValue !== UNCHANGED) {\n        var notify = hasListeners(adm);\n        var notifySpy = isSpyEnabled();\n        var change = notify || notifySpy ? {\n            type: \"update\",\n            object: instance,\n            oldValue: observable.value,\n            name: name, newValue: newValue\n        } : null;\n        if (notifySpy) spyReportStart(change);\n        observable.setNewValue(newValue);\n        if (notify) notifyListeners(adm, change);\n        if (notifySpy) spyReportEnd();\n    }\n}\nfunction notifyPropertyAddition(adm, object, name, newValue) {\n    var notify = hasListeners(adm);\n    var notifySpy = isSpyEnabled();\n    var change = notify || notifySpy ? {\n        type: \"add\",\n        object: object, name: name, newValue: newValue\n    } : null;\n    if (notifySpy) spyReportStart(change);\n    if (notify) notifyListeners(adm, change);\n    if (notifySpy) spyReportEnd();\n}\nvar isObservableObjectAdministration = createInstanceofPredicate(\"ObservableObjectAdministration\", ObservableObjectAdministration);\nfunction isObservableObject(thing) {\n    if (isObject(thing)) {\n        runLazyInitializers(thing);\n        return isObservableObjectAdministration(thing.$mobx);\n    }\n    return false;\n}\nexports.isObservableObject = isObservableObject;\nvar UNCHANGED = {};\nvar ObservableValue = function (_super) {\n    __extends(ObservableValue, _super);\n    function ObservableValue(value, enhancer, name, notifySpy) {\n        if (name === void 0) {\n            name = \"ObservableValue@\" + getNextId();\n        }\n        if (notifySpy === void 0) {\n            notifySpy = true;\n        }\n        var _this = _super.call(this, name) || this;\n        _this.enhancer = enhancer;\n        _this.hasUnreportedChange = false;\n        _this.value = enhancer(value, undefined, name);\n        if (notifySpy && isSpyEnabled()) {\n            spyReport({ type: \"create\", object: _this, newValue: _this.value });\n        }\n        return _this;\n    }\n    ObservableValue.prototype.set = function (newValue) {\n        var oldValue = this.value;\n        newValue = this.prepareNewValue(newValue);\n        if (newValue !== UNCHANGED) {\n            var notifySpy = isSpyEnabled();\n            if (notifySpy) {\n                spyReportStart({\n                    type: \"update\",\n                    object: this,\n                    newValue: newValue, oldValue: oldValue\n                });\n            }\n            this.setNewValue(newValue);\n            if (notifySpy) spyReportEnd();\n        }\n    };\n    ObservableValue.prototype.prepareNewValue = function (newValue) {\n        checkIfStateModificationsAreAllowed(this);\n        if (hasInterceptors(this)) {\n            var change = interceptChange(this, { object: this, type: \"update\", newValue: newValue });\n            if (!change) return UNCHANGED;\n            newValue = change.newValue;\n        }\n        newValue = this.enhancer(newValue, this.value, this.name);\n        return this.value !== newValue ? newValue : UNCHANGED;\n    };\n    ObservableValue.prototype.setNewValue = function (newValue) {\n        var oldValue = this.value;\n        this.value = newValue;\n        this.reportChanged();\n        if (hasListeners(this)) {\n            notifyListeners(this, {\n                type: \"update\",\n                object: this,\n                newValue: newValue,\n                oldValue: oldValue\n            });\n        }\n    };\n    ObservableValue.prototype.get = function () {\n        this.reportObserved();\n        return this.value;\n    };\n    ObservableValue.prototype.intercept = function (handler) {\n        return registerInterceptor(this, handler);\n    };\n    ObservableValue.prototype.observe = function (listener, fireImmediately) {\n        if (fireImmediately) listener({\n            object: this,\n            type: \"update\",\n            newValue: this.value,\n            oldValue: undefined\n        });\n        return registerListener(this, listener);\n    };\n    ObservableValue.prototype.toJSON = function () {\n        return this.get();\n    };\n    ObservableValue.prototype.toString = function () {\n        return this.name + \"[\" + this.value + \"]\";\n    };\n    ObservableValue.prototype.valueOf = function () {\n        return toPrimitive(this.get());\n    };\n    return ObservableValue;\n}(BaseAtom);\nObservableValue.prototype[primitiveSymbol()] = ObservableValue.prototype.valueOf;\nvar isObservableValue = createInstanceofPredicate(\"ObservableValue\", ObservableValue);\nexports.isBoxedObservable = isObservableValue;\nfunction getAtom(thing, property) {\n    if ((typeof thing === \"undefined\" ? \"undefined\" : _typeof(thing)) === \"object\" && thing !== null) {\n        if (isObservableArray(thing)) {\n            invariant(property === undefined, getMessage(\"m036\"));\n            return thing.$mobx.atom;\n        }\n        if (isObservableMap(thing)) {\n            var anyThing = thing;\n            if (property === undefined) return getAtom(anyThing._keys);\n            var observable_2 = anyThing._data[property] || anyThing._hasMap[property];\n            invariant(!!observable_2, \"the entry '\" + property + \"' does not exist in the observable map '\" + getDebugName(thing) + \"'\");\n            return observable_2;\n        }\n        runLazyInitializers(thing);\n        if (isObservableObject(thing)) {\n            if (!property) return fail(\"please specify a property\");\n            var observable_3 = thing.$mobx.values[property];\n            invariant(!!observable_3, \"no observable property '\" + property + \"' found on the observable object '\" + getDebugName(thing) + \"'\");\n            return observable_3;\n        }\n        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {\n            return thing;\n        }\n    } else if (typeof thing === \"function\") {\n        if (isReaction(thing.$mobx)) {\n            return thing.$mobx;\n        }\n    }\n    return fail(\"Cannot obtain atom from \" + thing);\n}\nfunction getAdministration(thing, property) {\n    invariant(thing, \"Expecting some object\");\n    if (property !== undefined) return getAdministration(getAtom(thing, property));\n    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;\n    if (isObservableMap(thing)) return thing;\n    runLazyInitializers(thing);\n    if (thing.$mobx) return thing.$mobx;\n    invariant(false, \"Cannot obtain administration from \" + thing);\n}\nfunction getDebugName(thing, property) {\n    var named;\n    if (property !== undefined) named = getAtom(thing, property);else if (isObservableObject(thing) || isObservableMap(thing)) named = getAdministration(thing);else named = getAtom(thing);\n    return named.name;\n}\nfunction createClassPropertyDecorator(onInitialize, _get, _set, enumerable, allowCustomArguments) {\n    function classPropertyDecorator(target, key, descriptor, customArgs, argLen) {\n        if (argLen === void 0) {\n            argLen = 0;\n        }\n        invariant(allowCustomArguments || quacksLikeADecorator(arguments), \"This function is a decorator, but it wasn't invoked like a decorator\");\n        if (!descriptor) {\n            var newDescriptor = {\n                enumerable: enumerable,\n                configurable: true,\n                get: function get() {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) typescriptInitializeProperty(this, key, undefined, onInitialize, customArgs, descriptor);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (!this.__mobxInitializedProps || this.__mobxInitializedProps[key] !== true) {\n                        typescriptInitializeProperty(this, key, v, onInitialize, customArgs, descriptor);\n                    } else {\n                        _set.call(this, key, v);\n                    }\n                }\n            };\n            if (arguments.length < 3 || arguments.length === 5 && argLen < 3) {\n                Object.defineProperty(target, key, newDescriptor);\n            }\n            return newDescriptor;\n        } else {\n            if (!hasOwnProperty(target, \"__mobxLazyInitializers\")) {\n                addHiddenProp(target, \"__mobxLazyInitializers\", target.__mobxLazyInitializers && target.__mobxLazyInitializers.slice() || []);\n            }\n            var value_1 = descriptor.value,\n                initializer_1 = descriptor.initializer;\n            target.__mobxLazyInitializers.push(function (instance) {\n                onInitialize(instance, key, initializer_1 ? initializer_1.call(instance) : value_1, customArgs, descriptor);\n            });\n            return {\n                enumerable: enumerable, configurable: true,\n                get: function get() {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    return _get.call(this, key);\n                },\n                set: function set(v) {\n                    if (this.__mobxDidRunLazyInitializers !== true) runLazyInitializers(this);\n                    _set.call(this, key, v);\n                }\n            };\n        }\n    }\n    if (allowCustomArguments) {\n        return function () {\n            if (quacksLikeADecorator(arguments)) return classPropertyDecorator.apply(null, arguments);\n            var outerArgs = arguments;\n            var argLen = arguments.length;\n            return function (target, key, descriptor) {\n                return classPropertyDecorator(target, key, descriptor, outerArgs, argLen);\n            };\n        };\n    }\n    return classPropertyDecorator;\n}\nfunction typescriptInitializeProperty(instance, key, v, onInitialize, customArgs, baseDescriptor) {\n    if (!hasOwnProperty(instance, \"__mobxInitializedProps\")) addHiddenProp(instance, \"__mobxInitializedProps\", {});\n    instance.__mobxInitializedProps[key] = true;\n    onInitialize(instance, key, v, customArgs, baseDescriptor);\n}\nfunction runLazyInitializers(instance) {\n    if (instance.__mobxDidRunLazyInitializers === true) return;\n    if (instance.__mobxLazyInitializers) {\n        addHiddenProp(instance, \"__mobxDidRunLazyInitializers\", true);\n        instance.__mobxDidRunLazyInitializers && instance.__mobxLazyInitializers.forEach(function (initializer) {\n            return initializer(instance);\n        });\n    }\n}\nfunction quacksLikeADecorator(args) {\n    return (args.length === 2 || args.length === 3) && typeof args[1] === \"string\";\n}\nfunction iteratorSymbol() {\n    return typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n}\nvar IS_ITERATING_MARKER = \"__$$iterating\";\nfunction arrayAsIterator(array) {\n    invariant(array[IS_ITERATING_MARKER] !== true, \"Illegal state: cannot recycle array as iterator\");\n    addHiddenFinalProp(array, IS_ITERATING_MARKER, true);\n    var idx = -1;\n    addHiddenFinalProp(array, \"next\", function next() {\n        idx++;\n        return {\n            done: idx >= this.length,\n            value: idx < this.length ? this[idx] : undefined\n        };\n    });\n    return array;\n}\nfunction declareIterator(prototType, iteratorFactory) {\n    addHiddenFinalProp(prototType, iteratorSymbol(), iteratorFactory);\n}\nvar messages = {\n    \"m001\": \"It is not allowed to assign new values to @action fields\",\n    \"m002\": \"`runInAction` expects a function\",\n    \"m003\": \"`runInAction` expects a function without arguments\",\n    \"m004\": \"autorun expects a function\",\n    \"m005\": \"Warning: attempted to pass an action to autorun. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m006\": \"Warning: attempted to pass an action to autorunAsync. Actions are untracked and will not trigger on state changes. Use `reaction` or wrap only your state modification code in an action.\",\n    \"m007\": \"reaction only accepts 2 or 3 arguments. If migrating from MobX 2, please provide an options object\",\n    \"m008\": \"wrapping reaction expression in `asReference` is no longer supported, use options object instead\",\n    \"m009\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'. It looks like it was used on a property.\",\n    \"m010\": \"@computed can only be used on getter functions, like: '@computed get myProps() { return ...; }'\",\n    \"m011\": \"First argument to `computed` should be an expression. If using computed as decorator, don't pass it arguments\",\n    \"m012\": \"computed takes one or two arguments if used as function\",\n    \"m013\": \"[mobx.expr] 'expr' should only be used inside other reactive functions.\",\n    \"m014\": \"extendObservable expected 2 or more arguments\",\n    \"m015\": \"extendObservable expects an object as first argument\",\n    \"m016\": \"extendObservable should not be used on maps, use map.merge instead\",\n    \"m017\": \"all arguments of extendObservable should be objects\",\n    \"m018\": \"extending an object with another observable (object) is not supported. Please construct an explicit propertymap, using `toJS` if need. See issue #540\",\n    \"m019\": \"[mobx.isObservable] isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.\",\n    \"m020\": \"modifiers can only be used for individual object properties\",\n    \"m021\": \"observable expects zero or one arguments\",\n    \"m022\": \"@observable can not be used on getters, use @computed instead\",\n    \"m023\": \"Using `transaction` is deprecated, use `runInAction` or `(@)action` instead.\",\n    \"m024\": \"whyRun() can only be used if a derivation is active, or by passing an computed value / reaction explicitly. If you invoked whyRun from inside a computation; the computation is currently suspended but re-evaluating because somebody requested its value.\",\n    \"m025\": \"whyRun can only be used on reactions and computed values\",\n    \"m026\": \"`action` can only be invoked on functions\",\n    \"m028\": \"It is not allowed to set `useStrict` when a derivation is running\",\n    \"m029\": \"INTERNAL ERROR only onBecomeUnobserved shouldn't be called twice in a row\",\n    \"m030a\": \"Since strict-mode is enabled, changing observed observable values outside actions is not allowed. Please wrap the code in an `action` if this change is intended. Tried to modify: \",\n    \"m030b\": \"Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, the render function of a React component? Tried to modify: \",\n    \"m031\": \"Computed values are not allowed to not cause side effects by changing observables that are already being observed. Tried to modify: \",\n    \"m032\": \"* This computation is suspended (not in use by any reaction) and won't run automatically.\\n\tDidn't expect this computation to be suspended at this point?\\n\t  1. Make sure this computation is used by a reaction (reaction, autorun, observer).\\n\t  2. Check whether you are using this computation synchronously (in the same stack as they reaction that needs it).\",\n    \"m033\": \"`observe` doesn't support the fire immediately property for observable maps.\",\n    \"m034\": \"`mobx.map` is deprecated, use `new ObservableMap` or `mobx.observable.map` instead\",\n    \"m035\": \"Cannot make the designated object observable; it is not extensible\",\n    \"m036\": \"It is not possible to get index atoms from arrays\",\n    \"m037\": \"Hi there! I'm sorry you have just run into an exception.\\nIf your debugger ends up here, know that some reaction (like the render() of an observer component, autorun or reaction)\\nthrew an exception and that mobx caught it, to avoid that it brings the rest of your application down.\\nThe original cause of the exception (the code that caused this reaction to run (again)), is still in the stack.\\n\\nHowever, more interesting is the actual stack trace of the error itself.\\nHopefully the error is an instanceof Error, because in that case you can inspect the original stack of the error from where it was thrown.\\nSee `error.stack` property, or press the very subtle \\\"(...)\\\" link you see near the console.error message that probably brought you here.\\nThat stack is more interesting than the stack of this console.error itself.\\n\\nIf the exception you see is an exception you created yourself, make sure to use `throw new Error(\\\"Oops\\\")` instead of `throw \\\"Oops\\\"`,\\nbecause the javascript environment will only preserve the original stack trace in the first form.\\n\\nYou can also make sure the debugger pauses the next time this very same exception is thrown by enabling \\\"Pause on caught exception\\\".\\n(Note that it might pause on many other, unrelated exception as well).\\n\\nIf that all doesn't help you out, feel free to open an issue https://github.com/mobxjs/mobx/issues!\\n\",\n    \"m038\": \"Missing items in this list?\\n    1. Check whether all used values are properly marked as observable (use isObservable to verify)\\n    2. Make sure you didn't dereference values too early. MobX observes props, not primitives. E.g: use 'person.name' instead of 'name' in your computation.\\n\"\n};\nfunction getMessage(id) {\n    return messages[id];\n}\nvar EMPTY_ARRAY = [];\nObject.freeze(EMPTY_ARRAY);\nfunction getGlobal() {\n    return global;\n}\nfunction getNextId() {\n    return ++globalState.mobxGuid;\n}\nfunction fail(message, thing) {\n    invariant(false, message, thing);\n    throw \"X\";\n}\nfunction invariant(check, message, thing) {\n    if (!check) throw new Error(\"[mobx] Invariant failed: \" + message + (thing ? \" in '\" + thing + \"'\" : \"\"));\n}\nvar deprecatedMessages = [];\nfunction deprecated(msg) {\n    if (deprecatedMessages.indexOf(msg) !== -1) return false;\n    deprecatedMessages.push(msg);\n    console.error(\"[mobx] Deprecated: \" + msg);\n    return true;\n}\nfunction once(func) {\n    var invoked = false;\n    return function () {\n        if (invoked) return;\n        invoked = true;\n        return func.apply(this, arguments);\n    };\n}\nvar noop = function noop() {};\nfunction unique(list) {\n    var res = [];\n    list.forEach(function (item) {\n        if (res.indexOf(item) === -1) res.push(item);\n    });\n    return res;\n}\nfunction joinStrings(things, limit, separator) {\n    if (limit === void 0) {\n        limit = 100;\n    }\n    if (separator === void 0) {\n        separator = \" - \";\n    }\n    if (!things) return \"\";\n    var sliced = things.slice(0, limit);\n    return \"\" + sliced.join(separator) + (things.length > limit ? \" (... and \" + (things.length - limit) + \"more)\" : \"\");\n}\nfunction isObject(value) {\n    return value !== null && (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\";\n}\nfunction isPlainObject(value) {\n    if (value === null || (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) !== \"object\") return false;\n    var proto = Object.getPrototypeOf(value);\n    return proto === Object.prototype || proto === null;\n}\nfunction objectAssign() {\n    var res = arguments[0];\n    for (var i = 1, l = arguments.length; i < l; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n            if (hasOwnProperty(source, key)) {\n                res[key] = source[key];\n            }\n        }\n    }\n    return res;\n}\nfunction valueDidChange(compareStructural, oldValue, newValue) {\n    if (typeof oldValue === 'number' && isNaN(oldValue)) {\n        return typeof newValue !== 'number' || !isNaN(newValue);\n    }\n    return compareStructural ? !deepEqual(oldValue, newValue) : oldValue !== newValue;\n}\nvar prototypeHasOwnProperty = Object.prototype.hasOwnProperty;\nfunction hasOwnProperty(object, propName) {\n    return prototypeHasOwnProperty.call(object, propName);\n}\nfunction makeNonEnumerable(object, propNames) {\n    for (var i = 0; i < propNames.length; i++) {\n        addHiddenProp(object, propNames[i], object[propNames[i]]);\n    }\n}\nfunction addHiddenProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value: value\n    });\n}\nfunction addHiddenFinalProp(object, propName, value) {\n    Object.defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value: value\n    });\n}\nfunction isPropertyConfigurable(object, prop) {\n    var descriptor = Object.getOwnPropertyDescriptor(object, prop);\n    return !descriptor || descriptor.configurable !== false && descriptor.writable !== false;\n}\nfunction assertPropertyConfigurable(object, prop) {\n    invariant(isPropertyConfigurable(object, prop), \"Cannot make property '\" + prop + \"' observable, it is not configurable and writable in the target object\");\n}\nfunction getEnumerableKeys(obj) {\n    var res = [];\n    for (var key in obj) {\n        res.push(key);\n    }return res;\n}\nfunction deepEqual(a, b) {\n    if (a === null && b === null) return true;\n    if (a === undefined && b === undefined) return true;\n    if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) !== \"object\") return a === b;\n    var aIsArray = isArrayLike(a);\n    var aIsMap = isMapLike(a);\n    if (aIsArray !== isArrayLike(b)) {\n        return false;\n    } else if (aIsMap !== isMapLike(b)) {\n        return false;\n    } else if (aIsArray) {\n        if (a.length !== b.length) return false;\n        for (var i = a.length - 1; i >= 0; i--) {\n            if (!deepEqual(a[i], b[i])) return false;\n        }return true;\n    } else if (aIsMap) {\n        if (a.size !== b.size) return false;\n        var equals_1 = true;\n        a.forEach(function (value, key) {\n            equals_1 = equals_1 && deepEqual(b.get(key), value);\n        });\n        return equals_1;\n    } else if ((typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) === \"object\" && (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) === \"object\") {\n        if (a === null || b === null) return false;\n        if (isMapLike(a) && isMapLike(b)) {\n            if (a.size !== b.size) return false;\n            return deepEqual(observable.shallowMap(a).entries(), observable.shallowMap(b).entries());\n        }\n        if (getEnumerableKeys(a).length !== getEnumerableKeys(b).length) return false;\n        for (var prop in a) {\n            if (!(prop in b)) return false;\n            if (!deepEqual(a[prop], b[prop])) return false;\n        }\n        return true;\n    }\n    return false;\n}\nfunction createInstanceofPredicate(name, clazz) {\n    var propName = \"isMobX\" + name;\n    clazz.prototype[propName] = true;\n    return function (x) {\n        return isObject(x) && x[propName] === true;\n    };\n}\nfunction isArrayLike(x) {\n    return Array.isArray(x) || isObservableArray(x);\n}\nexports.isArrayLike = isArrayLike;\nfunction isMapLike(x) {\n    return isES6Map(x) || isObservableMap(x);\n}\nfunction isES6Map(thing) {\n    if (getGlobal().Map !== undefined && thing instanceof getGlobal().Map) return true;\n    return false;\n}\nfunction primitiveSymbol() {\n    return typeof Symbol === \"function\" && Symbol.toPrimitive || \"@@toPrimitive\";\n}\nfunction toPrimitive(value) {\n    return value === null ? null : (typeof value === \"undefined\" ? \"undefined\" : _typeof(value)) === \"object\" ? \"\" + value : value;\n}\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nvar _icons = __webpack_require__(6);\n\nvar _constants = __webpack_require__(0);\n\nfunction renderHeader(_ref, instance) {\n  var meta = _ref.meta,\n      user = _ref.user,\n      reactions = _ref.reactions;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-header-container';\n\n  var likeButton = document.createElement('span');\n  var likedReaction = reactions.find(function (reaction) {\n    return reaction.content === 'heart' && reaction.user.login === user.login;\n  });\n  likeButton.className = 'gitment-header-like-btn';\n  likeButton.innerHTML = '\\n    ' + _icons.heart + '\\n    ' + (likedReaction ? 'Unlike' : 'Like') + '\\n    ' + (meta.reactions && meta.reactions.heart ? ' \\u2022 <strong>' + meta.reactions.heart + '</strong> Liked' : '') + '\\n  ';\n\n  if (likedReaction) {\n    likeButton.classList.add('liked');\n    likeButton.onclick = function () {\n      return instance.unlike();\n    };\n  } else {\n    likeButton.classList.remove('liked');\n    likeButton.onclick = function () {\n      return instance.like();\n    };\n  }\n  container.appendChild(likeButton);\n\n  var commentsCount = document.createElement('span');\n  commentsCount.innerHTML = '\\n    ' + (meta.comments ? ' \\u2022 <strong>' + meta.comments + '</strong> Comments' : '') + '\\n  ';\n  container.appendChild(commentsCount);\n\n  var issueLink = document.createElement('a');\n  issueLink.className = 'gitment-header-issue-link';\n  issueLink.href = meta.html_url;\n  issueLink.target = '_blank';\n  issueLink.innerText = 'Issue Page';\n  container.appendChild(issueLink);\n\n  return container;\n}\n\nfunction renderComments(_ref2, instance) {\n  var meta = _ref2.meta,\n      comments = _ref2.comments,\n      commentReactions = _ref2.commentReactions,\n      currentPage = _ref2.currentPage,\n      user = _ref2.user,\n      error = _ref2.error;\n\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-comments-container';\n\n  if (error) {\n    var errorBlock = document.createElement('div');\n    errorBlock.className = 'gitment-comments-error';\n\n    if (error === _constants.NOT_INITIALIZED_ERROR && user.login && user.login.toLowerCase() === instance.owner.toLowerCase()) {\n      var initHint = document.createElement('div');\n      var initButton = document.createElement('button');\n      initButton.className = 'gitment-comments-init-btn';\n      initButton.onclick = function () {\n        initButton.setAttribute('disabled', true);\n        instance.init().catch(function (e) {\n          initButton.removeAttribute('disabled');\n          alert(e);\n        });\n      };\n      initButton.innerText = 'Initialize Comments';\n      initHint.appendChild(initButton);\n      errorBlock.appendChild(initHint);\n    } else {\n      errorBlock.innerText = error;\n    }\n    container.appendChild(errorBlock);\n    return container;\n  } else if (comments === undefined) {\n    var loading = document.createElement('div');\n    loading.innerText = 'Loading comments...';\n    loading.className = 'gitment-comments-loading';\n    container.appendChild(loading);\n    return container;\n  } else if (!comments.length) {\n    var emptyBlock = document.createElement('div');\n    emptyBlock.className = 'gitment-comments-empty';\n    emptyBlock.innerText = 'No Comment Yet';\n    container.appendChild(emptyBlock);\n    return container;\n  }\n\n  var commentsList = document.createElement('ul');\n  commentsList.className = 'gitment-comments-list';\n\n  comments.forEach(function (comment) {\n    var createDate = new Date(comment.created_at);\n    var updateDate = new Date(comment.updated_at);\n    var commentItem = document.createElement('li');\n    commentItem.className = 'gitment-comment';\n    commentItem.innerHTML = '\\n      <a class=\"gitment-comment-avatar\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n        <img class=\"gitment-comment-avatar-img\" src=\"' + comment.user.avatar_url + '\">\\n      </a>\\n      <div class=\"gitment-comment-main\">\\n        <div class=\"gitment-comment-header\">\\n          <a class=\"gitment-comment-name\" href=\"' + comment.user.html_url + '\" target=\"_blank\">\\n            ' + comment.user.login + '\\n          </a>\\n          commented on\\n          <span title=\"' + createDate + '\">' + createDate.toDateString() + '</span>\\n          ' + (createDate.toString() !== updateDate.toString() ? ' \\u2022 <span title=\"comment was edited at ' + updateDate + '\">edited</span>' : '') + '\\n          <div class=\"gitment-comment-like-btn\">' + _icons.heart + ' ' + (comment.reactions.heart || '') + '</div>\\n        </div>\\n        <div class=\"gitment-comment-body gitment-markdown\">' + comment.body_html + '</div>\\n      </div>\\n    ';\n    var likeButton = commentItem.querySelector('.gitment-comment-like-btn');\n    var likedReaction = commentReactions[comment.id] && commentReactions[comment.id].find(function (reaction) {\n      return reaction.content === 'heart' && reaction.user.login === user.login;\n    });\n    if (likedReaction) {\n      likeButton.classList.add('liked');\n      likeButton.onclick = function () {\n        return instance.unlikeAComment(comment.id);\n      };\n    } else {\n      likeButton.classList.remove('liked');\n      likeButton.onclick = function () {\n        return instance.likeAComment(comment.id);\n      };\n    }\n\n    // dirty\n    // use a blank image to trigger height calculating when element rendered\n    var imgTrigger = document.createElement('img');\n    var markdownBody = commentItem.querySelector('.gitment-comment-body');\n    imgTrigger.className = 'gitment-hidden';\n    imgTrigger.src = \"data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==\";\n    imgTrigger.onload = function () {\n      if (markdownBody.clientHeight > instance.maxCommentHeight) {\n        markdownBody.classList.add('gitment-comment-body-folded');\n        markdownBody.style.maxHeight = instance.maxCommentHeight + 'px';\n        markdownBody.title = 'Click to Expand';\n        markdownBody.onclick = function () {\n          markdownBody.classList.remove('gitment-comment-body-folded');\n          markdownBody.style.maxHeight = '';\n          markdownBody.title = '';\n          markdownBody.onclick = null;\n        };\n      }\n    };\n    commentItem.appendChild(imgTrigger);\n\n    commentsList.appendChild(commentItem);\n  });\n\n  container.appendChild(commentsList);\n\n  if (meta) {\n    var pageCount = Math.ceil(meta.comments / instance.perPage);\n    if (pageCount > 1) {\n      var pagination = document.createElement('ul');\n      pagination.className = 'gitment-comments-pagination';\n\n      if (currentPage > 1) {\n        var previousButton = document.createElement('li');\n        previousButton.className = 'gitment-comments-page-item';\n        previousButton.innerText = 'Previous';\n        previousButton.onclick = function () {\n          return instance.goto(currentPage - 1);\n        };\n        pagination.appendChild(previousButton);\n      }\n\n      var _loop = function _loop(i) {\n        var pageItem = document.createElement('li');\n        pageItem.className = 'gitment-comments-page-item';\n        pageItem.innerText = i;\n        pageItem.onclick = function () {\n          return instance.goto(i);\n        };\n        if (currentPage === i) pageItem.classList.add('gitment-selected');\n        pagination.appendChild(pageItem);\n      };\n\n      for (var i = 1; i <= pagecount;=\"\" i++)=\"\" {=\"\" _loop(i);=\"\" }=\"\" if=\"\" (currentpage=\"\" <=\"\" pagecount)=\"\" var=\"\" nextbutton=\"document.createElement('li');\" nextbutton.classname=\"gitment-comments-page-item\" ;=\"\" nextbutton.innertext=\"Next\" nextbutton.onclick=\"function\" ()=\"\" return=\"\" instance.goto(currentpage=\"\" +=\"\" 1);=\"\" };=\"\" pagination.appendchild(nextbutton);=\"\" container.appendchild(pagination);=\"\" container;=\"\" function=\"\" rendereditor(_ref3,=\"\" instance)=\"\" user=\"_ref3.user,\" error=\"_ref3.error;\" container=\"document.createElement('div');\" container.lang=\"en-US\" container.classname=\"gitment-container gitment-editor-container\" shoulddisable=\"user.login\" &&=\"\" !error=\"\" ?=\"\" ''=\"\" :=\"\" 'disabled';=\"\" disabledtip=\"user.login\" 'login=\"\" to=\"\" comment';=\"\" container.innerhtml=\"\\n      \" (user.login=\"\" '<a=\"\" class=\"gitment-editor-avatar\" href=\"' + user.html_url + '\" target=\"_blank\">\\n            <img class=\"gitment-editor-avatar-img\" src=\"' + user.avatar_url + '\">\\n          ' : user.isLoggingIn ? '<div class=\"gitment-editor-avatar\">' + _icons.spinner + '</div>' : '<a class=\"gitment-editor-avatar\" href=\"' + instance.loginLink + '\" title=\"login with GitHub\">\\n              ' + _icons.github + '\\n            </a>') + '\\n    \\n    <div class=\"gitment-editor-main\">\\n      <div class=\"gitment-editor-header\">\\n        <nav class=\"gitment-editor-tabs\">\\n          <button class=\"gitment-editor-tab gitment-selected\">Write</button>\\n          <button class=\"gitment-editor-tab\">Preview</button>\\n        </nav>\\n        <div class=\"gitment-editor-login\">\\n          ' + (user.login ? '<a class=\"gitment-editor-logout-link\">Logout</a>' : user.isLoggingIn ? 'Logging in...' : '<a class=\"gitment-editor-login-link\" href=\"' + instance.loginLink + '\">Login</a> with GitHub') + '\\n        </div>\\n      </div>\\n      <div class=\"gitment-editor-body\">\\n        <div class=\"gitment-editor-write-field\">\\n          <textarea placeholder=\"Leave a comment\" title=\"' + disabledTip + '\" '=\"\" +=\"\" shoulddisable=\"\"></textarea>\\n        </div>\\n        <div class=\"gitment-editor-preview-field gitment-hidden\">\\n          <div class=\"gitment-editor-preview gitment-markdown\"></div>\\n        </div>\\n      </div>\\n    </div>\\n    <div class=\"gitment-editor-footer\">\\n      <a class=\"gitment-editor-footer-tip\" href=\"https://guides.github.com/features/mastering-markdown/\" target=\"_blank\">\\n        Styling with Markdown is supported\\n      </a>\\n      <button class=\"gitment-editor-submit\" title=\"' + disabledTip + '\" '=\"\" +=\"\" shoulddisable=\"\">Comment</button>\\n    </div>\\n  ';\n  if (user.login) {\n    container.querySelector('.gitment-editor-logout-link').onclick = function () {\n      return instance.logout();\n    };\n  }\n\n  var writeField = container.querySelector('.gitment-editor-write-field');\n  var previewField = container.querySelector('.gitment-editor-preview-field');\n\n  var textarea = writeField.querySelector('textarea');\n  textarea.oninput = function () {\n    textarea.style.height = 'auto';\n    var style = window.getComputedStyle(textarea, null);\n    var height = parseInt(style.height, 10);\n    var clientHeight = textarea.clientHeight;\n    var scrollHeight = textarea.scrollHeight;\n    if (clientHeight < scrollHeight) {\n      textarea.style.height = height + scrollHeight - clientHeight + 'px';\n    }\n  };\n\n  var _container$querySelec = container.querySelectorAll('.gitment-editor-tab'),\n      _container$querySelec2 = _slicedToArray(_container$querySelec, 2),\n      writeTab = _container$querySelec2[0],\n      previewTab = _container$querySelec2[1];\n\n  writeTab.onclick = function () {\n    writeTab.classList.add('gitment-selected');\n    previewTab.classList.remove('gitment-selected');\n    writeField.classList.remove('gitment-hidden');\n    previewField.classList.add('gitment-hidden');\n\n    textarea.focus();\n  };\n  previewTab.onclick = function () {\n    previewTab.classList.add('gitment-selected');\n    writeTab.classList.remove('gitment-selected');\n    previewField.classList.remove('gitment-hidden');\n    writeField.classList.add('gitment-hidden');\n\n    var preview = previewField.querySelector('.gitment-editor-preview');\n    var content = textarea.value.trim();\n    if (!content) {\n      preview.innerText = 'Nothing to preview';\n      return;\n    }\n\n    preview.innerText = 'Loading preview...';\n    instance.markdown(content).then(function (html) {\n      return preview.innerHTML = html;\n    });\n  };\n\n  var submitButton = container.querySelector('.gitment-editor-submit');\n  submitButton.onclick = function () {\n    submitButton.innerText = 'Submitting...';\n    submitButton.setAttribute('disabled', true);\n    instance.post(textarea.value.trim()).then(function (data) {\n      textarea.value = '';\n      textarea.style.height = 'auto';\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    }).catch(function (e) {\n      alert(e);\n      submitButton.removeAttribute('disabled');\n      submitButton.innerText = 'Comment';\n    });\n  };\n\n  return container;\n}\n\nfunction renderFooter() {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-footer-container';\n  container.innerHTML = '\\n    Powered by\\n    <a class=\"gitment-footer-project-link\" href=\"https://github.com/imsun/gitment\" target=\"_blank\">\\n      Gitment\\n    </a>\\n  ';\n  return container;\n}\n\nfunction render(state, instance) {\n  var container = document.createElement('div');\n  container.lang = \"en-US\";\n  container.className = 'gitment-container gitment-root-container';\n  container.appendChild(instance.renderHeader(state, instance));\n  container.appendChild(instance.renderComments(state, instance));\n  container.appendChild(instance.renderEditor(state, instance));\n  container.appendChild(instance.renderFooter(state, instance));\n  return container;\n}\n\nexports.default = { render: render, renderHeader: renderHeader, renderComments: renderComments, renderEditor: renderEditor, renderFooter: renderFooter };\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.http = exports.Query = exports.isString = undefined;\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nexports.getTargetContainer = getTargetContainer;\n\nvar _constants = __webpack_require__(0);\n\nvar isString = exports.isString = function isString(s) {\n  return toString.call(s) === '[object String]';\n};\n\nfunction getTargetContainer(container) {\n  var targetContainer = void 0;\n  if (container instanceof Element) {\n    targetContainer = container;\n  } else if (isString(container)) {\n    targetContainer = document.getElementById(container);\n  } else {\n    targetContainer = document.createElement('div');\n  }\n\n  return targetContainer;\n}\n\nvar Query = exports.Query = {\n  parse: function parse() {\n    var search = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window.location.search;\n\n    if (!search) return {};\n    var queryString = search[0] === '?' ? search.substring(1) : search;\n    var query = {};\n    queryString.split('&').forEach(function (queryStr) {\n      var _queryStr$split = queryStr.split('='),\n          _queryStr$split2 = _slicedToArray(_queryStr$split, 2),\n          key = _queryStr$split2[0],\n          value = _queryStr$split2[1];\n\n      if (key) query[key] = value;\n    });\n\n    return query;\n  },\n  stringify: function stringify(query) {\n    var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '?';\n\n    var queryString = Object.keys(query).map(function (key) {\n      return key + '=' + encodeURIComponent(query[key] || '');\n    }).join('&');\n    return queryString ? prefix + queryString : '';\n  }\n};\n\nfunction ajaxFactory(method) {\n  return function (apiPath) {\n    var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var base = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'https://api.github.com';\n\n    var req = new XMLHttpRequest();\n    var token = localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n\n    var url = '' + base + apiPath;\n    var body = null;\n    if (method === 'GET' || method === 'DELETE') {\n      url += Query.stringify(data);\n    }\n\n    var p = new Promise(function (resolve, reject) {\n      req.addEventListener('load', function () {\n        var contentType = req.getResponseHeader('content-type');\n        var res = req.responseText;\n        if (!/json/.test(contentType)) {\n          resolve(res);\n          return;\n        }\n        var data = req.responseText ? JSON.parse(res) : {};\n        if (data.message) {\n          reject(new Error(data.message));\n        } else {\n          resolve(data);\n        }\n      });\n      req.addEventListener('error', function (error) {\n        return reject(error);\n      });\n    });\n    req.open(method, url, true);\n\n    req.setRequestHeader('Accept', 'application/vnd.github.squirrel-girl-preview, application/vnd.github.html+json');\n    if (token) {\n      req.setRequestHeader('Authorization', 'token ' + token);\n    }\n    if (method !== 'GET' && method !== 'DELETE') {\n      body = JSON.stringify(data);\n      req.setRequestHeader('Content-Type', 'application/json');\n    }\n\n    req.send(body);\n    return p;\n  };\n}\n\nvar http = exports.http = {\n  get: ajaxFactory('GET'),\n  post: ajaxFactory('POST'),\n  delete: ajaxFactory('DELETE'),\n  put: ajaxFactory('PUT')\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar g;\n\n// This works in non-strict mode\ng = function () {\n\treturn this;\n}();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || Function(\"return this\")() || (1, eval)(\"this\");\n} catch (e) {\n\t// This works if the window reference is available\n\tif ((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _mobx = __webpack_require__(1);\n\nvar _constants = __webpack_require__(0);\n\nvar _utils = __webpack_require__(3);\n\nvar _default = __webpack_require__(2);\n\nvar _default2 = _interopRequireDefault(_default);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar scope = 'public_repo';\n\nfunction extendRenderer(instance, renderer) {\n  instance[renderer] = function (container) {\n    var targetContainer = (0, _utils.getTargetContainer)(container);\n    var render = instance.theme[renderer] || instance.defaultTheme[renderer];\n\n    (0, _mobx.autorun)(function () {\n      var e = render(instance.state, instance);\n      if (targetContainer.firstChild) {\n        targetContainer.replaceChild(e, targetContainer.firstChild);\n      } else {\n        targetContainer.appendChild(e);\n      }\n    });\n\n    return targetContainer;\n  };\n}\n\nvar Gitment = function () {\n  _createClass(Gitment, [{\n    key: 'accessToken',\n    get: function get() {\n      return localStorage.getItem(_constants.LS_ACCESS_TOKEN_KEY);\n    },\n    set: function set(token) {\n      localStorage.setItem(_constants.LS_ACCESS_TOKEN_KEY, token);\n    }\n  }, {\n    key: 'loginLink',\n    get: function get() {\n      var oauthUri = 'https://github.com/login/oauth/authorize';\n      var redirect_uri = this.oauth.redirect_uri || window.location.href;\n\n      var oauthParams = Object.assign({\n        scope: scope,\n        redirect_uri: redirect_uri\n      }, this.oauth);\n\n      return '' + oauthUri + _utils.Query.stringify(oauthParams);\n    }\n  }]);\n\n  function Gitment() {\n    var _this = this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Gitment);\n\n    this.defaultTheme = _default2.default;\n    this.useTheme(_default2.default);\n\n    Object.assign(this, {\n      id: window.location.href,\n      title: window.document.title,\n      link: window.location.href,\n      desc: '',\n      labels: [],\n      theme: _default2.default,\n      oauth: {},\n      perPage: 20,\n      maxCommentHeight: 250\n    }, options);\n\n    this.useTheme(this.theme);\n\n    var user = {};\n    try {\n      var userInfo = localStorage.getItem(_constants.LS_USER_KEY);\n      if (this.accessToken && userInfo) {\n        Object.assign(user, JSON.parse(userInfo), {\n          fromCache: true\n        });\n      }\n    } catch (e) {\n      localStorage.removeItem(_constants.LS_USER_KEY);\n    }\n\n    this.state = (0, _mobx.observable)({\n      user: user,\n      error: null,\n      meta: {},\n      comments: undefined,\n      reactions: [],\n      commentReactions: {},\n      currentPage: 1\n    });\n\n    var query = _utils.Query.parse();\n    if (query.code) {\n      var _oauth = this.oauth,\n          client_id = _oauth.client_id,\n          client_secret = _oauth.client_secret;\n\n      var code = query.code;\n      delete query.code;\n      var search = _utils.Query.stringify(query);\n      var replacedUrl = '' + window.location.origin + window.location.pathname + search + window.location.hash;\n      history.replaceState({}, '', replacedUrl);\n\n      Object.assign(this, {\n        id: replacedUrl,\n        link: replacedUrl\n      }, options);\n\n      this.state.user.isLoggingIn = true;\n      _utils.http.post('https://github.com/login/oauth/access_token', {\n        code: code,\n        client_id: client_id,\n        client_secret: client_secret\n      }, '').then(function (data) {\n        _this.accessToken = data.access_token;\n        _this.update();\n      }).catch(function (e) {\n        _this.state.user.isLoggingIn = false;\n        alert(e);\n      });\n    } else {\n      this.update();\n    }\n  }\n\n  _createClass(Gitment, [{\n    key: 'init',\n    value: function init() {\n      var _this2 = this;\n\n      return this.createIssue().then(function () {\n        return _this2.loadComments();\n      }).then(function (comments) {\n        _this2.state.error = null;\n        return comments;\n      });\n    }\n  }, {\n    key: 'useTheme',\n    value: function useTheme() {\n      var _this3 = this;\n\n      var theme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      this.theme = theme;\n\n      var renderers = Object.keys(this.theme);\n      renderers.forEach(function (renderer) {\n        return extendRenderer(_this3, renderer);\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update() {\n      var _this4 = this;\n\n      return Promise.all([this.loadMeta(), this.loadUserInfo()]).then(function () {\n        return Promise.all([_this4.loadComments().then(function () {\n          return _this4.loadCommentReactions();\n        }), _this4.loadReactions()]);\n      }).catch(function (e) {\n        return _this4.state.error = e;\n      });\n    }\n  }, {\n    key: 'markdown',\n    value: function markdown(text) {\n      return _utils.http.post('/markdown', {\n        text: text,\n        mode: 'gfm'\n      });\n    }\n  }, {\n    key: 'createIssue',\n    value: function createIssue() {\n      var _this5 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo,\n          title = this.title,\n          link = this.link,\n          desc = this.desc,\n          labels = this.labels;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues', {\n        title: title,\n        labels: labels.concat(['gitment', id]),\n        body: link + '\\n\\n' + desc\n      }).then(function (meta) {\n        _this5.state.meta = meta;\n        return meta;\n      });\n    }\n  }, {\n    key: 'getIssue',\n    value: function getIssue() {\n      if (this.state.meta.id) return Promise.resolve(this.state.meta);\n\n      return this.loadMeta();\n    }\n  }, {\n    key: 'post',\n    value: function post(body) {\n      var _this6 = this;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.post(issue.comments_url, { body: body }, '');\n      }).then(function (data) {\n        _this6.state.meta.comments++;\n        var pageCount = Math.ceil(_this6.state.meta.comments / _this6.perPage);\n        if (_this6.state.currentPage === pageCount) {\n          _this6.state.comments.push(data);\n        }\n        return data;\n      });\n    }\n  }, {\n    key: 'loadMeta',\n    value: function loadMeta() {\n      var _this7 = this;\n\n      var id = this.id,\n          owner = this.owner,\n          repo = this.repo;\n\n      return _utils.http.get('/repos/' + owner + '/' + repo + '/issues', {\n        creator: owner,\n        labels: id\n      }).then(function (issues) {\n        if (!issues.length) return Promise.reject(_constants.NOT_INITIALIZED_ERROR);\n        _this7.state.meta = issues[0];\n        return issues[0];\n      });\n    }\n  }, {\n    key: 'loadComments',\n    value: function loadComments() {\n      var _this8 = this;\n\n      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.state.currentPage;\n\n      return this.getIssue().then(function (issue) {\n        return _utils.http.get(issue.comments_url, { page: page, per_page: _this8.perPage }, '');\n      }).then(function (comments) {\n        _this8.state.comments = comments;\n        return comments;\n      });\n    }\n  }, {\n    key: 'loadUserInfo',\n    value: function loadUserInfo() {\n      var _this9 = this;\n\n      if (!this.accessToken) {\n        this.logout();\n        return Promise.resolve({});\n      }\n\n      return _utils.http.get('/user').then(function (user) {\n        _this9.state.user = user;\n        localStorage.setItem(_constants.LS_USER_KEY, JSON.stringify(user));\n        return user;\n      });\n    }\n  }, {\n    key: 'loadReactions',\n    value: function loadReactions() {\n      var _this10 = this;\n\n      if (!this.accessToken) {\n        this.state.reactions = [];\n        return Promise.resolve([]);\n      }\n\n      return this.getIssue().then(function (issue) {\n        if (!issue.reactions.total_count) return [];\n        return _utils.http.get(issue.reactions.url, {}, '');\n      }).then(function (reactions) {\n        _this10.state.reactions = reactions;\n        return reactions;\n      });\n    }\n  }, {\n    key: 'loadCommentReactions',\n    value: function loadCommentReactions() {\n      var _this11 = this;\n\n      if (!this.accessToken) {\n        this.state.commentReactions = {};\n        return Promise.resolve([]);\n      }\n\n      var comments = this.state.comments;\n      var comentReactions = {};\n\n      return Promise.all(comments.map(function (comment) {\n        if (!comment.reactions.total_count) return [];\n\n        var owner = _this11.owner,\n            repo = _this11.repo;\n\n        return _utils.http.get('/repos/' + owner + '/' + repo + '/issues/comments/' + comment.id + '/reactions', {});\n      })).then(function (reactionsArray) {\n        comments.forEach(function (comment, index) {\n          comentReactions[comment.id] = reactionsArray[index];\n        });\n        _this11.state.commentReactions = comentReactions;\n\n        return comentReactions;\n      });\n    }\n  }, {\n    key: 'login',\n    value: function login() {\n      window.location.href = this.loginLink;\n    }\n  }, {\n    key: 'logout',\n    value: function logout() {\n      localStorage.removeItem(_constants.LS_ACCESS_TOKEN_KEY);\n      localStorage.removeItem(_constants.LS_USER_KEY);\n      this.state.user = {};\n    }\n  }, {\n    key: 'goto',\n    value: function goto(page) {\n      this.state.currentPage = page;\n      this.state.comments = undefined;\n      return this.loadComments(page);\n    }\n  }, {\n    key: 'like',\n    value: function like() {\n      var _this12 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/' + this.state.meta.number + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this12.state.reactions.push(reaction);\n        _this12.state.meta.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlike',\n    value: function unlike() {\n      var _this13 = this;\n\n      if (!this.accessToken) return Promise.reject();\n\n      var _state = this.state,\n          user = _state.user,\n          reactions = _state.reactions;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        _this13.state.meta.reactions.heart--;\n      });\n    }\n  }, {\n    key: 'likeAComment',\n    value: function likeAComment(commentId) {\n      var _this14 = this;\n\n      if (!this.accessToken) {\n        alert('Login to Like');\n        return Promise.reject();\n      }\n\n      var owner = this.owner,\n          repo = this.repo;\n\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n\n      return _utils.http.post('/repos/' + owner + '/' + repo + '/issues/comments/' + commentId + '/reactions', {\n        content: 'heart'\n      }).then(function (reaction) {\n        _this14.state.commentReactions[commentId].push(reaction);\n        comment.reactions.heart++;\n      });\n    }\n  }, {\n    key: 'unlikeAComment',\n    value: function unlikeAComment(commentId) {\n      if (!this.accessToken) return Promise.reject();\n\n      var reactions = this.state.commentReactions[commentId];\n      var comment = this.state.comments.find(function (comment) {\n        return comment.id === commentId;\n      });\n      var user = this.state.user;\n\n      var index = reactions.findIndex(function (reaction) {\n        return reaction.user.login === user.login;\n      });\n\n      return _utils.http.delete('/reactions/' + reactions[index].id).then(function () {\n        reactions.splice(index, 1);\n        comment.reactions.heart--;\n      });\n    }\n  }]);\n\n  return Gitment;\n}();\n\nmodule.exports = Gitment;\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Modified from https://github.com/evil-icons/evil-icons\n */\n\nvar close = exports.close = '<svg class=\"gitment-close-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M37.304 11.282l1.414 1.414-26.022 26.02-1.414-1.413z\"/><path d=\"M12.696 11.282l26.022 26.02-1.414 1.415-26.022-26.02z\"/></svg>';\nvar github = exports.github = '<svg class=\"gitment-github-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 10c-8.3 0-15 6.7-15 15 0 6.6 4.3 12.2 10.3 14.2.8.1 1-.3 1-.7v-2.6c-4.2.9-5.1-2-5.1-2-.7-1.7-1.7-2.2-1.7-2.2-1.4-.9.1-.9.1-.9 1.5.1 2.3 1.5 2.3 1.5 1.3 2.3 3.5 1.6 4.4 1.2.1-1 .5-1.6 1-2-3.3-.4-6.8-1.7-6.8-7.4 0-1.6.6-3 1.5-4-.2-.4-.7-1.9.1-4 0 0 1.3-.4 4.1 1.5 1.2-.3 2.5-.5 3.8-.5 1.3 0 2.6.2 3.8.5 2.9-1.9 4.1-1.5 4.1-1.5.8 2.1.3 3.6.1 4 1 1 1.5 2.4 1.5 4 0 5.8-3.5 7-6.8 7.4.5.5 1 1.4 1 2.8v4.1c0 .4.3.9 1 .7 6-2 10.2-7.6 10.2-14.2C40 16.7 33.3 10 25 10z\"/></svg>';\nvar heart = exports.heart = '<svg class=\"gitment-heart-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 39.7l-.6-.5C11.5 28.7 8 25 8 19c0-5 4-9 9-9 4.1 0 6.4 2.3 8 4.1 1.6-1.8 3.9-4.1 8-4.1 5 0 9 4 9 9 0 6-3.5 9.7-16.4 20.2l-.6.5zM17 12c-3.9 0-7 3.1-7 7 0 5.1 3.2 8.5 15 18.1 11.8-9.6 15-13 15-18.1 0-3.9-3.1-7-7-7-3.5 0-5.4 2.1-6.9 3.8L25 17.1l-1.1-1.3C22.4 14.1 20.5 12 17 12z\"/></svg>';\nvar spinner = exports.spinner = '<svg class=\"gitment-spinner-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewbox=\"0 0 50 50\"><path d=\"M25 18c-.6 0-1-.4-1-1V9c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M25 42c-.6 0-1-.4-1-1v-8c0-.6.4-1 1-1s1 .4 1 1v8c0 .6-.4 1-1 1z\"/><path opacity=\".3\" d=\"M29 19c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M17 39.8c-.2 0-.3 0-.5-.1-.4-.3-.6-.8-.3-1.3l4-6.9c.3-.4.8-.6 1.3-.3.4.3.6.8.3 1.3l-4 6.9c-.2.2-.5.4-.8.4z\"/><path opacity=\".93\" d=\"M21 19c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M33 39.8c-.3 0-.6-.2-.8-.5l-4-6.9c-.3-.4-.1-1 .3-1.3.4-.3 1-.1 1.3.3l4 6.9c.3.4.1 1-.3 1.3-.2.1-.3.2-.5.2z\"/><path opacity=\".65\" d=\"M17 26H9c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".3\" d=\"M41 26h-8c-.6 0-1-.4-1-1s.4-1 1-1h8c.6 0 1 .4 1 1s-.4 1-1 1z\"/><path opacity=\".86\" d=\"M18.1 21.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".3\" d=\"M38.9 33.9c-.2 0-.3 0-.5-.1l-6.9-4c-.4-.3-.6-.8-.3-1.3.3-.4.8-.6 1.3-.3l6.9 4c.4.3.6.8.3 1.3-.2.3-.5.4-.8.4z\"/><path opacity=\".44\" d=\"M11.1 33.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.1.2-.3.2-.5.2z\"/><path opacity=\".3\" d=\"M31.9 21.9c-.3 0-.6-.2-.8-.5-.3-.4-.1-1 .3-1.3l6.9-4c.4-.3 1-.1 1.3.3.3.4.1 1-.3 1.3l-6.9 4c-.2.2-.3.2-.5.2z\"/></svg>';\n\n/***/ })\n/******/ ]);\n//# sourceMappingURL=gitment.browser.js.map</=></=></unnamed></not></unnamed></unnamed>"}],"Post":[{"title":"ConcurrentHashMap Put源码介绍","date":"2017-11-05T03:20:55.000Z","toc":true,"_content":"在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。\n首先放张大图, 对ConcurrentHashMap先有大致的了解。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"/>\n所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。\nConcurrentHashMap系列将分为以下三个方面进行详细描述:\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>\n# 成员变量介绍\nConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:\n+ LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh\n+ TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。\n+ UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。\n+ MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。\n+ MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容\n+ TREEBIN, 置为-2, 代表此元素后接红黑树。\n+ nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。\n+ sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:\n    0: table还没有被初始化\n    -1: table正在初始化\n    小于-1: 实际值为resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 表明table正在扩容\n    大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n\n+ transferIndex: table容量从n扩到2n时, 是从索引n->1的元素开始迁移, transferIndex代表当前已经迁移的元素下标\n+ ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。\n\n# putVal插入数据\n下面真正开始写入数据:\n```\n    /** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        // 定位到table[]中的i\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            //若table为0， 则初始化这个table\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); //首先初始化\n            //根据hash值计算出在table里面的位置\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //如果没有，则向这个位置添加一个节点\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            //整个table正在扩容\n            else if ((fh = f.hash) == MOVED)\n                //帮着一起扩容\n                tab = helpTransfer(tab, f);\n            //真正插入数据\n            else {\n                V oldVal = null;\n                //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                         //普通的数组\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                //找到key一样的，则直接替换并退出\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        //如果是红合树\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        //开始将table中元素为i的数组转变为二叉树\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        //链表或者红黑树不应该增加table的负载\n        addCount(1L, binCount);\n        return null;\n    }\n```\n主要做了如下事情:\n+ 根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h >>> 16)) & HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash>0一定成立, 若node.hash<0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树\n+ 检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。\n+ 根据i = (n - 1) & hash))确定需要插入table的位置i:\n1. 若table[i]没有元素, 则将key-value存放进去。\n2. 若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)\n3. 否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。\n4. 在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)\n5. 修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。\n\n## initTable初始化\n```\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {//只要没有成功，就一定重新尝试\n            if ((sc = sizeCtl) < 0)  //正在初始化，本节点先尝试放弃cpu的使用\n                Thread.yield(); // lost initialization race; just spin\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { //这里应该是个原子操作，将sizeCtl设置为-1\n                try {\n                    if ((tab = table) == null || tab.length == 0) { //\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n初始化table主要做了如下事情:\n+ 检查sizeCtl, 若发现<0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成\n+ 若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。\n+  初始化table\n+  设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数\n## addCount\naddCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。\n```\n    private final void addCount(long x, int check) {  //若小于0，则不检查扩容\n        CounterCell[] as; long b, s=baseCount+x;\n        .......//更新元素个数metrics\n        }\n        if (check >= 0) { //s是当前table长度\n            Node<K,V>[] tab, nt; int n, sc;\n            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&//达到容积上限，\n                   (n = tab.length) < MAXIMUM_CAPACITY) {\n                int rs = resizeStamp(n); //根据目前table长度做一个标识\n                if (sc < 0) { //说明table正在扩容\n                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                        transferIndex <= 0)\n                        break;\n                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                        transfer(tab, nt);\n                } //第一个线程开始扩容，sizeCtl = resizeStamp(n)<<16 + 2\n                else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs << 16 + 2\n                                             (rs << RESIZE_STAMP_SHIFT) + 2))//rs > 2^15,rs << RESIZE_STAMP_SHIFT) + 2) > 2^31+n,int类型的数就是负数了。\n                    transfer(tab, null);\n                s = sumCount();\n            }\n        }\n    }\n```\n主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。\n+ 若sizeCtl<0, 那么检查是否扩容完成, 若扩容完成了, 退出; 否则将sizeCtl加1, 并进行扩容操作transfer(), 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n+ 若sizeCtl>0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)<<16 + 2, 并进行扩容transfer()\n\n# 总结\nConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。","source":"_posts/ConcurrentHashMap-put过程介绍.md","raw":"---\ntitle: ConcurrentHashMap Put源码介绍\ndate: 2017-11-05 11:20:55\ntags:\ntoc: true\n---\n在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。\n首先放张大图, 对ConcurrentHashMap先有大致的了解。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"/>\n所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。\nConcurrentHashMap系列将分为以下三个方面进行详细描述:\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>\n# 成员变量介绍\nConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:\n+ LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh\n+ TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。\n+ UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。\n+ MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。\n+ MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容\n+ TREEBIN, 置为-2, 代表此元素后接红黑树。\n+ nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。\n+ sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:\n    0: table还没有被初始化\n    -1: table正在初始化\n    小于-1: 实际值为resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 表明table正在扩容\n    大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n\n+ transferIndex: table容量从n扩到2n时, 是从索引n->1的元素开始迁移, transferIndex代表当前已经迁移的元素下标\n+ ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。\n\n# putVal插入数据\n下面真正开始写入数据:\n```\n    /** Implementation for put and putIfAbsent */\n    final V putVal(K key, V value, boolean onlyIfAbsent) {\n        if (key == null || value == null) throw new NullPointerException();\n        // 定位到table[]中的i\n        int hash = spread(key.hashCode());\n        int binCount = 0;\n        for (Node<K,V>[] tab = table;;) {\n            Node<K,V> f; int n, i, fh;\n            //若table为0， 则初始化这个table\n            if (tab == null || (n = tab.length) == 0)\n                tab = initTable(); //首先初始化\n            //根据hash值计算出在table里面的位置\n            else if ((f = tabAt(tab, i = (n - 1) & hash)) == null) {\n                //如果没有，则向这个位置添加一个节点\n                if (casTabAt(tab, i, null,\n                             new Node<K,V>(hash, key, value, null)))\n                    break;                   // no lock when adding to empty bin\n            }\n            //整个table正在扩容\n            else if ((fh = f.hash) == MOVED)\n                //帮着一起扩容\n                tab = helpTransfer(tab, f);\n            //真正插入数据\n            else {\n                V oldVal = null;\n                //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {\n                         //普通的数组\n                        if (fh >= 0) {\n                            binCount = 1;\n                            for (Node<K,V> e = f;; ++binCount) {\n                                K ek;\n                                //找到key一样的，则直接替换并退出\n                                if (e.hash == hash &&\n                                    ((ek = e.key) == key ||\n                                     (ek != null && key.equals(ek)))) {\n                                    oldVal = e.val;\n                                    if (!onlyIfAbsent)\n                                        e.val = value;\n                                    break;\n                                }\n                                Node<K,V> pred = e;\n                                //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入\n                                if ((e = e.next) == null) {\n                                    pred.next = new Node<K,V>(hash, key,\n                                                              value, null);\n                                    break;\n                                }\n                            }\n                        }\n                        //如果是红合树\n                        else if (f instanceof TreeBin) {\n                            Node<K,V> p;\n                            //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行\n                            binCount = 2;\n                            if ((p = ((TreeBin<K,V>)f).putTreeVal(hash, key,\n                                                           value)) != null) {\n                                oldVal = p.val;\n                                if (!onlyIfAbsent)\n                                    p.val = value;\n                            }\n                        }\n                    }\n                }\n                if (binCount != 0) {\n                    if (binCount >= TREEIFY_THRESHOLD)\n                        //开始将table中元素为i的数组转变为二叉树\n                        treeifyBin(tab, i);\n                    if (oldVal != null)\n                        return oldVal;\n                    break;\n                }\n            }\n        }\n        //链表或者红黑树不应该增加table的负载\n        addCount(1L, binCount);\n        return null;\n    }\n```\n主要做了如下事情:\n+ 根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h >>> 16)) & HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash>0一定成立, 若node.hash<0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树\n+ 检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。\n+ 根据i = (n - 1) & hash))确定需要插入table的位置i:\n1. 若table[i]没有元素, 则将key-value存放进去。\n2. 若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)\n3. 否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。\n4. 在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)\n5. 修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。\n\n## initTable初始化\n```\n    private final Node<K,V>[] initTable() {\n        Node<K,V>[] tab; int sc;\n        while ((tab = table) == null || tab.length == 0) {//只要没有成功，就一定重新尝试\n            if ((sc = sizeCtl) < 0)  //正在初始化，本节点先尝试放弃cpu的使用\n                Thread.yield(); // lost initialization race; just spin\n            else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) { //这里应该是个原子操作，将sizeCtl设置为-1\n                try {\n                    if ((tab = table) == null || tab.length == 0) { //\n                        int n = (sc > 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量\n                        @SuppressWarnings(\"unchecked\")\n                        Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n];\n                        table = tab = nt;\n                        sc = n - (n >>> 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n\n                    }\n                } finally {\n                    sizeCtl = sc;\n                }\n                break;\n            }\n        }\n        return tab;\n    }\n```\n初始化table主要做了如下事情:\n+ 检查sizeCtl, 若发现<0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成\n+ 若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。\n+  初始化table\n+  设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数\n## addCount\naddCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。\n```\n    private final void addCount(long x, int check) {  //若小于0，则不检查扩容\n        CounterCell[] as; long b, s=baseCount+x;\n        .......//更新元素个数metrics\n        }\n        if (check >= 0) { //s是当前table长度\n            Node<K,V>[] tab, nt; int n, sc;\n            while (s >= (long)(sc = sizeCtl) && (tab = table) != null &&//达到容积上限，\n                   (n = tab.length) < MAXIMUM_CAPACITY) {\n                int rs = resizeStamp(n); //根据目前table长度做一个标识\n                if (sc < 0) { //说明table正在扩容\n                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n                        transferIndex <= 0)\n                        break;\n                    if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\n                        transfer(tab, nt);\n                } //第一个线程开始扩容，sizeCtl = resizeStamp(n)<<16 + 2\n                else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs << 16 + 2\n                                             (rs << RESIZE_STAMP_SHIFT) + 2))//rs > 2^15,rs << RESIZE_STAMP_SHIFT) + 2) > 2^31+n,int类型的数就是负数了。\n                    transfer(tab, null);\n                s = sumCount();\n            }\n        }\n    }\n```\n主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。\n+ 若sizeCtl<0, 那么检查是否扩容完成, 若扩容完成了, 退出; 否则将sizeCtl加1, 并进行扩容操作transfer(), 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>\n+ 若sizeCtl>0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)<<16 + 2, 并进行扩容transfer()\n\n# 总结\nConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。","slug":"ConcurrentHashMap-put过程介绍","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8ve0000phu51sc12es6","content":"<p>在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。<br>首先放张大图, 对ConcurrentHashMap先有大致的了解。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"><br>所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。<br>ConcurrentHashMap系列将分为以下三个方面进行详细描述:<br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a></p>\n<h1 id=\"成员变量介绍\"><a href=\"#成员变量介绍\" class=\"headerlink\" title=\"成员变量介绍\"></a>成员变量介绍</h1><p>ConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:</p>\n<ul>\n<li>LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh</li>\n<li>TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。</li>\n<li>UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。</li>\n<li>MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。</li>\n<li>MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容</li>\n<li>TREEBIN, 置为-2, 代表此元素后接红黑树。</li>\n<li>nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。</li>\n<li>sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:<br>  0: table还没有被初始化<br>  -1: table正在初始化<br>  小于-1: 实际值为resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 表明table正在扩容<br>  大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n</li>\n<li>transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标</li>\n<li>ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。</li>\n</ul>\n<h1 id=\"putVal插入数据\"><a href=\"#putVal插入数据\" class=\"headerlink\" title=\"putVal插入数据\"></a>putVal插入数据</h1><p>下面真正开始写入数据:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** Implementation for put and putIfAbsent */</div><div class=\"line\">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class=\"line\">    if (key == null || value == null) throw new NullPointerException();</div><div class=\"line\">    // 定位到table[]中的i</div><div class=\"line\">    int hash = spread(key.hashCode());</div><div class=\"line\">    int binCount = 0;</div><div class=\"line\">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class=\"line\">        //若table为0， 则初始化这个table</div><div class=\"line\">        if (tab == null || (n = tab.length) == 0)</div><div class=\"line\">            tab = initTable(); //首先初始化</div><div class=\"line\">        //根据hash值计算出在table里面的位置</div><div class=\"line\">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class=\"line\">            //如果没有，则向这个位置添加一个节点</div><div class=\"line\">            if (casTabAt(tab, i, null,</div><div class=\"line\">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class=\"line\">                break;                   // no lock when adding to empty bin</div><div class=\"line\">        &#125;</div><div class=\"line\">        //整个table正在扩容</div><div class=\"line\">        else if ((fh = f.hash) == MOVED)</div><div class=\"line\">            //帮着一起扩容</div><div class=\"line\">            tab = helpTransfer(tab, f);</div><div class=\"line\">        //真正插入数据</div><div class=\"line\">        else &#123;</div><div class=\"line\">            V oldVal = null;</div><div class=\"line\">            //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;</div><div class=\"line\">                     //普通的数组</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        binCount = 1;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class=\"line\">                            K ek;</div><div class=\"line\">                            //找到key一样的，则直接替换并退出</div><div class=\"line\">                            if (e.hash == hash &amp;&amp;</div><div class=\"line\">                                ((ek = e.key) == key ||</div><div class=\"line\">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class=\"line\">                                oldVal = e.val;</div><div class=\"line\">                                if (!onlyIfAbsent)</div><div class=\"line\">                                    e.val = value;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            Node&lt;K,V&gt; pred = e;</div><div class=\"line\">                            //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入</div><div class=\"line\">                            if ((e = e.next) == null) &#123;</div><div class=\"line\">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class=\"line\">                                                          value, null);</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //如果是红合树</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;</div><div class=\"line\">                        Node&lt;K,V&gt; p;</div><div class=\"line\">                        //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行</div><div class=\"line\">                        binCount = 2;</div><div class=\"line\">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class=\"line\">                                                       value)) != null) &#123;</div><div class=\"line\">                            oldVal = p.val;</div><div class=\"line\">                            if (!onlyIfAbsent)</div><div class=\"line\">                                p.val = value;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (binCount != 0) &#123;</div><div class=\"line\">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class=\"line\">                    //开始将table中元素为i的数组转变为二叉树</div><div class=\"line\">                    treeifyBin(tab, i);</div><div class=\"line\">                if (oldVal != null)</div><div class=\"line\">                    return oldVal;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //链表或者红黑树不应该增加table的负载</div><div class=\"line\">    addCount(1L, binCount);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash&gt;0一定成立, 若node.hash&lt;0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树</li>\n<li>检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。</li>\n<li>根据i = (n - 1) &amp; hash))确定需要插入table的位置i:</li>\n</ul>\n<ol>\n<li>若table[i]没有元素, 则将key-value存放进去。</li>\n<li>若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)</li>\n<li>否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。</li>\n<li>在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)</li>\n<li>修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。</li>\n</ol>\n<h2 id=\"initTable初始化\"><a href=\"#initTable初始化\" class=\"headerlink\" title=\"initTable初始化\"></a>initTable初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class=\"line\">    Node&lt;K,V&gt;[] tab; int sc;</div><div class=\"line\">    while ((tab = table) == null || tab.length == 0) &#123;//只要没有成功，就一定重新尝试</div><div class=\"line\">        if ((sc = sizeCtl) &lt; 0)  //正在初始化，本节点先尝试放弃cpu的使用</div><div class=\"line\">            Thread.yield(); // lost initialization race; just spin</div><div class=\"line\">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; //这里应该是个原子操作，将sizeCtl设置为-1</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if ((tab = table) == null || tab.length == 0) &#123; //</div><div class=\"line\">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量</div><div class=\"line\">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class=\"line\">                    table = tab = nt;</div><div class=\"line\">                    sc = n - (n &gt;&gt;&gt; 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                sizeCtl = sc;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tab;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>初始化table主要做了如下事情:</p>\n<ul>\n<li>检查sizeCtl, 若发现&lt;0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成</li>\n<li>若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。</li>\n<li>初始化table</li>\n<li>设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数<h2 id=\"addCount\"><a href=\"#addCount\" class=\"headerlink\" title=\"addCount\"></a>addCount</h2>addCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void addCount(long x, int check) &#123;  //若小于0，则不检查扩容</div><div class=\"line\">    CounterCell[] as; long b, s=baseCount+x;</div><div class=\"line\">    .......//更新元素个数metrics</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (check &gt;= 0) &#123; //s是当前table长度</div><div class=\"line\">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class=\"line\">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;//达到容积上限，</div><div class=\"line\">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class=\"line\">            int rs = resizeStamp(n); //根据目前table长度做一个标识</div><div class=\"line\">            if (sc &lt; 0) &#123; //说明table正在扩容</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class=\"line\">                    transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class=\"line\">                    transfer(tab, nt);</div><div class=\"line\">            &#125; //第一个线程开始扩容，sizeCtl = resizeStamp(n)&lt;&lt;16 + 2</div><div class=\"line\">            else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs &lt;&lt; 16 + 2</div><div class=\"line\">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))//rs &gt; 2^15,rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) &gt; 2^31+n,int类型的数就是负数了。</div><div class=\"line\">                transfer(tab, null);</div><div class=\"line\">            s = sumCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。</p>\n<ul>\n<li>若sizeCtl<0, 那么检查是否扩容完成,=\"\" 若扩容完成了,=\"\" 退出;=\"\" 否则将sizectl加1,=\"\" 并进行扩容操作transfer(),=\"\" 详见<a=\"\" href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</0,></li>\n<li>若sizeCtl&gt;0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)&lt;&lt;16 + 2, 并进行扩容transfer()</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在平时项目中, 较多的使用了HashMap容器, 但是它是非线程安全的, 在多线程put的时候, 可能会导致HashMap产生环链而导致死锁。 在并发场景下, 我们就得换成ConcurrentHashMap, 采用分段、红黑树等结构体, 支持多线程同时插入, 又拥有较高的性能。本文章将围绕put的过程进行详细描述。<br>首先放张大图, 对ConcurrentHashMap先有大致的了解。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap2.png\" height=\"400\" width=\"450\"><br>所有插入的值首先放在table的元素中, 当hash(key)冲突时, 将key-value存放在这个元素的后面, 形成一个链表, 当链表长度达到阈值时, 为减少索引时间, 将链表转变为一个红黑树; 当删除数据时, 红黑树可能会退化为链表; table由于负载高, 也可能会继续扩容。<br>ConcurrentHashMap系列将分为以下三个方面进行详细描述:<br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a><br><a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a></p>\n<h1 id=\"成员变量介绍\"><a href=\"#成员变量介绍\" class=\"headerlink\" title=\"成员变量介绍\"></a>成员变量介绍</h1><p>ConcurrentHashMap拥有出色的性能, 在真正掌握内部结构时, 先要掌握比较重要的成员:</p>\n<ul>\n<li>LOAD_FACTOR: 负载因子, 默认75%, 当table使用率达到75%时, 为减少table的hash碰撞, tabel长度将扩容一倍。负载因子计算: 元素总个数%table.lengh</li>\n<li>TREEIFY_THRESHOLD: 默认8, 当链表长度达到8时, 将结构转变为红黑树。</li>\n<li>UNTREEIFY_THRESHOLD: 默认6, 红黑树转变为链表的阈值。</li>\n<li>MIN_TRANSFER_STRIDE: 默认16, table扩容时, 每个线程最少迁移table的槽位个数。</li>\n<li>MOVED: 值为-1, 当Node.hash为MOVED时, 代表着table正在扩容</li>\n<li>TREEBIN, 置为-2, 代表此元素后接红黑树。</li>\n<li>nextTable: table迁移过程临时变量, 在迁移过程中将元素全部迁移到nextTable上。</li>\n<li>sizeCtl: 用来标志table初始化和扩容的,不同的取值代表着不同的含义:<br>  0: table还没有被初始化<br>  -1: table正在初始化<br>  小于-1: 实际值为resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 表明table正在扩容<br>  大于0: 初始化完成后, 代表table最大存放元素的个数, 默认为0.75*n</li>\n<li>transferIndex: table容量从n扩到2n时, 是从索引n-&gt;1的元素开始迁移, transferIndex代表当前已经迁移的元素下标</li>\n<li>ForwardingNode: 一个特殊的Node节点, 其hashcode=MOVED, 代表着此时table正在做扩容操作。扩容期间, 若table某个元素为null, 那么该元素设置为ForwardingNode, 当下个线程向这个元素插入数据时, 检查hashcode=MOVED, 就会帮着扩容。</li>\n</ul>\n<h1 id=\"putVal插入数据\"><a href=\"#putVal插入数据\" class=\"headerlink\" title=\"putVal插入数据\"></a>putVal插入数据</h1><p>下面真正开始写入数据:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** Implementation for put and putIfAbsent */</div><div class=\"line\">final V putVal(K key, V value, boolean onlyIfAbsent) &#123;</div><div class=\"line\">    if (key == null || value == null) throw new NullPointerException();</div><div class=\"line\">    // 定位到table[]中的i</div><div class=\"line\">    int hash = spread(key.hashCode());</div><div class=\"line\">    int binCount = 0;</div><div class=\"line\">    for (Node&lt;K,V&gt;[] tab = table;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int n, i, fh;</div><div class=\"line\">        //若table为0， 则初始化这个table</div><div class=\"line\">        if (tab == null || (n = tab.length) == 0)</div><div class=\"line\">            tab = initTable(); //首先初始化</div><div class=\"line\">        //根据hash值计算出在table里面的位置</div><div class=\"line\">        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123;</div><div class=\"line\">            //如果没有，则向这个位置添加一个节点</div><div class=\"line\">            if (casTabAt(tab, i, null,</div><div class=\"line\">                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div class=\"line\">                break;                   // no lock when adding to empty bin</div><div class=\"line\">        &#125;</div><div class=\"line\">        //整个table正在扩容</div><div class=\"line\">        else if ((fh = f.hash) == MOVED)</div><div class=\"line\">            //帮着一起扩容</div><div class=\"line\">            tab = helpTransfer(tab, f);</div><div class=\"line\">        //真正插入数据</div><div class=\"line\">        else &#123;</div><div class=\"line\">            V oldVal = null;</div><div class=\"line\">            //那么这个点先禁止别的线程插入数据，若整个table迁移还没有处理到这个元素，此时锁住后，迁移到这里后会被卡主</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;</div><div class=\"line\">                     //普通的数组</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        binCount = 1;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</div><div class=\"line\">                            K ek;</div><div class=\"line\">                            //找到key一样的，则直接替换并退出</div><div class=\"line\">                            if (e.hash == hash &amp;&amp;</div><div class=\"line\">                                ((ek = e.key) == key ||</div><div class=\"line\">                                 (ek != null &amp;&amp; key.equals(ek)))) &#123;</div><div class=\"line\">                                oldVal = e.val;</div><div class=\"line\">                                if (!onlyIfAbsent)</div><div class=\"line\">                                    e.val = value;</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            Node&lt;K,V&gt; pred = e;</div><div class=\"line\">                            //继续找下一个节点，若数组找到最后都没有找到合适的，那么就进行尾插法加入</div><div class=\"line\">                            if ((e = e.next) == null) &#123;</div><div class=\"line\">                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div class=\"line\">                                                          value, null);</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //如果是红合树</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;</div><div class=\"line\">                        Node&lt;K,V&gt; p;</div><div class=\"line\">                        //赋值固定，就不会再去转变了，只要小于TREEIFY_THRESHOLD就行</div><div class=\"line\">                        binCount = 2;</div><div class=\"line\">                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div class=\"line\">                                                       value)) != null) &#123;</div><div class=\"line\">                            oldVal = p.val;</div><div class=\"line\">                            if (!onlyIfAbsent)</div><div class=\"line\">                                p.val = value;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (binCount != 0) &#123;</div><div class=\"line\">                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div class=\"line\">                    //开始将table中元素为i的数组转变为二叉树</div><div class=\"line\">                    treeifyBin(tab, i);</div><div class=\"line\">                if (oldVal != null)</div><div class=\"line\">                    return oldVal;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //链表或者红黑树不应该增加table的负载</div><div class=\"line\">    addCount(1L, binCount);</div><div class=\"line\">    return null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>根据spread确定key-value的hash值, hash计算过程如下: (h ^ (h &gt;&gt;&gt; 16)) &amp; HASH_BITS, h=key.hashCode(), HASH_BITS=0x7fffffff, 由此可见, 计算出来的hash&gt;0一定成立, 若node.hash&lt;0是, -1(Moved)代表table正在扩容, -2(TREEBIN)代表此元素后接红黑树</li>\n<li>检查table是否初始化, 若没有初始化,则开始初始化initTable()。 这里可以看出ConcurrentHashMap使用懒性初始化, 只有在真正插入数据时候才进行扩容。</li>\n<li>根据i = (n - 1) &amp; hash))确定需要插入table的位置i:</li>\n</ul>\n<ol>\n<li>若table[i]没有元素, 则将key-value存放进去。</li>\n<li>若table[i].hash为MOVED, 那么说明table正在进行扩容, 则通过helpTransfer()进行扩容(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</a>)</li>\n<li>否则开始真正插入数据, 插入数据前, 先将table[i]锁住, 插入数据前, 检查table[i].hash, 若大于0, 说明此元素后接的是链表, 或者是个红黑树。 链表插入采取尾插法, 比较简单; 红黑树的插入详见后续描述。</li>\n<li>在链表插入时, 统计当前链表长度, 若长度超过TREEIFY_THRESHOLD(默认值为8), 则需要将链表转变为红黑树结构(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/06/ConcurrentHashMap%E7%BA%A2%E9%BB%91%E6%A0%91%E5%8E%9F%E7%90%86%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap红黑树原理介绍</a>)</li>\n<li>修改table存放所有元素个数、检查table是否需要扩容等, 详见addCount。 这里感觉代码有些问题, 插入任何一个元素, 无论插在table元素上、还是链表或者红黑树上, 都对table容量增加了1, 增加table容量的结果就是可能导致table扩容。 实际上插入链表或者红黑树, 并不会增加table的负载, 这两种情况下, 不应该增加table的负载、而去检查扩容。</li>\n</ol>\n<h2 id=\"initTable初始化\"><a href=\"#initTable初始化\" class=\"headerlink\" title=\"initTable初始化\"></a>initTable初始化</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final Node&lt;K,V&gt;[] initTable() &#123;</div><div class=\"line\">    Node&lt;K,V&gt;[] tab; int sc;</div><div class=\"line\">    while ((tab = table) == null || tab.length == 0) &#123;//只要没有成功，就一定重新尝试</div><div class=\"line\">        if ((sc = sizeCtl) &lt; 0)  //正在初始化，本节点先尝试放弃cpu的使用</div><div class=\"line\">            Thread.yield(); // lost initialization race; just spin</div><div class=\"line\">        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; //这里应该是个原子操作，将sizeCtl设置为-1</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if ((tab = table) == null || tab.length == 0) &#123; //</div><div class=\"line\">                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;//sc 大于零说明容量已经初始化了，否则使用默认容量</div><div class=\"line\">                    @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div class=\"line\">                    table = tab = nt;</div><div class=\"line\">                    sc = n - (n &gt;&gt;&gt; 2);//  //计算阈值，等效于 n*0.75，就是n-0.25*n</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                sizeCtl = sc;</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tab;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>初始化table主要做了如下事情:</p>\n<ul>\n<li>检查sizeCtl, 若发现&lt;0, 那么说明已经有线程正在初始化, 本线程先放弃cpu使用等待初始化完成</li>\n<li>若本线程是第一个初始化table, 那么原子操作, 将sizeCtl设置为-1, 表明有线程正在对table正在初始化。</li>\n<li>初始化table</li>\n<li>设置sizeCtl= table.length*0.75, 规定了table最大存放元素的个数<h2 id=\"addCount\"><a href=\"#addCount\" class=\"headerlink\" title=\"addCount\"></a>addCount</h2>addCount主要做两个事情: 并发环境下统计ConcurrentHashMap里属性的个数、检查table是否需要扩容。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void addCount(long x, int check) &#123;  //若小于0，则不检查扩容</div><div class=\"line\">    CounterCell[] as; long b, s=baseCount+x;</div><div class=\"line\">    .......//更新元素个数metrics</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (check &gt;= 0) &#123; //s是当前table长度</div><div class=\"line\">        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div class=\"line\">        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;//达到容积上限，</div><div class=\"line\">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</div><div class=\"line\">            int rs = resizeStamp(n); //根据目前table长度做一个标识</div><div class=\"line\">            if (sc &lt; 0) &#123; //说明table正在扩容</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div class=\"line\">                    transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div class=\"line\">                    transfer(tab, nt);</div><div class=\"line\">            &#125; //第一个线程开始扩容，sizeCtl = resizeStamp(n)&lt;&lt;16 + 2</div><div class=\"line\">            else if (U.compareAndSwapInt(this, SIZECTL, sc, //sc = rs &lt;&lt; 16 + 2</div><div class=\"line\">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))//rs &gt; 2^15,rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2) &gt; 2^31+n,int类型的数就是负数了。</div><div class=\"line\">                transfer(tab, null);</div><div class=\"line\">            s = sumCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要介绍检查是否需要扩容, 若ConcurrentHashMap总个数s+x达到了最大元素阈值sizeCtl, 那么开始进行扩容, 这里扩容应该分下场景, 链表和红黑树结构体的插入, 不应该进行扩容的。</p>\n<ul>\n<li>若sizeCtl<0, 那么检查是否扩容完成,=\"\" 若扩容完成了,=\"\" 退出;=\"\" 否则将sizectl加1,=\"\" 并进行扩容操作transfer(),=\"\" 详见<a=\"\" href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/14/ConcurrentHashMap%E6%89%A9%E5%AE%B9%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap扩容源码介绍</0,></li>\n<li>若sizeCtl&gt;0, 那么本线程是第一个开始对table进行扩容的, 将sizeCtl=resizeStamp(n)&lt;&lt;16 + 2, 并进行扩容transfer()</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ConcurrentHashMap为了加快索引速度和插入并发, 采用由数组+链表+红黑树来存储数据,  数据结构之间能够相互转变。 插入数据时, 会检查table是否初始化, 是否在扩容, 插入的元素位置是否为链表、红黑树, 针对不同的情况采取不同的插入方法。</p>\n"},{"title":"ConcurrentHashMap扩容源码介绍","date":"2017-11-14T03:21:07.000Z","toc":true,"_content":"在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:\n+ 一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容\n+ 一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。\n\n# 协助扩容helpTransfer()\n下面是协助扩容的过程:\n```\nfinal Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { //table扩容\n        Node<K,V>[] nextTab; int sc;\n        if (tab != null && (f instanceof ForwardingNode) &&\n            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n            // 根据 length 得到一个标识符号\n            int rs = resizeStamp(tab.length);\n            while (nextTab == nextTable && table == tab &&\n                   (sc = sizeCtl) < 0) {//说明还在扩容\n                //判断是否标志发生了变化||  扩容结束了\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）\n                    sc == rs + MAX_RESIZERS || transferIndex <= 0)\n                    break;\n                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {\n                    transfer(tab, nextTab);\n                    break;\n                }\n            }\n            return nextTab;\n        }\n        return table;\n    }\n```\n主要做了如下事情:\n+ 检查是否扩容完成\n扩容期间c >>> RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex <= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs << RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。\n+ 对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。\n\n## 扩容transfer\n扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。\n```\n    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n        int n = tab.length, stride;\n        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n           // subdivide range，每个线程最少迁移16个槽位，大的话，最多\n            stride = MIN_TRANSFER_STRIDE;\n        // initiating  才开始初始化新的nextTab\n        if (nextTab == null) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];  //扩容2倍\n                nextTab = nt;\n            } catch (Throwable ex) {      // try to cope with OOME\n                sizeCtl = Integer.MAX_VALUE;\n                return;\n            }\n            nextTable = nextTab;\n            transferIndex = n;//更新的转移下标，\n        }\n        int nextn = nextTab.length;\n        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n        //是否能够向前推进到下一个周期\n        boolean advance = true;\n        // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法\n        boolean finishing = false;\n        for (int i = 0, bound = 0;;) {\n            Node<K,V> f; int fh;\n            while (advance) { //取下一个周期\n                int nextIndex, nextBound;\n                //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理\n                if (--i >= bound || finishing)\n                    advance = false;\n                //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间\n                else if ((nextIndex = transferIndex) <= 0) {\n                    i = -1;\n                    advance = false;\n                }\n                //这个条件改变的是transferIndex的值，从16变成了1\n                else if (U.compareAndSwapInt\n                         (this, TRANSFERINDEX, nextIndex,\n                         //nextBound 是这次迁移任务的边界，注意，是从后往前\n                          nextBound = (nextIndex > stride ?\n                                       nextIndex - stride : 0))) {\n                    bound = nextBound; //一块区间最小桶的下标\n                    i = nextIndex - 1; //能够处理的最大桶的下标\n                    advance = false;\n                }\n            }\n            if (i < 0 || i >= n || i + n >= nextn) { //每个迁移线程都能达到这里\n                int sc;\n                if (finishing) { //迁移完成\n                    nextTable = null;\n                    //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的\n                    table = nextTab;\n                    sizeCtl = (n << 1) - (n >>> 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值\n                    return;\n                }\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n            }\n            //如果对应位置为null， 则将ForwardingNode放在对应的地方\n            else if ((f = tabAt(tab, i)) == null)\n                advance = casTabAt(tab, i, null, fwd);\n            else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标\n                advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束\n            else { //说明位置上有值了，\n                //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {//判断i下标和f是否相同\n                        Node<K,V> ln, hn; //高位桶， 地位桶\n                        if (fh >= 0) {\n                            int runBit = fh & n;//n为2^n, 取余后只能是2^n\n                            Node<K,V> lastRun = f;\n                            ///找到最后一个不和fn相同的节点\n                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n                                int b = p.hash & n;\n                                //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的\n                                if (b != runBit) {\n                                    runBit = b;\n                                    lastRun = p;\n                                }\n                            }\n                            if (runBit == 0) {\n                                ln = lastRun;\n                                hn = null;\n                            }\n                            else { //比如1，16，32,如果低位%16，那么肯定是0。\n                                hn = lastRun;\n                                ln = null;\n                            }\n                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                                int ph = p.hash; K pk = p.key; V pv = p.val;\n                                if ((ph & n) == 0)\n                                     //这样就把相同串的给串起来了\n                                    ln = new Node<K,V>(ph, pk, pv, ln);\n                                else\n                                    //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。\n                                    hn = new Node<K,V>(ph, pk, pv, hn);\n                            }\n                            setTabAt(nextTab, i, ln); //反着给串起来了\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                        else if (f instanceof TreeBin) {// 如果是红黑树\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> lo = null, loTail = null; //也是高低节点\n                            TreeNode<K,V> hi = null, hiTail = null;//也是高低节点\n                            int lc = 0, hc = 0;\n                            for (Node<K,V> e = t.first; e != null; e = e.next) { //中序遍历红黑树\n                                int h = e.hash;\n                                TreeNode<K,V> p = new TreeNode<K,V>\n                                    (h, e.key, e.val, null, null);\n                                if ((h & n) == 0) { //0的放低位\n                                    //注意这里p.prev = loTail，每一个p都是下一个的prev\n                                    if ((p.prev = loTail) == null)\n                                        lo = p; //把头记住\n                                    else\n                                        loTail.next = p;  //上一次的p的next是这次的p\n                                    loTail = p; //把上次p给记住\n                                    ++lc;\n                                }\n                                else { //高位\n                                    if ((p.prev = hiTail) == null)\n                                        hi = p; //把尾记住\n                                    else\n                                        hiTail.next = p;\n                                    hiTail = p;\n                                    ++hc;\n                                }\n                            }\n                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树\n                                (hc != 0) ? new TreeBin<K,V>(lo) : t; //如果没有高低的话，则部分为两个树\n                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                                (lc != 0) ? new TreeBin<K,V>(hi) : t;\n                            setTabAt(nextTab, i, ln);\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n其中有两个变量需要了解下:\nadvance: 表示是否可以向下一个轮元素进行迁移。\nfinishing: table所有元素是否迁移完成。\n大致做了如下事情:\n+ 确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。\n+ 检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。\n+ 进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。\n+ 从i -> bound开始遍历table中每个元素, 这里是`从大到小`遍历的:\n1. 若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。\n2. 若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。\n3. 否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash>0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。\n+ 链表迁移原理如下: `遍历链表每个节点。 若节点的f.hash&n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面`。\n迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。\n首先放一个张图展示扩容的变化:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"/>\n蓝色节点代表:f.hash&n==0, 绿色节点代表f.hash&n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。\n+ 迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。\n4.如何确定table所有元素迁移完成:\n```\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n```\n第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) << RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl> resizeStamp(n) << RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。\n# 总结\ntable扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。\n","source":"_posts/ConcurrentHashMap扩容过程介绍.md","raw":"---\ntitle: ConcurrentHashMap扩容源码介绍\ndate: 2017-11-14 11:21:07\ntags:\ntoc: true\n---\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:\n+ 一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容\n+ 一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。\n\n# 协助扩容helpTransfer()\n下面是协助扩容的过程:\n```\nfinal Node<K,V>[] helpTransfer(Node<K,V>[] tab, Node<K,V> f) { //table扩容\n        Node<K,V>[] nextTab; int sc;\n        if (tab != null && (f instanceof ForwardingNode) &&\n            (nextTab = ((ForwardingNode<K,V>)f).nextTable) != null) {\n            // 根据 length 得到一个标识符号\n            int rs = resizeStamp(tab.length);\n            while (nextTab == nextTable && table == tab &&\n                   (sc = sizeCtl) < 0) {//说明还在扩容\n                //判断是否标志发生了变化||  扩容结束了\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）\n                    sc == rs + MAX_RESIZERS || transferIndex <= 0)\n                    break;\n                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {\n                    transfer(tab, nextTab);\n                    break;\n                }\n            }\n            return nextTab;\n        }\n        return table;\n    }\n```\n主要做了如下事情:\n+ 检查是否扩容完成\n扩容期间c >>> RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex <= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs << RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)<<RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。\n+ 对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。\n\n## 扩容transfer\n扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。\n```\n    private final void transfer(Node<K,V>[] tab, Node<K,V>[] nextTab) {\n        int n = tab.length, stride;\n        if ((stride = (NCPU > 1) ? (n >>> 3) / NCPU : n) < MIN_TRANSFER_STRIDE)\n           // subdivide range，每个线程最少迁移16个槽位，大的话，最多\n            stride = MIN_TRANSFER_STRIDE;\n        // initiating  才开始初始化新的nextTab\n        if (nextTab == null) {\n            try {\n                @SuppressWarnings(\"unchecked\")\n                Node<K,V>[] nt = (Node<K,V>[])new Node<?,?>[n << 1];  //扩容2倍\n                nextTab = nt;\n            } catch (Throwable ex) {      // try to cope with OOME\n                sizeCtl = Integer.MAX_VALUE;\n                return;\n            }\n            nextTable = nextTab;\n            transferIndex = n;//更新的转移下标，\n        }\n        int nextn = nextTab.length;\n        ForwardingNode<K,V> fwd = new ForwardingNode<K,V>(nextTab);\n        //是否能够向前推进到下一个周期\n        boolean advance = true;\n        // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法\n        boolean finishing = false;\n        for (int i = 0, bound = 0;;) {\n            Node<K,V> f; int fh;\n            while (advance) { //取下一个周期\n                int nextIndex, nextBound;\n                //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理\n                if (--i >= bound || finishing)\n                    advance = false;\n                //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间\n                else if ((nextIndex = transferIndex) <= 0) {\n                    i = -1;\n                    advance = false;\n                }\n                //这个条件改变的是transferIndex的值，从16变成了1\n                else if (U.compareAndSwapInt\n                         (this, TRANSFERINDEX, nextIndex,\n                         //nextBound 是这次迁移任务的边界，注意，是从后往前\n                          nextBound = (nextIndex > stride ?\n                                       nextIndex - stride : 0))) {\n                    bound = nextBound; //一块区间最小桶的下标\n                    i = nextIndex - 1; //能够处理的最大桶的下标\n                    advance = false;\n                }\n            }\n            if (i < 0 || i >= n || i + n >= nextn) { //每个迁移线程都能达到这里\n                int sc;\n                if (finishing) { //迁移完成\n                    nextTable = null;\n                    //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的\n                    table = nextTab;\n                    sizeCtl = (n << 1) - (n >>> 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值\n                    return;\n                }\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n            }\n            //如果对应位置为null， 则将ForwardingNode放在对应的地方\n            else if ((f = tabAt(tab, i)) == null)\n                advance = casTabAt(tab, i, null, fwd);\n            else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标\n                advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束\n            else { //说明位置上有值了，\n                //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住\n                synchronized (f) {\n                    if (tabAt(tab, i) == f) {//判断i下标和f是否相同\n                        Node<K,V> ln, hn; //高位桶， 地位桶\n                        if (fh >= 0) {\n                            int runBit = fh & n;//n为2^n, 取余后只能是2^n\n                            Node<K,V> lastRun = f;\n                            ///找到最后一个不和fn相同的节点\n                            for (Node<K,V> p = f.next; p != null; p = p.next) {\n                                int b = p.hash & n;\n                                //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的\n                                if (b != runBit) {\n                                    runBit = b;\n                                    lastRun = p;\n                                }\n                            }\n                            if (runBit == 0) {\n                                ln = lastRun;\n                                hn = null;\n                            }\n                            else { //比如1，16，32,如果低位%16，那么肯定是0。\n                                hn = lastRun;\n                                ln = null;\n                            }\n                            for (Node<K,V> p = f; p != lastRun; p = p.next) {\n                                int ph = p.hash; K pk = p.key; V pv = p.val;\n                                if ((ph & n) == 0)\n                                     //这样就把相同串的给串起来了\n                                    ln = new Node<K,V>(ph, pk, pv, ln);\n                                else\n                                    //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。\n                                    hn = new Node<K,V>(ph, pk, pv, hn);\n                            }\n                            setTabAt(nextTab, i, ln); //反着给串起来了\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                        else if (f instanceof TreeBin) {// 如果是红黑树\n                            TreeBin<K,V> t = (TreeBin<K,V>)f;\n                            TreeNode<K,V> lo = null, loTail = null; //也是高低节点\n                            TreeNode<K,V> hi = null, hiTail = null;//也是高低节点\n                            int lc = 0, hc = 0;\n                            for (Node<K,V> e = t.first; e != null; e = e.next) { //中序遍历红黑树\n                                int h = e.hash;\n                                TreeNode<K,V> p = new TreeNode<K,V>\n                                    (h, e.key, e.val, null, null);\n                                if ((h & n) == 0) { //0的放低位\n                                    //注意这里p.prev = loTail，每一个p都是下一个的prev\n                                    if ((p.prev = loTail) == null)\n                                        lo = p; //把头记住\n                                    else\n                                        loTail.next = p;  //上一次的p的next是这次的p\n                                    loTail = p; //把上次p给记住\n                                    ++lc;\n                                }\n                                else { //高位\n                                    if ((p.prev = hiTail) == null)\n                                        hi = p; //把尾记住\n                                    else\n                                        hiTail.next = p;\n                                    hiTail = p;\n                                    ++hc;\n                                }\n                            }\n                            ln = (lc <= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树\n                                (hc != 0) ? new TreeBin<K,V>(lo) : t; //如果没有高低的话，则部分为两个树\n                            hn = (hc <= UNTREEIFY_THRESHOLD) ? untreeify(hi) :\n                                (lc != 0) ? new TreeBin<K,V>(hi) : t;\n                            setTabAt(nextTab, i, ln);\n                            setTabAt(nextTab, i + n, hn);\n                            setTabAt(tab, i, fwd);\n                            advance = true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n```\n其中有两个变量需要了解下:\nadvance: 表示是否可以向下一个轮元素进行迁移。\nfinishing: table所有元素是否迁移完成。\n大致做了如下事情:\n+ 确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。\n+ 检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。\n+ 进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。\n+ 从i -> bound开始遍历table中每个元素, 这里是`从大到小`遍历的:\n1. 若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。\n2. 若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。\n3. 否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash>0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。\n+ 链表迁移原理如下: `遍历链表每个节点。 若节点的f.hash&n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面`。\n迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。\n首先放一个张图展示扩容的变化:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"/>\n蓝色节点代表:f.hash&n==0, 绿色节点代表f.hash&n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。\n+ 迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。\n4.如何确定table所有元素迁移完成:\n```\n                //表示当前线程迁移完成了\n                if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {\n                     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的\n                    if ((sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT)\n                        return;\n                    finishing = advance = true;\n                    i = n; // recheck before commit\n                }\n```\n第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) << RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl> resizeStamp(n) << RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。\n# 总结\ntable扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。\n","slug":"ConcurrentHashMap扩容过程介绍","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8vn0002phu5u6onflxz","content":"<p>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:</p>\n<ul>\n<li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li>\n<li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</li>\n</ul>\n<h1 id=\"协助扩容helpTransfer\"><a href=\"#协助扩容helpTransfer\" class=\"headerlink\" title=\"协助扩容helpTransfer()\"></a>协助扩容helpTransfer()</h1><p>下面是协助扩容的过程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; //table扩容</div><div class=\"line\">        Node&lt;K,V&gt;[] nextTab; int sc;</div><div class=\"line\">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div class=\"line\">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</div><div class=\"line\">            // 根据 length 得到一个标识符号</div><div class=\"line\">            int rs = resizeStamp(tab.length);</div><div class=\"line\">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class=\"line\">                   (sc = sizeCtl) &lt; 0) &#123;//说明还在扩容</div><div class=\"line\">                //判断是否标志发生了变化||  扩容结束了</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</div><div class=\"line\">                    transfer(tab, nextTab);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return nextTab;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return table;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>检查是否扩容完成<br>扩容期间c &gt;&gt;&gt; RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex &lt;= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs &lt;&lt; RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。</li>\n<li>对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</li>\n</ul>\n<h2 id=\"扩容transfer\"><a href=\"#扩容transfer\" class=\"headerlink\" title=\"扩容transfer\"></a>扩容transfer</h2><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class=\"line\">    int n = tab.length, stride;</div><div class=\"line\">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class=\"line\">       // subdivide range，每个线程最少迁移16个槽位，大的话，最多</div><div class=\"line\">        stride = MIN_TRANSFER_STRIDE;</div><div class=\"line\">    // initiating  才开始初始化新的nextTab</div><div class=\"line\">    if (nextTab == null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];  //扩容2倍</div><div class=\"line\">            nextTab = nt;</div><div class=\"line\">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class=\"line\">            sizeCtl = Integer.MAX_VALUE;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        nextTable = nextTab;</div><div class=\"line\">        transferIndex = n;//更新的转移下标，</div><div class=\"line\">    &#125;</div><div class=\"line\">    int nextn = nextTab.length;</div><div class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class=\"line\">    //是否能够向前推进到下一个周期</div><div class=\"line\">    boolean advance = true;</div><div class=\"line\">    // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法</div><div class=\"line\">    boolean finishing = false;</div><div class=\"line\">    for (int i = 0, bound = 0;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int fh;</div><div class=\"line\">        while (advance) &#123; //取下一个周期</div><div class=\"line\">            int nextIndex, nextBound;</div><div class=\"line\">            //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理</div><div class=\"line\">            if (--i &gt;= bound || finishing)</div><div class=\"line\">                advance = false;</div><div class=\"line\">            //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间</div><div class=\"line\">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</div><div class=\"line\">                i = -1;</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //这个条件改变的是transferIndex的值，从16变成了1</div><div class=\"line\">            else if (U.compareAndSwapInt</div><div class=\"line\">                     (this, TRANSFERINDEX, nextIndex,</div><div class=\"line\">                     //nextBound 是这次迁移任务的边界，注意，是从后往前</div><div class=\"line\">                      nextBound = (nextIndex &gt; stride ?</div><div class=\"line\">                                   nextIndex - stride : 0))) &#123;</div><div class=\"line\">                bound = nextBound; //一块区间最小桶的下标</div><div class=\"line\">                i = nextIndex - 1; //能够处理的最大桶的下标</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; //每个迁移线程都能达到这里</div><div class=\"line\">            int sc;</div><div class=\"line\">            if (finishing) &#123; //迁移完成</div><div class=\"line\">                nextTable = null;</div><div class=\"line\">                //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的</div><div class=\"line\">                table = nextTab;</div><div class=\"line\">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //表示当前线程迁移完成了</div><div class=\"line\">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">                 //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">                    return;</div><div class=\"line\">                finishing = advance = true;</div><div class=\"line\">                i = n; // recheck before commit</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //如果对应位置为null， 则将ForwardingNode放在对应的地方</div><div class=\"line\">        else if ((f = tabAt(tab, i)) == null)</div><div class=\"line\">            advance = casTabAt(tab, i, null, fwd);</div><div class=\"line\">        else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标</div><div class=\"line\">            advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束</div><div class=\"line\">        else &#123; //说明位置上有值了，</div><div class=\"line\">            //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;//判断i下标和f是否相同</div><div class=\"line\">                    Node&lt;K,V&gt; ln, hn; //高位桶， 地位桶</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        int runBit = fh &amp; n;//n为2^n, 取余后只能是2^n</div><div class=\"line\">                        Node&lt;K,V&gt; lastRun = f;</div><div class=\"line\">                        ///找到最后一个不和fn相同的节点</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class=\"line\">                            int b = p.hash &amp; n;</div><div class=\"line\">                            //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的</div><div class=\"line\">                            if (b != runBit) &#123;</div><div class=\"line\">                                runBit = b;</div><div class=\"line\">                                lastRun = p;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (runBit == 0) &#123;</div><div class=\"line\">                            ln = lastRun;</div><div class=\"line\">                            hn = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        else &#123; //比如1，16，32,如果低位%16，那么肯定是0。</div><div class=\"line\">                            hn = lastRun;</div><div class=\"line\">                            ln = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class=\"line\">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class=\"line\">                            if ((ph &amp; n) == 0)</div><div class=\"line\">                                 //这样就把相同串的给串起来了</div><div class=\"line\">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class=\"line\">                            else</div><div class=\"line\">                                //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。</div><div class=\"line\">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        setTabAt(nextTab, i, ln); //反着给串起来了</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;// 如果是红黑树</div><div class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class=\"line\">                        TreeNode&lt;K,V&gt; lo = null, loTail = null; //也是高低节点</div><div class=\"line\">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;//也是高低节点</div><div class=\"line\">                        int lc = 0, hc = 0;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; //中序遍历红黑树</div><div class=\"line\">                            int h = e.hash;</div><div class=\"line\">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class=\"line\">                                (h, e.key, e.val, null, null);</div><div class=\"line\">                            if ((h &amp; n) == 0) &#123; //0的放低位</div><div class=\"line\">                                //注意这里p.prev = loTail，每一个p都是下一个的prev</div><div class=\"line\">                                if ((p.prev = loTail) == null)</div><div class=\"line\">                                    lo = p; //把头记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    loTail.next = p;  //上一次的p的next是这次的p</div><div class=\"line\">                                loTail = p; //把上次p给记住</div><div class=\"line\">                                ++lc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            else &#123; //高位</div><div class=\"line\">                                if ((p.prev = hiTail) == null)</div><div class=\"line\">                                    hi = p; //把尾记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    hiTail.next = p;</div><div class=\"line\">                                hiTail = p;</div><div class=\"line\">                                ++hc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树</div><div class=\"line\">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; //如果没有高低的话，则部分为两个树</div><div class=\"line\">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class=\"line\">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class=\"line\">                        setTabAt(nextTab, i, ln);</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有两个变量需要了解下:<br>advance: 表示是否可以向下一个轮元素进行迁移。<br>finishing: table所有元素是否迁移完成。<br>大致做了如下事情:</p>\n<ul>\n<li>确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。</li>\n<li>检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。</li>\n<li>进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。</li>\n<li>从i -&gt; bound开始遍历table中每个元素, 这里是<code>从大到小</code>遍历的:</li>\n</ul>\n<ol>\n<li>若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。</li>\n<li>若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。</li>\n<li>否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。</li>\n</ol>\n<ul>\n<li>链表迁移原理如下: <code>遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面</code>。<br>迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。<br>首先放一个张图展示扩容的变化:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"><br>蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。</li>\n<li>迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。<br>4.如何确定table所有元素迁移完成:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//表示当前线程迁移完成了</div><div class=\"line\">if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">        return;</div><div class=\"line\">    finishing = advance = true;</div><div class=\"line\">    i = n; // recheck before commit</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a>我们讲过, ConcurrentHashMap由三部分构成, table+链表+红黑树, 其中table是一个数组, 既然是数组, 必须要在使用时确定数组的大小, 当table存放的元素过多时, 就需要扩容, 以减少碰撞发生次数, 本文就讲解扩容的过程。扩容检查主要发生在插入元素(<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/11/05/ConcurrentHashMap-put%E8%BF%87%E7%A8%8B%E4%BB%8B%E7%BB%8D/\">ConcurrentHashMap Put源码介绍</a> putVal())的过程:</p>\n<ul>\n<li>一个线程插完元素后, 检查table使用率, 若超过阈值, 调用transfer进行扩容</li>\n<li>一个线程插入数据时, 发现table对应元素的hash=MOVED, 那么调用helpTransfer()协助扩容。</li>\n</ul>\n<h1 id=\"协助扩容helpTransfer\"><a href=\"#协助扩容helpTransfer\" class=\"headerlink\" title=\"协助扩容helpTransfer()\"></a>协助扩容helpTransfer()</h1><p>下面是协助扩容的过程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; //table扩容</div><div class=\"line\">        Node&lt;K,V&gt;[] nextTab; int sc;</div><div class=\"line\">        if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div class=\"line\">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123;</div><div class=\"line\">            // 根据 length 得到一个标识符号</div><div class=\"line\">            int rs = resizeStamp(tab.length);</div><div class=\"line\">            while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div class=\"line\">                   (sc = sizeCtl) &lt; 0) &#123;//说明还在扩容</div><div class=\"line\">                //判断是否标志发生了变化||  扩容结束了</div><div class=\"line\">                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div class=\"line\">                     //达到最大的帮助线程 ||  判断扩容转移下标是否在调整（扩容结束）</div><div class=\"line\">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div class=\"line\">                    break;</div><div class=\"line\">                // 将 sizeCtl + 1, （表示增加了一个线程帮助其扩容）</div><div class=\"line\">                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123;</div><div class=\"line\">                    transfer(tab, nextTab);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            return nextTab;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return table;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>检查是否扩容完成<br>扩容期间c &gt;&gt;&gt; RESIZE_STAMP_SHIFT == rs是成立的, 扩容完成后, transferIndex &lt;= 0是成立的。而这里的sc == rs + 1和sc == rs + MAX_RESIZERS并没有看到什么意义, 网上说的是检查扩容结束和扩容现成的控制。但是要是扩容结束, 应该是sc == rs &lt;&lt; RESIZE_STAMP_SHIFT + 1才对, 若是对线程控制, sc == rs + MAX_RESIZERS里面sc=resizeStamp(n)&lt;&lt;RESIZE_STAMP_SHIFT+2, 是一个大于-2^16的负数, 就算每个线程对sc+1, 那么需要2^16才能大于0, 相等基本也是不可能的。</li>\n<li>对sizeCtrl = sizeCtrl+1, 然后调用transfer()进行真正的扩容。</li>\n</ul>\n<h2 id=\"扩容transfer\"><a href=\"#扩容transfer\" class=\"headerlink\" title=\"扩容transfer\"></a>扩容transfer</h2><p>扩容的整体步骤就是新建一个nextTab, size是之前的2倍, 将table上的非空元素迁移到nextTab上面去。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123;</div><div class=\"line\">    int n = tab.length, stride;</div><div class=\"line\">    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div class=\"line\">       // subdivide range，每个线程最少迁移16个槽位，大的话，最多</div><div class=\"line\">        stride = MIN_TRANSFER_STRIDE;</div><div class=\"line\">    // initiating  才开始初始化新的nextTab</div><div class=\"line\">    if (nextTab == null) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];  //扩容2倍</div><div class=\"line\">            nextTab = nt;</div><div class=\"line\">        &#125; catch (Throwable ex) &#123;      // try to cope with OOME</div><div class=\"line\">            sizeCtl = Integer.MAX_VALUE;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        nextTable = nextTab;</div><div class=\"line\">        transferIndex = n;//更新的转移下标，</div><div class=\"line\">    &#125;</div><div class=\"line\">    int nextn = nextTab.length;</div><div class=\"line\">    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div class=\"line\">    //是否能够向前推进到下一个周期</div><div class=\"line\">    boolean advance = true;</div><div class=\"line\">    // to ensure sweep before committing nextTab，完成状态，如果是，则结束此方法</div><div class=\"line\">    boolean finishing = false;</div><div class=\"line\">    for (int i = 0, bound = 0;;) &#123;</div><div class=\"line\">        Node&lt;K,V&gt; f; int fh;</div><div class=\"line\">        while (advance) &#123; //取下一个周期</div><div class=\"line\">            int nextIndex, nextBound;</div><div class=\"line\">            //本线程处理的区间范围为[bound, i),范围还没有处理完成，那么就继续处理</div><div class=\"line\">            if (--i &gt;= bound || finishing)</div><div class=\"line\">                advance = false;</div><div class=\"line\">            //目前处理到了这里（从大到小， 下线），开始找新的一轮的区间</div><div class=\"line\">            else if ((nextIndex = transferIndex) &lt;= 0) &#123;</div><div class=\"line\">                i = -1;</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //这个条件改变的是transferIndex的值，从16变成了1</div><div class=\"line\">            else if (U.compareAndSwapInt</div><div class=\"line\">                     (this, TRANSFERINDEX, nextIndex,</div><div class=\"line\">                     //nextBound 是这次迁移任务的边界，注意，是从后往前</div><div class=\"line\">                      nextBound = (nextIndex &gt; stride ?</div><div class=\"line\">                                   nextIndex - stride : 0))) &#123;</div><div class=\"line\">                bound = nextBound; //一块区间最小桶的下标</div><div class=\"line\">                i = nextIndex - 1; //能够处理的最大桶的下标</div><div class=\"line\">                advance = false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; //每个迁移线程都能达到这里</div><div class=\"line\">            int sc;</div><div class=\"line\">            if (finishing) &#123; //迁移完成</div><div class=\"line\">                nextTable = null;</div><div class=\"line\">                //直接把以前的table丢弃了，上面的MOVE等标志全部丢弃，使用新的</div><div class=\"line\">                table = nextTab;</div><div class=\"line\">                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); //扩大2n-0.5n = 1.50n, 更新新的容量阈值</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //表示当前线程迁移完成了</div><div class=\"line\">            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">                 //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">                    return;</div><div class=\"line\">                finishing = advance = true;</div><div class=\"line\">                i = n; // recheck before commit</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //如果对应位置为null， 则将ForwardingNode放在对应的地方</div><div class=\"line\">        else if ((f = tabAt(tab, i)) == null)</div><div class=\"line\">            advance = casTabAt(tab, i, null, fwd);</div><div class=\"line\">        else if ((fh = f.hash) == MOVED) //别的线程已经在处理了，再推进一个下标</div><div class=\"line\">            advance = true; // already processed，推动到下一个周期，仍然会检查i与bound是否结束</div><div class=\"line\">        else &#123; //说明位置上有值了，</div><div class=\"line\">            //需要加锁，防止再向里面放值，在放数据时，也会锁住。比如整个table正在迁移，还没有迁移到这个元素，另外一个线程像这个节点插入数据，此时迁移到这里了，会被阻塞住</div><div class=\"line\">            synchronized (f) &#123;</div><div class=\"line\">                if (tabAt(tab, i) == f) &#123;//判断i下标和f是否相同</div><div class=\"line\">                    Node&lt;K,V&gt; ln, hn; //高位桶， 地位桶</div><div class=\"line\">                    if (fh &gt;= 0) &#123;</div><div class=\"line\">                        int runBit = fh &amp; n;//n为2^n, 取余后只能是2^n</div><div class=\"line\">                        Node&lt;K,V&gt; lastRun = f;</div><div class=\"line\">                        ///找到最后一个不和fn相同的节点</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123;</div><div class=\"line\">                            int b = p.hash &amp; n;</div><div class=\"line\">                            //只要找到这，之后的取值都是一样的，下次循环时，就不用再循环后面的</div><div class=\"line\">                            if (b != runBit) &#123;</div><div class=\"line\">                                runBit = b;</div><div class=\"line\">                                lastRun = p;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        if (runBit == 0) &#123;</div><div class=\"line\">                            ln = lastRun;</div><div class=\"line\">                            hn = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        else &#123; //比如1，16，32,如果低位%16，那么肯定是0。</div><div class=\"line\">                            hn = lastRun;</div><div class=\"line\">                            ln = null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</div><div class=\"line\">                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div class=\"line\">                            if ((ph &amp; n) == 0)</div><div class=\"line\">                                 //这样就把相同串的给串起来了</div><div class=\"line\">                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div class=\"line\">                            else</div><div class=\"line\">                                //这样就把相同串的给串起来了，注意这里ln用法，第一个next为null，烦着串起来了。</div><div class=\"line\">                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        setTabAt(nextTab, i, ln); //反着给串起来了</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    else if (f instanceof TreeBin) &#123;// 如果是红黑树</div><div class=\"line\">                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div class=\"line\">                        TreeNode&lt;K,V&gt; lo = null, loTail = null; //也是高低节点</div><div class=\"line\">                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;//也是高低节点</div><div class=\"line\">                        int lc = 0, hc = 0;</div><div class=\"line\">                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; //中序遍历红黑树</div><div class=\"line\">                            int h = e.hash;</div><div class=\"line\">                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div class=\"line\">                                (h, e.key, e.val, null, null);</div><div class=\"line\">                            if ((h &amp; n) == 0) &#123; //0的放低位</div><div class=\"line\">                                //注意这里p.prev = loTail，每一个p都是下一个的prev</div><div class=\"line\">                                if ((p.prev = loTail) == null)</div><div class=\"line\">                                    lo = p; //把头记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    loTail.next = p;  //上一次的p的next是这次的p</div><div class=\"line\">                                loTail = p; //把上次p给记住</div><div class=\"line\">                                ++lc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                            else &#123; //高位</div><div class=\"line\">                                if ((p.prev = hiTail) == null)</div><div class=\"line\">                                    hi = p; //把尾记住</div><div class=\"line\">                                else</div><div class=\"line\">                                    hiTail.next = p;</div><div class=\"line\">                                hiTail = p;</div><div class=\"line\">                                ++hc;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :// //判断是否需要转化为树</div><div class=\"line\">                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; //如果没有高低的话，则部分为两个树</div><div class=\"line\">                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div class=\"line\">                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div class=\"line\">                        setTabAt(nextTab, i, ln);</div><div class=\"line\">                        setTabAt(nextTab, i + n, hn);</div><div class=\"line\">                        setTabAt(tab, i, fwd);</div><div class=\"line\">                        advance = true;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中有两个变量需要了解下:<br>advance: 表示是否可以向下一个轮元素进行迁移。<br>finishing: table所有元素是否迁移完成。<br>大致做了如下事情:</p>\n<ul>\n<li>确定线程每轮迁移元素的个数stride, 比如进来一个线程, 确定扩容table下标为(a,b]之间元素, 下一个线程扩容(b,c]。这里对b-a或者c-b也是由最小值16限制的。 也就是说每个线程最少扩容连续16个table的元素。而标志当前迁移的下标保存在transferIndex里面。</li>\n<li>检查nextTab是否完成初始化, 若没有的话, 说明是第一个迁移的线程, 先初始化nextTab, size是之前table的2倍。</li>\n<li>进入while循环查找本轮迁移的table下标元素区间, 保存在(bound, i]中, 注意这里是半开半闭区间。</li>\n<li>从i -&gt; bound开始遍历table中每个元素, 这里是<code>从大到小</code>遍历的:</li>\n</ul>\n<ol>\n<li>若该元素为空, 则向该元素标写入ForwardingNode, 然后检查下一个元素。 当别的线程向这个元素插入数据时, 根据这个标志符知道了table正在被别的线程迁移, 在putVal中就会调用helpTransfer帮着迁移。</li>\n<li>若该元素的hash=MOVED, 代表次table正在处于迁移之中, 跳过。 按道理不会跑着这里的。</li>\n<li>否则说明该元素跟着的是一个链表或者是个红黑树结构, 若hash&gt;0, 则说明是个链表, 若f instanceof TreeBin, 则说明是个红黑树结构。</li>\n</ol>\n<ul>\n<li>链表迁移原理如下: <code>遍历链表每个节点。 若节点的f.hash&amp;n==0成立, 则将节点放在i, 否则, 则将节点放在n+i上面</code>。<br>迁移前, 对该元素进行加锁。 遍历链表时, 这里使用lastRun变量, 保留的是上次hash的值, 假如整个链表全部节点f.hash&amp;n==0, 那么第二次遍历, 只要找到lastRun的值, 那么认为之后的节点都是相同值, 减少了不必要的f.hash&amp;n取值。遍历完所有的节点后, 此时形成了两条链表, ln存放的是f.hash&amp;n=0的节点, hn存放的是非0的节点, 然后将ln存放在nextTable第i元素的位置, n+i存放在n+i的位置。<br>首先放一个张图展示扩容的变化:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap18.png\" height=\"450\" width=\"650\"><br>蓝色节点代表:f.hash&amp;n==0, 绿色节点代表f.hash&amp;n!=0。 最终蓝色的节点仍在存放在(0, n)范围里, 绿的的节点存放在(n, 2n-1)的范围之内。</li>\n<li>迁移链表和红黑树的原理是一样的, 在红黑树中, 我们记录了每个红黑树的first(这个节点不是hash最小的节点)和每个节点的next, 根据这两个元素, 我们可以访问红黑树所有的元素, 红黑树此时也是一个链表, 红黑树和链表迁移的过程一样。红黑树根据迁移后拆分成了hn和ln, 根据链表长度确定链表是红黑树结构还是退化为了链表。<br>4.如何确定table所有元素迁移完成:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//表示当前线程迁移完成了</div><div class=\"line\">if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123;</div><div class=\"line\">     //注意此时sc的值并不等于sizeCtl，上一步，sizeCtl=sizeCtl-1了。这两个对象还是分割的</div><div class=\"line\">    if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div class=\"line\">        return;</div><div class=\"line\">    finishing = advance = true;</div><div class=\"line\">    i = n; // recheck before commit</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第一个线程开始迁移时, 设置了sizeCtl= resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2, 此后每个新来帮助迁移的线程都会sizeCtl=sizeCtl+1, 完成迁移后,sizeCtl-1, 那么只要有一个线程还处于迁移状态, 那么sizeCtl&gt; resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT+2一直成立, 当只有最后一个线程完成迁移之后, 等式两边才成立。 可能大家会有疑问, 第一个线程并没有对sizeCtl=sizeCtl+1, 此时完成后再减一, 那不是不相等了吗, 注意这里, sizeCtl在减一前, 将值赋给了sc, 等式比较的是sc。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>table扩容过程就是将table元素迁移到新的table上, 在元素迁移时, 可以并发完成, 加快了迁移速度, 同时不至于阻塞线程。所有元素迁移完成后, 旧的table直接丢失, 直接使用新的table。</p>\n"},{"title":"ConcurrentHashMap红黑树原理介绍","date":"2017-11-06T09:48:34.000Z","toc":true,"_content":"为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。\n# 红黑树介绍\n一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:\n1）每个节点或者是黑的，或者是红的。\n2）根节点是黑的。\n3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n4）如果一个节点是红的，则它的两个儿子都是黑的。\n5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。\n红黑树示例如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"/>\n## 链表转化为红黑树\n```\n        TreeBin(TreeNode<K,V> b) {\n            super(TREEBIN, null, null, null);\n            this.first = b;\n            //设置前置节点\n            TreeNode<K,V> r = null;\n            for (TreeNode<K,V> x = b, next; x != null; x = next) {\n                next = (TreeNode<K,V>)x.next;\n                x.left = x.right = null;\n                //初始化节点\n                if (r == null) {\n                    x.parent = null;\n                    x.red = false;\n                    r = x;\n                }\n                else {\n                    K k = x.key;\n                    int h = x.hash;\n                    Class<?> kc = null;\n                    //从根节点开始找到合适的地方存放\n                    for (TreeNode<K,V> p = r;;) {\n                        int dir, ph;\n                        K pk = p.key;\n                        //左边\n                        if ((ph = p.hash) > h)\n                            dir = -1;\n                        //右边\n                        else if (ph < h)\n                            dir = 1;\n                        else if ((kc == null && //继续比较，类名接口名、hash值等方面来比较\n                                  (kc = comparableClassFor(k)) == null) ||\n                                 (dir = compareComparables(kc, k, pk)) == 0)\n                            dir = tieBreakOrder(k, pk);\n                            TreeNode<K,V> xp = p;\n                        if ((p = (dir <= 0) ? p.left : p.right) == null) { //判断是否找到头了，\n                            x.parent = xp;\n                            if (dir <= 0)\n                                xp.left = x;\n                            else\n                                xp.right = x;\n                            //开始调整\n                            r = balanceInsertion(r, x);\n                            break;\n                        }\n                    }\n                }\n            }\n            this.root = r;\n            assert checkInvariants(root);\n        }\n```\n主要做了如下事情:\n+ 初始化TreeBin节点, 设置其hash=TREEBIN(-2)\n+ 设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。\n+ 根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。\n## 红黑树插入后平衡balanceInsertion\n插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:\n```\n        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            x.red = true;//首先赋值头为red\n            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n                if ((xp = x.parent) == null) { //如果插入的是头结点\n                    x.red = false; //那么可以直接退出\n                    return x;\n                }\n                else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par\n                    //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）\n                    return root;\n                if (xp == (xppl = xpp.left)) { //父节点是左孩子\n                    if ((xppr = xpp.right) != null && xppr.red) { //叔叔节点是红色的\n                        xppr.red = false;\n                        xp.red = false;\n                        xpp.red = true;\n                        x = xpp; //x节点上移到祖父节点\n                    }\n                    else {\n                        //叔叔节点是黑色节点，x是右节点，那么移动到左边\n                        if (x == xp.right) {\n                            //x变成xp的位置，结构没变，只是x指向变了\n                            root = rotateLeft(root, x = xp);\n                            xpp = (xp = x.parent) == null ? null : xp.parent;\n                        }\n                        if (xp != null) { //叔叔是黑色节点，x是左节点\n                            xp.red = false;\n                            if (xpp != null) { //那么右旋就行了\n                                xpp.red = true;\n                                root = rotateRight(root, xpp);\n                            }\n                        }\n                    }\n                }\n                else {\n                   ...\n                }\n            }\n        }\n```\n首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:\ncase1. 叔叔C是红色的\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A\ncase2. 叔叔C是黑色的, 插入节点X是右孩子\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况\ncase3. 叔叔C是黑色的, 插入节点X是左孩子\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"/>\n调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。\n\n## 红黑树删除后平衡balanceInsertion\n红黑树删除分为两步:\n+ 二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是`该节点的中序遍历的后继节点`, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。\n+ 删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:\n```\n        //x点代表了一次删除的那个黑色\n        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            for (TreeNode<K,V> xp, xpl, xpr;;)  {\n                if (x == null || x == root)\n                    return root;\n                else if ((xp = x.parent) == null) {\n                    x.red = false;\n                    return x;\n                }\n                 //红色的，那么直接将红色变成黑色\n                else if (x.red) {\n                    x.red = false;\n                    return root;\n                }\n                //开始分两种情况，都是一样的， x是左兄弟\n                else if ((xpl = xp.left) == x) {\n                 //第一种情况：有兄弟是红色的，先将兄弟变成红色的\n                    if ((xpr = xp.right) != null && xpr.red) {\n                        xpr.red = false;\n                        xp.red = true;\n                        root = rotateLeft(root, xp);\n                        xpr = (xp = x.parent) == null ? null : xp.right;\n                    }\n                    if (xpr == null)//若有兄弟不存在，可以向上移动一个节点\n                        x = xp;\n                    else { //那么右兄弟为黑色的\n                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;\n                        if ((sr == null || !sr.red) &&\n                         //右兄弟的两个孩子若存在，那么是黑色的\n                            (sl == null || !sl.red)) {\n                            //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点\n                            xpr.red = true;\n                            x = xp;\n                        }\n                        else { //右兄弟为黑色\n                            //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色\n                            if (sr == null || !sr.red) {\n                                if (sl != null)//这里判断没有意义，一定是red\n                                    sl.red = false;\n                                xpr.red = true;\n                                root = rotateRight(root, xpr);//右旋\n                                xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针\n                                    null : xp.right;\n                            }\n                            //右兄弟为黑色，右兄弟的右孩子一定为red\n                            if (xpr != null) {\n                                xpr.red = (xp == null) ? false : xp.red;\n                                if ((sr = xpr.right) != null)\n                                    sr.red = false;\n                            }\n                            if (xp != null) {\n                                xp.red = false;\n                                root = rotateLeft(root, xp);\n                            }\n                            x = root;//那么旋转结束\n                        }\n                    }\n                }\n                else { // symmetric\n                   ...\n                }\n            }\n        }\n```\n若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.\n这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点\ncase1: 兄弟是红色的\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"/>\n调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色\ncase2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"/>\n调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。\ncase3: 兄弟是黑色的, 兄弟的左孩子是红色。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"/>\n调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。\ncase3: 兄弟是黑色的, 兄弟的右孩子是红色。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"/>\n调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。\n# 总结\n红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。","source":"_posts/ConcurrentHashMap红黑树原理介绍.md","raw":"---\ntitle: ConcurrentHashMap红黑树原理介绍\ndate: 2017-11-06 17:48:34\ntags:\ntoc: true\n---\n为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。\n# 红黑树介绍\n一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:\n1）每个节点或者是黑的，或者是红的。\n2）根节点是黑的。\n3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]\n4）如果一个节点是红的，则它的两个儿子都是黑的。\n5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。\n红黑树示例如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"/>\n## 链表转化为红黑树\n```\n        TreeBin(TreeNode<K,V> b) {\n            super(TREEBIN, null, null, null);\n            this.first = b;\n            //设置前置节点\n            TreeNode<K,V> r = null;\n            for (TreeNode<K,V> x = b, next; x != null; x = next) {\n                next = (TreeNode<K,V>)x.next;\n                x.left = x.right = null;\n                //初始化节点\n                if (r == null) {\n                    x.parent = null;\n                    x.red = false;\n                    r = x;\n                }\n                else {\n                    K k = x.key;\n                    int h = x.hash;\n                    Class<?> kc = null;\n                    //从根节点开始找到合适的地方存放\n                    for (TreeNode<K,V> p = r;;) {\n                        int dir, ph;\n                        K pk = p.key;\n                        //左边\n                        if ((ph = p.hash) > h)\n                            dir = -1;\n                        //右边\n                        else if (ph < h)\n                            dir = 1;\n                        else if ((kc == null && //继续比较，类名接口名、hash值等方面来比较\n                                  (kc = comparableClassFor(k)) == null) ||\n                                 (dir = compareComparables(kc, k, pk)) == 0)\n                            dir = tieBreakOrder(k, pk);\n                            TreeNode<K,V> xp = p;\n                        if ((p = (dir <= 0) ? p.left : p.right) == null) { //判断是否找到头了，\n                            x.parent = xp;\n                            if (dir <= 0)\n                                xp.left = x;\n                            else\n                                xp.right = x;\n                            //开始调整\n                            r = balanceInsertion(r, x);\n                            break;\n                        }\n                    }\n                }\n            }\n            this.root = r;\n            assert checkInvariants(root);\n        }\n```\n主要做了如下事情:\n+ 初始化TreeBin节点, 设置其hash=TREEBIN(-2)\n+ 设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。\n+ 根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。\n## 红黑树插入后平衡balanceInsertion\n插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:\n```\n        static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            x.red = true;//首先赋值头为red\n            for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {\n                if ((xp = x.parent) == null) { //如果插入的是头结点\n                    x.red = false; //那么可以直接退出\n                    return x;\n                }\n                else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par\n                    //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）\n                    return root;\n                if (xp == (xppl = xpp.left)) { //父节点是左孩子\n                    if ((xppr = xpp.right) != null && xppr.red) { //叔叔节点是红色的\n                        xppr.red = false;\n                        xp.red = false;\n                        xpp.red = true;\n                        x = xpp; //x节点上移到祖父节点\n                    }\n                    else {\n                        //叔叔节点是黑色节点，x是右节点，那么移动到左边\n                        if (x == xp.right) {\n                            //x变成xp的位置，结构没变，只是x指向变了\n                            root = rotateLeft(root, x = xp);\n                            xpp = (xp = x.parent) == null ? null : xp.parent;\n                        }\n                        if (xp != null) { //叔叔是黑色节点，x是左节点\n                            xp.red = false;\n                            if (xpp != null) { //那么右旋就行了\n                                xpp.red = true;\n                                root = rotateRight(root, xpp);\n                            }\n                        }\n                    }\n                }\n                else {\n                   ...\n                }\n            }\n        }\n```\n首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:\ncase1. 叔叔C是红色的\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A\ncase2. 叔叔C是黑色的, 插入节点X是右孩子\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"/>\n调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况\ncase3. 叔叔C是黑色的, 插入节点X是左孩子\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"/>\n调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。\n\n## 红黑树删除后平衡balanceInsertion\n红黑树删除分为两步:\n+ 二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是`该节点的中序遍历的后继节点`, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。\n+ 删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:\n```\n        //x点代表了一次删除的那个黑色\n        static <K,V> TreeNode<K,V> balanceDeletion(TreeNode<K,V> root, TreeNode<K,V> x) {\n            for (TreeNode<K,V> xp, xpl, xpr;;)  {\n                if (x == null || x == root)\n                    return root;\n                else if ((xp = x.parent) == null) {\n                    x.red = false;\n                    return x;\n                }\n                 //红色的，那么直接将红色变成黑色\n                else if (x.red) {\n                    x.red = false;\n                    return root;\n                }\n                //开始分两种情况，都是一样的， x是左兄弟\n                else if ((xpl = xp.left) == x) {\n                 //第一种情况：有兄弟是红色的，先将兄弟变成红色的\n                    if ((xpr = xp.right) != null && xpr.red) {\n                        xpr.red = false;\n                        xp.red = true;\n                        root = rotateLeft(root, xp);\n                        xpr = (xp = x.parent) == null ? null : xp.right;\n                    }\n                    if (xpr == null)//若有兄弟不存在，可以向上移动一个节点\n                        x = xp;\n                    else { //那么右兄弟为黑色的\n                        TreeNode<K,V> sl = xpr.left, sr = xpr.right;\n                        if ((sr == null || !sr.red) &&\n                         //右兄弟的两个孩子若存在，那么是黑色的\n                            (sl == null || !sl.red)) {\n                            //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点\n                            xpr.red = true;\n                            x = xp;\n                        }\n                        else { //右兄弟为黑色\n                            //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色\n                            if (sr == null || !sr.red) {\n                                if (sl != null)//这里判断没有意义，一定是red\n                                    sl.red = false;\n                                xpr.red = true;\n                                root = rotateRight(root, xpr);//右旋\n                                xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针\n                                    null : xp.right;\n                            }\n                            //右兄弟为黑色，右兄弟的右孩子一定为red\n                            if (xpr != null) {\n                                xpr.red = (xp == null) ? false : xp.red;\n                                if ((sr = xpr.right) != null)\n                                    sr.red = false;\n                            }\n                            if (xp != null) {\n                                xp.red = false;\n                                root = rotateLeft(root, xp);\n                            }\n                            x = root;//那么旋转结束\n                        }\n                    }\n                }\n                else { // symmetric\n                   ...\n                }\n            }\n        }\n```\n若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.\n这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点\ncase1: 兄弟是红色的\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"/>\n调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色\ncase2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"/>\n调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。\ncase3: 兄弟是黑色的, 兄弟的左孩子是红色。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"/>\n调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。\ncase3: 兄弟是黑色的, 兄弟的右孩子是红色。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"/>\n调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。\n# 总结\n红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。","slug":"ConcurrentHashMap红黑树原理介绍","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8vq0004phu5x7916u9k","content":"<p>为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。</p>\n<h1 id=\"红黑树介绍\"><a href=\"#红黑树介绍\" class=\"headerlink\" title=\"红黑树介绍\"></a>红黑树介绍</h1><p>一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:<br>1）每个节点或者是黑的，或者是红的。<br>2）根节点是黑的。<br>3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>4）如果一个节点是红的，则它的两个儿子都是黑的。<br>5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。<br>红黑树示例如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"></p>\n<h2 id=\"链表转化为红黑树\"><a href=\"#链表转化为红黑树\" class=\"headerlink\" title=\"链表转化为红黑树\"></a>链表转化为红黑树</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class=\"line\">    super(TREEBIN, null, null, null);</div><div class=\"line\">    this.first = b;</div><div class=\"line\">    //设置前置节点</div><div class=\"line\">    TreeNode&lt;K,V&gt; r = null;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</div><div class=\"line\">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class=\"line\">        x.left = x.right = null;</div><div class=\"line\">        //初始化节点</div><div class=\"line\">        if (r == null) &#123;</div><div class=\"line\">            x.parent = null;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            r = x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            K k = x.key;</div><div class=\"line\">            int h = x.hash;</div><div class=\"line\">            Class&lt;?&gt; kc = null;</div><div class=\"line\">            //从根节点开始找到合适的地方存放</div><div class=\"line\">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class=\"line\">                int dir, ph;</div><div class=\"line\">                K pk = p.key;</div><div class=\"line\">                //左边</div><div class=\"line\">                if ((ph = p.hash) &gt; h)</div><div class=\"line\">                    dir = -1;</div><div class=\"line\">                //右边</div><div class=\"line\">                else if (ph &lt; h)</div><div class=\"line\">                    dir = 1;</div><div class=\"line\">                else if ((kc == null &amp;&amp; //继续比较，类名接口名、hash值等方面来比较</div><div class=\"line\">                          (kc = comparableClassFor(k)) == null) ||</div><div class=\"line\">                         (dir = compareComparables(kc, k, pk)) == 0)</div><div class=\"line\">                    dir = tieBreakOrder(k, pk);</div><div class=\"line\">                    TreeNode&lt;K,V&gt; xp = p;</div><div class=\"line\">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; //判断是否找到头了，</div><div class=\"line\">                    x.parent = xp;</div><div class=\"line\">                    if (dir &lt;= 0)</div><div class=\"line\">                        xp.left = x;</div><div class=\"line\">                    else</div><div class=\"line\">                        xp.right = x;</div><div class=\"line\">                    //开始调整</div><div class=\"line\">                    r = balanceInsertion(r, x);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.root = r;</div><div class=\"line\">    assert checkInvariants(root);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要做了如下事情:</p>\n<ul>\n<li>初始化TreeBin节点, 设置其hash=TREEBIN(-2)</li>\n<li>设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。</li>\n<li>根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。<h2 id=\"红黑树插入后平衡balanceInsertion\"><a href=\"#红黑树插入后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树插入后平衡balanceInsertion\"></a>红黑树插入后平衡balanceInsertion</h2>插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    x.red = true;//首先赋值头为red</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class=\"line\">        if ((xp = x.parent) == null) &#123; //如果插入的是头结点</div><div class=\"line\">            x.red = false; //那么可以直接退出</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par</div><div class=\"line\">            //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）</div><div class=\"line\">            return root;</div><div class=\"line\">        if (xp == (xppl = xpp.left)) &#123; //父节点是左孩子</div><div class=\"line\">            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; //叔叔节点是红色的</div><div class=\"line\">                xppr.red = false;</div><div class=\"line\">                xp.red = false;</div><div class=\"line\">                xpp.red = true;</div><div class=\"line\">                x = xpp; //x节点上移到祖父节点</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                //叔叔节点是黑色节点，x是右节点，那么移动到左边</div><div class=\"line\">                if (x == xp.right) &#123;</div><div class=\"line\">                    //x变成xp的位置，结构没变，只是x指向变了</div><div class=\"line\">                    root = rotateLeft(root, x = xp);</div><div class=\"line\">                    xpp = (xp = x.parent) == null ? null : xp.parent;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (xp != null) &#123; //叔叔是黑色节点，x是左节点</div><div class=\"line\">                    xp.red = false;</div><div class=\"line\">                    if (xpp != null) &#123; //那么右旋就行了</div><div class=\"line\">                        xpp.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:<br>case1. 叔叔C是红色的<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"><br>调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A<br>case2. 叔叔C是黑色的, 插入节点X是右孩子<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"><br>调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况<br>case3. 叔叔C是黑色的, 插入节点X是左孩子<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"><br>调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。</p>\n<h2 id=\"红黑树删除后平衡balanceInsertion\"><a href=\"#红黑树删除后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树删除后平衡balanceInsertion\"></a>红黑树删除后平衡balanceInsertion</h2><p>红黑树删除分为两步:</p>\n<ul>\n<li>二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是<code>该节点的中序遍历的后继节点</code>, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。</li>\n<li>删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">//x点代表了一次删除的那个黑色</div><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</div><div class=\"line\">        if (x == null || x == root)</div><div class=\"line\">            return root;</div><div class=\"line\">        else if ((xp = x.parent) == null) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //红色的，那么直接将红色变成黑色</div><div class=\"line\">        else if (x.red) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return root;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //开始分两种情况，都是一样的， x是左兄弟</div><div class=\"line\">        else if ((xpl = xp.left) == x) &#123;</div><div class=\"line\">         //第一种情况：有兄弟是红色的，先将兄弟变成红色的</div><div class=\"line\">            if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</div><div class=\"line\">                xpr.red = false;</div><div class=\"line\">                xp.red = true;</div><div class=\"line\">                root = rotateLeft(root, xp);</div><div class=\"line\">                xpr = (xp = x.parent) == null ? null : xp.right;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (xpr == null)//若有兄弟不存在，可以向上移动一个节点</div><div class=\"line\">                x = xp;</div><div class=\"line\">            else &#123; //那么右兄弟为黑色的</div><div class=\"line\">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</div><div class=\"line\">                if ((sr == null || !sr.red) &amp;&amp;</div><div class=\"line\">                 //右兄弟的两个孩子若存在，那么是黑色的</div><div class=\"line\">                    (sl == null || !sl.red)) &#123;</div><div class=\"line\">                    //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点</div><div class=\"line\">                    xpr.red = true;</div><div class=\"line\">                    x = xp;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123; //右兄弟为黑色</div><div class=\"line\">                    //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色</div><div class=\"line\">                    if (sr == null || !sr.red) &#123;</div><div class=\"line\">                        if (sl != null)//这里判断没有意义，一定是red</div><div class=\"line\">                            sl.red = false;</div><div class=\"line\">                        xpr.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpr);//右旋</div><div class=\"line\">                        xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针</div><div class=\"line\">                            null : xp.right;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //右兄弟为黑色，右兄弟的右孩子一定为red</div><div class=\"line\">                    if (xpr != null) &#123;</div><div class=\"line\">                        xpr.red = (xp == null) ? false : xp.red;</div><div class=\"line\">                        if ((sr = xpr.right) != null)</div><div class=\"line\">                            sr.red = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (xp != null) &#123;</div><div class=\"line\">                        xp.red = false;</div><div class=\"line\">                        root = rotateLeft(root, xp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    x = root;//那么旋转结束</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123; // symmetric</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.<br>这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点<br>case1: 兄弟是红色的<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"><br>调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色<br>case2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"><br>调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。<br>case3: 兄弟是黑色的, 兄弟的左孩子是红色。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"><br>调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。<br>case3: 兄弟是黑色的, 兄弟的右孩子是红色。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"><br>调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>为了加快ConcurrentHashMap查找数据的速度, 若链表长度过长, 会将链表转化为红黑树, 本文主要讲解相关知识。</p>\n<h1 id=\"红黑树介绍\"><a href=\"#红黑树介绍\" class=\"headerlink\" title=\"红黑树介绍\"></a>红黑树介绍</h1><p>一棵二叉查找树如果满足下面的红黑性质, 则为一棵红黑树:<br>1）每个节点或者是黑的，或者是红的。<br>2）根节点是黑的。<br>3）每个叶子节点（NIL）是黑的。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]<br>4）如果一个节点是红的，则它的两个儿子都是黑的。<br>5）对每个节点, 从该节点到其子孙节点的所有路径上包含相同数目的黑节点。<br>红黑树示例如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap3.png\" height=\"300\" width=\"350\"></p>\n<h2 id=\"链表转化为红黑树\"><a href=\"#链表转化为红黑树\" class=\"headerlink\" title=\"链表转化为红黑树\"></a>链表转化为红黑树</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">TreeBin(TreeNode&lt;K,V&gt; b) &#123;</div><div class=\"line\">    super(TREEBIN, null, null, null);</div><div class=\"line\">    this.first = b;</div><div class=\"line\">    //设置前置节点</div><div class=\"line\">    TreeNode&lt;K,V&gt; r = null;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; x = b, next; x != null; x = next) &#123;</div><div class=\"line\">        next = (TreeNode&lt;K,V&gt;)x.next;</div><div class=\"line\">        x.left = x.right = null;</div><div class=\"line\">        //初始化节点</div><div class=\"line\">        if (r == null) &#123;</div><div class=\"line\">            x.parent = null;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            r = x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">            K k = x.key;</div><div class=\"line\">            int h = x.hash;</div><div class=\"line\">            Class&lt;?&gt; kc = null;</div><div class=\"line\">            //从根节点开始找到合适的地方存放</div><div class=\"line\">            for (TreeNode&lt;K,V&gt; p = r;;) &#123;</div><div class=\"line\">                int dir, ph;</div><div class=\"line\">                K pk = p.key;</div><div class=\"line\">                //左边</div><div class=\"line\">                if ((ph = p.hash) &gt; h)</div><div class=\"line\">                    dir = -1;</div><div class=\"line\">                //右边</div><div class=\"line\">                else if (ph &lt; h)</div><div class=\"line\">                    dir = 1;</div><div class=\"line\">                else if ((kc == null &amp;&amp; //继续比较，类名接口名、hash值等方面来比较</div><div class=\"line\">                          (kc = comparableClassFor(k)) == null) ||</div><div class=\"line\">                         (dir = compareComparables(kc, k, pk)) == 0)</div><div class=\"line\">                    dir = tieBreakOrder(k, pk);</div><div class=\"line\">                    TreeNode&lt;K,V&gt; xp = p;</div><div class=\"line\">                if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; //判断是否找到头了，</div><div class=\"line\">                    x.parent = xp;</div><div class=\"line\">                    if (dir &lt;= 0)</div><div class=\"line\">                        xp.left = x;</div><div class=\"line\">                    else</div><div class=\"line\">                        xp.right = x;</div><div class=\"line\">                    //开始调整</div><div class=\"line\">                    r = balanceInsertion(r, x);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    this.root = r;</div><div class=\"line\">    assert checkInvariants(root);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要做了如下事情:</p>\n<ul>\n<li>初始化TreeBin节点, 设置其hash=TREEBIN(-2)</li>\n<li>设置first结点, 这个节点就是链表的头, 根据这个头, 可以遍历整个红黑树。</li>\n<li>根据first开始遍历红黑树, 针对每个节点hash值, 插入红黑树中合适的位置, 然后调整该二叉树以满足红黑色的要求(balanceInsertion)。<h2 id=\"红黑树插入后平衡balanceInsertion\"><a href=\"#红黑树插入后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树插入后平衡balanceInsertion\"></a>红黑树插入后平衡balanceInsertion</h2>插入的节点为红色, 而可能导致红黑树出现红色的节点子节点还是红色, 违反4)条, 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceInsertion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    x.red = true;//首先赋值头为red</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class=\"line\">        if ((xp = x.parent) == null) &#123; //如果插入的是头结点</div><div class=\"line\">            x.red = false; //那么可以直接退出</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else if (!xp.red || (xpp = xp.parent) == null) //xp是插入的x的par</div><div class=\"line\">            //只有两层，x是红色不改变黑节点高度，只有par是red才需要调整（两个red不能相连）</div><div class=\"line\">            return root;</div><div class=\"line\">        if (xp == (xppl = xpp.left)) &#123; //父节点是左孩子</div><div class=\"line\">            if ((xppr = xpp.right) != null &amp;&amp; xppr.red) &#123; //叔叔节点是红色的</div><div class=\"line\">                xppr.red = false;</div><div class=\"line\">                xp.red = false;</div><div class=\"line\">                xpp.red = true;</div><div class=\"line\">                x = xpp; //x节点上移到祖父节点</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                //叔叔节点是黑色节点，x是右节点，那么移动到左边</div><div class=\"line\">                if (x == xp.right) &#123;</div><div class=\"line\">                    //x变成xp的位置，结构没变，只是x指向变了</div><div class=\"line\">                    root = rotateLeft(root, x = xp);</div><div class=\"line\">                    xpp = (xp = x.parent) == null ? null : xp.parent;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (xp != null) &#123; //叔叔是黑色节点，x是左节点</div><div class=\"line\">                    xp.red = false;</div><div class=\"line\">                    if (xpp != null) &#123; //那么右旋就行了</div><div class=\"line\">                        xpp.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123;</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先设置插入的节点为红色, 若插入节点的父节点是黑色的,那么没有打破红黑树的原则, 可以不用调整直接退出, 当且仅当父节点是红色时候才需要调整, 这里主要讨论插入节点的父节点是祖父节点左孩子(又孩子一样)的情况, 分三种情况进行调整:<br>case1. 叔叔C是红色的<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap5.png\" height=\"250\" width=\"400\"><br>调整: 父节点B与叔叔节点C变黑, 祖父节点A变红, 调整节点上移到祖父节点A<br>case2. 叔叔C是黑色的, 插入节点X是右孩子<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap6.png\" height=\"250\" width=\"400\"><br>调整: 父节点B右旋, 将调整节点指向曾经的自己D, 变成case3的情况<br>case3. 叔叔C是黑色的, 插入节点X是左孩子<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap7.png\" height=\"250\" width=\"400\"><br>调整: 祖父节点A右旋, 父节点B变黑, 祖父节A点变红, 调整完成, 退出函数。</p>\n<h2 id=\"红黑树删除后平衡balanceInsertion\"><a href=\"#红黑树删除后平衡balanceInsertion\" class=\"headerlink\" title=\"红黑树删除后平衡balanceInsertion\"></a>红黑树删除后平衡balanceInsertion</h2><p>红黑树删除分为两步:</p>\n<ul>\n<li>二叉树正常删除数据。红黑树在删除节点时, 若该节点做孩子或者右孩子最多只存在一个, 那么删除的就是本身节点; 若左右孩子同时存在, 那么结构上实际删除的节点将是<code>该节点的中序遍历的后继节点</code>, 然后再将实际删除的那个节点数据来置换理论上被删除的那个节点的数据, 所以:实际被删除的那个节点两个孩子不可能同时存在。</li>\n<li>删除节点后的调整。 删除后, 若删除的是黑色节点, 导致从该节点到其子孙节点的所有路径上包含相同不同数目的黑节点, 将违反第5)条。 以下是调整过程:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">//x点代表了一次删除的那个黑色</div><div class=\"line\">static &lt;K,V&gt; TreeNode&lt;K,V&gt; balanceDeletion(TreeNode&lt;K,V&gt; root, TreeNode&lt;K,V&gt; x) &#123;</div><div class=\"line\">    for (TreeNode&lt;K,V&gt; xp, xpl, xpr;;)  &#123;</div><div class=\"line\">        if (x == null || x == root)</div><div class=\"line\">            return root;</div><div class=\"line\">        else if ((xp = x.parent) == null) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return x;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //红色的，那么直接将红色变成黑色</div><div class=\"line\">        else if (x.red) &#123;</div><div class=\"line\">            x.red = false;</div><div class=\"line\">            return root;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //开始分两种情况，都是一样的， x是左兄弟</div><div class=\"line\">        else if ((xpl = xp.left) == x) &#123;</div><div class=\"line\">         //第一种情况：有兄弟是红色的，先将兄弟变成红色的</div><div class=\"line\">            if ((xpr = xp.right) != null &amp;&amp; xpr.red) &#123;</div><div class=\"line\">                xpr.red = false;</div><div class=\"line\">                xp.red = true;</div><div class=\"line\">                root = rotateLeft(root, xp);</div><div class=\"line\">                xpr = (xp = x.parent) == null ? null : xp.right;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (xpr == null)//若有兄弟不存在，可以向上移动一个节点</div><div class=\"line\">                x = xp;</div><div class=\"line\">            else &#123; //那么右兄弟为黑色的</div><div class=\"line\">                TreeNode&lt;K,V&gt; sl = xpr.left, sr = xpr.right;</div><div class=\"line\">                if ((sr == null || !sr.red) &amp;&amp;</div><div class=\"line\">                 //右兄弟的两个孩子若存在，那么是黑色的</div><div class=\"line\">                    (sl == null || !sl.red)) &#123;</div><div class=\"line\">                    //右兄弟将提取一个黑色，和本节点一起组成一个复黑色给父亲节点</div><div class=\"line\">                    xpr.red = true;</div><div class=\"line\">                    x = xp;</div><div class=\"line\">                &#125;</div><div class=\"line\">                else &#123; //右兄弟为黑色</div><div class=\"line\">                    //并且右兄弟的右孩子为若存在，是黑色。反过来说，左孩子一定存在，并且为红色</div><div class=\"line\">                    if (sr == null || !sr.red) &#123;</div><div class=\"line\">                        if (sl != null)//这里判断没有意义，一定是red</div><div class=\"line\">                            sl.red = false;</div><div class=\"line\">                        xpr.red = true;</div><div class=\"line\">                        root = rotateRight(root, xpr);//右旋</div><div class=\"line\">                        xpr = (xp = x.parent) == null ? //更新指向xpr和xp的指针</div><div class=\"line\">                            null : xp.right;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    //右兄弟为黑色，右兄弟的右孩子一定为red</div><div class=\"line\">                    if (xpr != null) &#123;</div><div class=\"line\">                        xpr.red = (xp == null) ? false : xp.red;</div><div class=\"line\">                        if ((sr = xpr.right) != null)</div><div class=\"line\">                            sr.red = false;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (xp != null) &#123;</div><div class=\"line\">                        xp.red = false;</div><div class=\"line\">                        root = rotateLeft(root, xp);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    x = root;//那么旋转结束</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        else &#123; // symmetric</div><div class=\"line\">           ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>若删除了红节点, 那么对二叉树没有任何影响, 调整的都是删除节点是黑色的情况; 若删除节点的父节点是红色的,直接变成黑的就over, 这里仅仅讨论删除节点的父节点是左孩子(右孩子类似)的情况.<br>这里的x需要看成双重黑色, 平衡的目的是将这个双重黑色分摊到别的节点, 变成单黑色, 调整节点迁移到父节点<br>case1: 兄弟是红色的<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap12.png\" height=\"350\" width=\"400\"><br>调整: 情况1: 若无右兄弟, 则将调整节点上移到父节点A; 若有右兄弟C, 对父节点A左旋, 父节点A变成红色, 兄弟节点C变成黑色<br>case2: 兄弟是黑色的, 兄弟的两个孩子(存在2个、1个、或者0个)没有一个是红色的<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap13.png\" height=\"250\" width=\"400\"><br>调整: 将兄弟节点C变成红色, 调整节点上移到父节点C。<br>case3: 兄弟是黑色的, 兄弟的左孩子是红色。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap14.png\" height=\"250\" width=\"400\"><br>调整: 右旋兄弟节点C, 兄弟节点左孩子变成黑色, 兄弟节点C变成红色, 变成case4。<br>case3: 兄弟是黑色的, 兄弟的右孩子是红色。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ConcurrentHashMap15.png\" height=\"250\" width=\"400\"><br>调整: 左旋父节点A, 将父节点A的颜色给兄弟节点, 父节点A变成黑色, 调整完成, 退出函数。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>红黑树重点是定义, 每次插入节点或者删除节点都会破坏红黑树的性能, 然后再通过调整修复这些性质就好了。</p>\n"},{"title":"Condition接口原理介绍及ArrayBlockingQueue、LinkedBlockingQueue实现","date":"2017-10-02T11:28:01.000Z","toc":true,"_content":"任何一个java对象都拥有wait()/nitify方法, 它们通过与synchronized结合(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结(-)</a>)来实现线程之间的通信机制。 在锁方面Lock与Condition接口配合也实现了相同的功能, 但是它们之间的原理是不相同的。使用上两者的区别如下(图片摘自<a href=\"https://www.jianshu.com/p/be2dc7c878dc\">java并发编程之Condition</a>)):\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition1.png\" height=\"400\" width=\"500\"/>\n# 基本使用\n我们将以最简单的消费者与生产者的示例讲解Condition与Lock配合使用的例子:\n```\npublic class ConditonTest {\n    //当前产品个数\n    public static int count = 0;\n    static ReentrantLock reentrantLock = new ReentrantLock();\n    //产品为空时, 那么消费者就得生产者来唤醒, 消费者就得等待生产者生产商品这个条件\n    static  Condition empty = reentrantLock.newCondition();\n    public static void main(String[] args) {\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        Thread t3 = new Consumer(\"A\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t1 = new Producder(\"B\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t2 = new Producder(\"C\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t4 = new Consumer(\"D\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t5 = new Consumer(\"E\", ConditonTest.reentrantLock, ConditonTest.empty);\n        // 执行各个线程\n        pool.execute(t1);\n        pool.execute(t2);\n        pool.execute(t3);\n        pool.execute(t4);\n        pool.execute(t5);\n        pool.shutdown();\n    }\n}\nclass Producder extends Thread {\n    private String name;\n    Lock lock;\n    Condition empty;\n    public Producder(String name, Lock lock, Condition empty) {\n        this.name = name;\n        this.lock = lock;\n        this.empty = empty;\n    }\n    public void run() {\n        lock.lock(); // 获取锁\n        ConditonTest.count ++;\n        System.out.println(name + \"产生一个\");\n        empty.signalAll(); // 唤醒所有等待线程。\n        lock.unlock(); // 释放锁\n    }\n}\nclass Consumer extends Thread {\n    private String name;\n    Lock lock;\n    Condition empty;\n    public Consumer(String name, Lock lock, Condition empty) {\n        this.name = name;\n        this.lock = lock;\n        this.empty = empty;\n    }\n    public void run() {\n        lock.lock(); // 获取锁\n        try {\n            while ( ConditonTest.count == 0) {\n                System.out.println(name + \"阻塞中\");\n                // 阻塞取款操作, await之后就隐示自动释放了lock，直到被唤醒自动获取\n                empty.await();\n                System.out.println(name + \"被唤醒\");\n            }\n            ConditonTest.count --;\n            System.out.println(name + \"消费一个\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n}\n```\n以上只是使用一个Condition条件队列(具体真实应用可参考ArrayBlockingQueue、LinkedBlockingQueue), 在实际应用中, 可以使用多个条件ConditionObject, ConditionObject都是通过调用reentrantLock.newCondition()中产生的, 该类在AbstractQueuedSynchronizer中定义。 条件队列结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition2.png\" height=\"250\" width=\"450\"/>\n每当线程调用Condition.wait()时, 该线程将会通过尾插发放入该条件队列; 当别的线程调用Condition.signal()时, 该线程将从等待队列转移到AQS阻塞队列(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 使用比较简单。\n注意阻塞队列和条件队列结构的区别:\n+ 阻塞队列拥有head, head不存放任何线程; 由tail指定结尾; 条件队列首尾由firstWaiter,lastWaiter指定, 第一个线程即为firstWaiter。\n+ 阻塞队列由next, pre连接; 条件队列由nextWaiter连接\n\n# wait()\nwait主要是将该线程存放在Condition队列等待被唤醒。empty.await()实际调用的AbstractQueuedSynchronizer中的wait函数:\n```\n   public final void await() throws InterruptedException {\n        //检查当前中断标志位, 若之前有中断, 那么直接向外抛出异常\n       if (Thread.interrupted())\n           throw new InterruptedException();\n       //将该线程添加到CONDITION队列中\n       Node node = addConditionWaiter();\n       //在该节点加入condition队列中等待前，await则需要释放掉当前线程占有的锁\n       int savedState = fullyRelease(node);\n       int interruptMode = 0;  //\n       //检查该线程是否在阻塞队列中。线程首先加入条件队列，若有signal发生，会被signal转移到阻塞队列中\n       while (!isOnSyncQueue(node)) {\n          //已经加入条件队列, 开始进行睡眠\n          LockSupport.park(this);\n          //被唤醒了, 可能是别的线程调用了signal; 也可能是别的线程调用了中断。线程可能在条件队列, 也可能在阻塞队列\n          if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n               break;\n           //等于0说明是被signal唤醒的，将在下次while时直接退出循环\n       }\n       //此时在阻塞队列中了\n       if (acquireQueued(node, savedState) && interruptMode != THROW_IE) //从阻塞队列中唤醒了\n           interruptMode = REINTERRUPT;\n       if (node.nextWaiter != null) // clean up if cancelled\n           unlinkCancelledWaiters();\n       if (interruptMode != 0)\n           reportInterruptAfterWait(interruptMode); //\n   }\n```\n主要做了如下事情:\n+ 检查线程中断位, 若该线程存在中断信号则抛出异常\n+ 将该线程加入条件队列, waitStatus置为Node.CONDITION, 见addConditionWaiter\n+ 释放被占用的锁, 释放的savedState的值说明下次还需要获取的值。见fullyRelease\n+ 检查线程是否阻塞队列, 见isOnSyncQueue。 若不在阻塞队列的话, 若在条件队列, 则开始调用LockSupport.park(this)睡眠。 若醒过来了存在两种可能: 别的线程调用了中断; 别的线程调用了signal, 需要继续判断是哪种情况, 见checkInterruptWhileWaiting。\n+ 从while退出, 说明已经在阻塞队列了, 进入acquireQueued(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)等待被别的线程释放锁来唤醒\n+ 清理条件队列中剩余线程, 若线程的node状态不为Node.CONDITION, 将从该队列中清理掉, 见unlinkCancelledWaiters函数。\n+ 检查中断信息, 若存在中断, 中断是在调用signal前的话, 说明唤醒原因是因为中断, 那么线程直接向上抛出异常; 若中断是在调用signal之后的话, 那么唤醒原因是因为signal。将中断复位给线程。见reportInterruptAfterWait()\n以下代码判断线程是否在阻塞队列中:isOnSyncQueue:\n```\n    final boolean isOnSyncQueue(Node node) {\n         //只有在等待队列,waitStatus才会等于CONDITION; node.prev !=null,不代表一定是在阻塞队列中, 也可能在迁移的路上\n        if (node.waitStatus == Node.CONDITION || node.prev == null)\n            return false;\n         #若设置了, 肯定是在阻塞队列中。那就说明条件队列的next一定为null\n        if (node.next != null) // If has successor, it must be on queue，\n            return true;\n        /*\n         * node.prev can be non-null, but not yet on queue because\n         * the CAS to place it on queue can fail. So we have to\n         * traverse from tail to make sure it actually made it.  It\n         * will always be near the tail in calls to this method, and\n         * unless the CAS failed (which is unlikely), it will be\n         * there, so we hardly ever traverse much.\n         */\n        return findNodeFromTail(node);  //同归对别在阻塞队列中彻头彻尾找这个节点\n    }\n```\n而checkInterruptWhileWaiting主要是为了检查线程从LockSupport.park(this)只醒来的原因:\n```\nprivate int checkInterruptWhileWaiting(Node node) {\n            return Thread.interrupted() ?\n                  //至少线程是被中断过\n                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :\n                0;  //返回0说明一定是被signasl唤醒的\n        }\n```\n这里判断, 若不存在中断信号的话, 那么线程一定是被别的线程调用signal唤醒的, 那么进入transferAfterCancelledWait判断线程中断发生的是时间\n```\n final boolean transferAfterCancelledWait(Node node) {\n         //线程被signal唤醒，只会是Node.SIGNAL，而不是Node.CONDITION\n        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\n            enq(node);//说明是被interput的\n            return true;\n        }\n        /*  此后说明是被signal唤醒的，\n         * If we lost out to a signal(), then we can't proceed  //若果我们从\n         * until it finishes its enq().  Cancelling during an\n         * incomplete transfer is both rare and transient, so just\n         * spin.\n         */\n         //等待调用singla的线程将本节点加入阻塞队列，该线程等待这个操作完成, 若还没有完成的话, 就等待\n        while (!isOnSyncQueue(node))\n            Thread.yield();  //偶尔释放下cpu，线程从运行到就绪状态\n        //说明是被singla唤醒的，同时已经被其他的线程加入了阻塞队列\n        return false;\n    }\n```\n总结一下, 此时线程被唤醒了:\n+ 不存在中断信号, 说明若线程被signal唤醒的, 那么返回0\n+ 存在中断信号, 而线程的statue为Node.CONDITION, 那么说明线程是被中断唤醒的, 之后将会向外抛出InterruptedException异常。\n+ 存在中断信号, 而线程的statue不为Node.CONDITION, 那么说明该中断信号是在线程被signal唤醒之后才出现的, 那么就不会抛向外抛出异常, 而是将中断信号再置位给线程。\n\n# signal()\n再来了解下signal是如何将唤醒线程的\n```\nprivate void doSignal(Node first) {\n\n            do {\n                if ( (firstWaiter = first.nextWaiter) == null)\n                    lastWaiter = null;\n                first.nextWaiter = null;\n            } while (!transferForSignal(first) && //这里while是\n                     (first = firstWaiter) != null);\n        }\n```\n通过不停地循环, 只是希望从条件队列中找到一个status=CONDITION的节点, 并将该节点移动到阻塞队列中。移动的过程如下:\n```\n  final boolean transferForSignal(Node node) {\n        /*\n         * If cannot change waitStatus, the node has been cancelled.\n         */\n         //如果不是CONDITION， 则返回再看条件队列中下一个元素\n        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n            return false;\n\n        /*\n         * Splice onto queue and try to set waitStatus of predecessor to\n         * indicate that thread is (probably) waiting. If cancelled or\n         * attempt to set waitStatus fails, wake up to resync (in which\n         * case the waitStatus can be transiently and harmlessly wrong).\n         */\n         //将该元素从条件队列移动到等待队列\n        Node p = enq(node);\n         //waitStatus>0的话，只能是cancel, 或者设置signal失败，那么唤醒该线程\n        int ws = p.waitStatus;\n         //若设置signal成功的话，wait函数那里的循环可能没有感觉到; 若没有感觉到会对调用yield减缓循环次数\n        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n            //目前线程已经处于阻塞队列, 唤醒该线程, 尝试再获取锁\n            LockSupport.unpark(node.thread);\n        return true;\n    }\n```\n我们现在回顾下, Condition的wait和signal整体逻辑如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition3.png\" height=\"270\" width=\"600\"/>\n# 总结\nCondition的wait和signal必须和锁配合使用, 以上只是结合ReentrantLock使用。ArrayBlockingQueue的实现原理与开头的示例类似, 基于ReentrantLock及Condition实现, Condition也可以与其他AQS结合, 比如CountDownLatch、ReentrantReadWriteLock, Semaphore, 使用大同小异, 这里就不一一讲解了。\n\n","source":"_posts/Condition原理解读.md","raw":"---\ntitle: Condition接口原理介绍及ArrayBlockingQueue、LinkedBlockingQueue实现\ndate: 2017-10-02 19:28:01\ntags:\ntoc: true\n---\n任何一个java对象都拥有wait()/nitify方法, 它们通过与synchronized结合(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结(-)</a>)来实现线程之间的通信机制。 在锁方面Lock与Condition接口配合也实现了相同的功能, 但是它们之间的原理是不相同的。使用上两者的区别如下(图片摘自<a href=\"https://www.jianshu.com/p/be2dc7c878dc\">java并发编程之Condition</a>)):\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition1.png\" height=\"400\" width=\"500\"/>\n# 基本使用\n我们将以最简单的消费者与生产者的示例讲解Condition与Lock配合使用的例子:\n```\npublic class ConditonTest {\n    //当前产品个数\n    public static int count = 0;\n    static ReentrantLock reentrantLock = new ReentrantLock();\n    //产品为空时, 那么消费者就得生产者来唤醒, 消费者就得等待生产者生产商品这个条件\n    static  Condition empty = reentrantLock.newCondition();\n    public static void main(String[] args) {\n        ExecutorService pool = Executors.newFixedThreadPool(2);\n        Thread t3 = new Consumer(\"A\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t1 = new Producder(\"B\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t2 = new Producder(\"C\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t4 = new Consumer(\"D\", ConditonTest.reentrantLock, ConditonTest.empty);\n        Thread t5 = new Consumer(\"E\", ConditonTest.reentrantLock, ConditonTest.empty);\n        // 执行各个线程\n        pool.execute(t1);\n        pool.execute(t2);\n        pool.execute(t3);\n        pool.execute(t4);\n        pool.execute(t5);\n        pool.shutdown();\n    }\n}\nclass Producder extends Thread {\n    private String name;\n    Lock lock;\n    Condition empty;\n    public Producder(String name, Lock lock, Condition empty) {\n        this.name = name;\n        this.lock = lock;\n        this.empty = empty;\n    }\n    public void run() {\n        lock.lock(); // 获取锁\n        ConditonTest.count ++;\n        System.out.println(name + \"产生一个\");\n        empty.signalAll(); // 唤醒所有等待线程。\n        lock.unlock(); // 释放锁\n    }\n}\nclass Consumer extends Thread {\n    private String name;\n    Lock lock;\n    Condition empty;\n    public Consumer(String name, Lock lock, Condition empty) {\n        this.name = name;\n        this.lock = lock;\n        this.empty = empty;\n    }\n    public void run() {\n        lock.lock(); // 获取锁\n        try {\n            while ( ConditonTest.count == 0) {\n                System.out.println(name + \"阻塞中\");\n                // 阻塞取款操作, await之后就隐示自动释放了lock，直到被唤醒自动获取\n                empty.await();\n                System.out.println(name + \"被唤醒\");\n            }\n            ConditonTest.count --;\n            System.out.println(name + \"消费一个\");\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            lock.unlock(); // 释放锁\n        }\n    }\n}\n```\n以上只是使用一个Condition条件队列(具体真实应用可参考ArrayBlockingQueue、LinkedBlockingQueue), 在实际应用中, 可以使用多个条件ConditionObject, ConditionObject都是通过调用reentrantLock.newCondition()中产生的, 该类在AbstractQueuedSynchronizer中定义。 条件队列结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition2.png\" height=\"250\" width=\"450\"/>\n每当线程调用Condition.wait()时, 该线程将会通过尾插发放入该条件队列; 当别的线程调用Condition.signal()时, 该线程将从等待队列转移到AQS阻塞队列(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 使用比较简单。\n注意阻塞队列和条件队列结构的区别:\n+ 阻塞队列拥有head, head不存放任何线程; 由tail指定结尾; 条件队列首尾由firstWaiter,lastWaiter指定, 第一个线程即为firstWaiter。\n+ 阻塞队列由next, pre连接; 条件队列由nextWaiter连接\n\n# wait()\nwait主要是将该线程存放在Condition队列等待被唤醒。empty.await()实际调用的AbstractQueuedSynchronizer中的wait函数:\n```\n   public final void await() throws InterruptedException {\n        //检查当前中断标志位, 若之前有中断, 那么直接向外抛出异常\n       if (Thread.interrupted())\n           throw new InterruptedException();\n       //将该线程添加到CONDITION队列中\n       Node node = addConditionWaiter();\n       //在该节点加入condition队列中等待前，await则需要释放掉当前线程占有的锁\n       int savedState = fullyRelease(node);\n       int interruptMode = 0;  //\n       //检查该线程是否在阻塞队列中。线程首先加入条件队列，若有signal发生，会被signal转移到阻塞队列中\n       while (!isOnSyncQueue(node)) {\n          //已经加入条件队列, 开始进行睡眠\n          LockSupport.park(this);\n          //被唤醒了, 可能是别的线程调用了signal; 也可能是别的线程调用了中断。线程可能在条件队列, 也可能在阻塞队列\n          if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)\n               break;\n           //等于0说明是被signal唤醒的，将在下次while时直接退出循环\n       }\n       //此时在阻塞队列中了\n       if (acquireQueued(node, savedState) && interruptMode != THROW_IE) //从阻塞队列中唤醒了\n           interruptMode = REINTERRUPT;\n       if (node.nextWaiter != null) // clean up if cancelled\n           unlinkCancelledWaiters();\n       if (interruptMode != 0)\n           reportInterruptAfterWait(interruptMode); //\n   }\n```\n主要做了如下事情:\n+ 检查线程中断位, 若该线程存在中断信号则抛出异常\n+ 将该线程加入条件队列, waitStatus置为Node.CONDITION, 见addConditionWaiter\n+ 释放被占用的锁, 释放的savedState的值说明下次还需要获取的值。见fullyRelease\n+ 检查线程是否阻塞队列, 见isOnSyncQueue。 若不在阻塞队列的话, 若在条件队列, 则开始调用LockSupport.park(this)睡眠。 若醒过来了存在两种可能: 别的线程调用了中断; 别的线程调用了signal, 需要继续判断是哪种情况, 见checkInterruptWhileWaiting。\n+ 从while退出, 说明已经在阻塞队列了, 进入acquireQueued(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)等待被别的线程释放锁来唤醒\n+ 清理条件队列中剩余线程, 若线程的node状态不为Node.CONDITION, 将从该队列中清理掉, 见unlinkCancelledWaiters函数。\n+ 检查中断信息, 若存在中断, 中断是在调用signal前的话, 说明唤醒原因是因为中断, 那么线程直接向上抛出异常; 若中断是在调用signal之后的话, 那么唤醒原因是因为signal。将中断复位给线程。见reportInterruptAfterWait()\n以下代码判断线程是否在阻塞队列中:isOnSyncQueue:\n```\n    final boolean isOnSyncQueue(Node node) {\n         //只有在等待队列,waitStatus才会等于CONDITION; node.prev !=null,不代表一定是在阻塞队列中, 也可能在迁移的路上\n        if (node.waitStatus == Node.CONDITION || node.prev == null)\n            return false;\n         #若设置了, 肯定是在阻塞队列中。那就说明条件队列的next一定为null\n        if (node.next != null) // If has successor, it must be on queue，\n            return true;\n        /*\n         * node.prev can be non-null, but not yet on queue because\n         * the CAS to place it on queue can fail. So we have to\n         * traverse from tail to make sure it actually made it.  It\n         * will always be near the tail in calls to this method, and\n         * unless the CAS failed (which is unlikely), it will be\n         * there, so we hardly ever traverse much.\n         */\n        return findNodeFromTail(node);  //同归对别在阻塞队列中彻头彻尾找这个节点\n    }\n```\n而checkInterruptWhileWaiting主要是为了检查线程从LockSupport.park(this)只醒来的原因:\n```\nprivate int checkInterruptWhileWaiting(Node node) {\n            return Thread.interrupted() ?\n                  //至少线程是被中断过\n                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :\n                0;  //返回0说明一定是被signasl唤醒的\n        }\n```\n这里判断, 若不存在中断信号的话, 那么线程一定是被别的线程调用signal唤醒的, 那么进入transferAfterCancelledWait判断线程中断发生的是时间\n```\n final boolean transferAfterCancelledWait(Node node) {\n         //线程被signal唤醒，只会是Node.SIGNAL，而不是Node.CONDITION\n        if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) {\n            enq(node);//说明是被interput的\n            return true;\n        }\n        /*  此后说明是被signal唤醒的，\n         * If we lost out to a signal(), then we can't proceed  //若果我们从\n         * until it finishes its enq().  Cancelling during an\n         * incomplete transfer is both rare and transient, so just\n         * spin.\n         */\n         //等待调用singla的线程将本节点加入阻塞队列，该线程等待这个操作完成, 若还没有完成的话, 就等待\n        while (!isOnSyncQueue(node))\n            Thread.yield();  //偶尔释放下cpu，线程从运行到就绪状态\n        //说明是被singla唤醒的，同时已经被其他的线程加入了阻塞队列\n        return false;\n    }\n```\n总结一下, 此时线程被唤醒了:\n+ 不存在中断信号, 说明若线程被signal唤醒的, 那么返回0\n+ 存在中断信号, 而线程的statue为Node.CONDITION, 那么说明线程是被中断唤醒的, 之后将会向外抛出InterruptedException异常。\n+ 存在中断信号, 而线程的statue不为Node.CONDITION, 那么说明该中断信号是在线程被signal唤醒之后才出现的, 那么就不会抛向外抛出异常, 而是将中断信号再置位给线程。\n\n# signal()\n再来了解下signal是如何将唤醒线程的\n```\nprivate void doSignal(Node first) {\n\n            do {\n                if ( (firstWaiter = first.nextWaiter) == null)\n                    lastWaiter = null;\n                first.nextWaiter = null;\n            } while (!transferForSignal(first) && //这里while是\n                     (first = firstWaiter) != null);\n        }\n```\n通过不停地循环, 只是希望从条件队列中找到一个status=CONDITION的节点, 并将该节点移动到阻塞队列中。移动的过程如下:\n```\n  final boolean transferForSignal(Node node) {\n        /*\n         * If cannot change waitStatus, the node has been cancelled.\n         */\n         //如果不是CONDITION， 则返回再看条件队列中下一个元素\n        if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))\n            return false;\n\n        /*\n         * Splice onto queue and try to set waitStatus of predecessor to\n         * indicate that thread is (probably) waiting. If cancelled or\n         * attempt to set waitStatus fails, wake up to resync (in which\n         * case the waitStatus can be transiently and harmlessly wrong).\n         */\n         //将该元素从条件队列移动到等待队列\n        Node p = enq(node);\n         //waitStatus>0的话，只能是cancel, 或者设置signal失败，那么唤醒该线程\n        int ws = p.waitStatus;\n         //若设置signal成功的话，wait函数那里的循环可能没有感觉到; 若没有感觉到会对调用yield减缓循环次数\n        if (ws > 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))\n            //目前线程已经处于阻塞队列, 唤醒该线程, 尝试再获取锁\n            LockSupport.unpark(node.thread);\n        return true;\n    }\n```\n我们现在回顾下, Condition的wait和signal整体逻辑如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition3.png\" height=\"270\" width=\"600\"/>\n# 总结\nCondition的wait和signal必须和锁配合使用, 以上只是结合ReentrantLock使用。ArrayBlockingQueue的实现原理与开头的示例类似, 基于ReentrantLock及Condition实现, Condition也可以与其他AQS结合, 比如CountDownLatch、ReentrantReadWriteLock, Semaphore, 使用大同小异, 这里就不一一讲解了。\n\n","slug":"Condition原理解读","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8vs0005phu5pcakgu13","content":"<p>任何一个java对象都拥有wait()/nitify方法, 它们通过与synchronized结合(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结(-)</a>)来实现线程之间的通信机制。 在锁方面Lock与Condition接口配合也实现了相同的功能, 但是它们之间的原理是不相同的。使用上两者的区别如下(图片摘自<a href=\"https://www.jianshu.com/p/be2dc7c878dc\" target=\"_blank\" rel=\"external\">java并发编程之Condition</a>)):<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition1.png\" height=\"400\" width=\"500\"></p>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><p>我们将以最简单的消费者与生产者的示例讲解Condition与Lock配合使用的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ConditonTest &#123;</div><div class=\"line\">    //当前产品个数</div><div class=\"line\">    public static int count = 0;</div><div class=\"line\">    static ReentrantLock reentrantLock = new ReentrantLock();</div><div class=\"line\">    //产品为空时, 那么消费者就得生产者来唤醒, 消费者就得等待生产者生产商品这个条件</div><div class=\"line\">    static  Condition empty = reentrantLock.newCondition();</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        ExecutorService pool = Executors.newFixedThreadPool(2);</div><div class=\"line\">        Thread t3 = new Consumer(&quot;A&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t1 = new Producder(&quot;B&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t2 = new Producder(&quot;C&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t4 = new Consumer(&quot;D&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t5 = new Consumer(&quot;E&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        // 执行各个线程</div><div class=\"line\">        pool.execute(t1);</div><div class=\"line\">        pool.execute(t2);</div><div class=\"line\">        pool.execute(t3);</div><div class=\"line\">        pool.execute(t4);</div><div class=\"line\">        pool.execute(t5);</div><div class=\"line\">        pool.shutdown();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Producder extends Thread &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    Lock lock;</div><div class=\"line\">    Condition empty;</div><div class=\"line\">    public Producder(String name, Lock lock, Condition empty) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\">        this.lock = lock;</div><div class=\"line\">        this.empty = empty;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        lock.lock(); // 获取锁</div><div class=\"line\">        ConditonTest.count ++;</div><div class=\"line\">        System.out.println(name + &quot;产生一个&quot;);</div><div class=\"line\">        empty.signalAll(); // 唤醒所有等待线程。</div><div class=\"line\">        lock.unlock(); // 释放锁</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Consumer extends Thread &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    Lock lock;</div><div class=\"line\">    Condition empty;</div><div class=\"line\">    public Consumer(String name, Lock lock, Condition empty) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\">        this.lock = lock;</div><div class=\"line\">        this.empty = empty;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        lock.lock(); // 获取锁</div><div class=\"line\">        try &#123;</div><div class=\"line\">            while ( ConditonTest.count == 0) &#123;</div><div class=\"line\">                System.out.println(name + &quot;阻塞中&quot;);</div><div class=\"line\">                // 阻塞取款操作, await之后就隐示自动释放了lock，直到被唤醒自动获取</div><div class=\"line\">                empty.await();</div><div class=\"line\">                System.out.println(name + &quot;被唤醒&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            ConditonTest.count --;</div><div class=\"line\">            System.out.println(name + &quot;消费一个&quot;);</div><div class=\"line\">        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            lock.unlock(); // 释放锁</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上只是使用一个Condition条件队列(具体真实应用可参考ArrayBlockingQueue、LinkedBlockingQueue), 在实际应用中, 可以使用多个条件ConditionObject, ConditionObject都是通过调用reentrantLock.newCondition()中产生的, 该类在AbstractQueuedSynchronizer中定义。 条件队列结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition2.png\" height=\"250\" width=\"450\"><br>每当线程调用Condition.wait()时, 该线程将会通过尾插发放入该条件队列; 当别的线程调用Condition.signal()时, 该线程将从等待队列转移到AQS阻塞队列(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 使用比较简单。<br>注意阻塞队列和条件队列结构的区别:</p>\n<ul>\n<li>阻塞队列拥有head, head不存放任何线程; 由tail指定结尾; 条件队列首尾由firstWaiter,lastWaiter指定, 第一个线程即为firstWaiter。</li>\n<li>阻塞队列由next, pre连接; 条件队列由nextWaiter连接</li>\n</ul>\n<h1 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait()\"></a>wait()</h1><p>wait主要是将该线程存放在Condition队列等待被唤醒。empty.await()实际调用的AbstractQueuedSynchronizer中的wait函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void await() throws InterruptedException &#123;</div><div class=\"line\">     //检查当前中断标志位, 若之前有中断, 那么直接向外抛出异常</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">    //将该线程添加到CONDITION队列中</div><div class=\"line\">    Node node = addConditionWaiter();</div><div class=\"line\">    //在该节点加入condition队列中等待前，await则需要释放掉当前线程占有的锁</div><div class=\"line\">    int savedState = fullyRelease(node);</div><div class=\"line\">    int interruptMode = 0;  //</div><div class=\"line\">    //检查该线程是否在阻塞队列中。线程首先加入条件队列，若有signal发生，会被signal转移到阻塞队列中</div><div class=\"line\">    while (!isOnSyncQueue(node)) &#123;</div><div class=\"line\">       //已经加入条件队列, 开始进行睡眠</div><div class=\"line\">       LockSupport.park(this);</div><div class=\"line\">       //被唤醒了, 可能是别的线程调用了signal; 也可能是别的线程调用了中断。线程可能在条件队列, 也可能在阻塞队列</div><div class=\"line\">       if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class=\"line\">            break;</div><div class=\"line\">        //等于0说明是被signal唤醒的，将在下次while时直接退出循环</div><div class=\"line\">    &#125;</div><div class=\"line\">    //此时在阻塞队列中了</div><div class=\"line\">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) //从阻塞队列中唤醒了</div><div class=\"line\">        interruptMode = REINTERRUPT;</div><div class=\"line\">    if (node.nextWaiter != null) // clean up if cancelled</div><div class=\"line\">        unlinkCancelledWaiters();</div><div class=\"line\">    if (interruptMode != 0)</div><div class=\"line\">        reportInterruptAfterWait(interruptMode); //</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>检查线程中断位, 若该线程存在中断信号则抛出异常</li>\n<li>将该线程加入条件队列, waitStatus置为Node.CONDITION, 见addConditionWaiter</li>\n<li>释放被占用的锁, 释放的savedState的值说明下次还需要获取的值。见fullyRelease</li>\n<li>检查线程是否阻塞队列, 见isOnSyncQueue。 若不在阻塞队列的话, 若在条件队列, 则开始调用LockSupport.park(this)睡眠。 若醒过来了存在两种可能: 别的线程调用了中断; 别的线程调用了signal, 需要继续判断是哪种情况, 见checkInterruptWhileWaiting。</li>\n<li>从while退出, 说明已经在阻塞队列了, 进入acquireQueued(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)等待被别的线程释放锁来唤醒</li>\n<li>清理条件队列中剩余线程, 若线程的node状态不为Node.CONDITION, 将从该队列中清理掉, 见unlinkCancelledWaiters函数。</li>\n<li>检查中断信息, 若存在中断, 中断是在调用signal前的话, 说明唤醒原因是因为中断, 那么线程直接向上抛出异常; 若中断是在调用signal之后的话, 那么唤醒原因是因为signal。将中断复位给线程。见reportInterruptAfterWait()<br>以下代码判断线程是否在阻塞队列中:isOnSyncQueue:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean isOnSyncQueue(Node node) &#123;</div><div class=\"line\">     //只有在等待队列,waitStatus才会等于CONDITION; node.prev !=null,不代表一定是在阻塞队列中, 也可能在迁移的路上</div><div class=\"line\">    if (node.waitStatus == Node.CONDITION || node.prev == null)</div><div class=\"line\">        return false;</div><div class=\"line\">     #若设置了, 肯定是在阻塞队列中。那就说明条件队列的next一定为null</div><div class=\"line\">    if (node.next != null) // If has successor, it must be on queue，</div><div class=\"line\">        return true;</div><div class=\"line\">    /*</div><div class=\"line\">     * node.prev can be non-null, but not yet on queue because</div><div class=\"line\">     * the CAS to place it on queue can fail. So we have to</div><div class=\"line\">     * traverse from tail to make sure it actually made it.  It</div><div class=\"line\">     * will always be near the tail in calls to this method, and</div><div class=\"line\">     * unless the CAS failed (which is unlikely), it will be</div><div class=\"line\">     * there, so we hardly ever traverse much.</div><div class=\"line\">     */</div><div class=\"line\">    return findNodeFromTail(node);  //同归对别在阻塞队列中彻头彻尾找这个节点</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>而checkInterruptWhileWaiting主要是为了检查线程从LockSupport.park(this)只醒来的原因:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int checkInterruptWhileWaiting(Node node) &#123;</div><div class=\"line\">            return Thread.interrupted() ?</div><div class=\"line\">                  //至少线程是被中断过</div><div class=\"line\">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</div><div class=\"line\">                0;  //返回0说明一定是被signasl唤醒的</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>这里判断, 若不存在中断信号的话, 那么线程一定是被别的线程调用signal唤醒的, 那么进入transferAfterCancelledWait判断线程中断发生的是时间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean transferAfterCancelledWait(Node node) &#123;</div><div class=\"line\">        //线程被signal唤醒，只会是Node.SIGNAL，而不是Node.CONDITION</div><div class=\"line\">       if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;</div><div class=\"line\">           enq(node);//说明是被interput的</div><div class=\"line\">           return true;</div><div class=\"line\">       &#125;</div><div class=\"line\">       /*  此后说明是被signal唤醒的，</div><div class=\"line\">        * If we lost out to a signal(), then we can&apos;t proceed  //若果我们从</div><div class=\"line\">        * until it finishes its enq().  Cancelling during an</div><div class=\"line\">        * incomplete transfer is both rare and transient, so just</div><div class=\"line\">        * spin.</div><div class=\"line\">        */</div><div class=\"line\">        //等待调用singla的线程将本节点加入阻塞队列，该线程等待这个操作完成, 若还没有完成的话, 就等待</div><div class=\"line\">       while (!isOnSyncQueue(node))</div><div class=\"line\">           Thread.yield();  //偶尔释放下cpu，线程从运行到就绪状态</div><div class=\"line\">       //说明是被singla唤醒的，同时已经被其他的线程加入了阻塞队列</div><div class=\"line\">       return false;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>总结一下, 此时线程被唤醒了:</p>\n<ul>\n<li>不存在中断信号, 说明若线程被signal唤醒的, 那么返回0</li>\n<li>存在中断信号, 而线程的statue为Node.CONDITION, 那么说明线程是被中断唤醒的, 之后将会向外抛出InterruptedException异常。</li>\n<li>存在中断信号, 而线程的statue不为Node.CONDITION, 那么说明该中断信号是在线程被signal唤醒之后才出现的, 那么就不会抛向外抛出异常, 而是将中断信号再置位给线程。</li>\n</ul>\n<h1 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal()\"></a>signal()</h1><p>再来了解下signal是如何将唤醒线程的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doSignal(Node first) &#123;</div><div class=\"line\"></div><div class=\"line\">            do &#123;</div><div class=\"line\">                if ( (firstWaiter = first.nextWaiter) == null)</div><div class=\"line\">                    lastWaiter = null;</div><div class=\"line\">                first.nextWaiter = null;</div><div class=\"line\">            &#125; while (!transferForSignal(first) &amp;&amp; //这里while是</div><div class=\"line\">                     (first = firstWaiter) != null);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>通过不停地循环, 只是希望从条件队列中找到一个status=CONDITION的节点, 并将该节点移动到阻塞队列中。移动的过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean transferForSignal(Node node) &#123;</div><div class=\"line\">      /*</div><div class=\"line\">       * If cannot change waitStatus, the node has been cancelled.</div><div class=\"line\">       */</div><div class=\"line\">       //如果不是CONDITION， 则返回再看条件队列中下一个元素</div><div class=\"line\">      if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</div><div class=\"line\">          return false;</div><div class=\"line\"></div><div class=\"line\">      /*</div><div class=\"line\">       * Splice onto queue and try to set waitStatus of predecessor to</div><div class=\"line\">       * indicate that thread is (probably) waiting. If cancelled or</div><div class=\"line\">       * attempt to set waitStatus fails, wake up to resync (in which</div><div class=\"line\">       * case the waitStatus can be transiently and harmlessly wrong).</div><div class=\"line\">       */</div><div class=\"line\">       //将该元素从条件队列移动到等待队列</div><div class=\"line\">      Node p = enq(node);</div><div class=\"line\">       //waitStatus&gt;0的话，只能是cancel, 或者设置signal失败，那么唤醒该线程</div><div class=\"line\">      int ws = p.waitStatus;</div><div class=\"line\">       //若设置signal成功的话，wait函数那里的循环可能没有感觉到; 若没有感觉到会对调用yield减缓循环次数</div><div class=\"line\">      if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class=\"line\">          //目前线程已经处于阻塞队列, 唤醒该线程, 尝试再获取锁</div><div class=\"line\">          LockSupport.unpark(node.thread);</div><div class=\"line\">      return true;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>我们现在回顾下, Condition的wait和signal整体逻辑如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition3.png\" height=\"270\" width=\"600\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Condition的wait和signal必须和锁配合使用, 以上只是结合ReentrantLock使用。ArrayBlockingQueue的实现原理与开头的示例类似, 基于ReentrantLock及Condition实现, Condition也可以与其他AQS结合, 比如CountDownLatch、ReentrantReadWriteLock, Semaphore, 使用大同小异, 这里就不一一讲解了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>任何一个java对象都拥有wait()/nitify方法, 它们通过与synchronized结合(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结(-)</a>)来实现线程之间的通信机制。 在锁方面Lock与Condition接口配合也实现了相同的功能, 但是它们之间的原理是不相同的。使用上两者的区别如下(图片摘自<a href=\"https://www.jianshu.com/p/be2dc7c878dc\" target=\"_blank\" rel=\"external\">java并发编程之Condition</a>)):<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition1.png\" height=\"400\" width=\"500\"></p>\n<h1 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h1><p>我们将以最简单的消费者与生产者的示例讲解Condition与Lock配合使用的例子:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class ConditonTest &#123;</div><div class=\"line\">    //当前产品个数</div><div class=\"line\">    public static int count = 0;</div><div class=\"line\">    static ReentrantLock reentrantLock = new ReentrantLock();</div><div class=\"line\">    //产品为空时, 那么消费者就得生产者来唤醒, 消费者就得等待生产者生产商品这个条件</div><div class=\"line\">    static  Condition empty = reentrantLock.newCondition();</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        ExecutorService pool = Executors.newFixedThreadPool(2);</div><div class=\"line\">        Thread t3 = new Consumer(&quot;A&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t1 = new Producder(&quot;B&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t2 = new Producder(&quot;C&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t4 = new Consumer(&quot;D&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        Thread t5 = new Consumer(&quot;E&quot;, ConditonTest.reentrantLock, ConditonTest.empty);</div><div class=\"line\">        // 执行各个线程</div><div class=\"line\">        pool.execute(t1);</div><div class=\"line\">        pool.execute(t2);</div><div class=\"line\">        pool.execute(t3);</div><div class=\"line\">        pool.execute(t4);</div><div class=\"line\">        pool.execute(t5);</div><div class=\"line\">        pool.shutdown();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Producder extends Thread &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    Lock lock;</div><div class=\"line\">    Condition empty;</div><div class=\"line\">    public Producder(String name, Lock lock, Condition empty) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\">        this.lock = lock;</div><div class=\"line\">        this.empty = empty;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        lock.lock(); // 获取锁</div><div class=\"line\">        ConditonTest.count ++;</div><div class=\"line\">        System.out.println(name + &quot;产生一个&quot;);</div><div class=\"line\">        empty.signalAll(); // 唤醒所有等待线程。</div><div class=\"line\">        lock.unlock(); // 释放锁</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">class Consumer extends Thread &#123;</div><div class=\"line\">    private String name;</div><div class=\"line\">    Lock lock;</div><div class=\"line\">    Condition empty;</div><div class=\"line\">    public Consumer(String name, Lock lock, Condition empty) &#123;</div><div class=\"line\">        this.name = name;</div><div class=\"line\">        this.lock = lock;</div><div class=\"line\">        this.empty = empty;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        lock.lock(); // 获取锁</div><div class=\"line\">        try &#123;</div><div class=\"line\">            while ( ConditonTest.count == 0) &#123;</div><div class=\"line\">                System.out.println(name + &quot;阻塞中&quot;);</div><div class=\"line\">                // 阻塞取款操作, await之后就隐示自动释放了lock，直到被唤醒自动获取</div><div class=\"line\">                empty.await();</div><div class=\"line\">                System.out.println(name + &quot;被唤醒&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">            ConditonTest.count --;</div><div class=\"line\">            System.out.println(name + &quot;消费一个&quot;);</div><div class=\"line\">        &#125; catch (InterruptedException e) &#123;</div><div class=\"line\">            e.printStackTrace();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            lock.unlock(); // 释放锁</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以上只是使用一个Condition条件队列(具体真实应用可参考ArrayBlockingQueue、LinkedBlockingQueue), 在实际应用中, 可以使用多个条件ConditionObject, ConditionObject都是通过调用reentrantLock.newCondition()中产生的, 该类在AbstractQueuedSynchronizer中定义。 条件队列结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition2.png\" height=\"250\" width=\"450\"><br>每当线程调用Condition.wait()时, 该线程将会通过尾插发放入该条件队列; 当别的线程调用Condition.signal()时, 该线程将从等待队列转移到AQS阻塞队列(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 使用比较简单。<br>注意阻塞队列和条件队列结构的区别:</p>\n<ul>\n<li>阻塞队列拥有head, head不存放任何线程; 由tail指定结尾; 条件队列首尾由firstWaiter,lastWaiter指定, 第一个线程即为firstWaiter。</li>\n<li>阻塞队列由next, pre连接; 条件队列由nextWaiter连接</li>\n</ul>\n<h1 id=\"wait\"><a href=\"#wait\" class=\"headerlink\" title=\"wait()\"></a>wait()</h1><p>wait主要是将该线程存放在Condition队列等待被唤醒。empty.await()实际调用的AbstractQueuedSynchronizer中的wait函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void await() throws InterruptedException &#123;</div><div class=\"line\">     //检查当前中断标志位, 若之前有中断, 那么直接向外抛出异常</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">    //将该线程添加到CONDITION队列中</div><div class=\"line\">    Node node = addConditionWaiter();</div><div class=\"line\">    //在该节点加入condition队列中等待前，await则需要释放掉当前线程占有的锁</div><div class=\"line\">    int savedState = fullyRelease(node);</div><div class=\"line\">    int interruptMode = 0;  //</div><div class=\"line\">    //检查该线程是否在阻塞队列中。线程首先加入条件队列，若有signal发生，会被signal转移到阻塞队列中</div><div class=\"line\">    while (!isOnSyncQueue(node)) &#123;</div><div class=\"line\">       //已经加入条件队列, 开始进行睡眠</div><div class=\"line\">       LockSupport.park(this);</div><div class=\"line\">       //被唤醒了, 可能是别的线程调用了signal; 也可能是别的线程调用了中断。线程可能在条件队列, 也可能在阻塞队列</div><div class=\"line\">       if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)</div><div class=\"line\">            break;</div><div class=\"line\">        //等于0说明是被signal唤醒的，将在下次while时直接退出循环</div><div class=\"line\">    &#125;</div><div class=\"line\">    //此时在阻塞队列中了</div><div class=\"line\">    if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) //从阻塞队列中唤醒了</div><div class=\"line\">        interruptMode = REINTERRUPT;</div><div class=\"line\">    if (node.nextWaiter != null) // clean up if cancelled</div><div class=\"line\">        unlinkCancelledWaiters();</div><div class=\"line\">    if (interruptMode != 0)</div><div class=\"line\">        reportInterruptAfterWait(interruptMode); //</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>检查线程中断位, 若该线程存在中断信号则抛出异常</li>\n<li>将该线程加入条件队列, waitStatus置为Node.CONDITION, 见addConditionWaiter</li>\n<li>释放被占用的锁, 释放的savedState的值说明下次还需要获取的值。见fullyRelease</li>\n<li>检查线程是否阻塞队列, 见isOnSyncQueue。 若不在阻塞队列的话, 若在条件队列, 则开始调用LockSupport.park(this)睡眠。 若醒过来了存在两种可能: 别的线程调用了中断; 别的线程调用了signal, 需要继续判断是哪种情况, 见checkInterruptWhileWaiting。</li>\n<li>从while退出, 说明已经在阻塞队列了, 进入acquireQueued(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)等待被别的线程释放锁来唤醒</li>\n<li>清理条件队列中剩余线程, 若线程的node状态不为Node.CONDITION, 将从该队列中清理掉, 见unlinkCancelledWaiters函数。</li>\n<li>检查中断信息, 若存在中断, 中断是在调用signal前的话, 说明唤醒原因是因为中断, 那么线程直接向上抛出异常; 若中断是在调用signal之后的话, 那么唤醒原因是因为signal。将中断复位给线程。见reportInterruptAfterWait()<br>以下代码判断线程是否在阻塞队列中:isOnSyncQueue:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean isOnSyncQueue(Node node) &#123;</div><div class=\"line\">     //只有在等待队列,waitStatus才会等于CONDITION; node.prev !=null,不代表一定是在阻塞队列中, 也可能在迁移的路上</div><div class=\"line\">    if (node.waitStatus == Node.CONDITION || node.prev == null)</div><div class=\"line\">        return false;</div><div class=\"line\">     #若设置了, 肯定是在阻塞队列中。那就说明条件队列的next一定为null</div><div class=\"line\">    if (node.next != null) // If has successor, it must be on queue，</div><div class=\"line\">        return true;</div><div class=\"line\">    /*</div><div class=\"line\">     * node.prev can be non-null, but not yet on queue because</div><div class=\"line\">     * the CAS to place it on queue can fail. So we have to</div><div class=\"line\">     * traverse from tail to make sure it actually made it.  It</div><div class=\"line\">     * will always be near the tail in calls to this method, and</div><div class=\"line\">     * unless the CAS failed (which is unlikely), it will be</div><div class=\"line\">     * there, so we hardly ever traverse much.</div><div class=\"line\">     */</div><div class=\"line\">    return findNodeFromTail(node);  //同归对别在阻塞队列中彻头彻尾找这个节点</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>而checkInterruptWhileWaiting主要是为了检查线程从LockSupport.park(this)只醒来的原因:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int checkInterruptWhileWaiting(Node node) &#123;</div><div class=\"line\">            return Thread.interrupted() ?</div><div class=\"line\">                  //至少线程是被中断过</div><div class=\"line\">                (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :</div><div class=\"line\">                0;  //返回0说明一定是被signasl唤醒的</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>这里判断, 若不存在中断信号的话, 那么线程一定是被别的线程调用signal唤醒的, 那么进入transferAfterCancelledWait判断线程中断发生的是时间<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean transferAfterCancelledWait(Node node) &#123;</div><div class=\"line\">        //线程被signal唤醒，只会是Node.SIGNAL，而不是Node.CONDITION</div><div class=\"line\">       if (compareAndSetWaitStatus(node, Node.CONDITION, 0)) &#123;</div><div class=\"line\">           enq(node);//说明是被interput的</div><div class=\"line\">           return true;</div><div class=\"line\">       &#125;</div><div class=\"line\">       /*  此后说明是被signal唤醒的，</div><div class=\"line\">        * If we lost out to a signal(), then we can&apos;t proceed  //若果我们从</div><div class=\"line\">        * until it finishes its enq().  Cancelling during an</div><div class=\"line\">        * incomplete transfer is both rare and transient, so just</div><div class=\"line\">        * spin.</div><div class=\"line\">        */</div><div class=\"line\">        //等待调用singla的线程将本节点加入阻塞队列，该线程等待这个操作完成, 若还没有完成的话, 就等待</div><div class=\"line\">       while (!isOnSyncQueue(node))</div><div class=\"line\">           Thread.yield();  //偶尔释放下cpu，线程从运行到就绪状态</div><div class=\"line\">       //说明是被singla唤醒的，同时已经被其他的线程加入了阻塞队列</div><div class=\"line\">       return false;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>总结一下, 此时线程被唤醒了:</p>\n<ul>\n<li>不存在中断信号, 说明若线程被signal唤醒的, 那么返回0</li>\n<li>存在中断信号, 而线程的statue为Node.CONDITION, 那么说明线程是被中断唤醒的, 之后将会向外抛出InterruptedException异常。</li>\n<li>存在中断信号, 而线程的statue不为Node.CONDITION, 那么说明该中断信号是在线程被signal唤醒之后才出现的, 那么就不会抛向外抛出异常, 而是将中断信号再置位给线程。</li>\n</ul>\n<h1 id=\"signal\"><a href=\"#signal\" class=\"headerlink\" title=\"signal()\"></a>signal()</h1><p>再来了解下signal是如何将唤醒线程的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doSignal(Node first) &#123;</div><div class=\"line\"></div><div class=\"line\">            do &#123;</div><div class=\"line\">                if ( (firstWaiter = first.nextWaiter) == null)</div><div class=\"line\">                    lastWaiter = null;</div><div class=\"line\">                first.nextWaiter = null;</div><div class=\"line\">            &#125; while (!transferForSignal(first) &amp;&amp; //这里while是</div><div class=\"line\">                     (first = firstWaiter) != null);</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>通过不停地循环, 只是希望从条件队列中找到一个status=CONDITION的节点, 并将该节点移动到阻塞队列中。移动的过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">final boolean transferForSignal(Node node) &#123;</div><div class=\"line\">      /*</div><div class=\"line\">       * If cannot change waitStatus, the node has been cancelled.</div><div class=\"line\">       */</div><div class=\"line\">       //如果不是CONDITION， 则返回再看条件队列中下一个元素</div><div class=\"line\">      if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))</div><div class=\"line\">          return false;</div><div class=\"line\"></div><div class=\"line\">      /*</div><div class=\"line\">       * Splice onto queue and try to set waitStatus of predecessor to</div><div class=\"line\">       * indicate that thread is (probably) waiting. If cancelled or</div><div class=\"line\">       * attempt to set waitStatus fails, wake up to resync (in which</div><div class=\"line\">       * case the waitStatus can be transiently and harmlessly wrong).</div><div class=\"line\">       */</div><div class=\"line\">       //将该元素从条件队列移动到等待队列</div><div class=\"line\">      Node p = enq(node);</div><div class=\"line\">       //waitStatus&gt;0的话，只能是cancel, 或者设置signal失败，那么唤醒该线程</div><div class=\"line\">      int ws = p.waitStatus;</div><div class=\"line\">       //若设置signal成功的话，wait函数那里的循环可能没有感觉到; 若没有感觉到会对调用yield减缓循环次数</div><div class=\"line\">      if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</div><div class=\"line\">          //目前线程已经处于阻塞队列, 唤醒该线程, 尝试再获取锁</div><div class=\"line\">          LockSupport.unpark(node.thread);</div><div class=\"line\">      return true;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>我们现在回顾下, Condition的wait和signal整体逻辑如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Condition3.png\" height=\"270\" width=\"600\"></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Condition的wait和signal必须和锁配合使用, 以上只是结合ReentrantLock使用。ArrayBlockingQueue的实现原理与开头的示例类似, 基于ReentrantLock及Condition实现, Condition也可以与其他AQS结合, 比如CountDownLatch、ReentrantReadWriteLock, Semaphore, 使用大同小异, 这里就不一一讲解了。</p>\n"},{"title":"CountDownLatch源码分析","date":"2017-08-24T08:47:06.000Z","toc":true,"_content":"CountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\nCountDownLatch与ReentrantLock的主要区别是:\n+ CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。\n+ CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。\nCountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。\nCountDownLatch使用方法如下:\n```\nCountDownLatch countDownLatch = new CountDownLatch(3);\n//获取共享锁,获取不到就阻塞\ncountDownLatch.await();\n //释放一份共享锁\ncountDownLatch.countDown();\n```\nawait()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。\n## countDown()\ncountDown()对state减1一:\n```\n    public final boolean releaseShared(int arg) {\n          //如果state为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了如下两个事情:\n+ 对state减一\n+ 若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:\n```\n    private void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                //若是singal，那么就会通知\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播\n                else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            // 如果发生了变动，说明一个线程被唤醒了\n            if (h == head)                    // loop if head changed,\n                break;\n        }\n    }\n```\n这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:\n+ 若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。\n+ 若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。\n+ 若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。\n+ 若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。\n需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。\n释放一个锁的整体过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch3.png\" height=\"250\" width=\"700\"/>\n\n\n## await()\nawait()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n主要做了如下事情:\n+ 首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。\n+ 检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念\n+ 若state > 0, 则需要将该线程加入等待队列。\n加入等待队列在doAcquireSharedInterruptibly中完成的。\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED); //创建共享锁\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) { //如果前继节点是头结点，\n                    int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的\n                    if (r >= 0) { //如果为0，就说明可以退出了\n                        setHeadAndPropagate(node, r); //向下传播释放锁的信号，\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:\n+ 首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch1.png\" height=\"200\" width=\"450\"/>\n+ 开始自旋, 进行判断:\n1. 若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。\n2. 通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。\n+ 若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。\n向后传播通过setHeadAndPropagate()完成, 也是比较简单的:\n```\n    private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node); //node前继节点就是头结点\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 || //如果\n            (h = head) == null || h.waitStatus < 0) { //这里是重复的\n            Node s = node.next;\n            if (s == null || s.isShared()) //本节点是共享的\n                doReleaseShared();\n        }\n    }\n```\n首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。\n获取所得过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch4.png\" height=\"250\" width=\"800\"/>\n\n\n## 超时等待\n在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:\n```\nCountDownLatch.await(100000, TimeUnit.MILLISECONDS)\n```\n指的是, 超时等待100s, 自动退出, `并不会因为超时没有获取到锁而抛出异常`。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。\ndoAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。\n\n## ReentrantLock和CountDownLatch对比\nReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。\nCountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。\n\n## 总结\nCountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。","source":"_posts/CountDownLatch源码解读.md","raw":"---\ntitle: CountDownLatch源码分析\ndate: 2017-08-24 16:47:06\ntags:\ntoc: true\n---\nCountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\nCountDownLatch与ReentrantLock的主要区别是:\n+ CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。\n+ CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。\nCountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。\nCountDownLatch使用方法如下:\n```\nCountDownLatch countDownLatch = new CountDownLatch(3);\n//获取共享锁,获取不到就阻塞\ncountDownLatch.await();\n //释放一份共享锁\ncountDownLatch.countDown();\n```\nawait()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。\n## countDown()\ncountDown()对state减1一:\n```\n    public final boolean releaseShared(int arg) {\n          //如果state为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了如下两个事情:\n+ 对state减一\n+ 若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:\n```\n    private void doReleaseShared() {\n        /*\n         * Ensure that a release propagates, even if there are other\n         * in-progress acquires/releases.  This proceeds in the usual\n         * way of trying to unparkSuccessor of head if it needs\n         * signal. But if it does not, status is set to PROPAGATE to\n         * ensure that upon release, propagation continues.\n         * Additionally, we must loop in case a new node is added\n         * while we are doing this. Also, unlike other uses of\n         * unparkSuccessor, we need to know if CAS to reset status\n         * fails, if so rechecking.\n         */\n        for (;;) {\n            Node h = head;\n            if (h != null && h != tail) {\n                int ws = h.waitStatus;\n                //若是singal，那么就会通知\n                if (ws == Node.SIGNAL) {\n                    if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))\n                        continue;            // loop to recheck cases\n                    unparkSuccessor(h);\n                }\n                //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播\n                else if (ws == 0 && !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))\n                    continue;                // loop on failed CAS\n            }\n            // 如果发生了变动，说明一个线程被唤醒了\n            if (h == head)                    // loop if head changed,\n                break;\n        }\n    }\n```\n这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:\n+ 若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。\n+ 若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。\n+ 若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。\n+ 若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。\n需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。\n释放一个锁的整体过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch3.png\" height=\"250\" width=\"700\"/>\n\n\n## await()\nawait()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。\n```\n    public final void acquireSharedInterruptibly(int arg)\n            throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n        if (tryAcquireShared(arg) < 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n主要做了如下事情:\n+ 首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。\n+ 检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念\n+ 若state > 0, 则需要将该线程加入等待队列。\n加入等待队列在doAcquireSharedInterruptibly中完成的。\n```\n    private void doAcquireSharedInterruptibly(int arg)\n        throws InterruptedException {\n        final Node node = addWaiter(Node.SHARED); //创建共享锁\n        boolean failed = true;\n        try {\n            for (;;) {\n                final Node p = node.predecessor();\n                if (p == head) { //如果前继节点是头结点，\n                    int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的\n                    if (r >= 0) { //如果为0，就说明可以退出了\n                        setHeadAndPropagate(node, r); //向下传播释放锁的信号，\n                        p.next = null; // help GC\n                        failed = false;\n                        return;\n                    }\n                }\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                    parkAndCheckInterrupt())\n                    throw new InterruptedException();\n            }\n        } finally {\n            if (failed)\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:\n+ 首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch1.png\" height=\"200\" width=\"450\"/>\n+ 开始自旋, 进行判断:\n1. 若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。\n2. 通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。\n+ 若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。\n向后传播通过setHeadAndPropagate()完成, 也是比较简单的:\n```\n    private void setHeadAndPropagate(Node node, int propagate) {\n        Node h = head; // Record old head for check below\n        setHead(node); //node前继节点就是头结点\n        /*\n         * Try to signal next queued node if:\n         *   Propagation was indicated by caller,\n         *     or was recorded (as h.waitStatus either before\n         *     or after setHead) by a previous operation\n         *     (note: this uses sign-check of waitStatus because\n         *      PROPAGATE status may transition to SIGNAL.)\n         * and\n         *   The next node is waiting in shared mode,\n         *     or we don't know, because it appears null\n         *\n         * The conservatism in both of these checks may cause\n         * unnecessary wake-ups, but only when there are multiple\n         * racing acquires/releases, so most need signals now or soon\n         * anyway.\n         */\n        if (propagate > 0 || h == null || h.waitStatus < 0 || //如果\n            (h = head) == null || h.waitStatus < 0) { //这里是重复的\n            Node s = node.next;\n            if (s == null || s.isShared()) //本节点是共享的\n                doReleaseShared();\n        }\n    }\n```\n首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。\n获取所得过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch4.png\" height=\"250\" width=\"800\"/>\n\n\n## 超时等待\n在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:\n```\nCountDownLatch.await(100000, TimeUnit.MILLISECONDS)\n```\n指的是, 超时等待100s, 自动退出, `并不会因为超时没有获取到锁而抛出异常`。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。\ndoAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。\n\n## ReentrantLock和CountDownLatch对比\nReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。\nCountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。\n\n## 总结\nCountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。","slug":"CountDownLatch源码解读","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8vu0006phu5dq7ylppo","content":"<p>CountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>CountDownLatch与ReentrantLock的主要区别是:</p>\n<ul>\n<li>CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。</li>\n<li>CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。<br>CountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。<br>CountDownLatch使用方法如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch countDownLatch = new CountDownLatch(3);</div><div class=\"line\">//获取共享锁,获取不到就阻塞</div><div class=\"line\">countDownLatch.await();</div><div class=\"line\"> //释放一份共享锁</div><div class=\"line\">countDownLatch.countDown();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>await()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。</p>\n<h2 id=\"countDown\"><a href=\"#countDown\" class=\"headerlink\" title=\"countDown()\"></a>countDown()</h2><p>countDown()对state减1一:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">      //如果state为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下两个事情:</p>\n<ul>\n<li>对state减一</li>\n<li>若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doReleaseShared() &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Ensure that a release propagates, even if there are other</div><div class=\"line\">     * in-progress acquires/releases.  This proceeds in the usual</div><div class=\"line\">     * way of trying to unparkSuccessor of head if it needs</div><div class=\"line\">     * signal. But if it does not, status is set to PROPAGATE to</div><div class=\"line\">     * ensure that upon release, propagation continues.</div><div class=\"line\">     * Additionally, we must loop in case a new node is added</div><div class=\"line\">     * while we are doing this. Also, unlike other uses of</div><div class=\"line\">     * unparkSuccessor, we need to know if CAS to reset status</div><div class=\"line\">     * fails, if so rechecking.</div><div class=\"line\">     */</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        if (h != null &amp;&amp; h != tail) &#123;</div><div class=\"line\">            int ws = h.waitStatus;</div><div class=\"line\">            //若是singal，那么就会通知</div><div class=\"line\">            if (ws == Node.SIGNAL) &#123;</div><div class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class=\"line\">                    continue;            // loop to recheck cases</div><div class=\"line\">                unparkSuccessor(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播</div><div class=\"line\">            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class=\"line\">                continue;                // loop on failed CAS</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 如果发生了变动，说明一个线程被唤醒了</div><div class=\"line\">        if (h == head)                    // loop if head changed,</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:</p>\n<ul>\n<li>若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。</li>\n<li>若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。</li>\n<li>若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。</li>\n<li>若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。<br>需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。<br>释放一个锁的整体过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch3.png\" height=\"250\" width=\"700\"></li>\n</ul>\n<h2 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await()\"></a>await()</h2><p>await()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireSharedInterruptibly(int arg)</div><div class=\"line\">        throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。</li>\n<li>检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念</li>\n<li>若state &gt; 0, 则需要将该线程加入等待队列。<br>加入等待队列在doAcquireSharedInterruptibly中完成的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doAcquireSharedInterruptibly(int arg)</div><div class=\"line\">    throws InterruptedException &#123;</div><div class=\"line\">    final Node node = addWaiter(Node.SHARED); //创建共享锁</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            final Node p = node.predecessor();</div><div class=\"line\">            if (p == head) &#123; //如果前继节点是头结点，</div><div class=\"line\">                int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的</div><div class=\"line\">                if (r &gt;= 0) &#123; //如果为0，就说明可以退出了</div><div class=\"line\">                    setHeadAndPropagate(node, r); //向下传播释放锁的信号，</div><div class=\"line\">                    p.next = null; // help GC</div><div class=\"line\">                    failed = false;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">                parkAndCheckInterrupt())</div><div class=\"line\">                throw new InterruptedException();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:</p>\n<ul>\n<li>首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch1.png\" height=\"200\" width=\"450\"></li>\n<li>开始自旋, 进行判断:</li>\n</ul>\n<ol>\n<li>若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。</li>\n<li>通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。</li>\n</ol>\n<ul>\n<li>若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。<br>向后传播通过setHeadAndPropagate()完成, 也是比较简单的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class=\"line\">    Node h = head; // Record old head for check below</div><div class=\"line\">    setHead(node); //node前继节点就是头结点</div><div class=\"line\">    /*</div><div class=\"line\">     * Try to signal next queued node if:</div><div class=\"line\">     *   Propagation was indicated by caller,</div><div class=\"line\">     *     or was recorded (as h.waitStatus either before</div><div class=\"line\">     *     or after setHead) by a previous operation</div><div class=\"line\">     *     (note: this uses sign-check of waitStatus because</div><div class=\"line\">     *      PROPAGATE status may transition to SIGNAL.)</div><div class=\"line\">     * and</div><div class=\"line\">     *   The next node is waiting in shared mode,</div><div class=\"line\">     *     or we don&apos;t know, because it appears null</div><div class=\"line\">     *</div><div class=\"line\">     * The conservatism in both of these checks may cause</div><div class=\"line\">     * unnecessary wake-ups, but only when there are multiple</div><div class=\"line\">     * racing acquires/releases, so most need signals now or soon</div><div class=\"line\">     * anyway.</div><div class=\"line\">     */</div><div class=\"line\">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || //如果</div><div class=\"line\">        (h = head) == null || h.waitStatus &lt; 0) &#123; //这里是重复的</div><div class=\"line\">        Node s = node.next;</div><div class=\"line\">        if (s == null || s.isShared()) //本节点是共享的</div><div class=\"line\">            doReleaseShared();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。<br>获取所得过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch4.png\" height=\"250\" width=\"800\"></p>\n<h2 id=\"超时等待\"><a href=\"#超时等待\" class=\"headerlink\" title=\"超时等待\"></a>超时等待</h2><p>在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch.await(100000, TimeUnit.MILLISECONDS)</div></pre></td></tr></table></figure></p>\n<p>指的是, 超时等待100s, 自动退出, <code>并不会因为超时没有获取到锁而抛出异常</code>。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。<br>doAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。</p>\n<h2 id=\"ReentrantLock和CountDownLatch对比\"><a href=\"#ReentrantLock和CountDownLatch对比\" class=\"headerlink\" title=\"ReentrantLock和CountDownLatch对比\"></a>ReentrantLock和CountDownLatch对比</h2><p>ReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。<br>CountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>CountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CountDownLatch也是线程同步的一个工具, 底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>CountDownLatch与ReentrantLock的主要区别是:</p>\n<ul>\n<li>CountDownLatch是一个共享锁, ReentrantLock是一个独占锁。</li>\n<li>CountDownLatch中state初始值为n, 代表一个锁被分成了n份。 好比门钥匙, 有一个门需要n份钥匙聚齐后才能打开。 若门打开后, 第一个通过的那个人可以告诉排队等待的人, 然后依次经过。而ReentrantLock中state为0, 表示锁没有被占用, 比如有一个很窄的门, 每次只能通过一个人, 虽拥有那个钥匙(state=1), 谁才能过那道门。 若有很多人等, 那么就要排队了。 若新来一个人来时, 门恰好是开着的, 他能忽略排队的人过去的话, 这就是非公平锁, 若需要进入等待队列的话, 那就是公平锁。<br>CountDownLatch并不存在公不公平锁的概念, CountDownLatch的这个门打开后, 进门的并发并没有限制, 任何人只要发现门打开了, 就可以进入。 而ReentrantLock对应的门, 设置了每次进门的并发只能是1, 所以需要排序进入。<br>CountDownLatch使用方法如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch countDownLatch = new CountDownLatch(3);</div><div class=\"line\">//获取共享锁,获取不到就阻塞</div><div class=\"line\">countDownLatch.await();</div><div class=\"line\"> //释放一份共享锁</div><div class=\"line\">countDownLatch.countDown();</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>await()方法检查state是否为0, 不为0则阻塞当前线程, countDown()把当前state减一。</p>\n<h2 id=\"countDown\"><a href=\"#countDown\" class=\"headerlink\" title=\"countDown()\"></a>countDown()</h2><p>countDown()对state减1一:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">      //如果state为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下两个事情:</p>\n<ul>\n<li>对state减一</li>\n<li>若state为0, 那么开始唤醒睡眠的线程, 唤醒过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doReleaseShared() &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Ensure that a release propagates, even if there are other</div><div class=\"line\">     * in-progress acquires/releases.  This proceeds in the usual</div><div class=\"line\">     * way of trying to unparkSuccessor of head if it needs</div><div class=\"line\">     * signal. But if it does not, status is set to PROPAGATE to</div><div class=\"line\">     * ensure that upon release, propagation continues.</div><div class=\"line\">     * Additionally, we must loop in case a new node is added</div><div class=\"line\">     * while we are doing this. Also, unlike other uses of</div><div class=\"line\">     * unparkSuccessor, we need to know if CAS to reset status</div><div class=\"line\">     * fails, if so rechecking.</div><div class=\"line\">     */</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        if (h != null &amp;&amp; h != tail) &#123;</div><div class=\"line\">            int ws = h.waitStatus;</div><div class=\"line\">            //若是singal，那么就会通知</div><div class=\"line\">            if (ws == Node.SIGNAL) &#123;</div><div class=\"line\">                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))</div><div class=\"line\">                    continue;            // loop to recheck cases</div><div class=\"line\">                unparkSuccessor(h);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //按道理这种情况不会发生，若发生了，那么下个节点要无条件传播</div><div class=\"line\">            else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))</div><div class=\"line\">                continue;                // loop on failed CAS</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 如果发生了变动，说明一个线程被唤醒了</div><div class=\"line\">        if (h == head)                    // loop if head changed,</div><div class=\"line\">            break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这个函数在countDown()和await()中都会被调用(在doAcquireSharedInterruptibly()中, 当阻塞线程从LockSupport.park(this)中醒来, 就会调用), 注意这里是一个死循环, 从头结点开始检查每个node的waitStatus, 直到等待队列没有要唤醒的线程为止, 主要做了如下判断:</p>\n<ul>\n<li>若节点waitStatus为signal, 那么就设置当前节点为0(初始化节点), 并且通过unparkSuccessor()唤醒等待队里里面的后继节点(该函数可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)。</li>\n<li>若当前节点waitStatus为0是(初始化状态, 比如刚将头结点从signal变成了0), 那么设置h为PROPAGATE, 表示状态需要向后传递。 实际查找代码, 并没有发现哪里显示使用Node.PROPAGATE这个条件的, 这步实际并没有看出存在的意义。</li>\n<li>若别的线程唤醒后, 做的一件事就是调用setHead(node), 重新设置head, 说明本次唤醒是成功的, 本线程再继续唤醒后续阻塞节点 。</li>\n<li>若h==head, 说明tail==head, 所有节点已经唤醒。那么此时才可以退出。<br>需要知道的是, 若节点对应的线程从等待队列中唤醒, 节点此时并没有从等待队列中去掉, 实际在await()中从等待队列中去掉而被回收的。<br>释放一个锁的整体过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch3.png\" height=\"250\" width=\"700\"></li>\n</ul>\n<h2 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await()\"></a>await()</h2><p>await()实际就是检查state是否为0, 若不为0, 那么本节点就加入等待队列中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireSharedInterruptibly(int arg)</div><div class=\"line\">        throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0) //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先检查是否有中断信号, 若有的话, 就直接抛异常, 否则LockSupport.lock()就会被直接唤醒而没有意义(中断信号就可以直接使lock()失效)。</li>\n<li>检查state是否为0, 若为0, 就说明直接获取了锁。这里可以体现CountDownLatch并没有公平锁的概念</li>\n<li>若state &gt; 0, 则需要将该线程加入等待队列。<br>加入等待队列在doAcquireSharedInterruptibly中完成的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doAcquireSharedInterruptibly(int arg)</div><div class=\"line\">    throws InterruptedException &#123;</div><div class=\"line\">    final Node node = addWaiter(Node.SHARED); //创建共享锁</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            final Node p = node.predecessor();</div><div class=\"line\">            if (p == head) &#123; //如果前继节点是头结点，</div><div class=\"line\">                int r = tryAcquireShared(arg); //如果获取到锁， 一定值大于0的</div><div class=\"line\">                if (r &gt;= 0) &#123; //如果为0，就说明可以退出了</div><div class=\"line\">                    setHeadAndPropagate(node, r); //向下传播释放锁的信号，</div><div class=\"line\">                    p.next = null; // help GC</div><div class=\"line\">                    failed = false;</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">                parkAndCheckInterrupt())</div><div class=\"line\">                throw new InterruptedException();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。该函数做了如下事情:</p>\n<ul>\n<li>首先将该节点以SHARED方式创建节点, 并加入等待队列。在addWaiter()中实现, 参数为Node.SHARED, 此时等待队列如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch1.png\" height=\"200\" width=\"450\"></li>\n<li>开始自旋, 进行判断:</li>\n</ul>\n<ol>\n<li>若当前节点的前继节点是head, 并且state=0, 那么说明该线程获取到了锁, 重新设置head, 并且向后传播(setHeadAndPropagate)。</li>\n<li>通过调用shouldParkAfterFailedAcquire判断是否可以直接睡眠(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>), 若可以的话, 就直接去睡眠。</li>\n</ol>\n<ul>\n<li>若被别人唤醒, 调用tryAcquireShared(), 这里仅仅是检测state是否为0, 所以不存在强锁。<br>向后传播通过setHeadAndPropagate()完成, 也是比较简单的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setHeadAndPropagate(Node node, int propagate) &#123;</div><div class=\"line\">    Node h = head; // Record old head for check below</div><div class=\"line\">    setHead(node); //node前继节点就是头结点</div><div class=\"line\">    /*</div><div class=\"line\">     * Try to signal next queued node if:</div><div class=\"line\">     *   Propagation was indicated by caller,</div><div class=\"line\">     *     or was recorded (as h.waitStatus either before</div><div class=\"line\">     *     or after setHead) by a previous operation</div><div class=\"line\">     *     (note: this uses sign-check of waitStatus because</div><div class=\"line\">     *      PROPAGATE status may transition to SIGNAL.)</div><div class=\"line\">     * and</div><div class=\"line\">     *   The next node is waiting in shared mode,</div><div class=\"line\">     *     or we don&apos;t know, because it appears null</div><div class=\"line\">     *</div><div class=\"line\">     * The conservatism in both of these checks may cause</div><div class=\"line\">     * unnecessary wake-ups, but only when there are multiple</div><div class=\"line\">     * racing acquires/releases, so most need signals now or soon</div><div class=\"line\">     * anyway.</div><div class=\"line\">     */</div><div class=\"line\">    if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || //如果</div><div class=\"line\">        (h = head) == null || h.waitStatus &lt; 0) &#123; //这里是重复的</div><div class=\"line\">        Node s = node.next;</div><div class=\"line\">        if (s == null || s.isShared()) //本节点是共享的</div><div class=\"line\">            doReleaseShared();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>首先修改头结点, 其次判断判断后继节点是否是共享的(nextWaiter == SHARED), 前面可知, 每个线程构造等待节点时, 传递的nextWaiter=SHARED, 也恰好满足条件。共享锁唤醒操作在await()里有介绍(doReleaseShared())。<br>获取所得过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CountDownLatch4.png\" height=\"250\" width=\"800\"></p>\n<h2 id=\"超时等待\"><a href=\"#超时等待\" class=\"headerlink\" title=\"超时等待\"></a>超时等待</h2><p>在项目使用中, 若有一个countDown()得不到执行, 那么awit()线程将永远阻塞下去, 这是一个比较严重的事情, ReentrantLock给我们提供了超时等待的机制:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">CountDownLatch.await(100000, TimeUnit.MILLISECONDS)</div></pre></td></tr></table></figure></p>\n<p>指的是, 超时等待100s, 自动退出, <code>并不会因为超时没有获取到锁而抛出异常</code>。这里doAcquireSharedNanos在睡眠前, 将剩余超时时间与spinForTimeoutThreshold(默认1ms)做对比, 若小于1ms, 说明超时时间太短, 就没有必要再去睡眠, 而采取自旋的方式。<br>doAcquireSharedNanos与非超时的函数doAcquireShared区别主要就是底层一个调用了LockSupport.parkNanos(this, nanosTimeout), 一个调用了LockSupport.parkNanos(this), 别的并没有区别。</p>\n<h2 id=\"ReentrantLock和CountDownLatch对比\"><a href=\"#ReentrantLock和CountDownLatch对比\" class=\"headerlink\" title=\"ReentrantLock和CountDownLatch对比\"></a>ReentrantLock和CountDownLatch对比</h2><p>ReentrantLock作为互斥锁, 当且仅当前面的线程被unlock()唤醒后, 后继节点才能被唤醒。前面一个节点唤醒后,直到运行unlock(), 才能继续唤醒阻塞的线程。<br>CountDownLatch作为共享锁, 在countDown()中首先会唤醒阻塞的队列, 再继续唤醒下一个线层(调用doReleaseShared()函数)。同时被唤醒的那个线程也会继续唤醒后继节点(调用doReleaseShared()函数), 在countDown()和await()都可能唤醒后续线程。代码中一个明显的区别就是, 阻塞的线程被唤醒后, ReentrantLock调用的的是setHead()就退出了, 而CountDownLatch调用的是setHeadAndPropagate(), 继续向后传播。这里也体现了共享的概念, 只要获得锁, 合适的情况下就会向后传播, 唤醒后续线程。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>CountDownLatch获取锁时候, 调用await()时, 只要state为0即可。 而state降低通过countDown()实现。该锁属于共享锁, 当state为0后, 会逐渐通知等待队列中的线程。</p>\n"},{"title":"DirectByteBuffer堆外内存详解","date":"2018-07-27T08:33:58.000Z","toc":true,"_content":"我们知道, 在使用IO传输数据时, 首先会将数据传输到堆外直接内存中, 然后才通过网络发送出去。这样的话, 数据多了次中间copy, 能否不经过copy而直接将数据发送出去呢, 其实是可以的, 存放的位置就是本文要讲的主角:DirectByteBuffer 。JVM内存主要分为heap内存和堆外内存(一般我们也会称呼为直接内存), heap内存我们不用care, jvm能自动帮我们管理, 而堆外内存回收不受JVM GC控制, 因此, 堆外内存使用必须小心。本文就主要讲jvm中堆外内存的实现及原理。\n## DirectByteBuffer使用\n在程序中, 我们可以通过如下方式获取到DirectByteBuffer, 并且直接作为IO的缓存:\n```\n public void sendAndRecv(String words) throws IOException\n    {\n        byte[] msg = new String(words).getBytes();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(msg.length);\n        buffer.put(msg);\n        //读写模式相互转化写\n        buffer.flip();\n        System.out.println(\"Client sending: \" + words);\n        channel.write(buffer);\n        channel.close();\n    }\n```\nDirectByteBuffer是不能直接被外界引用的, 类成员变量如下:\n```\n    DirectByteBuffer(int cap) {\n        super(-1, 0, cap, cap);\n        //是否页对齐\n        boolean pa = VM.isDirectMemoryPageAligned();\n        //页的大小4K\n        int ps = Bits.pageSize();\n        //最小申请1K，若需要页对齐，那么多申请1页，以应对初始地址的页对齐问题\n        long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n        //检查堆外内存是否够用, 并对分配的直接内存做一个记录\n        Bits.reserveMemory(size, cap);\n        long base = 0;\n        try {\n            //直接内存的初始地址, 返回初始地址\n            base = unsafe.allocateMemory(size);\n        } catch (OutOfMemoryError x) {\n            Bits.unreserveMemory(size, cap);\n            throw x;\n        }\n        //对直接内存初始化\n        unsafe.setMemory(base, size, (byte) 0);\n        //若需要页对其，并且不是页的整数倍，在需要将页对齐（默认是不需要进行页对齐的）\n        if (pa && (base % ps != 0)) {\n            // Round up to page boundary //初始地址取整页，注意申请的地址为取整数页\n            address = base + ps - (base & (ps - 1));\n        } else {\n            address = base;\n        }\n        //声明一个Cleaner对象用于清理该DirectBuffer内存\n        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n        att = null;\n    }\n```\n可以看到, DirectByteBuffer通过直接调用base=unsafe.allocateMemory(size)操作堆外内存, 返回的是该堆外内存的直接地址, 存放在address中, 以便通过address进行堆外数据的读取与写入。 unsafe的使用可以参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">LockSupport原理分析</a>\n我们需要了解下, Bits.reserveMemory()如何判断堆外内存是否可用的:\n```\n static void reserveMemory(long size, int cap) {  ////对分配的直接内存做一个记录\n        synchronized (Bits.class) {\n            if (!memoryLimitSet && VM.isBooted())\n            {\n                //堆外直接内存默认等于堆内内存大小, 可以通过\n                maxMemory = VM.maxDirectMemory();\n                memoryLimitSet = true;\n            }\n            // -XX:MaxDirectMemorySize limits the total capacity rather than the\n            // actual memory usage, which will differ when buffers are page\n            // aligned.\n            //如果够分的话，则直接退出\n            if (cap <= maxMemory - totalCapacity) {\n                reservedMemory += size;\n                totalCapacity += cap; //\n                count++;\n                return;\n            }\n        }\n        //不够分的话，则调用System.gc()进行一次full gc. 一般不要在线程启动时添加-XX:+DisableExplicitGC（禁止代码显示调用gc）\n        System.gc(); //只是告知机器，这里应该GC一次， 但是实际并不一定进行垃圾回收\n        try {\n             //再等待100ms使gc有时间完成，然后再看是否够分配\n            Thread.sleep(100);\n        } catch (InterruptedException x) {\n            // Restore interrupt status\n            Thread.currentThread().interrupt();\n        }\n        synchronized (Bits.class) {\n            //此时不够分的话，再调用向外抛出oom\n            if (totalCapacity + cap > maxMemory)\n                throw new OutOfMemoryError(\"Direct buffer memory\");\n            reservedMemory += size;\n            totalCapacity += cap;\n            count++;\n        }\n    }\n```\n可以看到:\n+ 首先检查堆外内存是否够分\n+ 若不够分的话, 再进行一次full gc显示推动对堆外内存的回收, 再次尝试分配堆外内存, 不够分的话, 则抛出OOM异常。\n\n# 堆外内存的回收\n在DirectByteBuffer的构造函数中, 我们可以看到这样的一行代码`cleaner = Cleaner.create(this, new Deallocator(base, size, cap));`, 没错, 直接内存释放主要由cleaner来完成。 我们知道JVM GC并不能直接释放直接内存, 但是GC可以释放管理直接内存的DirectByteBuffer对象。 我们需要注意下cleaner的类型:\n```\npublic class Cleaner  extends PhantomReference<Object>\n```\nPhantomReference并不会对对象的垃圾回收产生任何影响, 当进行gc完成后, 当发现某个对象只剩下虚引用后, 会将该引用迁移至Reference类的pending队列进行回收. 这里可以看到DirectByteBuffer被Cleaner引用着。Reference操作回收代码如下:\n```\n    static private class Lock { };\n    private static Lock lock = new Lock();\n\n\n    /* List of References waiting to be enqueued.  The collector adds\n     * References to this list, while the Reference-handler thread removes\n     * them.  This list is protected by the above lock object. The\n     * list uses the discovered field to link its elements.\n     */\n    //当gc时，发现DirectByteBuffer除了PhantomReference对象引用,没有其他对象引用， 会把DirectByteBuffer放入其中，等待被回收\n    private static Reference<Object> pending = null;\n\n    /* High-priority thread to enqueue pending References\n     */\n    private static class ReferenceHandler extends Thread {\n\n        ReferenceHandler(ThreadGroup g, String name) {\n            super(g, name);\n        }\n\n        public void run() {\n            for (;;) {\n                Reference<Object> r;\n                synchronized (lock) {\n                    if (pending != null) {\n                        r = pending;\n                        pending = r.discovered;\n                        r.discovered = null;\n                    } else {\n                        // The waiting on the lock may cause an OOME because it may try to allocate\n                        // exception objects, so also catch OOME here to avoid silent exit of the\n                        // reference handler thread.\n                        //\n                        // Explicitly define the order of the two exceptions we catch here\n                        // when waiting for the lock.\n                        //\n                        // We do not want to try to potentially load the InterruptedException class\n                        // (which would be done if this was its first use, and InterruptedException\n                        // were checked first) in this situation.\n                        //\n                        // This may lead to the VM not ever trying to load the InterruptedException\n                        // class again.\n                        try {\n                            try {\n                                //如果没有的话，会一直等待唤醒\n                                lock.wait();\n                            } catch (OutOfMemoryError x) { }\n                        } catch (InterruptedException x) { }\n                        continue;\n                    }\n                }\n\n                // Fast path for cleaners\n                if (r instanceof Cleaner) {\n                     //从头开始进行clena()调用\n                    ((Cleaner)r).clean();\n                    continue;\n                }\n\n                ReferenceQueue<Object> q = r.queue;\n                if (q != ReferenceQueue.NULL) q.enqueue(r);\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread handler = new ReferenceHandler(tg, \"Reference Handler\");\n        /* If there were a special system-only priority greater than\n         * MAX_PRIORITY, it would be used here\n         */\n        handler.setPriority(Thread.MAX_PRIORITY);\n        handler.setDaemon(true);\n        handler.start();\n    }\n```\n可以看出来, JV会新建名为`Reference Handler`的线程, 时刻回收被挂到pending上面的虚拟引用。 当DirectByteBuff对象仅被Cleaner引用时, Cleaner被放入pending队列, 之后调用Cleaner.clean()队列\n```\n public void clean() {  //这里的clean(）会在Reference回收时显示调用\n        if (!remove(this))\n            return;\n        try {\n            thunk.run();\n        } catch (final Throwable x) {\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        if (System.err != null)\n                            new Error(\"Cleaner terminated abnormally\", x)\n                                .printStackTrace();\n                        System.exit(1);\n                        return null;\n                    }});\n        }\n}\n//就是一个释放直接内存的线程\nprivate static class Deallocator  implements Runnable\n{\n\n        private static Unsafe unsafe = Unsafe.getUnsafe();\n\n        private long address;\n        private long size;\n        private int capacity;\n\n        private Deallocator(long address, long size, int capacity) {\n            assert (address != 0);\n            this.address = address;\n            this.size = size;\n            this.capacity = capacity;\n        }\n\n        public void run() {\n            if (address == 0) {\n                // Paranoia\n                return;\n            }\n            unsafe.freeMemory(address); //释放地址\n            address = 0;\n            Bits.unreserveMemory(size, capacity); //修改统计\n        }\n\n}\n\n```\n可以看到, 此时完成了DirectByteBuff直接内存的释放。\n\n可能有些人会好奇: 为什么IO操作不直接使用堆内内存? 这是因为堆内内存会发生GC移动操作, 对象移动后, 其绝对内存地址也会发生改变, 而gc时对象移动操作很频繁, 不可能每次移动堆内数据, IO时缓存的buffer也跟着一起移动。这样也是不合理的。 而IO操作直接使用堆外内存则没有了这一限制。同时jvm中IO操作的Buffer必须是DirectBuffer(可查看IO.write/read函数)\n# 总结\n在JVM中, 一般只有通过DirectByteBuffer这一种方式操作堆外内存, 平时说的堆外内存泄漏, 也就是指的DirectByteBuffer里面的堆外内存发生泄漏。合理使用DirectByteBuffer对通信框架有着很重要的帮助, 比如netty大量的IO数据传输, 都是通过DirectByteBuffer完成的。 直接内存的申请与释放比较代价比较大, 一般都会辅助对象池来尽量高效的利用申请的对象。\n","source":"_posts/DirectByteBuffer堆外内存详解.md","raw":"---\ntitle: DirectByteBuffer堆外内存详解\ndate: 2018-07-27 16:33:58\ntags:\ntoc: true\n---\n我们知道, 在使用IO传输数据时, 首先会将数据传输到堆外直接内存中, 然后才通过网络发送出去。这样的话, 数据多了次中间copy, 能否不经过copy而直接将数据发送出去呢, 其实是可以的, 存放的位置就是本文要讲的主角:DirectByteBuffer 。JVM内存主要分为heap内存和堆外内存(一般我们也会称呼为直接内存), heap内存我们不用care, jvm能自动帮我们管理, 而堆外内存回收不受JVM GC控制, 因此, 堆外内存使用必须小心。本文就主要讲jvm中堆外内存的实现及原理。\n## DirectByteBuffer使用\n在程序中, 我们可以通过如下方式获取到DirectByteBuffer, 并且直接作为IO的缓存:\n```\n public void sendAndRecv(String words) throws IOException\n    {\n        byte[] msg = new String(words).getBytes();\n        ByteBuffer buffer = ByteBuffer.allocateDirect(msg.length);\n        buffer.put(msg);\n        //读写模式相互转化写\n        buffer.flip();\n        System.out.println(\"Client sending: \" + words);\n        channel.write(buffer);\n        channel.close();\n    }\n```\nDirectByteBuffer是不能直接被外界引用的, 类成员变量如下:\n```\n    DirectByteBuffer(int cap) {\n        super(-1, 0, cap, cap);\n        //是否页对齐\n        boolean pa = VM.isDirectMemoryPageAligned();\n        //页的大小4K\n        int ps = Bits.pageSize();\n        //最小申请1K，若需要页对齐，那么多申请1页，以应对初始地址的页对齐问题\n        long size = Math.max(1L, (long)cap + (pa ? ps : 0));\n        //检查堆外内存是否够用, 并对分配的直接内存做一个记录\n        Bits.reserveMemory(size, cap);\n        long base = 0;\n        try {\n            //直接内存的初始地址, 返回初始地址\n            base = unsafe.allocateMemory(size);\n        } catch (OutOfMemoryError x) {\n            Bits.unreserveMemory(size, cap);\n            throw x;\n        }\n        //对直接内存初始化\n        unsafe.setMemory(base, size, (byte) 0);\n        //若需要页对其，并且不是页的整数倍，在需要将页对齐（默认是不需要进行页对齐的）\n        if (pa && (base % ps != 0)) {\n            // Round up to page boundary //初始地址取整页，注意申请的地址为取整数页\n            address = base + ps - (base & (ps - 1));\n        } else {\n            address = base;\n        }\n        //声明一个Cleaner对象用于清理该DirectBuffer内存\n        cleaner = Cleaner.create(this, new Deallocator(base, size, cap));\n        att = null;\n    }\n```\n可以看到, DirectByteBuffer通过直接调用base=unsafe.allocateMemory(size)操作堆外内存, 返回的是该堆外内存的直接地址, 存放在address中, 以便通过address进行堆外数据的读取与写入。 unsafe的使用可以参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">LockSupport原理分析</a>\n我们需要了解下, Bits.reserveMemory()如何判断堆外内存是否可用的:\n```\n static void reserveMemory(long size, int cap) {  ////对分配的直接内存做一个记录\n        synchronized (Bits.class) {\n            if (!memoryLimitSet && VM.isBooted())\n            {\n                //堆外直接内存默认等于堆内内存大小, 可以通过\n                maxMemory = VM.maxDirectMemory();\n                memoryLimitSet = true;\n            }\n            // -XX:MaxDirectMemorySize limits the total capacity rather than the\n            // actual memory usage, which will differ when buffers are page\n            // aligned.\n            //如果够分的话，则直接退出\n            if (cap <= maxMemory - totalCapacity) {\n                reservedMemory += size;\n                totalCapacity += cap; //\n                count++;\n                return;\n            }\n        }\n        //不够分的话，则调用System.gc()进行一次full gc. 一般不要在线程启动时添加-XX:+DisableExplicitGC（禁止代码显示调用gc）\n        System.gc(); //只是告知机器，这里应该GC一次， 但是实际并不一定进行垃圾回收\n        try {\n             //再等待100ms使gc有时间完成，然后再看是否够分配\n            Thread.sleep(100);\n        } catch (InterruptedException x) {\n            // Restore interrupt status\n            Thread.currentThread().interrupt();\n        }\n        synchronized (Bits.class) {\n            //此时不够分的话，再调用向外抛出oom\n            if (totalCapacity + cap > maxMemory)\n                throw new OutOfMemoryError(\"Direct buffer memory\");\n            reservedMemory += size;\n            totalCapacity += cap;\n            count++;\n        }\n    }\n```\n可以看到:\n+ 首先检查堆外内存是否够分\n+ 若不够分的话, 再进行一次full gc显示推动对堆外内存的回收, 再次尝试分配堆外内存, 不够分的话, 则抛出OOM异常。\n\n# 堆外内存的回收\n在DirectByteBuffer的构造函数中, 我们可以看到这样的一行代码`cleaner = Cleaner.create(this, new Deallocator(base, size, cap));`, 没错, 直接内存释放主要由cleaner来完成。 我们知道JVM GC并不能直接释放直接内存, 但是GC可以释放管理直接内存的DirectByteBuffer对象。 我们需要注意下cleaner的类型:\n```\npublic class Cleaner  extends PhantomReference<Object>\n```\nPhantomReference并不会对对象的垃圾回收产生任何影响, 当进行gc完成后, 当发现某个对象只剩下虚引用后, 会将该引用迁移至Reference类的pending队列进行回收. 这里可以看到DirectByteBuffer被Cleaner引用着。Reference操作回收代码如下:\n```\n    static private class Lock { };\n    private static Lock lock = new Lock();\n\n\n    /* List of References waiting to be enqueued.  The collector adds\n     * References to this list, while the Reference-handler thread removes\n     * them.  This list is protected by the above lock object. The\n     * list uses the discovered field to link its elements.\n     */\n    //当gc时，发现DirectByteBuffer除了PhantomReference对象引用,没有其他对象引用， 会把DirectByteBuffer放入其中，等待被回收\n    private static Reference<Object> pending = null;\n\n    /* High-priority thread to enqueue pending References\n     */\n    private static class ReferenceHandler extends Thread {\n\n        ReferenceHandler(ThreadGroup g, String name) {\n            super(g, name);\n        }\n\n        public void run() {\n            for (;;) {\n                Reference<Object> r;\n                synchronized (lock) {\n                    if (pending != null) {\n                        r = pending;\n                        pending = r.discovered;\n                        r.discovered = null;\n                    } else {\n                        // The waiting on the lock may cause an OOME because it may try to allocate\n                        // exception objects, so also catch OOME here to avoid silent exit of the\n                        // reference handler thread.\n                        //\n                        // Explicitly define the order of the two exceptions we catch here\n                        // when waiting for the lock.\n                        //\n                        // We do not want to try to potentially load the InterruptedException class\n                        // (which would be done if this was its first use, and InterruptedException\n                        // were checked first) in this situation.\n                        //\n                        // This may lead to the VM not ever trying to load the InterruptedException\n                        // class again.\n                        try {\n                            try {\n                                //如果没有的话，会一直等待唤醒\n                                lock.wait();\n                            } catch (OutOfMemoryError x) { }\n                        } catch (InterruptedException x) { }\n                        continue;\n                    }\n                }\n\n                // Fast path for cleaners\n                if (r instanceof Cleaner) {\n                     //从头开始进行clena()调用\n                    ((Cleaner)r).clean();\n                    continue;\n                }\n\n                ReferenceQueue<Object> q = r.queue;\n                if (q != ReferenceQueue.NULL) q.enqueue(r);\n            }\n        }\n    }\n\n    static {\n        ThreadGroup tg = Thread.currentThread().getThreadGroup();\n        for (ThreadGroup tgn = tg;\n             tgn != null;\n             tg = tgn, tgn = tg.getParent());\n        Thread handler = new ReferenceHandler(tg, \"Reference Handler\");\n        /* If there were a special system-only priority greater than\n         * MAX_PRIORITY, it would be used here\n         */\n        handler.setPriority(Thread.MAX_PRIORITY);\n        handler.setDaemon(true);\n        handler.start();\n    }\n```\n可以看出来, JV会新建名为`Reference Handler`的线程, 时刻回收被挂到pending上面的虚拟引用。 当DirectByteBuff对象仅被Cleaner引用时, Cleaner被放入pending队列, 之后调用Cleaner.clean()队列\n```\n public void clean() {  //这里的clean(）会在Reference回收时显示调用\n        if (!remove(this))\n            return;\n        try {\n            thunk.run();\n        } catch (final Throwable x) {\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                    public Void run() {\n                        if (System.err != null)\n                            new Error(\"Cleaner terminated abnormally\", x)\n                                .printStackTrace();\n                        System.exit(1);\n                        return null;\n                    }});\n        }\n}\n//就是一个释放直接内存的线程\nprivate static class Deallocator  implements Runnable\n{\n\n        private static Unsafe unsafe = Unsafe.getUnsafe();\n\n        private long address;\n        private long size;\n        private int capacity;\n\n        private Deallocator(long address, long size, int capacity) {\n            assert (address != 0);\n            this.address = address;\n            this.size = size;\n            this.capacity = capacity;\n        }\n\n        public void run() {\n            if (address == 0) {\n                // Paranoia\n                return;\n            }\n            unsafe.freeMemory(address); //释放地址\n            address = 0;\n            Bits.unreserveMemory(size, capacity); //修改统计\n        }\n\n}\n\n```\n可以看到, 此时完成了DirectByteBuff直接内存的释放。\n\n可能有些人会好奇: 为什么IO操作不直接使用堆内内存? 这是因为堆内内存会发生GC移动操作, 对象移动后, 其绝对内存地址也会发生改变, 而gc时对象移动操作很频繁, 不可能每次移动堆内数据, IO时缓存的buffer也跟着一起移动。这样也是不合理的。 而IO操作直接使用堆外内存则没有了这一限制。同时jvm中IO操作的Buffer必须是DirectBuffer(可查看IO.write/read函数)\n# 总结\n在JVM中, 一般只有通过DirectByteBuffer这一种方式操作堆外内存, 平时说的堆外内存泄漏, 也就是指的DirectByteBuffer里面的堆外内存发生泄漏。合理使用DirectByteBuffer对通信框架有着很重要的帮助, 比如netty大量的IO数据传输, 都是通过DirectByteBuffer完成的。 直接内存的申请与释放比较代价比较大, 一般都会辅助对象池来尽量高效的利用申请的对象。\n","slug":"DirectByteBuffer堆外内存详解","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8vv0007phu5uojo41cd","content":"<p>我们知道, 在使用IO传输数据时, 首先会将数据传输到堆外直接内存中, 然后才通过网络发送出去。这样的话, 数据多了次中间copy, 能否不经过copy而直接将数据发送出去呢, 其实是可以的, 存放的位置就是本文要讲的主角:DirectByteBuffer 。JVM内存主要分为heap内存和堆外内存(一般我们也会称呼为直接内存), heap内存我们不用care, jvm能自动帮我们管理, 而堆外内存回收不受JVM GC控制, 因此, 堆外内存使用必须小心。本文就主要讲jvm中堆外内存的实现及原理。</p>\n<h2 id=\"DirectByteBuffer使用\"><a href=\"#DirectByteBuffer使用\" class=\"headerlink\" title=\"DirectByteBuffer使用\"></a>DirectByteBuffer使用</h2><p>在程序中, 我们可以通过如下方式获取到DirectByteBuffer, 并且直接作为IO的缓存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void sendAndRecv(String words) throws IOException</div><div class=\"line\">   &#123;</div><div class=\"line\">       byte[] msg = new String(words).getBytes();</div><div class=\"line\">       ByteBuffer buffer = ByteBuffer.allocateDirect(msg.length);</div><div class=\"line\">       buffer.put(msg);</div><div class=\"line\">       //读写模式相互转化写</div><div class=\"line\">       buffer.flip();</div><div class=\"line\">       System.out.println(&quot;Client sending: &quot; + words);</div><div class=\"line\">       channel.write(buffer);</div><div class=\"line\">       channel.close();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>DirectByteBuffer是不能直接被外界引用的, 类成员变量如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">DirectByteBuffer(int cap) &#123;</div><div class=\"line\">    super(-1, 0, cap, cap);</div><div class=\"line\">    //是否页对齐</div><div class=\"line\">    boolean pa = VM.isDirectMemoryPageAligned();</div><div class=\"line\">    //页的大小4K</div><div class=\"line\">    int ps = Bits.pageSize();</div><div class=\"line\">    //最小申请1K，若需要页对齐，那么多申请1页，以应对初始地址的页对齐问题</div><div class=\"line\">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</div><div class=\"line\">    //检查堆外内存是否够用, 并对分配的直接内存做一个记录</div><div class=\"line\">    Bits.reserveMemory(size, cap);</div><div class=\"line\">    long base = 0;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        //直接内存的初始地址, 返回初始地址</div><div class=\"line\">        base = unsafe.allocateMemory(size);</div><div class=\"line\">    &#125; catch (OutOfMemoryError x) &#123;</div><div class=\"line\">        Bits.unreserveMemory(size, cap);</div><div class=\"line\">        throw x;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //对直接内存初始化</div><div class=\"line\">    unsafe.setMemory(base, size, (byte) 0);</div><div class=\"line\">    //若需要页对其，并且不是页的整数倍，在需要将页对齐（默认是不需要进行页对齐的）</div><div class=\"line\">    if (pa &amp;&amp; (base % ps != 0)) &#123;</div><div class=\"line\">        // Round up to page boundary //初始地址取整页，注意申请的地址为取整数页</div><div class=\"line\">        address = base + ps - (base &amp; (ps - 1));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        address = base;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //声明一个Cleaner对象用于清理该DirectBuffer内存</div><div class=\"line\">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</div><div class=\"line\">    att = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, DirectByteBuffer通过直接调用base=unsafe.allocateMemory(size)操作堆外内存, 返回的是该堆外内存的直接地址, 存放在address中, 以便通过address进行堆外数据的读取与写入。 unsafe的使用可以参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">LockSupport原理分析</a><br>我们需要了解下, Bits.reserveMemory()如何判断堆外内存是否可用的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void reserveMemory(long size, int cap) &#123;  ////对分配的直接内存做一个记录</div><div class=\"line\">       synchronized (Bits.class) &#123;</div><div class=\"line\">           if (!memoryLimitSet &amp;&amp; VM.isBooted())</div><div class=\"line\">           &#123;</div><div class=\"line\">               //堆外直接内存默认等于堆内内存大小, 可以通过</div><div class=\"line\">               maxMemory = VM.maxDirectMemory();</div><div class=\"line\">               memoryLimitSet = true;</div><div class=\"line\">           &#125;</div><div class=\"line\">           // -XX:MaxDirectMemorySize limits the total capacity rather than the</div><div class=\"line\">           // actual memory usage, which will differ when buffers are page</div><div class=\"line\">           // aligned.</div><div class=\"line\">           //如果够分的话，则直接退出</div><div class=\"line\">           if (cap &lt;= maxMemory - totalCapacity) &#123;</div><div class=\"line\">               reservedMemory += size;</div><div class=\"line\">               totalCapacity += cap; //</div><div class=\"line\">               count++;</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       //不够分的话，则调用System.gc()进行一次full gc. 一般不要在线程启动时添加-XX:+DisableExplicitGC（禁止代码显示调用gc）</div><div class=\"line\">       System.gc(); //只是告知机器，这里应该GC一次， 但是实际并不一定进行垃圾回收</div><div class=\"line\">       try &#123;</div><div class=\"line\">            //再等待100ms使gc有时间完成，然后再看是否够分配</div><div class=\"line\">           Thread.sleep(100);</div><div class=\"line\">       &#125; catch (InterruptedException x) &#123;</div><div class=\"line\">           // Restore interrupt status</div><div class=\"line\">           Thread.currentThread().interrupt();</div><div class=\"line\">       &#125;</div><div class=\"line\">       synchronized (Bits.class) &#123;</div><div class=\"line\">           //此时不够分的话，再调用向外抛出oom</div><div class=\"line\">           if (totalCapacity + cap &gt; maxMemory)</div><div class=\"line\">               throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</div><div class=\"line\">           reservedMemory += size;</div><div class=\"line\">           totalCapacity += cap;</div><div class=\"line\">           count++;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ul>\n<li>首先检查堆外内存是否够分</li>\n<li>若不够分的话, 再进行一次full gc显示推动对堆外内存的回收, 再次尝试分配堆外内存, 不够分的话, 则抛出OOM异常。</li>\n</ul>\n<h1 id=\"堆外内存的回收\"><a href=\"#堆外内存的回收\" class=\"headerlink\" title=\"堆外内存的回收\"></a>堆外内存的回收</h1><p>在DirectByteBuffer的构造函数中, 我们可以看到这样的一行代码<code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code>, 没错, 直接内存释放主要由cleaner来完成。 我们知道JVM GC并不能直接释放直接内存, 但是GC可以释放管理直接内存的DirectByteBuffer对象。 我们需要注意下cleaner的类型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Cleaner  extends PhantomReference&lt;Object&gt;</div></pre></td></tr></table></figure></p>\n<p>PhantomReference并不会对对象的垃圾回收产生任何影响, 当进行gc完成后, 当发现某个对象只剩下虚引用后, 会将该引用迁移至Reference类的pending队列进行回收. 这里可以看到DirectByteBuffer被Cleaner引用着。Reference操作回收代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">static private class Lock &#123; &#125;;</div><div class=\"line\">private static Lock lock = new Lock();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/* List of References waiting to be enqueued.  The collector adds</div><div class=\"line\"> * References to this list, while the Reference-handler thread removes</div><div class=\"line\"> * them.  This list is protected by the above lock object. The</div><div class=\"line\"> * list uses the discovered field to link its elements.</div><div class=\"line\"> */</div><div class=\"line\">//当gc时，发现DirectByteBuffer除了PhantomReference对象引用,没有其他对象引用， 会把DirectByteBuffer放入其中，等待被回收</div><div class=\"line\">private static Reference&lt;Object&gt; pending = null;</div><div class=\"line\"></div><div class=\"line\">/* High-priority thread to enqueue pending References</div><div class=\"line\"> */</div><div class=\"line\">private static class ReferenceHandler extends Thread &#123;</div><div class=\"line\"></div><div class=\"line\">    ReferenceHandler(ThreadGroup g, String name) &#123;</div><div class=\"line\">        super(g, name);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            Reference&lt;Object&gt; r;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                if (pending != null) &#123;</div><div class=\"line\">                    r = pending;</div><div class=\"line\">                    pending = r.discovered;</div><div class=\"line\">                    r.discovered = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // The waiting on the lock may cause an OOME because it may try to allocate</div><div class=\"line\">                    // exception objects, so also catch OOME here to avoid silent exit of the</div><div class=\"line\">                    // reference handler thread.</div><div class=\"line\">                    //</div><div class=\"line\">                    // Explicitly define the order of the two exceptions we catch here</div><div class=\"line\">                    // when waiting for the lock.</div><div class=\"line\">                    //</div><div class=\"line\">                    // We do not want to try to potentially load the InterruptedException class</div><div class=\"line\">                    // (which would be done if this was its first use, and InterruptedException</div><div class=\"line\">                    // were checked first) in this situation.</div><div class=\"line\">                    //</div><div class=\"line\">                    // This may lead to the VM not ever trying to load the InterruptedException</div><div class=\"line\">                    // class again.</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                            //如果没有的话，会一直等待唤醒</div><div class=\"line\">                            lock.wait();</div><div class=\"line\">                        &#125; catch (OutOfMemoryError x) &#123; &#125;</div><div class=\"line\">                    &#125; catch (InterruptedException x) &#123; &#125;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Fast path for cleaners</div><div class=\"line\">            if (r instanceof Cleaner) &#123;</div><div class=\"line\">                 //从头开始进行clena()调用</div><div class=\"line\">                ((Cleaner)r).clean();</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            ReferenceQueue&lt;Object&gt; q = r.queue;</div><div class=\"line\">            if (q != ReferenceQueue.NULL) q.enqueue(r);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</div><div class=\"line\">    for (ThreadGroup tgn = tg;</div><div class=\"line\">         tgn != null;</div><div class=\"line\">         tg = tgn, tgn = tg.getParent());</div><div class=\"line\">    Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);</div><div class=\"line\">    /* If there were a special system-only priority greater than</div><div class=\"line\">     * MAX_PRIORITY, it would be used here</div><div class=\"line\">     */</div><div class=\"line\">    handler.setPriority(Thread.MAX_PRIORITY);</div><div class=\"line\">    handler.setDaemon(true);</div><div class=\"line\">    handler.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出来, JV会新建名为<code>Reference Handler</code>的线程, 时刻回收被挂到pending上面的虚拟引用。 当DirectByteBuff对象仅被Cleaner引用时, Cleaner被放入pending队列, 之后调用Cleaner.clean()队列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public void clean() &#123;  //这里的clean(）会在Reference回收时显示调用</div><div class=\"line\">        if (!remove(this))</div><div class=\"line\">            return;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            thunk.run();</div><div class=\"line\">        &#125; catch (final Throwable x) &#123;</div><div class=\"line\">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</div><div class=\"line\">                    public Void run() &#123;</div><div class=\"line\">                        if (System.err != null)</div><div class=\"line\">                            new Error(&quot;Cleaner terminated abnormally&quot;, x)</div><div class=\"line\">                                .printStackTrace();</div><div class=\"line\">                        System.exit(1);</div><div class=\"line\">                        return null;</div><div class=\"line\">                    &#125;&#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//就是一个释放直接内存的线程</div><div class=\"line\">private static class Deallocator  implements Runnable</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">        private static Unsafe unsafe = Unsafe.getUnsafe();</div><div class=\"line\"></div><div class=\"line\">        private long address;</div><div class=\"line\">        private long size;</div><div class=\"line\">        private int capacity;</div><div class=\"line\"></div><div class=\"line\">        private Deallocator(long address, long size, int capacity) &#123;</div><div class=\"line\">            assert (address != 0);</div><div class=\"line\">            this.address = address;</div><div class=\"line\">            this.size = size;</div><div class=\"line\">            this.capacity = capacity;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            if (address == 0) &#123;</div><div class=\"line\">                // Paranoia</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            unsafe.freeMemory(address); //释放地址</div><div class=\"line\">            address = 0;</div><div class=\"line\">            Bits.unreserveMemory(size, capacity); //修改统计</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, 此时完成了DirectByteBuff直接内存的释放。</p>\n<p>可能有些人会好奇: 为什么IO操作不直接使用堆内内存? 这是因为堆内内存会发生GC移动操作, 对象移动后, 其绝对内存地址也会发生改变, 而gc时对象移动操作很频繁, 不可能每次移动堆内数据, IO时缓存的buffer也跟着一起移动。这样也是不合理的。 而IO操作直接使用堆外内存则没有了这一限制。同时jvm中IO操作的Buffer必须是DirectBuffer(可查看IO.write/read函数)</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在JVM中, 一般只有通过DirectByteBuffer这一种方式操作堆外内存, 平时说的堆外内存泄漏, 也就是指的DirectByteBuffer里面的堆外内存发生泄漏。合理使用DirectByteBuffer对通信框架有着很重要的帮助, 比如netty大量的IO数据传输, 都是通过DirectByteBuffer完成的。 直接内存的申请与释放比较代价比较大, 一般都会辅助对象池来尽量高效的利用申请的对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们知道, 在使用IO传输数据时, 首先会将数据传输到堆外直接内存中, 然后才通过网络发送出去。这样的话, 数据多了次中间copy, 能否不经过copy而直接将数据发送出去呢, 其实是可以的, 存放的位置就是本文要讲的主角:DirectByteBuffer 。JVM内存主要分为heap内存和堆外内存(一般我们也会称呼为直接内存), heap内存我们不用care, jvm能自动帮我们管理, 而堆外内存回收不受JVM GC控制, 因此, 堆外内存使用必须小心。本文就主要讲jvm中堆外内存的实现及原理。</p>\n<h2 id=\"DirectByteBuffer使用\"><a href=\"#DirectByteBuffer使用\" class=\"headerlink\" title=\"DirectByteBuffer使用\"></a>DirectByteBuffer使用</h2><p>在程序中, 我们可以通过如下方式获取到DirectByteBuffer, 并且直接作为IO的缓存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void sendAndRecv(String words) throws IOException</div><div class=\"line\">   &#123;</div><div class=\"line\">       byte[] msg = new String(words).getBytes();</div><div class=\"line\">       ByteBuffer buffer = ByteBuffer.allocateDirect(msg.length);</div><div class=\"line\">       buffer.put(msg);</div><div class=\"line\">       //读写模式相互转化写</div><div class=\"line\">       buffer.flip();</div><div class=\"line\">       System.out.println(&quot;Client sending: &quot; + words);</div><div class=\"line\">       channel.write(buffer);</div><div class=\"line\">       channel.close();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>DirectByteBuffer是不能直接被外界引用的, 类成员变量如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">DirectByteBuffer(int cap) &#123;</div><div class=\"line\">    super(-1, 0, cap, cap);</div><div class=\"line\">    //是否页对齐</div><div class=\"line\">    boolean pa = VM.isDirectMemoryPageAligned();</div><div class=\"line\">    //页的大小4K</div><div class=\"line\">    int ps = Bits.pageSize();</div><div class=\"line\">    //最小申请1K，若需要页对齐，那么多申请1页，以应对初始地址的页对齐问题</div><div class=\"line\">    long size = Math.max(1L, (long)cap + (pa ? ps : 0));</div><div class=\"line\">    //检查堆外内存是否够用, 并对分配的直接内存做一个记录</div><div class=\"line\">    Bits.reserveMemory(size, cap);</div><div class=\"line\">    long base = 0;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        //直接内存的初始地址, 返回初始地址</div><div class=\"line\">        base = unsafe.allocateMemory(size);</div><div class=\"line\">    &#125; catch (OutOfMemoryError x) &#123;</div><div class=\"line\">        Bits.unreserveMemory(size, cap);</div><div class=\"line\">        throw x;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //对直接内存初始化</div><div class=\"line\">    unsafe.setMemory(base, size, (byte) 0);</div><div class=\"line\">    //若需要页对其，并且不是页的整数倍，在需要将页对齐（默认是不需要进行页对齐的）</div><div class=\"line\">    if (pa &amp;&amp; (base % ps != 0)) &#123;</div><div class=\"line\">        // Round up to page boundary //初始地址取整页，注意申请的地址为取整数页</div><div class=\"line\">        address = base + ps - (base &amp; (ps - 1));</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        address = base;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //声明一个Cleaner对象用于清理该DirectBuffer内存</div><div class=\"line\">    cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</div><div class=\"line\">    att = null;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, DirectByteBuffer通过直接调用base=unsafe.allocateMemory(size)操作堆外内存, 返回的是该堆外内存的直接地址, 存放在address中, 以便通过address进行堆外数据的读取与写入。 unsafe的使用可以参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/11/10/LockSupport%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">LockSupport原理分析</a><br>我们需要了解下, Bits.reserveMemory()如何判断堆外内存是否可用的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void reserveMemory(long size, int cap) &#123;  ////对分配的直接内存做一个记录</div><div class=\"line\">       synchronized (Bits.class) &#123;</div><div class=\"line\">           if (!memoryLimitSet &amp;&amp; VM.isBooted())</div><div class=\"line\">           &#123;</div><div class=\"line\">               //堆外直接内存默认等于堆内内存大小, 可以通过</div><div class=\"line\">               maxMemory = VM.maxDirectMemory();</div><div class=\"line\">               memoryLimitSet = true;</div><div class=\"line\">           &#125;</div><div class=\"line\">           // -XX:MaxDirectMemorySize limits the total capacity rather than the</div><div class=\"line\">           // actual memory usage, which will differ when buffers are page</div><div class=\"line\">           // aligned.</div><div class=\"line\">           //如果够分的话，则直接退出</div><div class=\"line\">           if (cap &lt;= maxMemory - totalCapacity) &#123;</div><div class=\"line\">               reservedMemory += size;</div><div class=\"line\">               totalCapacity += cap; //</div><div class=\"line\">               count++;</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       //不够分的话，则调用System.gc()进行一次full gc. 一般不要在线程启动时添加-XX:+DisableExplicitGC（禁止代码显示调用gc）</div><div class=\"line\">       System.gc(); //只是告知机器，这里应该GC一次， 但是实际并不一定进行垃圾回收</div><div class=\"line\">       try &#123;</div><div class=\"line\">            //再等待100ms使gc有时间完成，然后再看是否够分配</div><div class=\"line\">           Thread.sleep(100);</div><div class=\"line\">       &#125; catch (InterruptedException x) &#123;</div><div class=\"line\">           // Restore interrupt status</div><div class=\"line\">           Thread.currentThread().interrupt();</div><div class=\"line\">       &#125;</div><div class=\"line\">       synchronized (Bits.class) &#123;</div><div class=\"line\">           //此时不够分的话，再调用向外抛出oom</div><div class=\"line\">           if (totalCapacity + cap &gt; maxMemory)</div><div class=\"line\">               throw new OutOfMemoryError(&quot;Direct buffer memory&quot;);</div><div class=\"line\">           reservedMemory += size;</div><div class=\"line\">           totalCapacity += cap;</div><div class=\"line\">           count++;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ul>\n<li>首先检查堆外内存是否够分</li>\n<li>若不够分的话, 再进行一次full gc显示推动对堆外内存的回收, 再次尝试分配堆外内存, 不够分的话, 则抛出OOM异常。</li>\n</ul>\n<h1 id=\"堆外内存的回收\"><a href=\"#堆外内存的回收\" class=\"headerlink\" title=\"堆外内存的回收\"></a>堆外内存的回收</h1><p>在DirectByteBuffer的构造函数中, 我们可以看到这样的一行代码<code>cleaner = Cleaner.create(this, new Deallocator(base, size, cap));</code>, 没错, 直接内存释放主要由cleaner来完成。 我们知道JVM GC并不能直接释放直接内存, 但是GC可以释放管理直接内存的DirectByteBuffer对象。 我们需要注意下cleaner的类型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Cleaner  extends PhantomReference&lt;Object&gt;</div></pre></td></tr></table></figure></p>\n<p>PhantomReference并不会对对象的垃圾回收产生任何影响, 当进行gc完成后, 当发现某个对象只剩下虚引用后, 会将该引用迁移至Reference类的pending队列进行回收. 这里可以看到DirectByteBuffer被Cleaner引用着。Reference操作回收代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">static private class Lock &#123; &#125;;</div><div class=\"line\">private static Lock lock = new Lock();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/* List of References waiting to be enqueued.  The collector adds</div><div class=\"line\"> * References to this list, while the Reference-handler thread removes</div><div class=\"line\"> * them.  This list is protected by the above lock object. The</div><div class=\"line\"> * list uses the discovered field to link its elements.</div><div class=\"line\"> */</div><div class=\"line\">//当gc时，发现DirectByteBuffer除了PhantomReference对象引用,没有其他对象引用， 会把DirectByteBuffer放入其中，等待被回收</div><div class=\"line\">private static Reference&lt;Object&gt; pending = null;</div><div class=\"line\"></div><div class=\"line\">/* High-priority thread to enqueue pending References</div><div class=\"line\"> */</div><div class=\"line\">private static class ReferenceHandler extends Thread &#123;</div><div class=\"line\"></div><div class=\"line\">    ReferenceHandler(ThreadGroup g, String name) &#123;</div><div class=\"line\">        super(g, name);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            Reference&lt;Object&gt; r;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                if (pending != null) &#123;</div><div class=\"line\">                    r = pending;</div><div class=\"line\">                    pending = r.discovered;</div><div class=\"line\">                    r.discovered = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // The waiting on the lock may cause an OOME because it may try to allocate</div><div class=\"line\">                    // exception objects, so also catch OOME here to avoid silent exit of the</div><div class=\"line\">                    // reference handler thread.</div><div class=\"line\">                    //</div><div class=\"line\">                    // Explicitly define the order of the two exceptions we catch here</div><div class=\"line\">                    // when waiting for the lock.</div><div class=\"line\">                    //</div><div class=\"line\">                    // We do not want to try to potentially load the InterruptedException class</div><div class=\"line\">                    // (which would be done if this was its first use, and InterruptedException</div><div class=\"line\">                    // were checked first) in this situation.</div><div class=\"line\">                    //</div><div class=\"line\">                    // This may lead to the VM not ever trying to load the InterruptedException</div><div class=\"line\">                    // class again.</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        try &#123;</div><div class=\"line\">                            //如果没有的话，会一直等待唤醒</div><div class=\"line\">                            lock.wait();</div><div class=\"line\">                        &#125; catch (OutOfMemoryError x) &#123; &#125;</div><div class=\"line\">                    &#125; catch (InterruptedException x) &#123; &#125;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            // Fast path for cleaners</div><div class=\"line\">            if (r instanceof Cleaner) &#123;</div><div class=\"line\">                 //从头开始进行clena()调用</div><div class=\"line\">                ((Cleaner)r).clean();</div><div class=\"line\">                continue;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            ReferenceQueue&lt;Object&gt; q = r.queue;</div><div class=\"line\">            if (q != ReferenceQueue.NULL) q.enqueue(r);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">static &#123;</div><div class=\"line\">    ThreadGroup tg = Thread.currentThread().getThreadGroup();</div><div class=\"line\">    for (ThreadGroup tgn = tg;</div><div class=\"line\">         tgn != null;</div><div class=\"line\">         tg = tgn, tgn = tg.getParent());</div><div class=\"line\">    Thread handler = new ReferenceHandler(tg, &quot;Reference Handler&quot;);</div><div class=\"line\">    /* If there were a special system-only priority greater than</div><div class=\"line\">     * MAX_PRIORITY, it would be used here</div><div class=\"line\">     */</div><div class=\"line\">    handler.setPriority(Thread.MAX_PRIORITY);</div><div class=\"line\">    handler.setDaemon(true);</div><div class=\"line\">    handler.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出来, JV会新建名为<code>Reference Handler</code>的线程, 时刻回收被挂到pending上面的虚拟引用。 当DirectByteBuff对象仅被Cleaner引用时, Cleaner被放入pending队列, 之后调用Cleaner.clean()队列<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public void clean() &#123;  //这里的clean(）会在Reference回收时显示调用</div><div class=\"line\">        if (!remove(this))</div><div class=\"line\">            return;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            thunk.run();</div><div class=\"line\">        &#125; catch (final Throwable x) &#123;</div><div class=\"line\">            AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123;</div><div class=\"line\">                    public Void run() &#123;</div><div class=\"line\">                        if (System.err != null)</div><div class=\"line\">                            new Error(&quot;Cleaner terminated abnormally&quot;, x)</div><div class=\"line\">                                .printStackTrace();</div><div class=\"line\">                        System.exit(1);</div><div class=\"line\">                        return null;</div><div class=\"line\">                    &#125;&#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">//就是一个释放直接内存的线程</div><div class=\"line\">private static class Deallocator  implements Runnable</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">        private static Unsafe unsafe = Unsafe.getUnsafe();</div><div class=\"line\"></div><div class=\"line\">        private long address;</div><div class=\"line\">        private long size;</div><div class=\"line\">        private int capacity;</div><div class=\"line\"></div><div class=\"line\">        private Deallocator(long address, long size, int capacity) &#123;</div><div class=\"line\">            assert (address != 0);</div><div class=\"line\">            this.address = address;</div><div class=\"line\">            this.size = size;</div><div class=\"line\">            this.capacity = capacity;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        public void run() &#123;</div><div class=\"line\">            if (address == 0) &#123;</div><div class=\"line\">                // Paranoia</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            unsafe.freeMemory(address); //释放地址</div><div class=\"line\">            address = 0;</div><div class=\"line\">            Bits.unreserveMemory(size, capacity); //修改统计</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, 此时完成了DirectByteBuff直接内存的释放。</p>\n<p>可能有些人会好奇: 为什么IO操作不直接使用堆内内存? 这是因为堆内内存会发生GC移动操作, 对象移动后, 其绝对内存地址也会发生改变, 而gc时对象移动操作很频繁, 不可能每次移动堆内数据, IO时缓存的buffer也跟着一起移动。这样也是不合理的。 而IO操作直接使用堆外内存则没有了这一限制。同时jvm中IO操作的Buffer必须是DirectBuffer(可查看IO.write/read函数)</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>在JVM中, 一般只有通过DirectByteBuffer这一种方式操作堆外内存, 平时说的堆外内存泄漏, 也就是指的DirectByteBuffer里面的堆外内存发生泄漏。合理使用DirectByteBuffer对通信框架有着很重要的帮助, 比如netty大量的IO数据传输, 都是通过DirectByteBuffer完成的。 直接内存的申请与释放比较代价比较大, 一般都会辅助对象池来尽量高效的利用申请的对象。</p>\n"},{"title":"ES原理-下线节点时分片并发rebalance的思考","date":"2019-06-16T14:29:49.000Z","_content":"# 现象\n最近在下线ES5.6.8集群节点时候, 发现了一个很奇怪的现象, 我先把cluster参数给贴出来看下:\n```\nPUT _cluster/settings\n{\n    \"transient\": {\n        \"cluster\": {\n         \"routing\": {\n            \"rebalance\": {\n               \"enable\": \"all\"\n            },\n            \"allocation\": {\n               \"allow_rebalance\": \"always\",\n               \"cluster_concurrent_rebalance\": \"1\",\n               \"node_concurrent_recoveries\": \"1\",\n               \"node_initial_primaries_recoveries\": \"1\",\n               \"enable\": \"all\"\n            }\n         }\n      }\n    }\n}\n```\n然后我通过如下命令下线4个节点:\n```\nPUT _cluster/settings\n{\n    \"transient\": {\n         \"cluster.routing.allocation.exclude._ip\": \"ip1,ip2,ip3,ip4\"\n    }\n}\n```\n发现此时集群上这4个节点分别有一个分片开始进行move, what for? 按我们的理解, move操作的并发应该被我们通过参数`cluster_concurrent_rebalance`控制为1, 可是为啥为4。好像这个下线节点时候shard的并发与下线节点个数一致, 而不是受我们控制。\n\n# 源码查看\n带着上面的疑问, 试图从代码中找到原因, 我们知道, 任何集群元数据变动都会跳到BalancedShardsAllocator.allocate():\n```\n    public void allocate(RoutingAllocation allocation) {\n        if (allocation.routingNodes().size() == 0) {\n            /* with no nodes this is pointless */\n            return;\n        }\n        final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);\n        balancer.allocateUnassigned();\n        balancer.moveShards();\n        balancer.balance();\n    }\n```\n这里操作都是依据分片分配到各个节点的打分为依据来操作, 主要分为三步: 分配unassigned分片, move分片, 均衡分片。 在开始的现象, 明显不是第一步, 只可能是move分片、或者均衡分片。\n## move分片\n我们首先进入move分片看下能否解释现象:\n```\n        public void moveShards() {\n            // Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling\n            // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are\n            // offloading the shards.\n            //实际上，每次moveShards只会从每个node中选择一个shard迁移\n            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator(); it.hasNext(); ) {\n                ShardRouting shardRouting = it.next();\n                final MoveDecision moveDecision = decideMove(shardRouting);\n                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {\n                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());\n                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId());\n                    sourceNode.removeShard(shardRouting);\n                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),\n                        allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes());\n                    targetNode.addShard(relocatingShards.v2());\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Moved shard [{}] to node [{}]\", shardRouting, targetNode.getRoutingNode());\n                    }\n                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {\n                    logger.trace(\"[{}][{}] can't move\", shardRouting.index(), shardRouting.id());\n                }\n            }\n        }\n```\n这里我们需要注意一个事实: 这里轮训所有分片是有顺序的, 依次从每个节点上选择一个分片判断, 首先第一轮: 选择第一个节点上的第一个分片, 然后第二个节点上的第一个分片..., 最后一个节点的第一个分片, 再开始第二轮: 第一个节点上第二个分片......。\n然后再进入decideMove看下具体的move的逻辑:\n```\n        /**\n         * Makes a decision on whether to move a started shard to another node.  The following rules apply\n         * to the {@link MoveDecision} return object:\n         *   1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false.\n         *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and\n         *      {@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null.\n         *   3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be\n         *      populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then\n         *      {@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null.\n         *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then\n         *      {@link MoveDecision#nodeDecisions} will have a non-null value.\n         */\n        public MoveDecision decideMove(final ShardRouting shardRouting) {\n            if (shardRouting.started() == false) {\n                // we can only move started shards\n                return MoveDecision.NOT_TAKEN;\n            }\n            final boolean explain = allocation.debugDecision();\n            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());\n            assert sourceNode != null && sourceNode.containsShard(shardRouting);\n            RoutingNode routingNode = sourceNode.getRoutingNode();\n            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation);  //确定该节点是否还能存储在当前节点上\n            if (canRemain.type() != Decision.Type.NO) {\n                return MoveDecision.stay(canRemain);\n            }\n            sorter.reset(shardRouting.getIndexName());\n            /*\n             * the sorter holds the minimum weight node first for the shards index.\n             * We now walk through the nodes until we find a node to allocate the shard.\n             * This is not guaranteed to be balanced after this operation we still try best effort to\n             * allocate on the minimal eligible node.\n             */\n            Type bestDecision = Type.NO;\n            RoutingNode targetNode = null;\n            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null;\n            int weightRanking = 0;\n            for (ModelNode currentNode : sorter.modelNodes) {\n                if (currentNode != sourceNode) {\n                    RoutingNode target = currentNode.getRoutingNode();\n                    // don't use canRebalance as we want hard filtering rules to apply. See #17698\n                    // 查看当前分片\n                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);\n                    if (explain) {\n                        nodeExplanationMap.add(new NodeAllocationResult(\n                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking));\n                    }\n                    // TODO maybe we can respect throttling here too?\n                    if (allocationDecision.type().higherThan(bestDecision)) {\n                        bestDecision = allocationDecision.type();\n                        if (bestDecision == Type.YES) {\n                            targetNode = target;\n                            if (explain == false) {\n                                // we are not in explain mode and already have a YES decision on the best weighted node,\n                                // no need to continue iterating\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),\n                targetNode != null ? targetNode.node() : null, nodeExplanationMap);\n        }\n```\n该函数主要做了如下逻辑:\n+ 若该分片不处于Started, 那么将不进行move。\n+ 首先通过canRemain检查该分片是否还可以继续存留在该节点上, 主要由以下几个因素决定:\n1. awareness(机房)\n2. 磁盘空间\n3. ip排除(就是本次修改的参数)\n4. 每个节点上最多分配个数(total_shards_per_node)。\n很显然, 本次过程中ip排除了,那么该分片不能再待在本节点上了。\n+ 那么在所有节点上找一个节点, 该分片可以迁移上去。找的依据是canAllocate, canAllocate决定因素并没有包含cluster_concurrent_rebalance, 但是增加了node_concurrent_outgoing_recoveries、node_concurrent_incoming_recoveries。这两个参数的含义是: 决定分片是否可以分配到某个节点上的依据是该节点上正在迁入/迁出的分片是否达到阈值, 若没有达到阈值, 就可以分配。\n`重点:` 这就解释了为啥通过调整_ip时, 为啥不能通过cluster_concurrent_rebalance控制rebalance的并发了, ip调整时并发是通过迁入/迁出并发控制的, 也就是我们最开始观察到的现象, 正因为我们设置了node_concurrent_recoveries, 导致每个分片上迁出并发只能是1, 那么设置exclude.ip为4个时, 我们在前端看到有4个分片正处于rebalance。这里完全都没想过使用cluster_concurrent_rebalance来控制迁移并发的。这里不用cluster_concurrent_rebalance, 官方也给出了<a href=\"https://github.com/elastic/elasticsearch/pull/17698\">原因</a>:\n```\n#14259 added a check to honor rebalancing policies (i.e., rebalance only on green state) when moving shards due to changes in allocation filtering rules. The rebalancing policy is there to make sure that we don't try to even out the number of shards per node when we are still missing shards. However, it should not interfere with explicit user commands (allocation filtering) or things like the disk threshold wanting to move shards because of a node hitting the high water mark.\n#14259 was done to address #14057 where people reported that using allocation filtering caused many shards to be moved at once. This is however a none issue - with 1.7 (where the issue was reported) and 2.x, we protect recovery source nodes by limitting the number of concurrent data streams they can open (i.e., we can have many recoveries, but they will be throttled). In 5.0 we came up with a simpler and more understandable approach where we have a hard limit on the number of outgoing recoveries per node (on top of the incoming recoveries we already had).\n```\n大致就是说, rebalance策略主要是为了解决的是: 当我们未对全局分片有足够了解的时候(当全局分片并未处于完全均衡的时候), 我们并不会去干扰每个节点的分片个数。当然, rebalance更不应该去干扰显示的用户命令比如分片排除, 或者达到磁盘阈值这样的情况。这里并发是通过Incoming/OutComing这样的并发去控制的。原因清楚了吧。\n+ 找到一个可以迁移到分片后, 然后通过routingNodes.relocateShard修改relocatingShards值, 这个值就是我们在前端看到的正在rebalance的个数。\n\n## 均衡分片\n既然现象是由move分片来解释了, 那么我们也来了解均衡分片大致做了那些事情呢?\n+ 通过allocation.deciders().canRebalance(allocation).type() 首先检查是否可以进行rebalance。通过ClusterRebalanceType来控制:\n1. 若设置为ALWAYS, 那么是可以进行rebalance的。\n2. 若设置为INDICES_PRIMARIES_ACTIVE, 那么当只有所有主分片处于active的时候才可以进行rebalance的。\n3. 若设置为INDICES_ALL_ACTIVE, 那么是禁止rebalance的。\n+ 若可以进行rebalance, 然后进入balanceByWeights()。\n```\n        private void balanceByWeights() {\n            final AllocationDeciders deciders = allocation.deciders();\n            final ModelNode[] modelNodes = sorter.modelNodes;\n            final float[] weights = sorter.weights;\n            //轮训所有索引\n            for (String index : buildWeightOrderedIndices()) {\n                IndexMetaData indexMetaData = metaData.index(index);\n                // find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,\n                // move these nodes to the front of modelNodes so that we can only balance based on these nodes\n                // 首先选择与该索引有关的节点, 这些节点, 那么该索引有分配在上面分配, 要么该索引可以分配到该节点上。默认情况下, 除了exclude外, 所有节点都是相关的。\n                int relevantNodes = 0;\n                for (int i = 0; i < modelNodes.length; i++) {\n                    ModelNode modelNode = modelNodes[i];\n                    if (modelNode.getIndex(index) != null\n                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {\n                        // swap nodes at position i and relevantNodes\n                        modelNodes[i] = modelNodes[relevantNodes];\n                        modelNodes[relevantNodes] = modelNode;\n                        relevantNodes++;\n                    }\n                }\n                // 若相关节点少于2个,就没有rebalance的必要了\n                if (relevantNodes < 2) {\n                    continue;\n                }\n                // 对相关节点与该索引之间进行打分, 分值从最小到最大进行排序(分值越大说明分配越不合理)\n                sorter.reset(index, 0, relevantNodes);\n                int lowIdx = 0;\n                int highIdx = relevantNodes - 1;\n                while (true) {\n                    final ModelNode minNode = modelNodes[lowIdx];\n                    final ModelNode maxNode = modelNodes[highIdx];\n                    advance_range:\n                    // 假如最大分值的节点, 该索引有分片存在\n                    if (maxNode.numShards(index) > 0) {\n                        //计算最大和最小分值差大于阈值\n                        final float delta = absDelta(weights[lowIdx], weights[highIdx]);\n                        //若差值小于阈值1\n                        if (lessThan(delta, threshold)) {\n\n                            if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta?\n                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) // check if we need to break at all\n                                ) {  //low和high差距大于阈值，那么还是可以继续找的\n                                /* This is a special case if allocations from the \"heaviest\" to the \"lighter\" nodes is not possible\n                                 * due to some allocation decider restrictions like zone awareness. if one zone has for instance\n                                 * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we\n                                 * can't move to the \"lighter\" shards since otherwise the zone would go over capacity.\n                                 *\n                                 * This break jumps straight to the condition below were we start moving from the high index towards\n                                 * the low index to shrink the window we are considering for balance from the other direction.\n                                 * (check shrinking the window from MAX to MIN)\n                                 * See #3580\n                                 */\n                                break advance_range;\n                            }\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]\",\n                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n                            }\n                            break; //low和high差距小于阈值，那么完全不用找了。直接退出当前索引的rebalance，进行下一个索引的rebalance\n                        }\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]\",\n                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n                        }\n                        /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.\n                         * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */\n                        if (tryRelocateShard(minNode, maxNode, index, delta)) {\n                            /*\n                             * TODO we could be a bit smarter here, we don't need to fully sort necessarily\n                             * we could just find the place to insert linearly but the win might be minor\n                             * compared to the added complexity\n                             */\n                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx]);\n                            weights[highIdx] = sorter.weight(modelNodes[highIdx]);\n                            sorter.sort(0, relevantNodes);\n                            lowIdx = 0;\n                            highIdx = relevantNodes - 1;\n                            // 再继续查找当前索引在别的节点上是都有更合适的分配。\n                            continue;\n                        }\n                    }\n                    // 若没有分配, 则开始low+1 进行第二轮重新开始。\n                    //第一轮：首先第一轮从high不变， low每次增加1，向higt靠近，直到low和high一样， 第二轮：然后high--， 继续low向higt靠近；再第三轮，这样实际循环次数是(high-low)(high-low)/2, 很像一个倒着的乘法表\n                    if (lowIdx < highIdx - 1) {\n                        /* Shrinking the window from MIN to MAX\n                         * we can't move from any shard from the min node lets move on to the next node\n                         * and see if the threshold still holds. We either don't have any shard of this\n                         * index on this node of allocation deciders prevent any relocation.*/\n                        lowIdx++;\n                    } else if (lowIdx > 0) {\n                        /* Shrinking the window from MAX to MIN\n                         * now we go max to min since obviously we can't move anything to the max node\n                         * lets pick the next highest */\n                        lowIdx = 0;\n                        highIdx--;\n                    } else {\n                        /* we are done here, we either can't relocate anymore or we are balanced */\n                        break;\n                    }\n                }\n            }\n        }\n```\nrebalance时, 以index来循环, 大概逻辑就是:\n1. 针对每个索引在每个节点上分配进行一个打分。打分依据是(该索引是否在所有节点是否分配均衡&&所有shard是否在所有节点分配均衡), 分支越低, 说明分配越合理。\n2. 从分值高低差的阈值来判断是否需要rebalance。阈值为1。\n\n# 总结\nmove, rebalance, allocation等操作都是由多个决策器一起决定如何分配的, 只要合理使用各种决策器, 那么分片分配就能被我们合理的掌握了。\n","source":"_posts/ES原理-下线节点时分片并发rebalance的思考.md","raw":"---\ntitle: ES原理-下线节点时分片并发rebalance的思考\ndate: 2019-06-16 22:29:49\ntags:\n---\n# 现象\n最近在下线ES5.6.8集群节点时候, 发现了一个很奇怪的现象, 我先把cluster参数给贴出来看下:\n```\nPUT _cluster/settings\n{\n    \"transient\": {\n        \"cluster\": {\n         \"routing\": {\n            \"rebalance\": {\n               \"enable\": \"all\"\n            },\n            \"allocation\": {\n               \"allow_rebalance\": \"always\",\n               \"cluster_concurrent_rebalance\": \"1\",\n               \"node_concurrent_recoveries\": \"1\",\n               \"node_initial_primaries_recoveries\": \"1\",\n               \"enable\": \"all\"\n            }\n         }\n      }\n    }\n}\n```\n然后我通过如下命令下线4个节点:\n```\nPUT _cluster/settings\n{\n    \"transient\": {\n         \"cluster.routing.allocation.exclude._ip\": \"ip1,ip2,ip3,ip4\"\n    }\n}\n```\n发现此时集群上这4个节点分别有一个分片开始进行move, what for? 按我们的理解, move操作的并发应该被我们通过参数`cluster_concurrent_rebalance`控制为1, 可是为啥为4。好像这个下线节点时候shard的并发与下线节点个数一致, 而不是受我们控制。\n\n# 源码查看\n带着上面的疑问, 试图从代码中找到原因, 我们知道, 任何集群元数据变动都会跳到BalancedShardsAllocator.allocate():\n```\n    public void allocate(RoutingAllocation allocation) {\n        if (allocation.routingNodes().size() == 0) {\n            /* with no nodes this is pointless */\n            return;\n        }\n        final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);\n        balancer.allocateUnassigned();\n        balancer.moveShards();\n        balancer.balance();\n    }\n```\n这里操作都是依据分片分配到各个节点的打分为依据来操作, 主要分为三步: 分配unassigned分片, move分片, 均衡分片。 在开始的现象, 明显不是第一步, 只可能是move分片、或者均衡分片。\n## move分片\n我们首先进入move分片看下能否解释现象:\n```\n        public void moveShards() {\n            // Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling\n            // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are\n            // offloading the shards.\n            //实际上，每次moveShards只会从每个node中选择一个shard迁移\n            for (Iterator<ShardRouting> it = allocation.routingNodes().nodeInterleavedShardIterator(); it.hasNext(); ) {\n                ShardRouting shardRouting = it.next();\n                final MoveDecision moveDecision = decideMove(shardRouting);\n                if (moveDecision.isDecisionTaken() && moveDecision.forceMove()) {\n                    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());\n                    final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId());\n                    sourceNode.removeShard(shardRouting);\n                    Tuple<ShardRouting, ShardRouting> relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),\n                        allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes());\n                    targetNode.addShard(relocatingShards.v2());\n                    if (logger.isTraceEnabled()) {\n                        logger.trace(\"Moved shard [{}] to node [{}]\", shardRouting, targetNode.getRoutingNode());\n                    }\n                } else if (moveDecision.isDecisionTaken() && moveDecision.canRemain() == false) {\n                    logger.trace(\"[{}][{}] can't move\", shardRouting.index(), shardRouting.id());\n                }\n            }\n        }\n```\n这里我们需要注意一个事实: 这里轮训所有分片是有顺序的, 依次从每个节点上选择一个分片判断, 首先第一轮: 选择第一个节点上的第一个分片, 然后第二个节点上的第一个分片..., 最后一个节点的第一个分片, 再开始第二轮: 第一个节点上第二个分片......。\n然后再进入decideMove看下具体的move的逻辑:\n```\n        /**\n         * Makes a decision on whether to move a started shard to another node.  The following rules apply\n         * to the {@link MoveDecision} return object:\n         *   1. If the shard is not started, no decision will be taken and {@link MoveDecision#isDecisionTaken()} will return false.\n         *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and\n         *      {@link MoveDecision#canRemainDecision} will have a decision type of YES.  All other fields in the object will be null.\n         *   3. If the shard is not allowed to remain on its current node, then {@link MoveDecision#getAllocationDecision()} will be\n         *      populated with the decision of moving to another node.  If {@link MoveDecision#forceMove()} ()} returns {@code true}, then\n         *      {@link MoveDecision#targetNode} will return a non-null value, otherwise the assignedNodeId will be null.\n         *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then\n         *      {@link MoveDecision#nodeDecisions} will have a non-null value.\n         */\n        public MoveDecision decideMove(final ShardRouting shardRouting) {\n            if (shardRouting.started() == false) {\n                // we can only move started shards\n                return MoveDecision.NOT_TAKEN;\n            }\n            final boolean explain = allocation.debugDecision();\n            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());\n            assert sourceNode != null && sourceNode.containsShard(shardRouting);\n            RoutingNode routingNode = sourceNode.getRoutingNode();\n            Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation);  //确定该节点是否还能存储在当前节点上\n            if (canRemain.type() != Decision.Type.NO) {\n                return MoveDecision.stay(canRemain);\n            }\n            sorter.reset(shardRouting.getIndexName());\n            /*\n             * the sorter holds the minimum weight node first for the shards index.\n             * We now walk through the nodes until we find a node to allocate the shard.\n             * This is not guaranteed to be balanced after this operation we still try best effort to\n             * allocate on the minimal eligible node.\n             */\n            Type bestDecision = Type.NO;\n            RoutingNode targetNode = null;\n            final List<NodeAllocationResult> nodeExplanationMap = explain ? new ArrayList<>() : null;\n            int weightRanking = 0;\n            for (ModelNode currentNode : sorter.modelNodes) {\n                if (currentNode != sourceNode) {\n                    RoutingNode target = currentNode.getRoutingNode();\n                    // don't use canRebalance as we want hard filtering rules to apply. See #17698\n                    // 查看当前分片\n                    Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);\n                    if (explain) {\n                        nodeExplanationMap.add(new NodeAllocationResult(\n                            currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking));\n                    }\n                    // TODO maybe we can respect throttling here too?\n                    if (allocationDecision.type().higherThan(bestDecision)) {\n                        bestDecision = allocationDecision.type();\n                        if (bestDecision == Type.YES) {\n                            targetNode = target;\n                            if (explain == false) {\n                                // we are not in explain mode and already have a YES decision on the best weighted node,\n                                // no need to continue iterating\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),\n                targetNode != null ? targetNode.node() : null, nodeExplanationMap);\n        }\n```\n该函数主要做了如下逻辑:\n+ 若该分片不处于Started, 那么将不进行move。\n+ 首先通过canRemain检查该分片是否还可以继续存留在该节点上, 主要由以下几个因素决定:\n1. awareness(机房)\n2. 磁盘空间\n3. ip排除(就是本次修改的参数)\n4. 每个节点上最多分配个数(total_shards_per_node)。\n很显然, 本次过程中ip排除了,那么该分片不能再待在本节点上了。\n+ 那么在所有节点上找一个节点, 该分片可以迁移上去。找的依据是canAllocate, canAllocate决定因素并没有包含cluster_concurrent_rebalance, 但是增加了node_concurrent_outgoing_recoveries、node_concurrent_incoming_recoveries。这两个参数的含义是: 决定分片是否可以分配到某个节点上的依据是该节点上正在迁入/迁出的分片是否达到阈值, 若没有达到阈值, 就可以分配。\n`重点:` 这就解释了为啥通过调整_ip时, 为啥不能通过cluster_concurrent_rebalance控制rebalance的并发了, ip调整时并发是通过迁入/迁出并发控制的, 也就是我们最开始观察到的现象, 正因为我们设置了node_concurrent_recoveries, 导致每个分片上迁出并发只能是1, 那么设置exclude.ip为4个时, 我们在前端看到有4个分片正处于rebalance。这里完全都没想过使用cluster_concurrent_rebalance来控制迁移并发的。这里不用cluster_concurrent_rebalance, 官方也给出了<a href=\"https://github.com/elastic/elasticsearch/pull/17698\">原因</a>:\n```\n#14259 added a check to honor rebalancing policies (i.e., rebalance only on green state) when moving shards due to changes in allocation filtering rules. The rebalancing policy is there to make sure that we don't try to even out the number of shards per node when we are still missing shards. However, it should not interfere with explicit user commands (allocation filtering) or things like the disk threshold wanting to move shards because of a node hitting the high water mark.\n#14259 was done to address #14057 where people reported that using allocation filtering caused many shards to be moved at once. This is however a none issue - with 1.7 (where the issue was reported) and 2.x, we protect recovery source nodes by limitting the number of concurrent data streams they can open (i.e., we can have many recoveries, but they will be throttled). In 5.0 we came up with a simpler and more understandable approach where we have a hard limit on the number of outgoing recoveries per node (on top of the incoming recoveries we already had).\n```\n大致就是说, rebalance策略主要是为了解决的是: 当我们未对全局分片有足够了解的时候(当全局分片并未处于完全均衡的时候), 我们并不会去干扰每个节点的分片个数。当然, rebalance更不应该去干扰显示的用户命令比如分片排除, 或者达到磁盘阈值这样的情况。这里并发是通过Incoming/OutComing这样的并发去控制的。原因清楚了吧。\n+ 找到一个可以迁移到分片后, 然后通过routingNodes.relocateShard修改relocatingShards值, 这个值就是我们在前端看到的正在rebalance的个数。\n\n## 均衡分片\n既然现象是由move分片来解释了, 那么我们也来了解均衡分片大致做了那些事情呢?\n+ 通过allocation.deciders().canRebalance(allocation).type() 首先检查是否可以进行rebalance。通过ClusterRebalanceType来控制:\n1. 若设置为ALWAYS, 那么是可以进行rebalance的。\n2. 若设置为INDICES_PRIMARIES_ACTIVE, 那么当只有所有主分片处于active的时候才可以进行rebalance的。\n3. 若设置为INDICES_ALL_ACTIVE, 那么是禁止rebalance的。\n+ 若可以进行rebalance, 然后进入balanceByWeights()。\n```\n        private void balanceByWeights() {\n            final AllocationDeciders deciders = allocation.deciders();\n            final ModelNode[] modelNodes = sorter.modelNodes;\n            final float[] weights = sorter.weights;\n            //轮训所有索引\n            for (String index : buildWeightOrderedIndices()) {\n                IndexMetaData indexMetaData = metaData.index(index);\n                // find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,\n                // move these nodes to the front of modelNodes so that we can only balance based on these nodes\n                // 首先选择与该索引有关的节点, 这些节点, 那么该索引有分配在上面分配, 要么该索引可以分配到该节点上。默认情况下, 除了exclude外, 所有节点都是相关的。\n                int relevantNodes = 0;\n                for (int i = 0; i < modelNodes.length; i++) {\n                    ModelNode modelNode = modelNodes[i];\n                    if (modelNode.getIndex(index) != null\n                        || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) {\n                        // swap nodes at position i and relevantNodes\n                        modelNodes[i] = modelNodes[relevantNodes];\n                        modelNodes[relevantNodes] = modelNode;\n                        relevantNodes++;\n                    }\n                }\n                // 若相关节点少于2个,就没有rebalance的必要了\n                if (relevantNodes < 2) {\n                    continue;\n                }\n                // 对相关节点与该索引之间进行打分, 分值从最小到最大进行排序(分值越大说明分配越不合理)\n                sorter.reset(index, 0, relevantNodes);\n                int lowIdx = 0;\n                int highIdx = relevantNodes - 1;\n                while (true) {\n                    final ModelNode minNode = modelNodes[lowIdx];\n                    final ModelNode maxNode = modelNodes[highIdx];\n                    advance_range:\n                    // 假如最大分值的节点, 该索引有分片存在\n                    if (maxNode.numShards(index) > 0) {\n                        //计算最大和最小分值差大于阈值\n                        final float delta = absDelta(weights[lowIdx], weights[highIdx]);\n                        //若差值小于阈值1\n                        if (lessThan(delta, threshold)) {\n\n                            if (lowIdx > 0 && highIdx-1 > 0 // is there a chance for a higher delta?\n                                && (absDelta(weights[0], weights[highIdx-1]) > threshold) // check if we need to break at all\n                                ) {  //low和high差距大于阈值，那么还是可以继续找的\n                                /* This is a special case if allocations from the \"heaviest\" to the \"lighter\" nodes is not possible\n                                 * due to some allocation decider restrictions like zone awareness. if one zone has for instance\n                                 * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we\n                                 * can't move to the \"lighter\" shards since otherwise the zone would go over capacity.\n                                 *\n                                 * This break jumps straight to the condition below were we start moving from the high index towards\n                                 * the low index to shrink the window we are considering for balance from the other direction.\n                                 * (check shrinking the window from MAX to MIN)\n                                 * See #3580\n                                 */\n                                break advance_range;\n                            }\n                            if (logger.isTraceEnabled()) {\n                                logger.trace(\"Stop balancing index [{}]  min_node [{}] weight: [{}]  max_node [{}] weight: [{}]  delta: [{}]\",\n                                        index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n                            }\n                            break; //low和high差距小于阈值，那么完全不用找了。直接退出当前索引的rebalance，进行下一个索引的rebalance\n                        }\n                        if (logger.isTraceEnabled()) {\n                            logger.trace(\"Balancing from node [{}] weight: [{}] to node [{}] weight: [{}]  delta: [{}]\",\n                                    maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);\n                        }\n                        /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.\n                         * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */\n                        if (tryRelocateShard(minNode, maxNode, index, delta)) {\n                            /*\n                             * TODO we could be a bit smarter here, we don't need to fully sort necessarily\n                             * we could just find the place to insert linearly but the win might be minor\n                             * compared to the added complexity\n                             */\n                            weights[lowIdx] = sorter.weight(modelNodes[lowIdx]);\n                            weights[highIdx] = sorter.weight(modelNodes[highIdx]);\n                            sorter.sort(0, relevantNodes);\n                            lowIdx = 0;\n                            highIdx = relevantNodes - 1;\n                            // 再继续查找当前索引在别的节点上是都有更合适的分配。\n                            continue;\n                        }\n                    }\n                    // 若没有分配, 则开始low+1 进行第二轮重新开始。\n                    //第一轮：首先第一轮从high不变， low每次增加1，向higt靠近，直到low和high一样， 第二轮：然后high--， 继续low向higt靠近；再第三轮，这样实际循环次数是(high-low)(high-low)/2, 很像一个倒着的乘法表\n                    if (lowIdx < highIdx - 1) {\n                        /* Shrinking the window from MIN to MAX\n                         * we can't move from any shard from the min node lets move on to the next node\n                         * and see if the threshold still holds. We either don't have any shard of this\n                         * index on this node of allocation deciders prevent any relocation.*/\n                        lowIdx++;\n                    } else if (lowIdx > 0) {\n                        /* Shrinking the window from MAX to MIN\n                         * now we go max to min since obviously we can't move anything to the max node\n                         * lets pick the next highest */\n                        lowIdx = 0;\n                        highIdx--;\n                    } else {\n                        /* we are done here, we either can't relocate anymore or we are balanced */\n                        break;\n                    }\n                }\n            }\n        }\n```\nrebalance时, 以index来循环, 大概逻辑就是:\n1. 针对每个索引在每个节点上分配进行一个打分。打分依据是(该索引是否在所有节点是否分配均衡&&所有shard是否在所有节点分配均衡), 分支越低, 说明分配越合理。\n2. 从分值高低差的阈值来判断是否需要rebalance。阈值为1。\n\n# 总结\nmove, rebalance, allocation等操作都是由多个决策器一起决定如何分配的, 只要合理使用各种决策器, 那么分片分配就能被我们合理的掌握了。\n","slug":"ES原理-下线节点时分片并发rebalance的思考","published":1,"updated":"2019-06-24T00:43:49.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w00008phu5m3xpbisb","content":"<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>最近在下线ES5.6.8集群节点时候, 发现了一个很奇怪的现象, 我先把cluster参数给贴出来看下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">PUT _cluster/settings</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;transient&quot;: &#123;</div><div class=\"line\">        &quot;cluster&quot;: &#123;</div><div class=\"line\">         &quot;routing&quot;: &#123;</div><div class=\"line\">            &quot;rebalance&quot;: &#123;</div><div class=\"line\">               &quot;enable&quot;: &quot;all&quot;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            &quot;allocation&quot;: &#123;</div><div class=\"line\">               &quot;allow_rebalance&quot;: &quot;always&quot;,</div><div class=\"line\">               &quot;cluster_concurrent_rebalance&quot;: &quot;1&quot;,</div><div class=\"line\">               &quot;node_concurrent_recoveries&quot;: &quot;1&quot;,</div><div class=\"line\">               &quot;node_initial_primaries_recoveries&quot;: &quot;1&quot;,</div><div class=\"line\">               &quot;enable&quot;: &quot;all&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我通过如下命令下线4个节点:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PUT _cluster/settings</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;transient&quot;: &#123;</div><div class=\"line\">         &quot;cluster.routing.allocation.exclude._ip&quot;: &quot;ip1,ip2,ip3,ip4&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>发现此时集群上这4个节点分别有一个分片开始进行move, what for? 按我们的理解, move操作的并发应该被我们通过参数<code>cluster_concurrent_rebalance</code>控制为1, 可是为啥为4。好像这个下线节点时候shard的并发与下线节点个数一致, 而不是受我们控制。</p>\n<h1 id=\"源码查看\"><a href=\"#源码查看\" class=\"headerlink\" title=\"源码查看\"></a>源码查看</h1><p>带着上面的疑问, 试图从代码中找到原因, 我们知道, 任何集群元数据变动都会跳到BalancedShardsAllocator.allocate():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void allocate(RoutingAllocation allocation) &#123;</div><div class=\"line\">    if (allocation.routingNodes().size() == 0) &#123;</div><div class=\"line\">        /* with no nodes this is pointless */</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);</div><div class=\"line\">    balancer.allocateUnassigned();</div><div class=\"line\">    balancer.moveShards();</div><div class=\"line\">    balancer.balance();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里操作都是依据分片分配到各个节点的打分为依据来操作, 主要分为三步: 分配unassigned分片, move分片, 均衡分片。 在开始的现象, 明显不是第一步, 只可能是move分片、或者均衡分片。</p>\n<h2 id=\"move分片\"><a href=\"#move分片\" class=\"headerlink\" title=\"move分片\"></a>move分片</h2><p>我们首先进入move分片看下能否解释现象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void moveShards() &#123;</div><div class=\"line\">    // Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling</div><div class=\"line\">    // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are</div><div class=\"line\">    // offloading the shards.</div><div class=\"line\">    //实际上，每次moveShards只会从每个node中选择一个shard迁移</div><div class=\"line\">    for (Iterator&lt;ShardRouting&gt; it = allocation.routingNodes().nodeInterleavedShardIterator(); it.hasNext(); ) &#123;</div><div class=\"line\">        ShardRouting shardRouting = it.next();</div><div class=\"line\">        final MoveDecision moveDecision = decideMove(shardRouting);</div><div class=\"line\">        if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.forceMove()) &#123;</div><div class=\"line\">            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());</div><div class=\"line\">            final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId());</div><div class=\"line\">            sourceNode.removeShard(shardRouting);</div><div class=\"line\">            Tuple&lt;ShardRouting, ShardRouting&gt; relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),</div><div class=\"line\">                allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes());</div><div class=\"line\">            targetNode.addShard(relocatingShards.v2());</div><div class=\"line\">            if (logger.isTraceEnabled()) &#123;</div><div class=\"line\">                logger.trace(&quot;Moved shard [&#123;&#125;] to node [&#123;&#125;]&quot;, shardRouting, targetNode.getRoutingNode());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.canRemain() == false) &#123;</div><div class=\"line\">            logger.trace(&quot;[&#123;&#125;][&#123;&#125;] can&apos;t move&quot;, shardRouting.index(), shardRouting.id());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们需要注意一个事实: 这里轮训所有分片是有顺序的, 依次从每个节点上选择一个分片判断, 首先第一轮: 选择第一个节点上的第一个分片, 然后第二个节点上的第一个分片…, 最后一个节点的第一个分片, 再开始第二轮: 第一个节点上第二个分片……。<br>然后再进入decideMove看下具体的move的逻辑:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Makes a decision on whether to move a started shard to another node.  The following rules apply</div><div class=\"line\"> * to the &#123;@link MoveDecision&#125; return object:</div><div class=\"line\"> *   1. If the shard is not started, no decision will be taken and &#123;@link MoveDecision#isDecisionTaken()&#125; will return false.</div><div class=\"line\"> *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and</div><div class=\"line\"> *      &#123;@link MoveDecision#canRemainDecision&#125; will have a decision type of YES.  All other fields in the object will be null.</div><div class=\"line\"> *   3. If the shard is not allowed to remain on its current node, then &#123;@link MoveDecision#getAllocationDecision()&#125; will be</div><div class=\"line\"> *      populated with the decision of moving to another node.  If &#123;@link MoveDecision#forceMove()&#125; ()&#125; returns &#123;@code true&#125;, then</div><div class=\"line\"> *      &#123;@link MoveDecision#targetNode&#125; will return a non-null value, otherwise the assignedNodeId will be null.</div><div class=\"line\"> *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then</div><div class=\"line\"> *      &#123;@link MoveDecision#nodeDecisions&#125; will have a non-null value.</div><div class=\"line\"> */</div><div class=\"line\">public MoveDecision decideMove(final ShardRouting shardRouting) &#123;</div><div class=\"line\">    if (shardRouting.started() == false) &#123;</div><div class=\"line\">        // we can only move started shards</div><div class=\"line\">        return MoveDecision.NOT_TAKEN;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final boolean explain = allocation.debugDecision();</div><div class=\"line\">    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());</div><div class=\"line\">    assert sourceNode != null &amp;&amp; sourceNode.containsShard(shardRouting);</div><div class=\"line\">    RoutingNode routingNode = sourceNode.getRoutingNode();</div><div class=\"line\">    Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation);  //确定该节点是否还能存储在当前节点上</div><div class=\"line\">    if (canRemain.type() != Decision.Type.NO) &#123;</div><div class=\"line\">        return MoveDecision.stay(canRemain);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sorter.reset(shardRouting.getIndexName());</div><div class=\"line\">    /*</div><div class=\"line\">     * the sorter holds the minimum weight node first for the shards index.</div><div class=\"line\">     * We now walk through the nodes until we find a node to allocate the shard.</div><div class=\"line\">     * This is not guaranteed to be balanced after this operation we still try best effort to</div><div class=\"line\">     * allocate on the minimal eligible node.</div><div class=\"line\">     */</div><div class=\"line\">    Type bestDecision = Type.NO;</div><div class=\"line\">    RoutingNode targetNode = null;</div><div class=\"line\">    final List&lt;NodeAllocationResult&gt; nodeExplanationMap = explain ? new ArrayList&lt;&gt;() : null;</div><div class=\"line\">    int weightRanking = 0;</div><div class=\"line\">    for (ModelNode currentNode : sorter.modelNodes) &#123;</div><div class=\"line\">        if (currentNode != sourceNode) &#123;</div><div class=\"line\">            RoutingNode target = currentNode.getRoutingNode();</div><div class=\"line\">            // don&apos;t use canRebalance as we want hard filtering rules to apply. See #17698</div><div class=\"line\">            // 查看当前分片</div><div class=\"line\">            Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);</div><div class=\"line\">            if (explain) &#123;</div><div class=\"line\">                nodeExplanationMap.add(new NodeAllocationResult(</div><div class=\"line\">                    currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking));</div><div class=\"line\">            &#125;</div><div class=\"line\">            // TODO maybe we can respect throttling here too?</div><div class=\"line\">            if (allocationDecision.type().higherThan(bestDecision)) &#123;</div><div class=\"line\">                bestDecision = allocationDecision.type();</div><div class=\"line\">                if (bestDecision == Type.YES) &#123;</div><div class=\"line\">                    targetNode = target;</div><div class=\"line\">                    if (explain == false) &#123;</div><div class=\"line\">                        // we are not in explain mode and already have a YES decision on the best weighted node,</div><div class=\"line\">                        // no need to continue iterating</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),</div><div class=\"line\">        targetNode != null ? targetNode.node() : null, nodeExplanationMap);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下逻辑:</p>\n<ul>\n<li>若该分片不处于Started, 那么将不进行move。</li>\n<li>首先通过canRemain检查该分片是否还可以继续存留在该节点上, 主要由以下几个因素决定:</li>\n</ul>\n<ol>\n<li>awareness(机房)</li>\n<li>磁盘空间</li>\n<li>ip排除(就是本次修改的参数)</li>\n<li>每个节点上最多分配个数(total_shards_per_node)。<br>很显然, 本次过程中ip排除了,那么该分片不能再待在本节点上了。</li>\n</ol>\n<ul>\n<li>那么在所有节点上找一个节点, 该分片可以迁移上去。找的依据是canAllocate, canAllocate决定因素并没有包含cluster_concurrent_rebalance, 但是增加了node_concurrent_outgoing_recoveries、node_concurrent_incoming_recoveries。这两个参数的含义是: 决定分片是否可以分配到某个节点上的依据是该节点上正在迁入/迁出的分片是否达到阈值, 若没有达到阈值, 就可以分配。<br><code>重点:</code> 这就解释了为啥通过调整_ip时, 为啥不能通过cluster_concurrent_rebalance控制rebalance的并发了, ip调整时并发是通过迁入/迁出并发控制的, 也就是我们最开始观察到的现象, 正因为我们设置了node_concurrent_recoveries, 导致每个分片上迁出并发只能是1, 那么设置exclude.ip为4个时, 我们在前端看到有4个分片正处于rebalance。这里完全都没想过使用cluster_concurrent_rebalance来控制迁移并发的。这里不用cluster_concurrent_rebalance, 官方也给出了<a href=\"https://github.com/elastic/elasticsearch/pull/17698\" target=\"_blank\" rel=\"external\">原因</a>:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#14259 added a check to honor rebalancing policies (i.e., rebalance only on green state) when moving shards due to changes in allocation filtering rules. The rebalancing policy is there to make sure that we don&apos;t try to even out the number of shards per node when we are still missing shards. However, it should not interfere with explicit user commands (allocation filtering) or things like the disk threshold wanting to move shards because of a node hitting the high water mark.</div><div class=\"line\">#14259 was done to address #14057 where people reported that using allocation filtering caused many shards to be moved at once. This is however a none issue - with 1.7 (where the issue was reported) and 2.x, we protect recovery source nodes by limitting the number of concurrent data streams they can open (i.e., we can have many recoveries, but they will be throttled). In 5.0 we came up with a simpler and more understandable approach where we have a hard limit on the number of outgoing recoveries per node (on top of the incoming recoveries we already had).</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>大致就是说, rebalance策略主要是为了解决的是: 当我们未对全局分片有足够了解的时候(当全局分片并未处于完全均衡的时候), 我们并不会去干扰每个节点的分片个数。当然, rebalance更不应该去干扰显示的用户命令比如分片排除, 或者达到磁盘阈值这样的情况。这里并发是通过Incoming/OutComing这样的并发去控制的。原因清楚了吧。</p>\n<ul>\n<li>找到一个可以迁移到分片后, 然后通过routingNodes.relocateShard修改relocatingShards值, 这个值就是我们在前端看到的正在rebalance的个数。</li>\n</ul>\n<h2 id=\"均衡分片\"><a href=\"#均衡分片\" class=\"headerlink\" title=\"均衡分片\"></a>均衡分片</h2><p>既然现象是由move分片来解释了, 那么我们也来了解均衡分片大致做了那些事情呢?</p>\n<ul>\n<li>通过allocation.deciders().canRebalance(allocation).type() 首先检查是否可以进行rebalance。通过ClusterRebalanceType来控制:</li>\n</ul>\n<ol>\n<li>若设置为ALWAYS, 那么是可以进行rebalance的。</li>\n<li>若设置为INDICES_PRIMARIES_ACTIVE, 那么当只有所有主分片处于active的时候才可以进行rebalance的。</li>\n<li>若设置为INDICES_ALL_ACTIVE, 那么是禁止rebalance的。</li>\n</ol>\n<ul>\n<li>若可以进行rebalance, 然后进入balanceByWeights()。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void balanceByWeights() &#123;</div><div class=\"line\">    final AllocationDeciders deciders = allocation.deciders();</div><div class=\"line\">    final ModelNode[] modelNodes = sorter.modelNodes;</div><div class=\"line\">    final float[] weights = sorter.weights;</div><div class=\"line\">    //轮训所有索引</div><div class=\"line\">    for (String index : buildWeightOrderedIndices()) &#123;</div><div class=\"line\">        IndexMetaData indexMetaData = metaData.index(index);</div><div class=\"line\">        // find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,</div><div class=\"line\">        // move these nodes to the front of modelNodes so that we can only balance based on these nodes</div><div class=\"line\">        // 首先选择与该索引有关的节点, 这些节点, 那么该索引有分配在上面分配, 要么该索引可以分配到该节点上。默认情况下, 除了exclude外, 所有节点都是相关的。</div><div class=\"line\">        int relevantNodes = 0;</div><div class=\"line\">        for (int i = 0; i &lt; modelNodes.length; i++) &#123;</div><div class=\"line\">            ModelNode modelNode = modelNodes[i];</div><div class=\"line\">            if (modelNode.getIndex(index) != null</div><div class=\"line\">                || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) &#123;</div><div class=\"line\">                // swap nodes at position i and relevantNodes</div><div class=\"line\">                modelNodes[i] = modelNodes[relevantNodes];</div><div class=\"line\">                modelNodes[relevantNodes] = modelNode;</div><div class=\"line\">                relevantNodes++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 若相关节点少于2个,就没有rebalance的必要了</div><div class=\"line\">        if (relevantNodes &lt; 2) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 对相关节点与该索引之间进行打分, 分值从最小到最大进行排序(分值越大说明分配越不合理)</div><div class=\"line\">        sorter.reset(index, 0, relevantNodes);</div><div class=\"line\">        int lowIdx = 0;</div><div class=\"line\">        int highIdx = relevantNodes - 1;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            final ModelNode minNode = modelNodes[lowIdx];</div><div class=\"line\">            final ModelNode maxNode = modelNodes[highIdx];</div><div class=\"line\">            advance_range:</div><div class=\"line\">            // 假如最大分值的节点, 该索引有分片存在</div><div class=\"line\">            if (maxNode.numShards(index) &gt; 0) &#123;</div><div class=\"line\">                //计算最大和最小分值差大于阈值</div><div class=\"line\">                final float delta = absDelta(weights[lowIdx], weights[highIdx]);</div><div class=\"line\">                //若差值小于阈值1</div><div class=\"line\">                if (lessThan(delta, threshold)) &#123;</div><div class=\"line\"></div><div class=\"line\">                    if (lowIdx &gt; 0 &amp;&amp; highIdx-1 &gt; 0 // is there a chance for a higher delta?</div><div class=\"line\">                        &amp;&amp; (absDelta(weights[0], weights[highIdx-1]) &gt; threshold) // check if we need to break at all</div><div class=\"line\">                        ) &#123;  //low和high差距大于阈值，那么还是可以继续找的</div><div class=\"line\">                        /* This is a special case if allocations from the &quot;heaviest&quot; to the &quot;lighter&quot; nodes is not possible</div><div class=\"line\">                         * due to some allocation decider restrictions like zone awareness. if one zone has for instance</div><div class=\"line\">                         * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we</div><div class=\"line\">                         * can&apos;t move to the &quot;lighter&quot; shards since otherwise the zone would go over capacity.</div><div class=\"line\">                         *</div><div class=\"line\">                         * This break jumps straight to the condition below were we start moving from the high index towards</div><div class=\"line\">                         * the low index to shrink the window we are considering for balance from the other direction.</div><div class=\"line\">                         * (check shrinking the window from MAX to MIN)</div><div class=\"line\">                         * See #3580</div><div class=\"line\">                         */</div><div class=\"line\">                        break advance_range;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (logger.isTraceEnabled()) &#123;</div><div class=\"line\">                        logger.trace(&quot;Stop balancing index [&#123;&#125;]  min_node [&#123;&#125;] weight: [&#123;&#125;]  max_node [&#123;&#125;] weight: [&#123;&#125;]  delta: [&#123;&#125;]&quot;,</div><div class=\"line\">                                index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break; //low和high差距小于阈值，那么完全不用找了。直接退出当前索引的rebalance，进行下一个索引的rebalance</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (logger.isTraceEnabled()) &#123;</div><div class=\"line\">                    logger.trace(&quot;Balancing from node [&#123;&#125;] weight: [&#123;&#125;] to node [&#123;&#125;] weight: [&#123;&#125;]  delta: [&#123;&#125;]&quot;,</div><div class=\"line\">                            maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);</div><div class=\"line\">                &#125;</div><div class=\"line\">                /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.</div><div class=\"line\">                 * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */</div><div class=\"line\">                if (tryRelocateShard(minNode, maxNode, index, delta)) &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * TODO we could be a bit smarter here, we don&apos;t need to fully sort necessarily</div><div class=\"line\">                     * we could just find the place to insert linearly but the win might be minor</div><div class=\"line\">                     * compared to the added complexity</div><div class=\"line\">                     */</div><div class=\"line\">                    weights[lowIdx] = sorter.weight(modelNodes[lowIdx]);</div><div class=\"line\">                    weights[highIdx] = sorter.weight(modelNodes[highIdx]);</div><div class=\"line\">                    sorter.sort(0, relevantNodes);</div><div class=\"line\">                    lowIdx = 0;</div><div class=\"line\">                    highIdx = relevantNodes - 1;</div><div class=\"line\">                    // 再继续查找当前索引在别的节点上是都有更合适的分配。</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // 若没有分配, 则开始low+1 进行第二轮重新开始。</div><div class=\"line\">            //第一轮：首先第一轮从high不变， low每次增加1，向higt靠近，直到low和high一样， 第二轮：然后high--， 继续low向higt靠近；再第三轮，这样实际循环次数是(high-low)(high-low)/2, 很像一个倒着的乘法表</div><div class=\"line\">            if (lowIdx &lt; highIdx - 1) &#123;</div><div class=\"line\">                /* Shrinking the window from MIN to MAX</div><div class=\"line\">                 * we can&apos;t move from any shard from the min node lets move on to the next node</div><div class=\"line\">                 * and see if the threshold still holds. We either don&apos;t have any shard of this</div><div class=\"line\">                 * index on this node of allocation deciders prevent any relocation.*/</div><div class=\"line\">                lowIdx++;</div><div class=\"line\">            &#125; else if (lowIdx &gt; 0) &#123;</div><div class=\"line\">                /* Shrinking the window from MAX to MIN</div><div class=\"line\">                 * now we go max to min since obviously we can&apos;t move anything to the max node</div><div class=\"line\">                 * lets pick the next highest */</div><div class=\"line\">                lowIdx = 0;</div><div class=\"line\">                highIdx--;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                /* we are done here, we either can&apos;t relocate anymore or we are balanced */</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>rebalance时, 以index来循环, 大概逻辑就是:</p>\n<ol>\n<li>针对每个索引在每个节点上分配进行一个打分。打分依据是(该索引是否在所有节点是否分配均衡&amp;&amp;所有shard是否在所有节点分配均衡), 分支越低, 说明分配越合理。</li>\n<li>从分值高低差的阈值来判断是否需要rebalance。阈值为1。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>move, rebalance, allocation等操作都是由多个决策器一起决定如何分配的, 只要合理使用各种决策器, 那么分片分配就能被我们合理的掌握了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"现象\"><a href=\"#现象\" class=\"headerlink\" title=\"现象\"></a>现象</h1><p>最近在下线ES5.6.8集群节点时候, 发现了一个很奇怪的现象, 我先把cluster参数给贴出来看下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">PUT _cluster/settings</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;transient&quot;: &#123;</div><div class=\"line\">        &quot;cluster&quot;: &#123;</div><div class=\"line\">         &quot;routing&quot;: &#123;</div><div class=\"line\">            &quot;rebalance&quot;: &#123;</div><div class=\"line\">               &quot;enable&quot;: &quot;all&quot;</div><div class=\"line\">            &#125;,</div><div class=\"line\">            &quot;allocation&quot;: &#123;</div><div class=\"line\">               &quot;allow_rebalance&quot;: &quot;always&quot;,</div><div class=\"line\">               &quot;cluster_concurrent_rebalance&quot;: &quot;1&quot;,</div><div class=\"line\">               &quot;node_concurrent_recoveries&quot;: &quot;1&quot;,</div><div class=\"line\">               &quot;node_initial_primaries_recoveries&quot;: &quot;1&quot;,</div><div class=\"line\">               &quot;enable&quot;: &quot;all&quot;</div><div class=\"line\">            &#125;</div><div class=\"line\">         &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后我通过如下命令下线4个节点:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">PUT _cluster/settings</div><div class=\"line\">&#123;</div><div class=\"line\">    &quot;transient&quot;: &#123;</div><div class=\"line\">         &quot;cluster.routing.allocation.exclude._ip&quot;: &quot;ip1,ip2,ip3,ip4&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>发现此时集群上这4个节点分别有一个分片开始进行move, what for? 按我们的理解, move操作的并发应该被我们通过参数<code>cluster_concurrent_rebalance</code>控制为1, 可是为啥为4。好像这个下线节点时候shard的并发与下线节点个数一致, 而不是受我们控制。</p>\n<h1 id=\"源码查看\"><a href=\"#源码查看\" class=\"headerlink\" title=\"源码查看\"></a>源码查看</h1><p>带着上面的疑问, 试图从代码中找到原因, 我们知道, 任何集群元数据变动都会跳到BalancedShardsAllocator.allocate():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void allocate(RoutingAllocation allocation) &#123;</div><div class=\"line\">    if (allocation.routingNodes().size() == 0) &#123;</div><div class=\"line\">        /* with no nodes this is pointless */</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final Balancer balancer = new Balancer(logger, allocation, weightFunction, threshold);</div><div class=\"line\">    balancer.allocateUnassigned();</div><div class=\"line\">    balancer.moveShards();</div><div class=\"line\">    balancer.balance();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里操作都是依据分片分配到各个节点的打分为依据来操作, 主要分为三步: 分配unassigned分片, move分片, 均衡分片。 在开始的现象, 明显不是第一步, 只可能是move分片、或者均衡分片。</p>\n<h2 id=\"move分片\"><a href=\"#move分片\" class=\"headerlink\" title=\"move分片\"></a>move分片</h2><p>我们首先进入move分片看下能否解释现象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void moveShards() &#123;</div><div class=\"line\">    // Iterate over the started shards interleaving between nodes, and check if they can remain. In the presence of throttling</div><div class=\"line\">    // shard movements, the goal of this iteration order is to achieve a fairer movement of shards from the nodes that are</div><div class=\"line\">    // offloading the shards.</div><div class=\"line\">    //实际上，每次moveShards只会从每个node中选择一个shard迁移</div><div class=\"line\">    for (Iterator&lt;ShardRouting&gt; it = allocation.routingNodes().nodeInterleavedShardIterator(); it.hasNext(); ) &#123;</div><div class=\"line\">        ShardRouting shardRouting = it.next();</div><div class=\"line\">        final MoveDecision moveDecision = decideMove(shardRouting);</div><div class=\"line\">        if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.forceMove()) &#123;</div><div class=\"line\">            final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());</div><div class=\"line\">            final ModelNode targetNode = nodes.get(moveDecision.getTargetNode().getId());</div><div class=\"line\">            sourceNode.removeShard(shardRouting);</div><div class=\"line\">            Tuple&lt;ShardRouting, ShardRouting&gt; relocatingShards = routingNodes.relocateShard(shardRouting, targetNode.getNodeId(),</div><div class=\"line\">                allocation.clusterInfo().getShardSize(shardRouting, ShardRouting.UNAVAILABLE_EXPECTED_SHARD_SIZE), allocation.changes());</div><div class=\"line\">            targetNode.addShard(relocatingShards.v2());</div><div class=\"line\">            if (logger.isTraceEnabled()) &#123;</div><div class=\"line\">                logger.trace(&quot;Moved shard [&#123;&#125;] to node [&#123;&#125;]&quot;, shardRouting, targetNode.getRoutingNode());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (moveDecision.isDecisionTaken() &amp;&amp; moveDecision.canRemain() == false) &#123;</div><div class=\"line\">            logger.trace(&quot;[&#123;&#125;][&#123;&#125;] can&apos;t move&quot;, shardRouting.index(), shardRouting.id());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们需要注意一个事实: 这里轮训所有分片是有顺序的, 依次从每个节点上选择一个分片判断, 首先第一轮: 选择第一个节点上的第一个分片, 然后第二个节点上的第一个分片…, 最后一个节点的第一个分片, 再开始第二轮: 第一个节点上第二个分片……。<br>然后再进入decideMove看下具体的move的逻辑:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * Makes a decision on whether to move a started shard to another node.  The following rules apply</div><div class=\"line\"> * to the &#123;@link MoveDecision&#125; return object:</div><div class=\"line\"> *   1. If the shard is not started, no decision will be taken and &#123;@link MoveDecision#isDecisionTaken()&#125; will return false.</div><div class=\"line\"> *   2. If the shard is allowed to remain on its current node, no attempt will be made to move the shard and</div><div class=\"line\"> *      &#123;@link MoveDecision#canRemainDecision&#125; will have a decision type of YES.  All other fields in the object will be null.</div><div class=\"line\"> *   3. If the shard is not allowed to remain on its current node, then &#123;@link MoveDecision#getAllocationDecision()&#125; will be</div><div class=\"line\"> *      populated with the decision of moving to another node.  If &#123;@link MoveDecision#forceMove()&#125; ()&#125; returns &#123;@code true&#125;, then</div><div class=\"line\"> *      &#123;@link MoveDecision#targetNode&#125; will return a non-null value, otherwise the assignedNodeId will be null.</div><div class=\"line\"> *   4. If the method is invoked in explain mode (e.g. from the cluster allocation explain APIs), then</div><div class=\"line\"> *      &#123;@link MoveDecision#nodeDecisions&#125; will have a non-null value.</div><div class=\"line\"> */</div><div class=\"line\">public MoveDecision decideMove(final ShardRouting shardRouting) &#123;</div><div class=\"line\">    if (shardRouting.started() == false) &#123;</div><div class=\"line\">        // we can only move started shards</div><div class=\"line\">        return MoveDecision.NOT_TAKEN;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final boolean explain = allocation.debugDecision();</div><div class=\"line\">    final ModelNode sourceNode = nodes.get(shardRouting.currentNodeId());</div><div class=\"line\">    assert sourceNode != null &amp;&amp; sourceNode.containsShard(shardRouting);</div><div class=\"line\">    RoutingNode routingNode = sourceNode.getRoutingNode();</div><div class=\"line\">    Decision canRemain = allocation.deciders().canRemain(shardRouting, routingNode, allocation);  //确定该节点是否还能存储在当前节点上</div><div class=\"line\">    if (canRemain.type() != Decision.Type.NO) &#123;</div><div class=\"line\">        return MoveDecision.stay(canRemain);</div><div class=\"line\">    &#125;</div><div class=\"line\">    sorter.reset(shardRouting.getIndexName());</div><div class=\"line\">    /*</div><div class=\"line\">     * the sorter holds the minimum weight node first for the shards index.</div><div class=\"line\">     * We now walk through the nodes until we find a node to allocate the shard.</div><div class=\"line\">     * This is not guaranteed to be balanced after this operation we still try best effort to</div><div class=\"line\">     * allocate on the minimal eligible node.</div><div class=\"line\">     */</div><div class=\"line\">    Type bestDecision = Type.NO;</div><div class=\"line\">    RoutingNode targetNode = null;</div><div class=\"line\">    final List&lt;NodeAllocationResult&gt; nodeExplanationMap = explain ? new ArrayList&lt;&gt;() : null;</div><div class=\"line\">    int weightRanking = 0;</div><div class=\"line\">    for (ModelNode currentNode : sorter.modelNodes) &#123;</div><div class=\"line\">        if (currentNode != sourceNode) &#123;</div><div class=\"line\">            RoutingNode target = currentNode.getRoutingNode();</div><div class=\"line\">            // don&apos;t use canRebalance as we want hard filtering rules to apply. See #17698</div><div class=\"line\">            // 查看当前分片</div><div class=\"line\">            Decision allocationDecision = allocation.deciders().canAllocate(shardRouting, target, allocation);</div><div class=\"line\">            if (explain) &#123;</div><div class=\"line\">                nodeExplanationMap.add(new NodeAllocationResult(</div><div class=\"line\">                    currentNode.getRoutingNode().node(), allocationDecision, ++weightRanking));</div><div class=\"line\">            &#125;</div><div class=\"line\">            // TODO maybe we can respect throttling here too?</div><div class=\"line\">            if (allocationDecision.type().higherThan(bestDecision)) &#123;</div><div class=\"line\">                bestDecision = allocationDecision.type();</div><div class=\"line\">                if (bestDecision == Type.YES) &#123;</div><div class=\"line\">                    targetNode = target;</div><div class=\"line\">                    if (explain == false) &#123;</div><div class=\"line\">                        // we are not in explain mode and already have a YES decision on the best weighted node,</div><div class=\"line\">                        // no need to continue iterating</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return MoveDecision.cannotRemain(canRemain, AllocationDecision.fromDecisionType(bestDecision),</div><div class=\"line\">        targetNode != null ? targetNode.node() : null, nodeExplanationMap);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下逻辑:</p>\n<ul>\n<li>若该分片不处于Started, 那么将不进行move。</li>\n<li>首先通过canRemain检查该分片是否还可以继续存留在该节点上, 主要由以下几个因素决定:</li>\n</ul>\n<ol>\n<li>awareness(机房)</li>\n<li>磁盘空间</li>\n<li>ip排除(就是本次修改的参数)</li>\n<li>每个节点上最多分配个数(total_shards_per_node)。<br>很显然, 本次过程中ip排除了,那么该分片不能再待在本节点上了。</li>\n</ol>\n<ul>\n<li>那么在所有节点上找一个节点, 该分片可以迁移上去。找的依据是canAllocate, canAllocate决定因素并没有包含cluster_concurrent_rebalance, 但是增加了node_concurrent_outgoing_recoveries、node_concurrent_incoming_recoveries。这两个参数的含义是: 决定分片是否可以分配到某个节点上的依据是该节点上正在迁入/迁出的分片是否达到阈值, 若没有达到阈值, 就可以分配。<br><code>重点:</code> 这就解释了为啥通过调整_ip时, 为啥不能通过cluster_concurrent_rebalance控制rebalance的并发了, ip调整时并发是通过迁入/迁出并发控制的, 也就是我们最开始观察到的现象, 正因为我们设置了node_concurrent_recoveries, 导致每个分片上迁出并发只能是1, 那么设置exclude.ip为4个时, 我们在前端看到有4个分片正处于rebalance。这里完全都没想过使用cluster_concurrent_rebalance来控制迁移并发的。这里不用cluster_concurrent_rebalance, 官方也给出了<a href=\"https://github.com/elastic/elasticsearch/pull/17698\" target=\"_blank\" rel=\"external\">原因</a>:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#14259 added a check to honor rebalancing policies (i.e., rebalance only on green state) when moving shards due to changes in allocation filtering rules. The rebalancing policy is there to make sure that we don&apos;t try to even out the number of shards per node when we are still missing shards. However, it should not interfere with explicit user commands (allocation filtering) or things like the disk threshold wanting to move shards because of a node hitting the high water mark.</div><div class=\"line\">#14259 was done to address #14057 where people reported that using allocation filtering caused many shards to be moved at once. This is however a none issue - with 1.7 (where the issue was reported) and 2.x, we protect recovery source nodes by limitting the number of concurrent data streams they can open (i.e., we can have many recoveries, but they will be throttled). In 5.0 we came up with a simpler and more understandable approach where we have a hard limit on the number of outgoing recoveries per node (on top of the incoming recoveries we already had).</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>大致就是说, rebalance策略主要是为了解决的是: 当我们未对全局分片有足够了解的时候(当全局分片并未处于完全均衡的时候), 我们并不会去干扰每个节点的分片个数。当然, rebalance更不应该去干扰显示的用户命令比如分片排除, 或者达到磁盘阈值这样的情况。这里并发是通过Incoming/OutComing这样的并发去控制的。原因清楚了吧。</p>\n<ul>\n<li>找到一个可以迁移到分片后, 然后通过routingNodes.relocateShard修改relocatingShards值, 这个值就是我们在前端看到的正在rebalance的个数。</li>\n</ul>\n<h2 id=\"均衡分片\"><a href=\"#均衡分片\" class=\"headerlink\" title=\"均衡分片\"></a>均衡分片</h2><p>既然现象是由move分片来解释了, 那么我们也来了解均衡分片大致做了那些事情呢?</p>\n<ul>\n<li>通过allocation.deciders().canRebalance(allocation).type() 首先检查是否可以进行rebalance。通过ClusterRebalanceType来控制:</li>\n</ul>\n<ol>\n<li>若设置为ALWAYS, 那么是可以进行rebalance的。</li>\n<li>若设置为INDICES_PRIMARIES_ACTIVE, 那么当只有所有主分片处于active的时候才可以进行rebalance的。</li>\n<li>若设置为INDICES_ALL_ACTIVE, 那么是禁止rebalance的。</li>\n</ol>\n<ul>\n<li>若可以进行rebalance, 然后进入balanceByWeights()。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void balanceByWeights() &#123;</div><div class=\"line\">    final AllocationDeciders deciders = allocation.deciders();</div><div class=\"line\">    final ModelNode[] modelNodes = sorter.modelNodes;</div><div class=\"line\">    final float[] weights = sorter.weights;</div><div class=\"line\">    //轮训所有索引</div><div class=\"line\">    for (String index : buildWeightOrderedIndices()) &#123;</div><div class=\"line\">        IndexMetaData indexMetaData = metaData.index(index);</div><div class=\"line\">        // find nodes that have a shard of this index or where shards of this index are allowed to be allocated to,</div><div class=\"line\">        // move these nodes to the front of modelNodes so that we can only balance based on these nodes</div><div class=\"line\">        // 首先选择与该索引有关的节点, 这些节点, 那么该索引有分配在上面分配, 要么该索引可以分配到该节点上。默认情况下, 除了exclude外, 所有节点都是相关的。</div><div class=\"line\">        int relevantNodes = 0;</div><div class=\"line\">        for (int i = 0; i &lt; modelNodes.length; i++) &#123;</div><div class=\"line\">            ModelNode modelNode = modelNodes[i];</div><div class=\"line\">            if (modelNode.getIndex(index) != null</div><div class=\"line\">                || deciders.canAllocate(indexMetaData, modelNode.getRoutingNode(), allocation).type() != Type.NO) &#123;</div><div class=\"line\">                // swap nodes at position i and relevantNodes</div><div class=\"line\">                modelNodes[i] = modelNodes[relevantNodes];</div><div class=\"line\">                modelNodes[relevantNodes] = modelNode;</div><div class=\"line\">                relevantNodes++;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 若相关节点少于2个,就没有rebalance的必要了</div><div class=\"line\">        if (relevantNodes &lt; 2) &#123;</div><div class=\"line\">            continue;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // 对相关节点与该索引之间进行打分, 分值从最小到最大进行排序(分值越大说明分配越不合理)</div><div class=\"line\">        sorter.reset(index, 0, relevantNodes);</div><div class=\"line\">        int lowIdx = 0;</div><div class=\"line\">        int highIdx = relevantNodes - 1;</div><div class=\"line\">        while (true) &#123;</div><div class=\"line\">            final ModelNode minNode = modelNodes[lowIdx];</div><div class=\"line\">            final ModelNode maxNode = modelNodes[highIdx];</div><div class=\"line\">            advance_range:</div><div class=\"line\">            // 假如最大分值的节点, 该索引有分片存在</div><div class=\"line\">            if (maxNode.numShards(index) &gt; 0) &#123;</div><div class=\"line\">                //计算最大和最小分值差大于阈值</div><div class=\"line\">                final float delta = absDelta(weights[lowIdx], weights[highIdx]);</div><div class=\"line\">                //若差值小于阈值1</div><div class=\"line\">                if (lessThan(delta, threshold)) &#123;</div><div class=\"line\"></div><div class=\"line\">                    if (lowIdx &gt; 0 &amp;&amp; highIdx-1 &gt; 0 // is there a chance for a higher delta?</div><div class=\"line\">                        &amp;&amp; (absDelta(weights[0], weights[highIdx-1]) &gt; threshold) // check if we need to break at all</div><div class=\"line\">                        ) &#123;  //low和high差距大于阈值，那么还是可以继续找的</div><div class=\"line\">                        /* This is a special case if allocations from the &quot;heaviest&quot; to the &quot;lighter&quot; nodes is not possible</div><div class=\"line\">                         * due to some allocation decider restrictions like zone awareness. if one zone has for instance</div><div class=\"line\">                         * less nodes than another zone. so one zone is horribly overloaded from a balanced perspective but we</div><div class=\"line\">                         * can&apos;t move to the &quot;lighter&quot; shards since otherwise the zone would go over capacity.</div><div class=\"line\">                         *</div><div class=\"line\">                         * This break jumps straight to the condition below were we start moving from the high index towards</div><div class=\"line\">                         * the low index to shrink the window we are considering for balance from the other direction.</div><div class=\"line\">                         * (check shrinking the window from MAX to MIN)</div><div class=\"line\">                         * See #3580</div><div class=\"line\">                         */</div><div class=\"line\">                        break advance_range;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    if (logger.isTraceEnabled()) &#123;</div><div class=\"line\">                        logger.trace(&quot;Stop balancing index [&#123;&#125;]  min_node [&#123;&#125;] weight: [&#123;&#125;]  max_node [&#123;&#125;] weight: [&#123;&#125;]  delta: [&#123;&#125;]&quot;,</div><div class=\"line\">                                index, maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break; //low和high差距小于阈值，那么完全不用找了。直接退出当前索引的rebalance，进行下一个索引的rebalance</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (logger.isTraceEnabled()) &#123;</div><div class=\"line\">                    logger.trace(&quot;Balancing from node [&#123;&#125;] weight: [&#123;&#125;] to node [&#123;&#125;] weight: [&#123;&#125;]  delta: [&#123;&#125;]&quot;,</div><div class=\"line\">                            maxNode.getNodeId(), weights[highIdx], minNode.getNodeId(), weights[lowIdx], delta);</div><div class=\"line\">                &#125;</div><div class=\"line\">                /* pass the delta to the replication function to prevent relocations that only swap the weights of the two nodes.</div><div class=\"line\">                 * a relocation must bring us closer to the balance if we only achieve the same delta the relocation is useless */</div><div class=\"line\">                if (tryRelocateShard(minNode, maxNode, index, delta)) &#123;</div><div class=\"line\">                    /*</div><div class=\"line\">                     * TODO we could be a bit smarter here, we don&apos;t need to fully sort necessarily</div><div class=\"line\">                     * we could just find the place to insert linearly but the win might be minor</div><div class=\"line\">                     * compared to the added complexity</div><div class=\"line\">                     */</div><div class=\"line\">                    weights[lowIdx] = sorter.weight(modelNodes[lowIdx]);</div><div class=\"line\">                    weights[highIdx] = sorter.weight(modelNodes[highIdx]);</div><div class=\"line\">                    sorter.sort(0, relevantNodes);</div><div class=\"line\">                    lowIdx = 0;</div><div class=\"line\">                    highIdx = relevantNodes - 1;</div><div class=\"line\">                    // 再继续查找当前索引在别的节点上是都有更合适的分配。</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // 若没有分配, 则开始low+1 进行第二轮重新开始。</div><div class=\"line\">            //第一轮：首先第一轮从high不变， low每次增加1，向higt靠近，直到low和high一样， 第二轮：然后high--， 继续low向higt靠近；再第三轮，这样实际循环次数是(high-low)(high-low)/2, 很像一个倒着的乘法表</div><div class=\"line\">            if (lowIdx &lt; highIdx - 1) &#123;</div><div class=\"line\">                /* Shrinking the window from MIN to MAX</div><div class=\"line\">                 * we can&apos;t move from any shard from the min node lets move on to the next node</div><div class=\"line\">                 * and see if the threshold still holds. We either don&apos;t have any shard of this</div><div class=\"line\">                 * index on this node of allocation deciders prevent any relocation.*/</div><div class=\"line\">                lowIdx++;</div><div class=\"line\">            &#125; else if (lowIdx &gt; 0) &#123;</div><div class=\"line\">                /* Shrinking the window from MAX to MIN</div><div class=\"line\">                 * now we go max to min since obviously we can&apos;t move anything to the max node</div><div class=\"line\">                 * lets pick the next highest */</div><div class=\"line\">                lowIdx = 0;</div><div class=\"line\">                highIdx--;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                /* we are done here, we either can&apos;t relocate anymore or we are balanced */</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>rebalance时, 以index来循环, 大概逻辑就是:</p>\n<ol>\n<li>针对每个索引在每个节点上分配进行一个打分。打分依据是(该索引是否在所有节点是否分配均衡&amp;&amp;所有shard是否在所有节点分配均衡), 分支越低, 说明分配越合理。</li>\n<li>从分值高低差的阈值来判断是否需要rebalance。阈值为1。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>move, rebalance, allocation等操作都是由多个决策器一起决定如何分配的, 只要合理使用各种决策器, 那么分片分配就能被我们合理的掌握了。</p>\n"},{"title":"ES索引创建流程","date":"2017-12-17T15:25:54.000Z","_content":"","source":"_posts/ES索引创建流程.md","raw":"---\ntitle: ES索引创建流程\ndate: 2017-12-17 23:25:54\ntags:\n---\n","slug":"ES索引创建流程","published":1,"updated":"2019-06-05T11:00:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w10009phu5zyez85ke","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Flink原理-Akka通信&TaskManager注册","date":"2019-04-20T15:16:59.000Z","toc":true,"_content":"Flink对于JobManager和TaskManager之间通信采用Akka remote实现, 本文将以tm和jm之间的一次远程通信为示例进行讲解。为了读者更好地理解, 本文首先介绍AKKa相关基本知识。\n# Akka基础学习\n本文首先以hello world为例进行讲解:\n```\npublic class hello {\n    public static void main(String[] args) {\n        // 创建系统\n        final ActorSystem system = ActorSystem.create(\"hello\");\n        // 创建消息角色(): greeter1, 接受消息处理类: Greeter\n        final ActorRef greeter1 = system.actorOf(Props.create(Greeter.class), \"Sender1\");\n        final ActorRef greeter2 = system.actorOf(Props.create(Greeter.class), \"Sender2\");\n        //消息发送greeter1 ->  greeter2, 消息内容\"tell1\"\n        greeter2.tell(\"tell1\", greeter1);\n\n        //通过ask, 表示角色发送完消息, 希望对方返回。\n        Future<String> future  = Patterns.ask(greeter1, \"ask1\", 5000).<String>mapTo(ClassTag$.MODULE$.<String>apply(String.class));\n        future.onComplete(new OnComplete<String>() {\n            public void onComplete(Throwable throwable, String o) throws Throwable {\n                if (throwable == null) {\n                    System.out.println(o);\n                }\n            }\n        }, system.dispatcher());\n\n        //获取greeter1的绝对路径\n        String url = greeter1.path().parent().toString()+\"/\"+greeter1.path().name()+\"#\"+greeter1.path().uid();\n        // 通过actorSelection, 可以查找角色, 这个函数比较重要, 我们只知道某个角色的绝对路径, 我们通过该函数, 就可以获取到该角色。一般用于远程数据传输。\n        ActorSelection actorSelection = system.actorSelection(url);\n        Future<ActorIdentity> identify  = Patterns.ask(actorSelection, new Identify(1), 5000).<ActorIdentity>mapTo(ClassTag$.MODULE$.<ActorIdentity>apply(ActorIdentity.class));\n        identify.onComplete(new OnComplete<ActorIdentity>() {\n            public void onComplete(Throwable throwable, ActorIdentity o) throws Throwable {\n                if (throwable != null) {\n                } else {\n                    // 我们可以对比发现, 之前那个角色通过绝对路径获取到了。\n                    ActorRef actorRef = o.getRef();\n                    System.out.println(\"system.actorSelection verify:\" + (actorRef==greeter1));\n                }\n            }\n        }, system.dispatcher());\n    }\n    //消息处理类, 必须继承UntypedActor\n    public static class Greeter extends UntypedActor {\n        // 消息角色真正接收到数据的函数\n        public void onReceive(Object message) {\n            if(message instanceof String && ((String)message).equals(\"tell1\")) {\n                System.out.println(message);\n                getSender().tell(\"word2\", getSelf());\n            } else if(message instanceof String && ((String)message).equals(\"ask1\")) {\n                System.out.println(message);\n                // getSelf()表示本角色\n                getSender().tell(\"Patterns.ask()\", getSelf());\n            } else {\n                System.out.println(\"unhandled:\" + message);\n                unhandled(message);\n            }\n        }\n    }\n}\n```\n输出为:\n```\ntell1\nunhandled:word2\nask1\nPatterns.ask()\nsystem.actorSelection verify:true\n```\n1. 在使用actorSelection函数的时候, 我们需要了解一个关键字<a href=\"https://doc.akka.io/docs/akka/2.3.6/java/untyped-actors.html#actorselection-java\">Identify</a>, 它被定义为每个角色都知道其含义的消息, 当接收到Identify时, 角色自动回复ActorIdentity, 其中包含着对地址的角色。actorSelection可以获取该角色的引用, 这样就可以首先和该角色通信了。\n2. ask和tell的区别是, ask希望对方角色返回结果, 而tell不需要返回结果。\n\n# Akka RPC通信过程\n## AkkaRpcService和RpcServer\n在正式介绍之前, 先介绍AkkaRpcService, 作为Flink Akka通信核心类, 它包含了akka通信系统ActorSystem, 任何角色产生, 都会调用RpcService.startServer\n```\n    public <C extends RpcEndpoint & RpcGateway> RpcServer startServer(C rpcEndpoint) {\n\t\tCompletableFuture<Void> terminationFuture = new CompletableFuture<>();\n\t\tfinal Props akkaRpcActorProps;\n\t\tif (rpcEndpoint instanceof FencedRpcEndpoint) {\n\t\t\takkaRpcActorProps = Props.create(FencedAkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());\n\t\t} else {\n\t\t\takkaRpcActorProps = Props.create(AkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());\n\t\t}\n\t\tActorRef actorRef;\n\t\tsynchronized (lock) {\n\t\t\tactorRef = actorSystem.actorOf(akkaRpcActorProps, rpcEndpoint.getEndpointId());\n\t\t\tactors.put(actorRef, rpcEndpoint);\n\t\t}\n\t\tLOG.info(\"Starting RPC endpoint for {} at {} .\", rpcEndpoint.getClass().getName(), actorRef.path());\n\t\tfinal String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);\n\t\tfinal String hostname;\n\t\tOption<String> host = actorRef.path().address().host();\n\t\tif (host.isEmpty()) {\n\t\t\thostname = \"localhost\";\n\t\t} else {\n\t\t\thostname = host.get();\n\t\t}\n\t\tSet<Class<?>> implementedRpcGateways = new HashSet<>(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));\n\t\timplementedRpcGateways.add(RpcServer.class);\n\t\timplementedRpcGateways.add(AkkaBasedEndpoint.class);\n\t\tfinal InvocationHandler akkaInvocationHandler;\n\t\tif (rpcEndpoint instanceof FencedRpcEndpoint) {\n\t\t\t// a FencedRpcEndpoint needs a FencedAkkaInvocationHandler\n\t\t\takkaInvocationHandler = new FencedAkkaInvocationHandler<>(\n\t\t\t\takkaAddress,\n\t\t\t\thostname,\n\t\t\t\tactorRef,\n\t\t\t\ttimeout,\n\t\t\t\tmaximumFramesize,\n\t\t\t\tterminationFuture,\n\t\t\t\t((FencedRpcEndpoint<?>) rpcEndpoint)::getFencingToken);\n\t\t\timplementedRpcGateways.add(FencedMainThreadExecutable.class);\n\t\t} else {\n\t\t\takkaInvocationHandler = new AkkaInvocationHandler(\n\t\t\t\takkaAddress,\n\t\t\t\thostname,\n\t\t\t\tactorRef,\n\t\t\t\ttimeout,\n\t\t\t\tmaximumFramesize,\n\t\t\t\tterminationFuture);\n\t\t}\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\tRpcServer server = (RpcServer) Proxy.newProxyInstance(\n\t\t\tclassLoader,\n\t\t\timplementedRpcGateways.toArray(new Class<?>[implementedRpcGateways.size()]),\n\t\t\takkaInvocationHandler);\n\t\treturn server;\n\t}\n```\n可以看到:\n 1. 角色接收到信息后, 处理的类为FencedAkkaRpcActor/AkkaRpcActor。\n 2. 调用函数时的接口handler也分为FencedAkkaInvocationHandler/AkkaInvocationHandler。每次代理GateWay请求时, 首先会调用AkkaInvocationHandler.invoke()类。\n我们再来介绍下: RpcServer, RpcServer作为任何一个请求终端, 每次都将从相同的AkkaRpcService中参数, 实际封装了ActorRef来进行内部数据传输。\n\n# TM向JM注册\n我们以TaskManager启动后, 会去主动连接JobMaster的ResourceManager, 以它们之间的通信为例进行讲解。YarnTaskExecutorRunner在运行主函数时, 会去调用TaskExecutor.connectToResourceManager()主动连接JobManager:\n```\n    private void connectToResourceManager() {\n        log.info(\"Connecting to ResourceManager {}.\", resourceManagerAddress);\n\t\tresourceManagerConnection =\n\t\t\tnew TaskExecutorToResourceManagerConnection(\n\t\t\t\tlog,\n\t\t\t\tgetRpcService(),\n\t\t\t\tgetAddress(),\n\t\t\t\tgetResourceID(),\n\t\t\t\ttaskManagerLocation.dataPort(),\n\t\t\t\thardwareDescription,\n\t\t\t\tresourceManagerAddress.getAddress(),\n\t\t\t\tresourceManagerAddress.getResourceManagerId(),\n\t\t\t\tgetMainThreadExecutor(),\n\t\t\t\tnew ResourceManagerRegistrationListener());\n\t\tresourceManagerConnection.start();\n\t}\n```\n建立好TaskExecutorToResourceManagerConnection之后,看下是如何操作的:\n```\n\tpublic void start() {\n\t\tfinal RetryingRegistration<F, G, S> newRegistration = createNewRegistration();\n\t\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {\n\t\t\tnewRegistration.startRegistration();\n\t\t}\n\t}\n```\n该函数主要做了如下事情:\n1. 通过createNewRegistration构建ResourceManagerRegistration对象, 并没有做其他的事。同时在父类RetryingRegistration中定义了一个CompletableFuture, 当complete时候(成功向jm注册后), 会去调用TaskExecutorToResourceManagerConnection.onRegistrationSuccess(), 之后会详细介绍。\n2. 通过AkkaRpcService.startRegistration真正开始注册TaskManager。接下来看下如何向JobManager的ResourceManager注册该TaskManager。\n```\n    public void startRegistration() {\n\t\ttry {\n\t\t\t// trigger resolution of the resource manager address to a callable gateway\n\t\t\tfinal CompletableFuture<G> resourceManagerFuture;\n\t\t\tif (FencedRpcGateway.class.isAssignableFrom(targetType)) {\n\t\t\t    //返回的就是clazz对象ResourceManagerGateway的代理\n\t\t\t\tresourceManagerFuture = (CompletableFuture<G>) rpcService.connect(\n\t\t\t\t\ttargetAddress,\n\t\t\t\t\tfencingToken,\n\t\t\t\t\ttargetType.asSubclass(FencedRpcGateway.class));\n\t\t\t} else {\n\t\t\t\tresourceManagerFuture = rpcService.connect(targetAddress, targetType);\n\t\t\t}\n\t\t\t// upon success, start the registration attempts\n\t\t\tCompletableFuture<Void> resourceManagerAcceptFuture = resourceManagerFuture.thenAcceptAsync(\n\t\t\t\t(G result) -> {\n\t\t\t\t\tlog.info(\"Resolved {} address, beginning registration\", targetName);\n\t\t\t\t\t// 真正想远程JobManager进行注册\n\t\t\t\t\tregister(result, 1, initialRegistrationTimeout);\n\t\t\t\t},\n\t\t\t\trpcService.getExecutor());\n\t\t}\n\t}\n```\n主要逻辑如下:\n1. 调用rpcService.connect, 获取代理, 代理中包含指向jobManager的ResourceManager的地址(akka.tcp://flink@jobmanager:port/user/resourcemanager)的角色, 以进行rpc通信。\n2. 当产生代理后, 再调用register进行真正RPC远程向JobManager的ResourceManager注册。\n\n## 构建远程RPC调用的角色及代理\n我们首先来看下是如何获取代理的:\n```\nprivate <C extends RpcGateway> CompletableFuture<C> connectInternal(\n\t\t\tfinal String address,\n\t\t\tfinal Class<C> clazz,\n\t\t\tFunction<ActorRef, InvocationHandler> invocationHandlerFactory) {\n\t\t// 根据路径获取YarnResourceManager中JobManager ResourceManager的路径引用\n\t\tfinal ActorSelection actorSel = actorSystem.actorSelection(address);\n\t\t// 向该远程路径发送RPC请求, 获取对该远程路径的回话角色, 之后就可以向这个地址发送数据了\n\t\tfinal Future<ActorIdentity> identify = Patterns\n\t\t\t.ask(actorSel, new Identify(42), timeout.toMilliseconds())\n\t\t\t.<ActorIdentity>mapTo(ClassTag$.MODULE$.<ActorIdentity>apply(ActorIdentity.class));\n\n\t\tfinal CompletableFuture<ActorIdentity> identifyFuture = FutureUtils.toJava(identify);\n\t\tfinal CompletableFuture<ActorRef> actorRefFuture = identifyFuture.thenApply(\n\t\t\t(ActorIdentity actorIdentity) -> {\n\t\t\t\tif (actorIdentity.getRef() == null) {\n\t\t\t\t} else {\n\t\t\t\t    //获取对应的引用\n\t\t\t\t\treturn actorIdentity.getRef();\n\t\t\t\t}\n\t\t\t});\n\t\t// 发送handshake请求\n\t\tfinal CompletableFuture<HandshakeSuccessMessage> handshakeFuture = actorRefFuture.thenCompose(\n\t\t\t(ActorRef actorRef) -> FutureUtils.toJava(\n\t\t\t\tPatterns\n\t\t\t\t\t.ask(actorRef, new RemoteHandshakeMessage(clazz, getVersion()), timeout.toMilliseconds())\n\t\t\t\t\t.<HandshakeSuccessMessage>mapTo(ClassTag$.MODULE$.<HandshakeSuccessMessage>apply(HandshakeSuccessMessage.class))));\n\t\treturn actorRefFuture.thenCombineAsync(\n\t\t\thandshakeFuture,\n\t\t\t(ActorRef actorRef, HandshakeSuccessMessage ignored) -> {\n\t\t\t    //获取FencedAkkaInvocationHandler\n\t\t\t\tInvocationHandler invocationHandler = invocationHandlerFactory.apply(actorRef);\n\t\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t// 构建针对ResourceManagerGateway的代理, handler为FencedAkkaInvocationHandler\n\t\t\t\tC proxy = (C) Proxy.newProxyInstance(\n\t\t\t\t\tclassLoader,\n\t\t\t\t\tnew Class<?>[]{clazz},\n\t\t\t\t\tinvocationHandler);\n\t\t\t\treturn proxy;\n\t\t\t},\n\t\t\tactorSystem.dispatcher());\n\t}\n```\n连接请求也比较简单, 每次RPC调用时, 都使用ask:\n1. 向ResourceManager发送Identify, 远程响应并发返回对应路径的角色\n2. 向ResourceManager发送RemoteHandshakeMessage, 再次和远程确认。\n3. 以上两个RPC调用完成后, 构建针对ResourceManagerGateway的代理, 其中handler为FencedAkkaInvocationHandler(rpcEndpoint=ActorRef)。\n\n## TM向JM远程RPC注册\n当获取到通信的ActorRef后, 调用register进行注册:\n```\n    private void register(final G gateway, final int attempt, final long timeoutMillis) {\n\t\ttry {\n\t\t    // 跑到ResourceManagerConnection.invokeRegistration\n\t\t\tlog.info(\"Registration at {} attempt {} (timeout={}ms)\", targetName, attempt, timeoutMillis);\n\t\t\tCompletableFuture<RegistrationResponse> registrationFuture = invokeRegistration(gateway, fencingToken, timeoutMillis);\n\t\t\t// if the registration was successful, let the TaskExecutor know\n\t\t\tCompletableFuture<Void> registrationAcceptFuture = registrationFuture.thenAcceptAsync(\n\t\t\t\t(RegistrationResponse result) -> {\n\t\t\t\t\tif (!isCanceled()) {\n\t\t\t\t\t\tif (result instanceof RegistrationResponse.Success) {\n\t\t\t\t\t\t\t// registration successful!\n\t\t\t\t\t\t\tS success = (S) result;  // JobMasterRegistrationSuccess\n\t\t\t\t\t\t\t//表示完成了JobMaster的注册，将completionFuture置为完成\n\t\t\t\t\t\t\tcompletionFuture.complete(Tuple2.of(gateway, success));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trpcService.getExecutor());\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tcompletionFuture.completeExceptionally(t);\n\t\t\tcancel();\n\t\t}\n\t}\n```\n可以看到:\n1. register中真正向ResourceManager通信的是invokeRegistration()。\n2. 将completionFuture置为完成, 那么将触发之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。\n我们先看invokeRegistration的实现逻辑:\n```\n        protected CompletableFuture<RegistrationResponse> invokeRegistration(\n\t\t\t\tResourceManagerGateway resourceManager, ResourceManagerId fencingToken, long timeoutMillis) throws Exception {\n\t\t\tTime timeout = Time.milliseconds(timeoutMillis);\n\t\t\t//resourceManager=FencedAkkaInvocationHandler,返回TaskExecutorRegistrationSuccess， 这里会跳到JobManager\n\t\t\treturn resourceManager.registerTaskExecutor(\n\t\t\t\ttaskExecutorAddress,\n\t\t\t\tresourceID,\n\t\t\t\tdataPort,\n\t\t\t\thardwareDescription,\n\t\t\t\ttimeout);\n\t\t}\n```\nresourceManager.registerTaskExecutor将首先跑到FencedAkkaInvocationHandler.invoke, 最终真正发送rpc请求的是invokeRpc:\n```\n\tprivate Object invokeRpc(Method method, Object[] args) throws Exception {\n\t\tString methodName = method.getName();\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tTime futureTimeout = extractRpcTimeout(parameterAnnotations, args, timeout);\n\t\t//这里会构建函数名称等\n\t\tfinal RpcInvocation rpcInvocation = createRpcInvocationMessage(methodName, parameterTypes, args);\n\t\tClass<?> returnType = method.getReturnType();\n\t\tfinal Object result;\n\t\tif (Objects.equals(returnType, Void.TYPE)) {\n\t\t\ttell(rpcInvocation);\n\t\t\tresult = null;\n\t\t} else if (Objects.equals(returnType, CompletableFuture.class)) {\n\t\t\t// execute an asynchronous call, 需要返回请求结果。\n\t\t\tresult = ask(rpcInvocation, futureTimeout);\n\t\t} else {\n\t\t\t// execute a synchronous call\n\t\t\tCompletableFuture<?> futureResult = ask(rpcInvocation, futureTimeout);\n\t\t\tresult = futureResult.get(futureTimeout.getSize(), futureTimeout.getUnit());\n\t\t}\n\t\treturn result;\n\t}\n```\n最终通过ask将请求发送出去, 其中包括函数名, 参数等信息。\n# 远程ResourceManager接收到请求\n我们可以看到在构建YarnResourceManager时, resourceManagerEndpointId为`resourcemanager`, 最终其ActorRef对应的直接地址为: akka.tcp://flink@jobmanager:port/user/resourcemanager, 印证了之前TM向JM注册时, JM通信的终端就是该类。在ActorRef构建过程中, 知道JM接受处理类为AkkaRpcActor.onReceive(FencedAkkaRpcActor父类), 继续调用的是handleRpcMessage()\n```\n\tprotected void handleRpcMessage(Object message) {\n\t\tif (message instanceof RunAsync) {\n\t\t\thandleRunAsync((RunAsync) message);\n\t\t} else if (message instanceof CallAsync) {\n\t\t\thandleCallAsync((CallAsync) message);\n\t\t} else if (message instanceof RpcInvocation) {\n\t\t\thandleRpcInvocation((RpcInvocation) message);\n\t\t}\n\t}\n```\nflink针对不同类型的消息, 使用调用的函数, 很显然, 这里调用handleRpcInvocation:\n```\n\tprivate void handleRpcInvocation(RpcInvocation rpcInvocation) {\n\t\tMethod rpcMethod = null;\n\t\ttry {\n\t\t\tString methodName = rpcInvocation.getMethodName();\n\t\t\tClass<?>[] parameterTypes = rpcInvocation.getParameterTypes();\n\t\t\trpcMethod = lookupRpcMethod(methodName, parameterTypes);\n\t\t}\n\t\tif (rpcMethod != null) {\n\t\t\ttry {\n\t\t\t\t// this supports declaration of anonymous classes\n\t\t\t\trpcMethod.setAccessible(true);\n\t\t\t\tif (rpcMethod.getReturnType().equals(Void.TYPE)) {\n\t\t\t\t\t// No return value to send back\n\t\t\t\t\trpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Object result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());\n\t\t\t\t\t}\n\t\t\t\t\tif (result instanceof CompletableFuture) {\n\t\t\t\t\t\tfinal CompletableFuture<?> future = (CompletableFuture<?>) result;\n\t\t\t\t\t\tPromise.DefaultPromise<Object> promise = new Promise.DefaultPromise<>();\n\n\t\t\t\t\t\tfuture.whenComplete(\n\t\t\t\t\t\t\t(value, throwable) -> {\n\t\t\t\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\t\t\t\tpromise.failure(throwable);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t    //再回调一下\n\t\t\t\t\t\t\t\t\tpromise.success(value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tPatterns.pipe(promise.future(), getContext().dispatcher()).to(getSender());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n最终调用的是result = rpcMethod.invoke()来处理TM发送的请求。实际调用ResourceManager.registerTaskExecutor()->registerTaskExecutorInternal()\n```\n\tprivate RegistrationResponse registerTaskExecutorInternal(\n\t\t\tTaskExecutorGateway taskExecutorGateway,\n\t\t\tString taskExecutorAddress,\n\t\t\tResourceID taskExecutorResourceId,\n\t\t\tint dataPort,\n\t\t\tHardwareDescription hardwareDescription) {\n\t\tWorkerRegistration<WorkerType> oldRegistration = taskExecutors.remove(taskExecutorResourceId);\n\t\t// 首先做些清理, 删掉旧的\n\t\tif (oldRegistration != null) {\n\t\t\t// TODO :: suggest old taskExecutor to stop itself\n\t\t\tlog.debug(\"Replacing old registration of TaskExecutor {}.\", taskExecutorResourceId);\n\t\t\t// remove old task manager registration from slot manager\n\t\t\tslotManager.unregisterTaskManager(oldRegistration.getInstanceID());\n\t\t}\n        // 跑到YarnResourceManager.workerStarted(在yarn返回container成功后，会去注册Container)\n\t\tfinal WorkerType newWorker = workerStarted(taskExecutorResourceId);\n\t\tif (newWorker == null) {\n\t\t    //找不到, 就说明这个container不是这个JM申请的\n\t\t\tlog.warn(\"Discard registration from TaskExecutor {} at ({}) because the framework did \" +\n\t\t\t\t\"not recognize it\", taskExecutorResourceId, taskExecutorAddress);\n\t\t\treturn new RegistrationResponse.Decline(\"unrecognized TaskExecutor\");\n\t\t} else {\n\t\t\tWorkerRegistration<WorkerType> registration =\n\t\t\t    //taskExecutorGateway=AkkaInvocationHandler，  newWorker = YarnWorkerNode\n\t\t\t\tnew WorkerRegistration<>(taskExecutorGateway, newWorker, dataPort, hardwareDescription);\n\t\t\t// 统计活跃而Container。\n\t\t\ttaskExecutors.put(taskExecutorResourceId, registration);\n\t\t\ttaskManagerHeartbeatManager.monitorTarget(taskExecutorResourceId, new HeartbeatTarget<Void>() {\n\t\t\t\t@Override\n\t\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, Void payload) {\n\t\t\t\t\t// the ResourceManager will always send heartbeat requests to the\n\t\t\t\t\t// TaskManager\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void requestHeartbeat(ResourceID resourceID, Void payload) {\n\t\t\t\t\ttaskExecutorGateway.heartbeatFromResourceManager(resourceID);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn new TaskExecutorRegistrationSuccess(\n\t\t\t\tregistration.getInstanceID(),\n\t\t\t\tresourceId,\n\t\t\t\tresourceManagerConfiguration.getHeartbeatInterval().toMilliseconds(),\n\t\t\t\tclusterInformation);\n\t\t}\n\t}\n```\nResourceManager注册主要做了如下事情:\n1. 从taskExecutors中删除旧的通信管道。\n2. 跑到YarnResourceManager.workerStarted()里面, 从JM端根据获取当初yarn分配的Container。\n3. 向taskExecutors添加新产生的管道WorkerRegistration。管道里包含TaskExecutorGateway的代理, 其中handler为AkkaInvocationHandler, 且包含连接JobManager的ActorRef。\n4. JM对连接的TM添加监控。然后响应TM。\n\n# TM接收到JM响应\n当TM接收到JM响应, 就会回调之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。\n```\n\tprivate void establishResourceManagerConnection(\n\t\t\tResourceManagerGateway resourceManagerGateway,\n\t\t\tResourceID resourceManagerResourceId,\n\t\t\tInstanceID taskExecutorRegistrationId,\n\t\t\tClusterInformation clusterInformation) {\n\t\t// TM向JM会报本地slot的情况, 供JM来分配给申请者。\n\t\tfinal CompletableFuture<Acknowledge> slotReportResponseFuture = resourceManagerGateway.sendSlotReport(\n\t\t\tgetResourceID(),\n\t\t\ttaskExecutorRegistrationId,\n\t\t\ttaskSlotTable.createSlotReport(getResourceID()),\n\t\t\ttaskManagerConfiguration.getTimeout());\n\t\t// monitor the resource manager as heartbeat target\n\t\tresourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget<SlotReport>() {\n\t\t\t@Override\n\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, SlotReport slotReport) {\n\t\t\t\tresourceManagerGateway.heartbeatFromTaskManager(resourceID, slotReport);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void requestHeartbeat(ResourceID resourceID, SlotReport slotReport) {\n\t\t\t\t// the TaskManager won't send heartbeat requests to the ResourceManager\n\t\t\t}\n\t\t});\n\t\t// set the propagated blob server address\n\t\tfinal InetSocketAddress blobServerAddress = new InetSocketAddress(\n\t\t\tclusterInformation.getBlobServerHostname(),\n\t\t\tclusterInformation.getBlobServerPort());\n\t\tblobCacheService.setBlobServerAddress(blobServerAddress);\n\t\testablishedResourceManagerConnection = new EstablishedResourceManagerConnection(\n\t\t\tresourceManagerGateway,\n\t\t\tresourceManagerResourceId,\n\t\t\ttaskExecutorRegistrationId);\n\t\tstopRegistrationTimeout();\n\t}\n```\nTM当收到Response, 回调函数做了如下事情:\n1. 通过resourceManagerGateway.sendSlotReport向YarnResourceManager汇报当前TM可用slot, 可用slot都将保存在 JobManager ResourceManager.freeSlots里面。\n2. 开始向ResourceManager上报心跳。\n\n# 总结\n可以看到, Akka通信最底层依靠的是Patterns.ask来完成, 整个通信流程也是比较清晰的。","source":"_posts/Flink原理-Akka通信模块.md","raw":"---\ntitle: Flink原理-Akka通信&TaskManager注册\ndate: 2019-04-20 23:16:59\ntags:\ntoc: true\n---\nFlink对于JobManager和TaskManager之间通信采用Akka remote实现, 本文将以tm和jm之间的一次远程通信为示例进行讲解。为了读者更好地理解, 本文首先介绍AKKa相关基本知识。\n# Akka基础学习\n本文首先以hello world为例进行讲解:\n```\npublic class hello {\n    public static void main(String[] args) {\n        // 创建系统\n        final ActorSystem system = ActorSystem.create(\"hello\");\n        // 创建消息角色(): greeter1, 接受消息处理类: Greeter\n        final ActorRef greeter1 = system.actorOf(Props.create(Greeter.class), \"Sender1\");\n        final ActorRef greeter2 = system.actorOf(Props.create(Greeter.class), \"Sender2\");\n        //消息发送greeter1 ->  greeter2, 消息内容\"tell1\"\n        greeter2.tell(\"tell1\", greeter1);\n\n        //通过ask, 表示角色发送完消息, 希望对方返回。\n        Future<String> future  = Patterns.ask(greeter1, \"ask1\", 5000).<String>mapTo(ClassTag$.MODULE$.<String>apply(String.class));\n        future.onComplete(new OnComplete<String>() {\n            public void onComplete(Throwable throwable, String o) throws Throwable {\n                if (throwable == null) {\n                    System.out.println(o);\n                }\n            }\n        }, system.dispatcher());\n\n        //获取greeter1的绝对路径\n        String url = greeter1.path().parent().toString()+\"/\"+greeter1.path().name()+\"#\"+greeter1.path().uid();\n        // 通过actorSelection, 可以查找角色, 这个函数比较重要, 我们只知道某个角色的绝对路径, 我们通过该函数, 就可以获取到该角色。一般用于远程数据传输。\n        ActorSelection actorSelection = system.actorSelection(url);\n        Future<ActorIdentity> identify  = Patterns.ask(actorSelection, new Identify(1), 5000).<ActorIdentity>mapTo(ClassTag$.MODULE$.<ActorIdentity>apply(ActorIdentity.class));\n        identify.onComplete(new OnComplete<ActorIdentity>() {\n            public void onComplete(Throwable throwable, ActorIdentity o) throws Throwable {\n                if (throwable != null) {\n                } else {\n                    // 我们可以对比发现, 之前那个角色通过绝对路径获取到了。\n                    ActorRef actorRef = o.getRef();\n                    System.out.println(\"system.actorSelection verify:\" + (actorRef==greeter1));\n                }\n            }\n        }, system.dispatcher());\n    }\n    //消息处理类, 必须继承UntypedActor\n    public static class Greeter extends UntypedActor {\n        // 消息角色真正接收到数据的函数\n        public void onReceive(Object message) {\n            if(message instanceof String && ((String)message).equals(\"tell1\")) {\n                System.out.println(message);\n                getSender().tell(\"word2\", getSelf());\n            } else if(message instanceof String && ((String)message).equals(\"ask1\")) {\n                System.out.println(message);\n                // getSelf()表示本角色\n                getSender().tell(\"Patterns.ask()\", getSelf());\n            } else {\n                System.out.println(\"unhandled:\" + message);\n                unhandled(message);\n            }\n        }\n    }\n}\n```\n输出为:\n```\ntell1\nunhandled:word2\nask1\nPatterns.ask()\nsystem.actorSelection verify:true\n```\n1. 在使用actorSelection函数的时候, 我们需要了解一个关键字<a href=\"https://doc.akka.io/docs/akka/2.3.6/java/untyped-actors.html#actorselection-java\">Identify</a>, 它被定义为每个角色都知道其含义的消息, 当接收到Identify时, 角色自动回复ActorIdentity, 其中包含着对地址的角色。actorSelection可以获取该角色的引用, 这样就可以首先和该角色通信了。\n2. ask和tell的区别是, ask希望对方角色返回结果, 而tell不需要返回结果。\n\n# Akka RPC通信过程\n## AkkaRpcService和RpcServer\n在正式介绍之前, 先介绍AkkaRpcService, 作为Flink Akka通信核心类, 它包含了akka通信系统ActorSystem, 任何角色产生, 都会调用RpcService.startServer\n```\n    public <C extends RpcEndpoint & RpcGateway> RpcServer startServer(C rpcEndpoint) {\n\t\tCompletableFuture<Void> terminationFuture = new CompletableFuture<>();\n\t\tfinal Props akkaRpcActorProps;\n\t\tif (rpcEndpoint instanceof FencedRpcEndpoint) {\n\t\t\takkaRpcActorProps = Props.create(FencedAkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());\n\t\t} else {\n\t\t\takkaRpcActorProps = Props.create(AkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());\n\t\t}\n\t\tActorRef actorRef;\n\t\tsynchronized (lock) {\n\t\t\tactorRef = actorSystem.actorOf(akkaRpcActorProps, rpcEndpoint.getEndpointId());\n\t\t\tactors.put(actorRef, rpcEndpoint);\n\t\t}\n\t\tLOG.info(\"Starting RPC endpoint for {} at {} .\", rpcEndpoint.getClass().getName(), actorRef.path());\n\t\tfinal String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);\n\t\tfinal String hostname;\n\t\tOption<String> host = actorRef.path().address().host();\n\t\tif (host.isEmpty()) {\n\t\t\thostname = \"localhost\";\n\t\t} else {\n\t\t\thostname = host.get();\n\t\t}\n\t\tSet<Class<?>> implementedRpcGateways = new HashSet<>(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));\n\t\timplementedRpcGateways.add(RpcServer.class);\n\t\timplementedRpcGateways.add(AkkaBasedEndpoint.class);\n\t\tfinal InvocationHandler akkaInvocationHandler;\n\t\tif (rpcEndpoint instanceof FencedRpcEndpoint) {\n\t\t\t// a FencedRpcEndpoint needs a FencedAkkaInvocationHandler\n\t\t\takkaInvocationHandler = new FencedAkkaInvocationHandler<>(\n\t\t\t\takkaAddress,\n\t\t\t\thostname,\n\t\t\t\tactorRef,\n\t\t\t\ttimeout,\n\t\t\t\tmaximumFramesize,\n\t\t\t\tterminationFuture,\n\t\t\t\t((FencedRpcEndpoint<?>) rpcEndpoint)::getFencingToken);\n\t\t\timplementedRpcGateways.add(FencedMainThreadExecutable.class);\n\t\t} else {\n\t\t\takkaInvocationHandler = new AkkaInvocationHandler(\n\t\t\t\takkaAddress,\n\t\t\t\thostname,\n\t\t\t\tactorRef,\n\t\t\t\ttimeout,\n\t\t\t\tmaximumFramesize,\n\t\t\t\tterminationFuture);\n\t\t}\n\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\tRpcServer server = (RpcServer) Proxy.newProxyInstance(\n\t\t\tclassLoader,\n\t\t\timplementedRpcGateways.toArray(new Class<?>[implementedRpcGateways.size()]),\n\t\t\takkaInvocationHandler);\n\t\treturn server;\n\t}\n```\n可以看到:\n 1. 角色接收到信息后, 处理的类为FencedAkkaRpcActor/AkkaRpcActor。\n 2. 调用函数时的接口handler也分为FencedAkkaInvocationHandler/AkkaInvocationHandler。每次代理GateWay请求时, 首先会调用AkkaInvocationHandler.invoke()类。\n我们再来介绍下: RpcServer, RpcServer作为任何一个请求终端, 每次都将从相同的AkkaRpcService中参数, 实际封装了ActorRef来进行内部数据传输。\n\n# TM向JM注册\n我们以TaskManager启动后, 会去主动连接JobMaster的ResourceManager, 以它们之间的通信为例进行讲解。YarnTaskExecutorRunner在运行主函数时, 会去调用TaskExecutor.connectToResourceManager()主动连接JobManager:\n```\n    private void connectToResourceManager() {\n        log.info(\"Connecting to ResourceManager {}.\", resourceManagerAddress);\n\t\tresourceManagerConnection =\n\t\t\tnew TaskExecutorToResourceManagerConnection(\n\t\t\t\tlog,\n\t\t\t\tgetRpcService(),\n\t\t\t\tgetAddress(),\n\t\t\t\tgetResourceID(),\n\t\t\t\ttaskManagerLocation.dataPort(),\n\t\t\t\thardwareDescription,\n\t\t\t\tresourceManagerAddress.getAddress(),\n\t\t\t\tresourceManagerAddress.getResourceManagerId(),\n\t\t\t\tgetMainThreadExecutor(),\n\t\t\t\tnew ResourceManagerRegistrationListener());\n\t\tresourceManagerConnection.start();\n\t}\n```\n建立好TaskExecutorToResourceManagerConnection之后,看下是如何操作的:\n```\n\tpublic void start() {\n\t\tfinal RetryingRegistration<F, G, S> newRegistration = createNewRegistration();\n\t\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {\n\t\t\tnewRegistration.startRegistration();\n\t\t}\n\t}\n```\n该函数主要做了如下事情:\n1. 通过createNewRegistration构建ResourceManagerRegistration对象, 并没有做其他的事。同时在父类RetryingRegistration中定义了一个CompletableFuture, 当complete时候(成功向jm注册后), 会去调用TaskExecutorToResourceManagerConnection.onRegistrationSuccess(), 之后会详细介绍。\n2. 通过AkkaRpcService.startRegistration真正开始注册TaskManager。接下来看下如何向JobManager的ResourceManager注册该TaskManager。\n```\n    public void startRegistration() {\n\t\ttry {\n\t\t\t// trigger resolution of the resource manager address to a callable gateway\n\t\t\tfinal CompletableFuture<G> resourceManagerFuture;\n\t\t\tif (FencedRpcGateway.class.isAssignableFrom(targetType)) {\n\t\t\t    //返回的就是clazz对象ResourceManagerGateway的代理\n\t\t\t\tresourceManagerFuture = (CompletableFuture<G>) rpcService.connect(\n\t\t\t\t\ttargetAddress,\n\t\t\t\t\tfencingToken,\n\t\t\t\t\ttargetType.asSubclass(FencedRpcGateway.class));\n\t\t\t} else {\n\t\t\t\tresourceManagerFuture = rpcService.connect(targetAddress, targetType);\n\t\t\t}\n\t\t\t// upon success, start the registration attempts\n\t\t\tCompletableFuture<Void> resourceManagerAcceptFuture = resourceManagerFuture.thenAcceptAsync(\n\t\t\t\t(G result) -> {\n\t\t\t\t\tlog.info(\"Resolved {} address, beginning registration\", targetName);\n\t\t\t\t\t// 真正想远程JobManager进行注册\n\t\t\t\t\tregister(result, 1, initialRegistrationTimeout);\n\t\t\t\t},\n\t\t\t\trpcService.getExecutor());\n\t\t}\n\t}\n```\n主要逻辑如下:\n1. 调用rpcService.connect, 获取代理, 代理中包含指向jobManager的ResourceManager的地址(akka.tcp://flink@jobmanager:port/user/resourcemanager)的角色, 以进行rpc通信。\n2. 当产生代理后, 再调用register进行真正RPC远程向JobManager的ResourceManager注册。\n\n## 构建远程RPC调用的角色及代理\n我们首先来看下是如何获取代理的:\n```\nprivate <C extends RpcGateway> CompletableFuture<C> connectInternal(\n\t\t\tfinal String address,\n\t\t\tfinal Class<C> clazz,\n\t\t\tFunction<ActorRef, InvocationHandler> invocationHandlerFactory) {\n\t\t// 根据路径获取YarnResourceManager中JobManager ResourceManager的路径引用\n\t\tfinal ActorSelection actorSel = actorSystem.actorSelection(address);\n\t\t// 向该远程路径发送RPC请求, 获取对该远程路径的回话角色, 之后就可以向这个地址发送数据了\n\t\tfinal Future<ActorIdentity> identify = Patterns\n\t\t\t.ask(actorSel, new Identify(42), timeout.toMilliseconds())\n\t\t\t.<ActorIdentity>mapTo(ClassTag$.MODULE$.<ActorIdentity>apply(ActorIdentity.class));\n\n\t\tfinal CompletableFuture<ActorIdentity> identifyFuture = FutureUtils.toJava(identify);\n\t\tfinal CompletableFuture<ActorRef> actorRefFuture = identifyFuture.thenApply(\n\t\t\t(ActorIdentity actorIdentity) -> {\n\t\t\t\tif (actorIdentity.getRef() == null) {\n\t\t\t\t} else {\n\t\t\t\t    //获取对应的引用\n\t\t\t\t\treturn actorIdentity.getRef();\n\t\t\t\t}\n\t\t\t});\n\t\t// 发送handshake请求\n\t\tfinal CompletableFuture<HandshakeSuccessMessage> handshakeFuture = actorRefFuture.thenCompose(\n\t\t\t(ActorRef actorRef) -> FutureUtils.toJava(\n\t\t\t\tPatterns\n\t\t\t\t\t.ask(actorRef, new RemoteHandshakeMessage(clazz, getVersion()), timeout.toMilliseconds())\n\t\t\t\t\t.<HandshakeSuccessMessage>mapTo(ClassTag$.MODULE$.<HandshakeSuccessMessage>apply(HandshakeSuccessMessage.class))));\n\t\treturn actorRefFuture.thenCombineAsync(\n\t\t\thandshakeFuture,\n\t\t\t(ActorRef actorRef, HandshakeSuccessMessage ignored) -> {\n\t\t\t    //获取FencedAkkaInvocationHandler\n\t\t\t\tInvocationHandler invocationHandler = invocationHandlerFactory.apply(actorRef);\n\t\t\t\tClassLoader classLoader = getClass().getClassLoader();\n\t\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\t\t// 构建针对ResourceManagerGateway的代理, handler为FencedAkkaInvocationHandler\n\t\t\t\tC proxy = (C) Proxy.newProxyInstance(\n\t\t\t\t\tclassLoader,\n\t\t\t\t\tnew Class<?>[]{clazz},\n\t\t\t\t\tinvocationHandler);\n\t\t\t\treturn proxy;\n\t\t\t},\n\t\t\tactorSystem.dispatcher());\n\t}\n```\n连接请求也比较简单, 每次RPC调用时, 都使用ask:\n1. 向ResourceManager发送Identify, 远程响应并发返回对应路径的角色\n2. 向ResourceManager发送RemoteHandshakeMessage, 再次和远程确认。\n3. 以上两个RPC调用完成后, 构建针对ResourceManagerGateway的代理, 其中handler为FencedAkkaInvocationHandler(rpcEndpoint=ActorRef)。\n\n## TM向JM远程RPC注册\n当获取到通信的ActorRef后, 调用register进行注册:\n```\n    private void register(final G gateway, final int attempt, final long timeoutMillis) {\n\t\ttry {\n\t\t    // 跑到ResourceManagerConnection.invokeRegistration\n\t\t\tlog.info(\"Registration at {} attempt {} (timeout={}ms)\", targetName, attempt, timeoutMillis);\n\t\t\tCompletableFuture<RegistrationResponse> registrationFuture = invokeRegistration(gateway, fencingToken, timeoutMillis);\n\t\t\t// if the registration was successful, let the TaskExecutor know\n\t\t\tCompletableFuture<Void> registrationAcceptFuture = registrationFuture.thenAcceptAsync(\n\t\t\t\t(RegistrationResponse result) -> {\n\t\t\t\t\tif (!isCanceled()) {\n\t\t\t\t\t\tif (result instanceof RegistrationResponse.Success) {\n\t\t\t\t\t\t\t// registration successful!\n\t\t\t\t\t\t\tS success = (S) result;  // JobMasterRegistrationSuccess\n\t\t\t\t\t\t\t//表示完成了JobMaster的注册，将completionFuture置为完成\n\t\t\t\t\t\t\tcompletionFuture.complete(Tuple2.of(gateway, success));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\trpcService.getExecutor());\n\t\t}\n\t\tcatch (Throwable t) {\n\t\t\tcompletionFuture.completeExceptionally(t);\n\t\t\tcancel();\n\t\t}\n\t}\n```\n可以看到:\n1. register中真正向ResourceManager通信的是invokeRegistration()。\n2. 将completionFuture置为完成, 那么将触发之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。\n我们先看invokeRegistration的实现逻辑:\n```\n        protected CompletableFuture<RegistrationResponse> invokeRegistration(\n\t\t\t\tResourceManagerGateway resourceManager, ResourceManagerId fencingToken, long timeoutMillis) throws Exception {\n\t\t\tTime timeout = Time.milliseconds(timeoutMillis);\n\t\t\t//resourceManager=FencedAkkaInvocationHandler,返回TaskExecutorRegistrationSuccess， 这里会跳到JobManager\n\t\t\treturn resourceManager.registerTaskExecutor(\n\t\t\t\ttaskExecutorAddress,\n\t\t\t\tresourceID,\n\t\t\t\tdataPort,\n\t\t\t\thardwareDescription,\n\t\t\t\ttimeout);\n\t\t}\n```\nresourceManager.registerTaskExecutor将首先跑到FencedAkkaInvocationHandler.invoke, 最终真正发送rpc请求的是invokeRpc:\n```\n\tprivate Object invokeRpc(Method method, Object[] args) throws Exception {\n\t\tString methodName = method.getName();\n\t\tClass<?>[] parameterTypes = method.getParameterTypes();\n\t\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();\n\t\tTime futureTimeout = extractRpcTimeout(parameterAnnotations, args, timeout);\n\t\t//这里会构建函数名称等\n\t\tfinal RpcInvocation rpcInvocation = createRpcInvocationMessage(methodName, parameterTypes, args);\n\t\tClass<?> returnType = method.getReturnType();\n\t\tfinal Object result;\n\t\tif (Objects.equals(returnType, Void.TYPE)) {\n\t\t\ttell(rpcInvocation);\n\t\t\tresult = null;\n\t\t} else if (Objects.equals(returnType, CompletableFuture.class)) {\n\t\t\t// execute an asynchronous call, 需要返回请求结果。\n\t\t\tresult = ask(rpcInvocation, futureTimeout);\n\t\t} else {\n\t\t\t// execute a synchronous call\n\t\t\tCompletableFuture<?> futureResult = ask(rpcInvocation, futureTimeout);\n\t\t\tresult = futureResult.get(futureTimeout.getSize(), futureTimeout.getUnit());\n\t\t}\n\t\treturn result;\n\t}\n```\n最终通过ask将请求发送出去, 其中包括函数名, 参数等信息。\n# 远程ResourceManager接收到请求\n我们可以看到在构建YarnResourceManager时, resourceManagerEndpointId为`resourcemanager`, 最终其ActorRef对应的直接地址为: akka.tcp://flink@jobmanager:port/user/resourcemanager, 印证了之前TM向JM注册时, JM通信的终端就是该类。在ActorRef构建过程中, 知道JM接受处理类为AkkaRpcActor.onReceive(FencedAkkaRpcActor父类), 继续调用的是handleRpcMessage()\n```\n\tprotected void handleRpcMessage(Object message) {\n\t\tif (message instanceof RunAsync) {\n\t\t\thandleRunAsync((RunAsync) message);\n\t\t} else if (message instanceof CallAsync) {\n\t\t\thandleCallAsync((CallAsync) message);\n\t\t} else if (message instanceof RpcInvocation) {\n\t\t\thandleRpcInvocation((RpcInvocation) message);\n\t\t}\n\t}\n```\nflink针对不同类型的消息, 使用调用的函数, 很显然, 这里调用handleRpcInvocation:\n```\n\tprivate void handleRpcInvocation(RpcInvocation rpcInvocation) {\n\t\tMethod rpcMethod = null;\n\t\ttry {\n\t\t\tString methodName = rpcInvocation.getMethodName();\n\t\t\tClass<?>[] parameterTypes = rpcInvocation.getParameterTypes();\n\t\t\trpcMethod = lookupRpcMethod(methodName, parameterTypes);\n\t\t}\n\t\tif (rpcMethod != null) {\n\t\t\ttry {\n\t\t\t\t// this supports declaration of anonymous classes\n\t\t\t\trpcMethod.setAccessible(true);\n\t\t\t\tif (rpcMethod.getReturnType().equals(Void.TYPE)) {\n\t\t\t\t\t// No return value to send back\n\t\t\t\t\trpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfinal Object result;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresult = rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());\n\t\t\t\t\t}\n\t\t\t\t\tif (result instanceof CompletableFuture) {\n\t\t\t\t\t\tfinal CompletableFuture<?> future = (CompletableFuture<?>) result;\n\t\t\t\t\t\tPromise.DefaultPromise<Object> promise = new Promise.DefaultPromise<>();\n\n\t\t\t\t\t\tfuture.whenComplete(\n\t\t\t\t\t\t\t(value, throwable) -> {\n\t\t\t\t\t\t\t\tif (throwable != null) {\n\t\t\t\t\t\t\t\t\tpromise.failure(throwable);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t    //再回调一下\n\t\t\t\t\t\t\t\t\tpromise.success(value);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tPatterns.pipe(promise.future(), getContext().dispatcher()).to(getSender());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n```\n最终调用的是result = rpcMethod.invoke()来处理TM发送的请求。实际调用ResourceManager.registerTaskExecutor()->registerTaskExecutorInternal()\n```\n\tprivate RegistrationResponse registerTaskExecutorInternal(\n\t\t\tTaskExecutorGateway taskExecutorGateway,\n\t\t\tString taskExecutorAddress,\n\t\t\tResourceID taskExecutorResourceId,\n\t\t\tint dataPort,\n\t\t\tHardwareDescription hardwareDescription) {\n\t\tWorkerRegistration<WorkerType> oldRegistration = taskExecutors.remove(taskExecutorResourceId);\n\t\t// 首先做些清理, 删掉旧的\n\t\tif (oldRegistration != null) {\n\t\t\t// TODO :: suggest old taskExecutor to stop itself\n\t\t\tlog.debug(\"Replacing old registration of TaskExecutor {}.\", taskExecutorResourceId);\n\t\t\t// remove old task manager registration from slot manager\n\t\t\tslotManager.unregisterTaskManager(oldRegistration.getInstanceID());\n\t\t}\n        // 跑到YarnResourceManager.workerStarted(在yarn返回container成功后，会去注册Container)\n\t\tfinal WorkerType newWorker = workerStarted(taskExecutorResourceId);\n\t\tif (newWorker == null) {\n\t\t    //找不到, 就说明这个container不是这个JM申请的\n\t\t\tlog.warn(\"Discard registration from TaskExecutor {} at ({}) because the framework did \" +\n\t\t\t\t\"not recognize it\", taskExecutorResourceId, taskExecutorAddress);\n\t\t\treturn new RegistrationResponse.Decline(\"unrecognized TaskExecutor\");\n\t\t} else {\n\t\t\tWorkerRegistration<WorkerType> registration =\n\t\t\t    //taskExecutorGateway=AkkaInvocationHandler，  newWorker = YarnWorkerNode\n\t\t\t\tnew WorkerRegistration<>(taskExecutorGateway, newWorker, dataPort, hardwareDescription);\n\t\t\t// 统计活跃而Container。\n\t\t\ttaskExecutors.put(taskExecutorResourceId, registration);\n\t\t\ttaskManagerHeartbeatManager.monitorTarget(taskExecutorResourceId, new HeartbeatTarget<Void>() {\n\t\t\t\t@Override\n\t\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, Void payload) {\n\t\t\t\t\t// the ResourceManager will always send heartbeat requests to the\n\t\t\t\t\t// TaskManager\n\t\t\t\t}\n\t\t\t\t@Override\n\t\t\t\tpublic void requestHeartbeat(ResourceID resourceID, Void payload) {\n\t\t\t\t\ttaskExecutorGateway.heartbeatFromResourceManager(resourceID);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn new TaskExecutorRegistrationSuccess(\n\t\t\t\tregistration.getInstanceID(),\n\t\t\t\tresourceId,\n\t\t\t\tresourceManagerConfiguration.getHeartbeatInterval().toMilliseconds(),\n\t\t\t\tclusterInformation);\n\t\t}\n\t}\n```\nResourceManager注册主要做了如下事情:\n1. 从taskExecutors中删除旧的通信管道。\n2. 跑到YarnResourceManager.workerStarted()里面, 从JM端根据获取当初yarn分配的Container。\n3. 向taskExecutors添加新产生的管道WorkerRegistration。管道里包含TaskExecutorGateway的代理, 其中handler为AkkaInvocationHandler, 且包含连接JobManager的ActorRef。\n4. JM对连接的TM添加监控。然后响应TM。\n\n# TM接收到JM响应\n当TM接收到JM响应, 就会回调之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。\n```\n\tprivate void establishResourceManagerConnection(\n\t\t\tResourceManagerGateway resourceManagerGateway,\n\t\t\tResourceID resourceManagerResourceId,\n\t\t\tInstanceID taskExecutorRegistrationId,\n\t\t\tClusterInformation clusterInformation) {\n\t\t// TM向JM会报本地slot的情况, 供JM来分配给申请者。\n\t\tfinal CompletableFuture<Acknowledge> slotReportResponseFuture = resourceManagerGateway.sendSlotReport(\n\t\t\tgetResourceID(),\n\t\t\ttaskExecutorRegistrationId,\n\t\t\ttaskSlotTable.createSlotReport(getResourceID()),\n\t\t\ttaskManagerConfiguration.getTimeout());\n\t\t// monitor the resource manager as heartbeat target\n\t\tresourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget<SlotReport>() {\n\t\t\t@Override\n\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, SlotReport slotReport) {\n\t\t\t\tresourceManagerGateway.heartbeatFromTaskManager(resourceID, slotReport);\n\t\t\t}\n\t\t\t@Override\n\t\t\tpublic void requestHeartbeat(ResourceID resourceID, SlotReport slotReport) {\n\t\t\t\t// the TaskManager won't send heartbeat requests to the ResourceManager\n\t\t\t}\n\t\t});\n\t\t// set the propagated blob server address\n\t\tfinal InetSocketAddress blobServerAddress = new InetSocketAddress(\n\t\t\tclusterInformation.getBlobServerHostname(),\n\t\t\tclusterInformation.getBlobServerPort());\n\t\tblobCacheService.setBlobServerAddress(blobServerAddress);\n\t\testablishedResourceManagerConnection = new EstablishedResourceManagerConnection(\n\t\t\tresourceManagerGateway,\n\t\t\tresourceManagerResourceId,\n\t\t\ttaskExecutorRegistrationId);\n\t\tstopRegistrationTimeout();\n\t}\n```\nTM当收到Response, 回调函数做了如下事情:\n1. 通过resourceManagerGateway.sendSlotReport向YarnResourceManager汇报当前TM可用slot, 可用slot都将保存在 JobManager ResourceManager.freeSlots里面。\n2. 开始向ResourceManager上报心跳。\n\n# 总结\n可以看到, Akka通信最底层依靠的是Patterns.ask来完成, 整个通信流程也是比较清晰的。","slug":"Flink原理-Akka通信模块","published":1,"updated":"2019-06-06T01:22:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w2000aphu5zd45zxo6","content":"<p>Flink对于JobManager和TaskManager之间通信采用Akka remote实现, 本文将以tm和jm之间的一次远程通信为示例进行讲解。为了读者更好地理解, 本文首先介绍AKKa相关基本知识。</p>\n<h1 id=\"Akka基础学习\"><a href=\"#Akka基础学习\" class=\"headerlink\" title=\"Akka基础学习\"></a>Akka基础学习</h1><p>本文首先以hello world为例进行讲解:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class hello &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        // 创建系统</div><div class=\"line\">        final ActorSystem system = ActorSystem.create(&quot;hello&quot;);</div><div class=\"line\">        // 创建消息角色(): greeter1, 接受消息处理类: Greeter</div><div class=\"line\">        final ActorRef greeter1 = system.actorOf(Props.create(Greeter.class), &quot;Sender1&quot;);</div><div class=\"line\">        final ActorRef greeter2 = system.actorOf(Props.create(Greeter.class), &quot;Sender2&quot;);</div><div class=\"line\">        //消息发送greeter1 -&gt;  greeter2, 消息内容&quot;tell1&quot;</div><div class=\"line\">        greeter2.tell(&quot;tell1&quot;, greeter1);</div><div class=\"line\"></div><div class=\"line\">        //通过ask, 表示角色发送完消息, 希望对方返回。</div><div class=\"line\">        Future&lt;String&gt; future  = Patterns.ask(greeter1, &quot;ask1&quot;, 5000).&lt;String&gt;mapTo(ClassTag$.MODULE$.&lt;String&gt;apply(String.class));</div><div class=\"line\">        future.onComplete(new OnComplete&lt;String&gt;() &#123;</div><div class=\"line\">            public void onComplete(Throwable throwable, String o) throws Throwable &#123;</div><div class=\"line\">                if (throwable == null) &#123;</div><div class=\"line\">                    System.out.println(o);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, system.dispatcher());</div><div class=\"line\"></div><div class=\"line\">        //获取greeter1的绝对路径</div><div class=\"line\">        String url = greeter1.path().parent().toString()+&quot;/&quot;+greeter1.path().name()+&quot;#&quot;+greeter1.path().uid();</div><div class=\"line\">        // 通过actorSelection, 可以查找角色, 这个函数比较重要, 我们只知道某个角色的绝对路径, 我们通过该函数, 就可以获取到该角色。一般用于远程数据传输。</div><div class=\"line\">        ActorSelection actorSelection = system.actorSelection(url);</div><div class=\"line\">        Future&lt;ActorIdentity&gt; identify  = Patterns.ask(actorSelection, new Identify(1), 5000).&lt;ActorIdentity&gt;mapTo(ClassTag$.MODULE$.&lt;ActorIdentity&gt;apply(ActorIdentity.class));</div><div class=\"line\">        identify.onComplete(new OnComplete&lt;ActorIdentity&gt;() &#123;</div><div class=\"line\">            public void onComplete(Throwable throwable, ActorIdentity o) throws Throwable &#123;</div><div class=\"line\">                if (throwable != null) &#123;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // 我们可以对比发现, 之前那个角色通过绝对路径获取到了。</div><div class=\"line\">                    ActorRef actorRef = o.getRef();</div><div class=\"line\">                    System.out.println(&quot;system.actorSelection verify:&quot; + (actorRef==greeter1));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, system.dispatcher());</div><div class=\"line\">    &#125;</div><div class=\"line\">    //消息处理类, 必须继承UntypedActor</div><div class=\"line\">    public static class Greeter extends UntypedActor &#123;</div><div class=\"line\">        // 消息角色真正接收到数据的函数</div><div class=\"line\">        public void onReceive(Object message) &#123;</div><div class=\"line\">            if(message instanceof String &amp;&amp; ((String)message).equals(&quot;tell1&quot;)) &#123;</div><div class=\"line\">                System.out.println(message);</div><div class=\"line\">                getSender().tell(&quot;word2&quot;, getSelf());</div><div class=\"line\">            &#125; else if(message instanceof String &amp;&amp; ((String)message).equals(&quot;ask1&quot;)) &#123;</div><div class=\"line\">                System.out.println(message);</div><div class=\"line\">                // getSelf()表示本角色</div><div class=\"line\">                getSender().tell(&quot;Patterns.ask()&quot;, getSelf());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                System.out.println(&quot;unhandled:&quot; + message);</div><div class=\"line\">                unhandled(message);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">tell1</div><div class=\"line\">unhandled:word2</div><div class=\"line\">ask1</div><div class=\"line\">Patterns.ask()</div><div class=\"line\">system.actorSelection verify:true</div></pre></td></tr></table></figure></p>\n<ol>\n<li>在使用actorSelection函数的时候, 我们需要了解一个关键字<a href=\"https://doc.akka.io/docs/akka/2.3.6/java/untyped-actors.html#actorselection-java\" target=\"_blank\" rel=\"external\">Identify</a>, 它被定义为每个角色都知道其含义的消息, 当接收到Identify时, 角色自动回复ActorIdentity, 其中包含着对地址的角色。actorSelection可以获取该角色的引用, 这样就可以首先和该角色通信了。</li>\n<li>ask和tell的区别是, ask希望对方角色返回结果, 而tell不需要返回结果。</li>\n</ol>\n<h1 id=\"Akka-RPC通信过程\"><a href=\"#Akka-RPC通信过程\" class=\"headerlink\" title=\"Akka RPC通信过程\"></a>Akka RPC通信过程</h1><h2 id=\"AkkaRpcService和RpcServer\"><a href=\"#AkkaRpcService和RpcServer\" class=\"headerlink\" title=\"AkkaRpcService和RpcServer\"></a>AkkaRpcService和RpcServer</h2><p>在正式介绍之前, 先介绍AkkaRpcService, 作为Flink Akka通信核心类, 它包含了akka通信系统ActorSystem, 任何角色产生, 都会调用RpcService.startServer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public &lt;C extends RpcEndpoint &amp; RpcGateway&gt; RpcServer startServer(C rpcEndpoint) &#123;</div><div class=\"line\">\tCompletableFuture&lt;Void&gt; terminationFuture = new CompletableFuture&lt;&gt;();</div><div class=\"line\">\tfinal Props akkaRpcActorProps;</div><div class=\"line\">\tif (rpcEndpoint instanceof FencedRpcEndpoint) &#123;</div><div class=\"line\">\t\takkaRpcActorProps = Props.create(FencedAkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\takkaRpcActorProps = Props.create(AkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tActorRef actorRef;</div><div class=\"line\">\tsynchronized (lock) &#123;</div><div class=\"line\">\t\tactorRef = actorSystem.actorOf(akkaRpcActorProps, rpcEndpoint.getEndpointId());</div><div class=\"line\">\t\tactors.put(actorRef, rpcEndpoint);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tLOG.info(&quot;Starting RPC endpoint for &#123;&#125; at &#123;&#125; .&quot;, rpcEndpoint.getClass().getName(), actorRef.path());</div><div class=\"line\">\tfinal String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);</div><div class=\"line\">\tfinal String hostname;</div><div class=\"line\">\tOption&lt;String&gt; host = actorRef.path().address().host();</div><div class=\"line\">\tif (host.isEmpty()) &#123;</div><div class=\"line\">\t\thostname = &quot;localhost&quot;;</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\thostname = host.get();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tSet&lt;Class&lt;?&gt;&gt; implementedRpcGateways = new HashSet&lt;&gt;(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));</div><div class=\"line\">\timplementedRpcGateways.add(RpcServer.class);</div><div class=\"line\">\timplementedRpcGateways.add(AkkaBasedEndpoint.class);</div><div class=\"line\">\tfinal InvocationHandler akkaInvocationHandler;</div><div class=\"line\">\tif (rpcEndpoint instanceof FencedRpcEndpoint) &#123;</div><div class=\"line\">\t\t// a FencedRpcEndpoint needs a FencedAkkaInvocationHandler</div><div class=\"line\">\t\takkaInvocationHandler = new FencedAkkaInvocationHandler&lt;&gt;(</div><div class=\"line\">\t\t\takkaAddress,</div><div class=\"line\">\t\t\thostname,</div><div class=\"line\">\t\t\tactorRef,</div><div class=\"line\">\t\t\ttimeout,</div><div class=\"line\">\t\t\tmaximumFramesize,</div><div class=\"line\">\t\t\tterminationFuture,</div><div class=\"line\">\t\t\t((FencedRpcEndpoint&lt;?&gt;) rpcEndpoint)::getFencingToken);</div><div class=\"line\">\t\timplementedRpcGateways.add(FencedMainThreadExecutable.class);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\takkaInvocationHandler = new AkkaInvocationHandler(</div><div class=\"line\">\t\t\takkaAddress,</div><div class=\"line\">\t\t\thostname,</div><div class=\"line\">\t\t\tactorRef,</div><div class=\"line\">\t\t\ttimeout,</div><div class=\"line\">\t\t\tmaximumFramesize,</div><div class=\"line\">\t\t\tterminationFuture);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tClassLoader classLoader = getClass().getClassLoader();</div><div class=\"line\">\tRpcServer server = (RpcServer) Proxy.newProxyInstance(</div><div class=\"line\">\t\tclassLoader,</div><div class=\"line\">\t\timplementedRpcGateways.toArray(new Class&lt;?&gt;[implementedRpcGateways.size()]),</div><div class=\"line\">\t\takkaInvocationHandler);</div><div class=\"line\">\treturn server;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ol>\n<li>角色接收到信息后, 处理的类为FencedAkkaRpcActor/AkkaRpcActor。</li>\n<li>调用函数时的接口handler也分为FencedAkkaInvocationHandler/AkkaInvocationHandler。每次代理GateWay请求时, 首先会调用AkkaInvocationHandler.invoke()类。<br>我们再来介绍下: RpcServer, RpcServer作为任何一个请求终端, 每次都将从相同的AkkaRpcService中参数, 实际封装了ActorRef来进行内部数据传输。</li>\n</ol>\n<h1 id=\"TM向JM注册\"><a href=\"#TM向JM注册\" class=\"headerlink\" title=\"TM向JM注册\"></a>TM向JM注册</h1><p>我们以TaskManager启动后, 会去主动连接JobMaster的ResourceManager, 以它们之间的通信为例进行讲解。YarnTaskExecutorRunner在运行主函数时, 会去调用TaskExecutor.connectToResourceManager()主动连接JobManager:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private void connectToResourceManager() &#123;</div><div class=\"line\">       log.info(&quot;Connecting to ResourceManager &#123;&#125;.&quot;, resourceManagerAddress);</div><div class=\"line\">\tresourceManagerConnection =</div><div class=\"line\">\t\tnew TaskExecutorToResourceManagerConnection(</div><div class=\"line\">\t\t\tlog,</div><div class=\"line\">\t\t\tgetRpcService(),</div><div class=\"line\">\t\t\tgetAddress(),</div><div class=\"line\">\t\t\tgetResourceID(),</div><div class=\"line\">\t\t\ttaskManagerLocation.dataPort(),</div><div class=\"line\">\t\t\thardwareDescription,</div><div class=\"line\">\t\t\tresourceManagerAddress.getAddress(),</div><div class=\"line\">\t\t\tresourceManagerAddress.getResourceManagerId(),</div><div class=\"line\">\t\t\tgetMainThreadExecutor(),</div><div class=\"line\">\t\t\tnew ResourceManagerRegistrationListener());</div><div class=\"line\">\tresourceManagerConnection.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>建立好TaskExecutorToResourceManagerConnection之后,看下是如何操作的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">\tfinal RetryingRegistration&lt;F, G, S&gt; newRegistration = createNewRegistration();</div><div class=\"line\">\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</div><div class=\"line\">\t\tnewRegistration.startRegistration();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过createNewRegistration构建ResourceManagerRegistration对象, 并没有做其他的事。同时在父类RetryingRegistration中定义了一个CompletableFuture, 当complete时候(成功向jm注册后), 会去调用TaskExecutorToResourceManagerConnection.onRegistrationSuccess(), 之后会详细介绍。</li>\n<li>通过AkkaRpcService.startRegistration真正开始注册TaskManager。接下来看下如何向JobManager的ResourceManager注册该TaskManager。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void startRegistration() &#123;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\t// trigger resolution of the resource manager address to a callable gateway</div><div class=\"line\">\t\tfinal CompletableFuture&lt;G&gt; resourceManagerFuture;</div><div class=\"line\">\t\tif (FencedRpcGateway.class.isAssignableFrom(targetType)) &#123;</div><div class=\"line\">\t\t    //返回的就是clazz对象ResourceManagerGateway的代理</div><div class=\"line\">\t\t\tresourceManagerFuture = (CompletableFuture&lt;G&gt;) rpcService.connect(</div><div class=\"line\">\t\t\t\ttargetAddress,</div><div class=\"line\">\t\t\t\tfencingToken,</div><div class=\"line\">\t\t\t\ttargetType.asSubclass(FencedRpcGateway.class));</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tresourceManagerFuture = rpcService.connect(targetAddress, targetType);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t// upon success, start the registration attempts</div><div class=\"line\">\t\tCompletableFuture&lt;Void&gt; resourceManagerAcceptFuture = resourceManagerFuture.thenAcceptAsync(</div><div class=\"line\">\t\t\t(G result) -&gt; &#123;</div><div class=\"line\">\t\t\t\tlog.info(&quot;Resolved &#123;&#125; address, beginning registration&quot;, targetName);</div><div class=\"line\">\t\t\t\t// 真正想远程JobManager进行注册</div><div class=\"line\">\t\t\t\tregister(result, 1, initialRegistrationTimeout);</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\trpcService.getExecutor());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要逻辑如下:</p>\n<ol>\n<li>调用rpcService.connect, 获取代理, 代理中包含指向jobManager的ResourceManager的地址(akka.tcp://flink@jobmanager:port/user/resourcemanager)的角色, 以进行rpc通信。</li>\n<li>当产生代理后, 再调用register进行真正RPC远程向JobManager的ResourceManager注册。</li>\n</ol>\n<h2 id=\"构建远程RPC调用的角色及代理\"><a href=\"#构建远程RPC调用的角色及代理\" class=\"headerlink\" title=\"构建远程RPC调用的角色及代理\"></a>构建远程RPC调用的角色及代理</h2><p>我们首先来看下是如何获取代理的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">private &lt;C extends RpcGateway&gt; CompletableFuture&lt;C&gt; connectInternal(</div><div class=\"line\">\t\t\tfinal String address,</div><div class=\"line\">\t\t\tfinal Class&lt;C&gt; clazz,</div><div class=\"line\">\t\t\tFunction&lt;ActorRef, InvocationHandler&gt; invocationHandlerFactory) &#123;</div><div class=\"line\">\t\t// 根据路径获取YarnResourceManager中JobManager ResourceManager的路径引用</div><div class=\"line\">\t\tfinal ActorSelection actorSel = actorSystem.actorSelection(address);</div><div class=\"line\">\t\t// 向该远程路径发送RPC请求, 获取对该远程路径的回话角色, 之后就可以向这个地址发送数据了</div><div class=\"line\">\t\tfinal Future&lt;ActorIdentity&gt; identify = Patterns</div><div class=\"line\">\t\t\t.ask(actorSel, new Identify(42), timeout.toMilliseconds())</div><div class=\"line\">\t\t\t.&lt;ActorIdentity&gt;mapTo(ClassTag$.MODULE$.&lt;ActorIdentity&gt;apply(ActorIdentity.class));</div><div class=\"line\"></div><div class=\"line\">\t\tfinal CompletableFuture&lt;ActorIdentity&gt; identifyFuture = FutureUtils.toJava(identify);</div><div class=\"line\">\t\tfinal CompletableFuture&lt;ActorRef&gt; actorRefFuture = identifyFuture.thenApply(</div><div class=\"line\">\t\t\t(ActorIdentity actorIdentity) -&gt; &#123;</div><div class=\"line\">\t\t\t\tif (actorIdentity.getRef() == null) &#123;</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t    //获取对应的引用</div><div class=\"line\">\t\t\t\t\treturn actorIdentity.getRef();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t// 发送handshake请求</div><div class=\"line\">\t\tfinal CompletableFuture&lt;HandshakeSuccessMessage&gt; handshakeFuture = actorRefFuture.thenCompose(</div><div class=\"line\">\t\t\t(ActorRef actorRef) -&gt; FutureUtils.toJava(</div><div class=\"line\">\t\t\t\tPatterns</div><div class=\"line\">\t\t\t\t\t.ask(actorRef, new RemoteHandshakeMessage(clazz, getVersion()), timeout.toMilliseconds())</div><div class=\"line\">\t\t\t\t\t.&lt;HandshakeSuccessMessage&gt;mapTo(ClassTag$.MODULE$.&lt;HandshakeSuccessMessage&gt;apply(HandshakeSuccessMessage.class))));</div><div class=\"line\">\t\treturn actorRefFuture.thenCombineAsync(</div><div class=\"line\">\t\t\thandshakeFuture,</div><div class=\"line\">\t\t\t(ActorRef actorRef, HandshakeSuccessMessage ignored) -&gt; &#123;</div><div class=\"line\">\t\t\t    //获取FencedAkkaInvocationHandler</div><div class=\"line\">\t\t\t\tInvocationHandler invocationHandler = invocationHandlerFactory.apply(actorRef);</div><div class=\"line\">\t\t\t\tClassLoader classLoader = getClass().getClassLoader();</div><div class=\"line\">\t\t\t\t@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">\t\t\t\t// 构建针对ResourceManagerGateway的代理, handler为FencedAkkaInvocationHandler</div><div class=\"line\">\t\t\t\tC proxy = (C) Proxy.newProxyInstance(</div><div class=\"line\">\t\t\t\t\tclassLoader,</div><div class=\"line\">\t\t\t\t\tnew Class&lt;?&gt;[]&#123;clazz&#125;,</div><div class=\"line\">\t\t\t\t\tinvocationHandler);</div><div class=\"line\">\t\t\t\treturn proxy;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\tactorSystem.dispatcher());</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>连接请求也比较简单, 每次RPC调用时, 都使用ask:</p>\n<ol>\n<li>向ResourceManager发送Identify, 远程响应并发返回对应路径的角色</li>\n<li>向ResourceManager发送RemoteHandshakeMessage, 再次和远程确认。</li>\n<li>以上两个RPC调用完成后, 构建针对ResourceManagerGateway的代理, 其中handler为FencedAkkaInvocationHandler(rpcEndpoint=ActorRef)。</li>\n</ol>\n<h2 id=\"TM向JM远程RPC注册\"><a href=\"#TM向JM远程RPC注册\" class=\"headerlink\" title=\"TM向JM远程RPC注册\"></a>TM向JM远程RPC注册</h2><p>当获取到通信的ActorRef后, 调用register进行注册:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private void register(final G gateway, final int attempt, final long timeoutMillis) &#123;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t    // 跑到ResourceManagerConnection.invokeRegistration</div><div class=\"line\">\t\tlog.info(&quot;Registration at &#123;&#125; attempt &#123;&#125; (timeout=&#123;&#125;ms)&quot;, targetName, attempt, timeoutMillis);</div><div class=\"line\">\t\tCompletableFuture&lt;RegistrationResponse&gt; registrationFuture = invokeRegistration(gateway, fencingToken, timeoutMillis);</div><div class=\"line\">\t\t// if the registration was successful, let the TaskExecutor know</div><div class=\"line\">\t\tCompletableFuture&lt;Void&gt; registrationAcceptFuture = registrationFuture.thenAcceptAsync(</div><div class=\"line\">\t\t\t(RegistrationResponse result) -&gt; &#123;</div><div class=\"line\">\t\t\t\tif (!isCanceled()) &#123;</div><div class=\"line\">\t\t\t\t\tif (result instanceof RegistrationResponse.Success) &#123;</div><div class=\"line\">\t\t\t\t\t\t// registration successful!</div><div class=\"line\">\t\t\t\t\t\tS success = (S) result;  // JobMasterRegistrationSuccess</div><div class=\"line\">\t\t\t\t\t\t//表示完成了JobMaster的注册，将completionFuture置为完成</div><div class=\"line\">\t\t\t\t\t\tcompletionFuture.complete(Tuple2.of(gateway, success));</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\trpcService.getExecutor());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcatch (Throwable t) &#123;</div><div class=\"line\">\t\tcompletionFuture.completeExceptionally(t);</div><div class=\"line\">\t\tcancel();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ol>\n<li>register中真正向ResourceManager通信的是invokeRegistration()。</li>\n<li>将completionFuture置为完成, 那么将触发之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。<br>我们先看invokeRegistration的实现逻辑:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">      protected CompletableFuture&lt;RegistrationResponse&gt; invokeRegistration(</div><div class=\"line\">\t\tResourceManagerGateway resourceManager, ResourceManagerId fencingToken, long timeoutMillis) throws Exception &#123;</div><div class=\"line\">\tTime timeout = Time.milliseconds(timeoutMillis);</div><div class=\"line\">\t//resourceManager=FencedAkkaInvocationHandler,返回TaskExecutorRegistrationSuccess， 这里会跳到JobManager</div><div class=\"line\">\treturn resourceManager.registerTaskExecutor(</div><div class=\"line\">\t\ttaskExecutorAddress,</div><div class=\"line\">\t\tresourceID,</div><div class=\"line\">\t\tdataPort,</div><div class=\"line\">\t\thardwareDescription,</div><div class=\"line\">\t\ttimeout);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>resourceManager.registerTaskExecutor将首先跑到FencedAkkaInvocationHandler.invoke, 最终真正发送rpc请求的是invokeRpc:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Object invokeRpc(Method method, Object[] args) throws Exception &#123;</div><div class=\"line\">\tString methodName = method.getName();</div><div class=\"line\">\tClass&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class=\"line\">\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();</div><div class=\"line\">\tTime futureTimeout = extractRpcTimeout(parameterAnnotations, args, timeout);</div><div class=\"line\">\t//这里会构建函数名称等</div><div class=\"line\">\tfinal RpcInvocation rpcInvocation = createRpcInvocationMessage(methodName, parameterTypes, args);</div><div class=\"line\">\tClass&lt;?&gt; returnType = method.getReturnType();</div><div class=\"line\">\tfinal Object result;</div><div class=\"line\">\tif (Objects.equals(returnType, Void.TYPE)) &#123;</div><div class=\"line\">\t\ttell(rpcInvocation);</div><div class=\"line\">\t\tresult = null;</div><div class=\"line\">\t&#125; else if (Objects.equals(returnType, CompletableFuture.class)) &#123;</div><div class=\"line\">\t\t// execute an asynchronous call, 需要返回请求结果。</div><div class=\"line\">\t\tresult = ask(rpcInvocation, futureTimeout);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\t// execute a synchronous call</div><div class=\"line\">\t\tCompletableFuture&lt;?&gt; futureResult = ask(rpcInvocation, futureTimeout);</div><div class=\"line\">\t\tresult = futureResult.get(futureTimeout.getSize(), futureTimeout.getUnit());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最终通过ask将请求发送出去, 其中包括函数名, 参数等信息。</p>\n<h1 id=\"远程ResourceManager接收到请求\"><a href=\"#远程ResourceManager接收到请求\" class=\"headerlink\" title=\"远程ResourceManager接收到请求\"></a>远程ResourceManager接收到请求</h1><p>我们可以看到在构建YarnResourceManager时, resourceManagerEndpointId为<code>resourcemanager</code>, 最终其ActorRef对应的直接地址为: akka.tcp://flink@jobmanager:port/user/resourcemanager, 印证了之前TM向JM注册时, JM通信的终端就是该类。在ActorRef构建过程中, 知道JM接受处理类为AkkaRpcActor.onReceive(FencedAkkaRpcActor父类), 继续调用的是handleRpcMessage()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void handleRpcMessage(Object message) &#123;</div><div class=\"line\">\tif (message instanceof RunAsync) &#123;</div><div class=\"line\">\t\thandleRunAsync((RunAsync) message);</div><div class=\"line\">\t&#125; else if (message instanceof CallAsync) &#123;</div><div class=\"line\">\t\thandleCallAsync((CallAsync) message);</div><div class=\"line\">\t&#125; else if (message instanceof RpcInvocation) &#123;</div><div class=\"line\">\t\thandleRpcInvocation((RpcInvocation) message);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>flink针对不同类型的消息, 使用调用的函数, 很显然, 这里调用handleRpcInvocation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleRpcInvocation(RpcInvocation rpcInvocation) &#123;</div><div class=\"line\">\tMethod rpcMethod = null;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tString methodName = rpcInvocation.getMethodName();</div><div class=\"line\">\t\tClass&lt;?&gt;[] parameterTypes = rpcInvocation.getParameterTypes();</div><div class=\"line\">\t\trpcMethod = lookupRpcMethod(methodName, parameterTypes);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (rpcMethod != null) &#123;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\t// this supports declaration of anonymous classes</div><div class=\"line\">\t\t\trpcMethod.setAccessible(true);</div><div class=\"line\">\t\t\tif (rpcMethod.getReturnType().equals(Void.TYPE)) &#123;</div><div class=\"line\">\t\t\t\t// No return value to send back</div><div class=\"line\">\t\t\t\trpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse &#123;</div><div class=\"line\">\t\t\t\tfinal Object result;</div><div class=\"line\">\t\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\t\tresult = rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tif (result instanceof CompletableFuture) &#123;</div><div class=\"line\">\t\t\t\t\tfinal CompletableFuture&lt;?&gt; future = (CompletableFuture&lt;?&gt;) result;</div><div class=\"line\">\t\t\t\t\tPromise.DefaultPromise&lt;Object&gt; promise = new Promise.DefaultPromise&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tfuture.whenComplete(</div><div class=\"line\">\t\t\t\t\t\t(value, throwable) -&gt; &#123;</div><div class=\"line\">\t\t\t\t\t\t\tif (throwable != null) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\tpromise.failure(throwable);</div><div class=\"line\">\t\t\t\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\t\t\t    //再回调一下</div><div class=\"line\">\t\t\t\t\t\t\t\tpromise.success(value);</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tPatterns.pipe(promise.future(), getContext().dispatcher()).to(getSender());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最终调用的是result = rpcMethod.invoke()来处理TM发送的请求。实际调用ResourceManager.registerTaskExecutor()-&gt;registerTaskExecutorInternal()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">private RegistrationResponse registerTaskExecutorInternal(</div><div class=\"line\">\t\tTaskExecutorGateway taskExecutorGateway,</div><div class=\"line\">\t\tString taskExecutorAddress,</div><div class=\"line\">\t\tResourceID taskExecutorResourceId,</div><div class=\"line\">\t\tint dataPort,</div><div class=\"line\">\t\tHardwareDescription hardwareDescription) &#123;</div><div class=\"line\">\tWorkerRegistration&lt;WorkerType&gt; oldRegistration = taskExecutors.remove(taskExecutorResourceId);</div><div class=\"line\">\t// 首先做些清理, 删掉旧的</div><div class=\"line\">\tif (oldRegistration != null) &#123;</div><div class=\"line\">\t\t// TODO :: suggest old taskExecutor to stop itself</div><div class=\"line\">\t\tlog.debug(&quot;Replacing old registration of TaskExecutor &#123;&#125;.&quot;, taskExecutorResourceId);</div><div class=\"line\">\t\t// remove old task manager registration from slot manager</div><div class=\"line\">\t\tslotManager.unregisterTaskManager(oldRegistration.getInstanceID());</div><div class=\"line\">\t&#125;</div><div class=\"line\">       // 跑到YarnResourceManager.workerStarted(在yarn返回container成功后，会去注册Container)</div><div class=\"line\">\tfinal WorkerType newWorker = workerStarted(taskExecutorResourceId);</div><div class=\"line\">\tif (newWorker == null) &#123;</div><div class=\"line\">\t    //找不到, 就说明这个container不是这个JM申请的</div><div class=\"line\">\t\tlog.warn(&quot;Discard registration from TaskExecutor &#123;&#125; at (&#123;&#125;) because the framework did &quot; +</div><div class=\"line\">\t\t\t&quot;not recognize it&quot;, taskExecutorResourceId, taskExecutorAddress);</div><div class=\"line\">\t\treturn new RegistrationResponse.Decline(&quot;unrecognized TaskExecutor&quot;);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\tWorkerRegistration&lt;WorkerType&gt; registration =</div><div class=\"line\">\t\t    //taskExecutorGateway=AkkaInvocationHandler，  newWorker = YarnWorkerNode</div><div class=\"line\">\t\t\tnew WorkerRegistration&lt;&gt;(taskExecutorGateway, newWorker, dataPort, hardwareDescription);</div><div class=\"line\">\t\t// 统计活跃而Container。</div><div class=\"line\">\t\ttaskExecutors.put(taskExecutorResourceId, registration);</div><div class=\"line\">\t\ttaskManagerHeartbeatManager.monitorTarget(taskExecutorResourceId, new HeartbeatTarget&lt;Void&gt;() &#123;</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, Void payload) &#123;</div><div class=\"line\">\t\t\t\t// the ResourceManager will always send heartbeat requests to the</div><div class=\"line\">\t\t\t\t// TaskManager</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic void requestHeartbeat(ResourceID resourceID, Void payload) &#123;</div><div class=\"line\">\t\t\t\ttaskExecutorGateway.heartbeatFromResourceManager(resourceID);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\treturn new TaskExecutorRegistrationSuccess(</div><div class=\"line\">\t\t\tregistration.getInstanceID(),</div><div class=\"line\">\t\t\tresourceId,</div><div class=\"line\">\t\t\tresourceManagerConfiguration.getHeartbeatInterval().toMilliseconds(),</div><div class=\"line\">\t\t\tclusterInformation);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>ResourceManager注册主要做了如下事情:</p>\n<ol>\n<li>从taskExecutors中删除旧的通信管道。</li>\n<li>跑到YarnResourceManager.workerStarted()里面, 从JM端根据获取当初yarn分配的Container。</li>\n<li>向taskExecutors添加新产生的管道WorkerRegistration。管道里包含TaskExecutorGateway的代理, 其中handler为AkkaInvocationHandler, 且包含连接JobManager的ActorRef。</li>\n<li>JM对连接的TM添加监控。然后响应TM。</li>\n</ol>\n<h1 id=\"TM接收到JM响应\"><a href=\"#TM接收到JM响应\" class=\"headerlink\" title=\"TM接收到JM响应\"></a>TM接收到JM响应</h1><p>当TM接收到JM响应, 就会回调之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void establishResourceManagerConnection(</div><div class=\"line\">\t\tResourceManagerGateway resourceManagerGateway,</div><div class=\"line\">\t\tResourceID resourceManagerResourceId,</div><div class=\"line\">\t\tInstanceID taskExecutorRegistrationId,</div><div class=\"line\">\t\tClusterInformation clusterInformation) &#123;</div><div class=\"line\">\t// TM向JM会报本地slot的情况, 供JM来分配给申请者。</div><div class=\"line\">\tfinal CompletableFuture&lt;Acknowledge&gt; slotReportResponseFuture = resourceManagerGateway.sendSlotReport(</div><div class=\"line\">\t\tgetResourceID(),</div><div class=\"line\">\t\ttaskExecutorRegistrationId,</div><div class=\"line\">\t\ttaskSlotTable.createSlotReport(getResourceID()),</div><div class=\"line\">\t\ttaskManagerConfiguration.getTimeout());</div><div class=\"line\">\t// monitor the resource manager as heartbeat target</div><div class=\"line\">\tresourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget&lt;SlotReport&gt;() &#123;</div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void receiveHeartbeat(ResourceID resourceID, SlotReport slotReport) &#123;</div><div class=\"line\">\t\t\tresourceManagerGateway.heartbeatFromTaskManager(resourceID, slotReport);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void requestHeartbeat(ResourceID resourceID, SlotReport slotReport) &#123;</div><div class=\"line\">\t\t\t// the TaskManager won&apos;t send heartbeat requests to the ResourceManager</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t// set the propagated blob server address</div><div class=\"line\">\tfinal InetSocketAddress blobServerAddress = new InetSocketAddress(</div><div class=\"line\">\t\tclusterInformation.getBlobServerHostname(),</div><div class=\"line\">\t\tclusterInformation.getBlobServerPort());</div><div class=\"line\">\tblobCacheService.setBlobServerAddress(blobServerAddress);</div><div class=\"line\">\testablishedResourceManagerConnection = new EstablishedResourceManagerConnection(</div><div class=\"line\">\t\tresourceManagerGateway,</div><div class=\"line\">\t\tresourceManagerResourceId,</div><div class=\"line\">\t\ttaskExecutorRegistrationId);</div><div class=\"line\">\tstopRegistrationTimeout();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>TM当收到Response, 回调函数做了如下事情:</p>\n<ol>\n<li>通过resourceManagerGateway.sendSlotReport向YarnResourceManager汇报当前TM可用slot, 可用slot都将保存在 JobManager ResourceManager.freeSlots里面。</li>\n<li>开始向ResourceManager上报心跳。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>可以看到, Akka通信最底层依靠的是Patterns.ask来完成, 整个通信流程也是比较清晰的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Flink对于JobManager和TaskManager之间通信采用Akka remote实现, 本文将以tm和jm之间的一次远程通信为示例进行讲解。为了读者更好地理解, 本文首先介绍AKKa相关基本知识。</p>\n<h1 id=\"Akka基础学习\"><a href=\"#Akka基础学习\" class=\"headerlink\" title=\"Akka基础学习\"></a>Akka基础学习</h1><p>本文首先以hello world为例进行讲解:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class hello &#123;</div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        // 创建系统</div><div class=\"line\">        final ActorSystem system = ActorSystem.create(&quot;hello&quot;);</div><div class=\"line\">        // 创建消息角色(): greeter1, 接受消息处理类: Greeter</div><div class=\"line\">        final ActorRef greeter1 = system.actorOf(Props.create(Greeter.class), &quot;Sender1&quot;);</div><div class=\"line\">        final ActorRef greeter2 = system.actorOf(Props.create(Greeter.class), &quot;Sender2&quot;);</div><div class=\"line\">        //消息发送greeter1 -&gt;  greeter2, 消息内容&quot;tell1&quot;</div><div class=\"line\">        greeter2.tell(&quot;tell1&quot;, greeter1);</div><div class=\"line\"></div><div class=\"line\">        //通过ask, 表示角色发送完消息, 希望对方返回。</div><div class=\"line\">        Future&lt;String&gt; future  = Patterns.ask(greeter1, &quot;ask1&quot;, 5000).&lt;String&gt;mapTo(ClassTag$.MODULE$.&lt;String&gt;apply(String.class));</div><div class=\"line\">        future.onComplete(new OnComplete&lt;String&gt;() &#123;</div><div class=\"line\">            public void onComplete(Throwable throwable, String o) throws Throwable &#123;</div><div class=\"line\">                if (throwable == null) &#123;</div><div class=\"line\">                    System.out.println(o);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, system.dispatcher());</div><div class=\"line\"></div><div class=\"line\">        //获取greeter1的绝对路径</div><div class=\"line\">        String url = greeter1.path().parent().toString()+&quot;/&quot;+greeter1.path().name()+&quot;#&quot;+greeter1.path().uid();</div><div class=\"line\">        // 通过actorSelection, 可以查找角色, 这个函数比较重要, 我们只知道某个角色的绝对路径, 我们通过该函数, 就可以获取到该角色。一般用于远程数据传输。</div><div class=\"line\">        ActorSelection actorSelection = system.actorSelection(url);</div><div class=\"line\">        Future&lt;ActorIdentity&gt; identify  = Patterns.ask(actorSelection, new Identify(1), 5000).&lt;ActorIdentity&gt;mapTo(ClassTag$.MODULE$.&lt;ActorIdentity&gt;apply(ActorIdentity.class));</div><div class=\"line\">        identify.onComplete(new OnComplete&lt;ActorIdentity&gt;() &#123;</div><div class=\"line\">            public void onComplete(Throwable throwable, ActorIdentity o) throws Throwable &#123;</div><div class=\"line\">                if (throwable != null) &#123;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // 我们可以对比发现, 之前那个角色通过绝对路径获取到了。</div><div class=\"line\">                    ActorRef actorRef = o.getRef();</div><div class=\"line\">                    System.out.println(&quot;system.actorSelection verify:&quot; + (actorRef==greeter1));</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, system.dispatcher());</div><div class=\"line\">    &#125;</div><div class=\"line\">    //消息处理类, 必须继承UntypedActor</div><div class=\"line\">    public static class Greeter extends UntypedActor &#123;</div><div class=\"line\">        // 消息角色真正接收到数据的函数</div><div class=\"line\">        public void onReceive(Object message) &#123;</div><div class=\"line\">            if(message instanceof String &amp;&amp; ((String)message).equals(&quot;tell1&quot;)) &#123;</div><div class=\"line\">                System.out.println(message);</div><div class=\"line\">                getSender().tell(&quot;word2&quot;, getSelf());</div><div class=\"line\">            &#125; else if(message instanceof String &amp;&amp; ((String)message).equals(&quot;ask1&quot;)) &#123;</div><div class=\"line\">                System.out.println(message);</div><div class=\"line\">                // getSelf()表示本角色</div><div class=\"line\">                getSender().tell(&quot;Patterns.ask()&quot;, getSelf());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                System.out.println(&quot;unhandled:&quot; + message);</div><div class=\"line\">                unhandled(message);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>输出为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">tell1</div><div class=\"line\">unhandled:word2</div><div class=\"line\">ask1</div><div class=\"line\">Patterns.ask()</div><div class=\"line\">system.actorSelection verify:true</div></pre></td></tr></table></figure></p>\n<ol>\n<li>在使用actorSelection函数的时候, 我们需要了解一个关键字<a href=\"https://doc.akka.io/docs/akka/2.3.6/java/untyped-actors.html#actorselection-java\" target=\"_blank\" rel=\"external\">Identify</a>, 它被定义为每个角色都知道其含义的消息, 当接收到Identify时, 角色自动回复ActorIdentity, 其中包含着对地址的角色。actorSelection可以获取该角色的引用, 这样就可以首先和该角色通信了。</li>\n<li>ask和tell的区别是, ask希望对方角色返回结果, 而tell不需要返回结果。</li>\n</ol>\n<h1 id=\"Akka-RPC通信过程\"><a href=\"#Akka-RPC通信过程\" class=\"headerlink\" title=\"Akka RPC通信过程\"></a>Akka RPC通信过程</h1><h2 id=\"AkkaRpcService和RpcServer\"><a href=\"#AkkaRpcService和RpcServer\" class=\"headerlink\" title=\"AkkaRpcService和RpcServer\"></a>AkkaRpcService和RpcServer</h2><p>在正式介绍之前, 先介绍AkkaRpcService, 作为Flink Akka通信核心类, 它包含了akka通信系统ActorSystem, 任何角色产生, 都会调用RpcService.startServer<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public &lt;C extends RpcEndpoint &amp; RpcGateway&gt; RpcServer startServer(C rpcEndpoint) &#123;</div><div class=\"line\">\tCompletableFuture&lt;Void&gt; terminationFuture = new CompletableFuture&lt;&gt;();</div><div class=\"line\">\tfinal Props akkaRpcActorProps;</div><div class=\"line\">\tif (rpcEndpoint instanceof FencedRpcEndpoint) &#123;</div><div class=\"line\">\t\takkaRpcActorProps = Props.create(FencedAkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\takkaRpcActorProps = Props.create(AkkaRpcActor.class, rpcEndpoint, terminationFuture, getVersion());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tActorRef actorRef;</div><div class=\"line\">\tsynchronized (lock) &#123;</div><div class=\"line\">\t\tactorRef = actorSystem.actorOf(akkaRpcActorProps, rpcEndpoint.getEndpointId());</div><div class=\"line\">\t\tactors.put(actorRef, rpcEndpoint);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tLOG.info(&quot;Starting RPC endpoint for &#123;&#125; at &#123;&#125; .&quot;, rpcEndpoint.getClass().getName(), actorRef.path());</div><div class=\"line\">\tfinal String akkaAddress = AkkaUtils.getAkkaURL(actorSystem, actorRef);</div><div class=\"line\">\tfinal String hostname;</div><div class=\"line\">\tOption&lt;String&gt; host = actorRef.path().address().host();</div><div class=\"line\">\tif (host.isEmpty()) &#123;</div><div class=\"line\">\t\thostname = &quot;localhost&quot;;</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\thostname = host.get();</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tSet&lt;Class&lt;?&gt;&gt; implementedRpcGateways = new HashSet&lt;&gt;(RpcUtils.extractImplementedRpcGateways(rpcEndpoint.getClass()));</div><div class=\"line\">\timplementedRpcGateways.add(RpcServer.class);</div><div class=\"line\">\timplementedRpcGateways.add(AkkaBasedEndpoint.class);</div><div class=\"line\">\tfinal InvocationHandler akkaInvocationHandler;</div><div class=\"line\">\tif (rpcEndpoint instanceof FencedRpcEndpoint) &#123;</div><div class=\"line\">\t\t// a FencedRpcEndpoint needs a FencedAkkaInvocationHandler</div><div class=\"line\">\t\takkaInvocationHandler = new FencedAkkaInvocationHandler&lt;&gt;(</div><div class=\"line\">\t\t\takkaAddress,</div><div class=\"line\">\t\t\thostname,</div><div class=\"line\">\t\t\tactorRef,</div><div class=\"line\">\t\t\ttimeout,</div><div class=\"line\">\t\t\tmaximumFramesize,</div><div class=\"line\">\t\t\tterminationFuture,</div><div class=\"line\">\t\t\t((FencedRpcEndpoint&lt;?&gt;) rpcEndpoint)::getFencingToken);</div><div class=\"line\">\t\timplementedRpcGateways.add(FencedMainThreadExecutable.class);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\takkaInvocationHandler = new AkkaInvocationHandler(</div><div class=\"line\">\t\t\takkaAddress,</div><div class=\"line\">\t\t\thostname,</div><div class=\"line\">\t\t\tactorRef,</div><div class=\"line\">\t\t\ttimeout,</div><div class=\"line\">\t\t\tmaximumFramesize,</div><div class=\"line\">\t\t\tterminationFuture);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tClassLoader classLoader = getClass().getClassLoader();</div><div class=\"line\">\tRpcServer server = (RpcServer) Proxy.newProxyInstance(</div><div class=\"line\">\t\tclassLoader,</div><div class=\"line\">\t\timplementedRpcGateways.toArray(new Class&lt;?&gt;[implementedRpcGateways.size()]),</div><div class=\"line\">\t\takkaInvocationHandler);</div><div class=\"line\">\treturn server;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ol>\n<li>角色接收到信息后, 处理的类为FencedAkkaRpcActor/AkkaRpcActor。</li>\n<li>调用函数时的接口handler也分为FencedAkkaInvocationHandler/AkkaInvocationHandler。每次代理GateWay请求时, 首先会调用AkkaInvocationHandler.invoke()类。<br>我们再来介绍下: RpcServer, RpcServer作为任何一个请求终端, 每次都将从相同的AkkaRpcService中参数, 实际封装了ActorRef来进行内部数据传输。</li>\n</ol>\n<h1 id=\"TM向JM注册\"><a href=\"#TM向JM注册\" class=\"headerlink\" title=\"TM向JM注册\"></a>TM向JM注册</h1><p>我们以TaskManager启动后, 会去主动连接JobMaster的ResourceManager, 以它们之间的通信为例进行讲解。YarnTaskExecutorRunner在运行主函数时, 会去调用TaskExecutor.connectToResourceManager()主动连接JobManager:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private void connectToResourceManager() &#123;</div><div class=\"line\">       log.info(&quot;Connecting to ResourceManager &#123;&#125;.&quot;, resourceManagerAddress);</div><div class=\"line\">\tresourceManagerConnection =</div><div class=\"line\">\t\tnew TaskExecutorToResourceManagerConnection(</div><div class=\"line\">\t\t\tlog,</div><div class=\"line\">\t\t\tgetRpcService(),</div><div class=\"line\">\t\t\tgetAddress(),</div><div class=\"line\">\t\t\tgetResourceID(),</div><div class=\"line\">\t\t\ttaskManagerLocation.dataPort(),</div><div class=\"line\">\t\t\thardwareDescription,</div><div class=\"line\">\t\t\tresourceManagerAddress.getAddress(),</div><div class=\"line\">\t\t\tresourceManagerAddress.getResourceManagerId(),</div><div class=\"line\">\t\t\tgetMainThreadExecutor(),</div><div class=\"line\">\t\t\tnew ResourceManagerRegistrationListener());</div><div class=\"line\">\tresourceManagerConnection.start();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>建立好TaskExecutorToResourceManagerConnection之后,看下是如何操作的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void start() &#123;</div><div class=\"line\">\tfinal RetryingRegistration&lt;F, G, S&gt; newRegistration = createNewRegistration();</div><div class=\"line\">\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</div><div class=\"line\">\t\tnewRegistration.startRegistration();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过createNewRegistration构建ResourceManagerRegistration对象, 并没有做其他的事。同时在父类RetryingRegistration中定义了一个CompletableFuture, 当complete时候(成功向jm注册后), 会去调用TaskExecutorToResourceManagerConnection.onRegistrationSuccess(), 之后会详细介绍。</li>\n<li>通过AkkaRpcService.startRegistration真正开始注册TaskManager。接下来看下如何向JobManager的ResourceManager注册该TaskManager。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void startRegistration() &#123;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\t// trigger resolution of the resource manager address to a callable gateway</div><div class=\"line\">\t\tfinal CompletableFuture&lt;G&gt; resourceManagerFuture;</div><div class=\"line\">\t\tif (FencedRpcGateway.class.isAssignableFrom(targetType)) &#123;</div><div class=\"line\">\t\t    //返回的就是clazz对象ResourceManagerGateway的代理</div><div class=\"line\">\t\t\tresourceManagerFuture = (CompletableFuture&lt;G&gt;) rpcService.connect(</div><div class=\"line\">\t\t\t\ttargetAddress,</div><div class=\"line\">\t\t\t\tfencingToken,</div><div class=\"line\">\t\t\t\ttargetType.asSubclass(FencedRpcGateway.class));</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tresourceManagerFuture = rpcService.connect(targetAddress, targetType);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t// upon success, start the registration attempts</div><div class=\"line\">\t\tCompletableFuture&lt;Void&gt; resourceManagerAcceptFuture = resourceManagerFuture.thenAcceptAsync(</div><div class=\"line\">\t\t\t(G result) -&gt; &#123;</div><div class=\"line\">\t\t\t\tlog.info(&quot;Resolved &#123;&#125; address, beginning registration&quot;, targetName);</div><div class=\"line\">\t\t\t\t// 真正想远程JobManager进行注册</div><div class=\"line\">\t\t\t\tregister(result, 1, initialRegistrationTimeout);</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\trpcService.getExecutor());</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要逻辑如下:</p>\n<ol>\n<li>调用rpcService.connect, 获取代理, 代理中包含指向jobManager的ResourceManager的地址(akka.tcp://flink@jobmanager:port/user/resourcemanager)的角色, 以进行rpc通信。</li>\n<li>当产生代理后, 再调用register进行真正RPC远程向JobManager的ResourceManager注册。</li>\n</ol>\n<h2 id=\"构建远程RPC调用的角色及代理\"><a href=\"#构建远程RPC调用的角色及代理\" class=\"headerlink\" title=\"构建远程RPC调用的角色及代理\"></a>构建远程RPC调用的角色及代理</h2><p>我们首先来看下是如何获取代理的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">private &lt;C extends RpcGateway&gt; CompletableFuture&lt;C&gt; connectInternal(</div><div class=\"line\">\t\t\tfinal String address,</div><div class=\"line\">\t\t\tfinal Class&lt;C&gt; clazz,</div><div class=\"line\">\t\t\tFunction&lt;ActorRef, InvocationHandler&gt; invocationHandlerFactory) &#123;</div><div class=\"line\">\t\t// 根据路径获取YarnResourceManager中JobManager ResourceManager的路径引用</div><div class=\"line\">\t\tfinal ActorSelection actorSel = actorSystem.actorSelection(address);</div><div class=\"line\">\t\t// 向该远程路径发送RPC请求, 获取对该远程路径的回话角色, 之后就可以向这个地址发送数据了</div><div class=\"line\">\t\tfinal Future&lt;ActorIdentity&gt; identify = Patterns</div><div class=\"line\">\t\t\t.ask(actorSel, new Identify(42), timeout.toMilliseconds())</div><div class=\"line\">\t\t\t.&lt;ActorIdentity&gt;mapTo(ClassTag$.MODULE$.&lt;ActorIdentity&gt;apply(ActorIdentity.class));</div><div class=\"line\"></div><div class=\"line\">\t\tfinal CompletableFuture&lt;ActorIdentity&gt; identifyFuture = FutureUtils.toJava(identify);</div><div class=\"line\">\t\tfinal CompletableFuture&lt;ActorRef&gt; actorRefFuture = identifyFuture.thenApply(</div><div class=\"line\">\t\t\t(ActorIdentity actorIdentity) -&gt; &#123;</div><div class=\"line\">\t\t\t\tif (actorIdentity.getRef() == null) &#123;</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t    //获取对应的引用</div><div class=\"line\">\t\t\t\t\treturn actorIdentity.getRef();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t\t// 发送handshake请求</div><div class=\"line\">\t\tfinal CompletableFuture&lt;HandshakeSuccessMessage&gt; handshakeFuture = actorRefFuture.thenCompose(</div><div class=\"line\">\t\t\t(ActorRef actorRef) -&gt; FutureUtils.toJava(</div><div class=\"line\">\t\t\t\tPatterns</div><div class=\"line\">\t\t\t\t\t.ask(actorRef, new RemoteHandshakeMessage(clazz, getVersion()), timeout.toMilliseconds())</div><div class=\"line\">\t\t\t\t\t.&lt;HandshakeSuccessMessage&gt;mapTo(ClassTag$.MODULE$.&lt;HandshakeSuccessMessage&gt;apply(HandshakeSuccessMessage.class))));</div><div class=\"line\">\t\treturn actorRefFuture.thenCombineAsync(</div><div class=\"line\">\t\t\thandshakeFuture,</div><div class=\"line\">\t\t\t(ActorRef actorRef, HandshakeSuccessMessage ignored) -&gt; &#123;</div><div class=\"line\">\t\t\t    //获取FencedAkkaInvocationHandler</div><div class=\"line\">\t\t\t\tInvocationHandler invocationHandler = invocationHandlerFactory.apply(actorRef);</div><div class=\"line\">\t\t\t\tClassLoader classLoader = getClass().getClassLoader();</div><div class=\"line\">\t\t\t\t@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">\t\t\t\t// 构建针对ResourceManagerGateway的代理, handler为FencedAkkaInvocationHandler</div><div class=\"line\">\t\t\t\tC proxy = (C) Proxy.newProxyInstance(</div><div class=\"line\">\t\t\t\t\tclassLoader,</div><div class=\"line\">\t\t\t\t\tnew Class&lt;?&gt;[]&#123;clazz&#125;,</div><div class=\"line\">\t\t\t\t\tinvocationHandler);</div><div class=\"line\">\t\t\t\treturn proxy;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\tactorSystem.dispatcher());</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>连接请求也比较简单, 每次RPC调用时, 都使用ask:</p>\n<ol>\n<li>向ResourceManager发送Identify, 远程响应并发返回对应路径的角色</li>\n<li>向ResourceManager发送RemoteHandshakeMessage, 再次和远程确认。</li>\n<li>以上两个RPC调用完成后, 构建针对ResourceManagerGateway的代理, 其中handler为FencedAkkaInvocationHandler(rpcEndpoint=ActorRef)。</li>\n</ol>\n<h2 id=\"TM向JM远程RPC注册\"><a href=\"#TM向JM远程RPC注册\" class=\"headerlink\" title=\"TM向JM远程RPC注册\"></a>TM向JM远程RPC注册</h2><p>当获取到通信的ActorRef后, 调用register进行注册:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private void register(final G gateway, final int attempt, final long timeoutMillis) &#123;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t    // 跑到ResourceManagerConnection.invokeRegistration</div><div class=\"line\">\t\tlog.info(&quot;Registration at &#123;&#125; attempt &#123;&#125; (timeout=&#123;&#125;ms)&quot;, targetName, attempt, timeoutMillis);</div><div class=\"line\">\t\tCompletableFuture&lt;RegistrationResponse&gt; registrationFuture = invokeRegistration(gateway, fencingToken, timeoutMillis);</div><div class=\"line\">\t\t// if the registration was successful, let the TaskExecutor know</div><div class=\"line\">\t\tCompletableFuture&lt;Void&gt; registrationAcceptFuture = registrationFuture.thenAcceptAsync(</div><div class=\"line\">\t\t\t(RegistrationResponse result) -&gt; &#123;</div><div class=\"line\">\t\t\t\tif (!isCanceled()) &#123;</div><div class=\"line\">\t\t\t\t\tif (result instanceof RegistrationResponse.Success) &#123;</div><div class=\"line\">\t\t\t\t\t\t// registration successful!</div><div class=\"line\">\t\t\t\t\t\tS success = (S) result;  // JobMasterRegistrationSuccess</div><div class=\"line\">\t\t\t\t\t\t//表示完成了JobMaster的注册，将completionFuture置为完成</div><div class=\"line\">\t\t\t\t\t\tcompletionFuture.complete(Tuple2.of(gateway, success));</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\trpcService.getExecutor());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tcatch (Throwable t) &#123;</div><div class=\"line\">\t\tcompletionFuture.completeExceptionally(t);</div><div class=\"line\">\t\tcancel();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ol>\n<li>register中真正向ResourceManager通信的是invokeRegistration()。</li>\n<li>将completionFuture置为完成, 那么将触发之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。<br>我们先看invokeRegistration的实现逻辑:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">      protected CompletableFuture&lt;RegistrationResponse&gt; invokeRegistration(</div><div class=\"line\">\t\tResourceManagerGateway resourceManager, ResourceManagerId fencingToken, long timeoutMillis) throws Exception &#123;</div><div class=\"line\">\tTime timeout = Time.milliseconds(timeoutMillis);</div><div class=\"line\">\t//resourceManager=FencedAkkaInvocationHandler,返回TaskExecutorRegistrationSuccess， 这里会跳到JobManager</div><div class=\"line\">\treturn resourceManager.registerTaskExecutor(</div><div class=\"line\">\t\ttaskExecutorAddress,</div><div class=\"line\">\t\tresourceID,</div><div class=\"line\">\t\tdataPort,</div><div class=\"line\">\t\thardwareDescription,</div><div class=\"line\">\t\ttimeout);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>resourceManager.registerTaskExecutor将首先跑到FencedAkkaInvocationHandler.invoke, 最终真正发送rpc请求的是invokeRpc:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Object invokeRpc(Method method, Object[] args) throws Exception &#123;</div><div class=\"line\">\tString methodName = method.getName();</div><div class=\"line\">\tClass&lt;?&gt;[] parameterTypes = method.getParameterTypes();</div><div class=\"line\">\tAnnotation[][] parameterAnnotations = method.getParameterAnnotations();</div><div class=\"line\">\tTime futureTimeout = extractRpcTimeout(parameterAnnotations, args, timeout);</div><div class=\"line\">\t//这里会构建函数名称等</div><div class=\"line\">\tfinal RpcInvocation rpcInvocation = createRpcInvocationMessage(methodName, parameterTypes, args);</div><div class=\"line\">\tClass&lt;?&gt; returnType = method.getReturnType();</div><div class=\"line\">\tfinal Object result;</div><div class=\"line\">\tif (Objects.equals(returnType, Void.TYPE)) &#123;</div><div class=\"line\">\t\ttell(rpcInvocation);</div><div class=\"line\">\t\tresult = null;</div><div class=\"line\">\t&#125; else if (Objects.equals(returnType, CompletableFuture.class)) &#123;</div><div class=\"line\">\t\t// execute an asynchronous call, 需要返回请求结果。</div><div class=\"line\">\t\tresult = ask(rpcInvocation, futureTimeout);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\t// execute a synchronous call</div><div class=\"line\">\t\tCompletableFuture&lt;?&gt; futureResult = ask(rpcInvocation, futureTimeout);</div><div class=\"line\">\t\tresult = futureResult.get(futureTimeout.getSize(), futureTimeout.getUnit());</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最终通过ask将请求发送出去, 其中包括函数名, 参数等信息。</p>\n<h1 id=\"远程ResourceManager接收到请求\"><a href=\"#远程ResourceManager接收到请求\" class=\"headerlink\" title=\"远程ResourceManager接收到请求\"></a>远程ResourceManager接收到请求</h1><p>我们可以看到在构建YarnResourceManager时, resourceManagerEndpointId为<code>resourcemanager</code>, 最终其ActorRef对应的直接地址为: akka.tcp://flink@jobmanager:port/user/resourcemanager, 印证了之前TM向JM注册时, JM通信的终端就是该类。在ActorRef构建过程中, 知道JM接受处理类为AkkaRpcActor.onReceive(FencedAkkaRpcActor父类), 继续调用的是handleRpcMessage()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void handleRpcMessage(Object message) &#123;</div><div class=\"line\">\tif (message instanceof RunAsync) &#123;</div><div class=\"line\">\t\thandleRunAsync((RunAsync) message);</div><div class=\"line\">\t&#125; else if (message instanceof CallAsync) &#123;</div><div class=\"line\">\t\thandleCallAsync((CallAsync) message);</div><div class=\"line\">\t&#125; else if (message instanceof RpcInvocation) &#123;</div><div class=\"line\">\t\thandleRpcInvocation((RpcInvocation) message);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>flink针对不同类型的消息, 使用调用的函数, 很显然, 这里调用handleRpcInvocation:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void handleRpcInvocation(RpcInvocation rpcInvocation) &#123;</div><div class=\"line\">\tMethod rpcMethod = null;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tString methodName = rpcInvocation.getMethodName();</div><div class=\"line\">\t\tClass&lt;?&gt;[] parameterTypes = rpcInvocation.getParameterTypes();</div><div class=\"line\">\t\trpcMethod = lookupRpcMethod(methodName, parameterTypes);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (rpcMethod != null) &#123;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\t// this supports declaration of anonymous classes</div><div class=\"line\">\t\t\trpcMethod.setAccessible(true);</div><div class=\"line\">\t\t\tif (rpcMethod.getReturnType().equals(Void.TYPE)) &#123;</div><div class=\"line\">\t\t\t\t// No return value to send back</div><div class=\"line\">\t\t\t\trpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse &#123;</div><div class=\"line\">\t\t\t\tfinal Object result;</div><div class=\"line\">\t\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\t\tresult = rpcMethod.invoke(rpcEndpoint, rpcInvocation.getArgs());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\tif (result instanceof CompletableFuture) &#123;</div><div class=\"line\">\t\t\t\t\tfinal CompletableFuture&lt;?&gt; future = (CompletableFuture&lt;?&gt;) result;</div><div class=\"line\">\t\t\t\t\tPromise.DefaultPromise&lt;Object&gt; promise = new Promise.DefaultPromise&lt;&gt;();</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tfuture.whenComplete(</div><div class=\"line\">\t\t\t\t\t\t(value, throwable) -&gt; &#123;</div><div class=\"line\">\t\t\t\t\t\t\tif (throwable != null) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\tpromise.failure(throwable);</div><div class=\"line\">\t\t\t\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\t\t\t    //再回调一下</div><div class=\"line\">\t\t\t\t\t\t\t\tpromise.success(value);</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t\tPatterns.pipe(promise.future(), getContext().dispatcher()).to(getSender());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最终调用的是result = rpcMethod.invoke()来处理TM发送的请求。实际调用ResourceManager.registerTaskExecutor()-&gt;registerTaskExecutorInternal()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div></pre></td><td class=\"code\"><pre><div class=\"line\">private RegistrationResponse registerTaskExecutorInternal(</div><div class=\"line\">\t\tTaskExecutorGateway taskExecutorGateway,</div><div class=\"line\">\t\tString taskExecutorAddress,</div><div class=\"line\">\t\tResourceID taskExecutorResourceId,</div><div class=\"line\">\t\tint dataPort,</div><div class=\"line\">\t\tHardwareDescription hardwareDescription) &#123;</div><div class=\"line\">\tWorkerRegistration&lt;WorkerType&gt; oldRegistration = taskExecutors.remove(taskExecutorResourceId);</div><div class=\"line\">\t// 首先做些清理, 删掉旧的</div><div class=\"line\">\tif (oldRegistration != null) &#123;</div><div class=\"line\">\t\t// TODO :: suggest old taskExecutor to stop itself</div><div class=\"line\">\t\tlog.debug(&quot;Replacing old registration of TaskExecutor &#123;&#125;.&quot;, taskExecutorResourceId);</div><div class=\"line\">\t\t// remove old task manager registration from slot manager</div><div class=\"line\">\t\tslotManager.unregisterTaskManager(oldRegistration.getInstanceID());</div><div class=\"line\">\t&#125;</div><div class=\"line\">       // 跑到YarnResourceManager.workerStarted(在yarn返回container成功后，会去注册Container)</div><div class=\"line\">\tfinal WorkerType newWorker = workerStarted(taskExecutorResourceId);</div><div class=\"line\">\tif (newWorker == null) &#123;</div><div class=\"line\">\t    //找不到, 就说明这个container不是这个JM申请的</div><div class=\"line\">\t\tlog.warn(&quot;Discard registration from TaskExecutor &#123;&#125; at (&#123;&#125;) because the framework did &quot; +</div><div class=\"line\">\t\t\t&quot;not recognize it&quot;, taskExecutorResourceId, taskExecutorAddress);</div><div class=\"line\">\t\treturn new RegistrationResponse.Decline(&quot;unrecognized TaskExecutor&quot;);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\tWorkerRegistration&lt;WorkerType&gt; registration =</div><div class=\"line\">\t\t    //taskExecutorGateway=AkkaInvocationHandler，  newWorker = YarnWorkerNode</div><div class=\"line\">\t\t\tnew WorkerRegistration&lt;&gt;(taskExecutorGateway, newWorker, dataPort, hardwareDescription);</div><div class=\"line\">\t\t// 统计活跃而Container。</div><div class=\"line\">\t\ttaskExecutors.put(taskExecutorResourceId, registration);</div><div class=\"line\">\t\ttaskManagerHeartbeatManager.monitorTarget(taskExecutorResourceId, new HeartbeatTarget&lt;Void&gt;() &#123;</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, Void payload) &#123;</div><div class=\"line\">\t\t\t\t// the ResourceManager will always send heartbeat requests to the</div><div class=\"line\">\t\t\t\t// TaskManager</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\t@Override</div><div class=\"line\">\t\t\tpublic void requestHeartbeat(ResourceID resourceID, Void payload) &#123;</div><div class=\"line\">\t\t\t\ttaskExecutorGateway.heartbeatFromResourceManager(resourceID);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\">\t\treturn new TaskExecutorRegistrationSuccess(</div><div class=\"line\">\t\t\tregistration.getInstanceID(),</div><div class=\"line\">\t\t\tresourceId,</div><div class=\"line\">\t\t\tresourceManagerConfiguration.getHeartbeatInterval().toMilliseconds(),</div><div class=\"line\">\t\t\tclusterInformation);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>ResourceManager注册主要做了如下事情:</p>\n<ol>\n<li>从taskExecutors中删除旧的通信管道。</li>\n<li>跑到YarnResourceManager.workerStarted()里面, 从JM端根据获取当初yarn分配的Container。</li>\n<li>向taskExecutors添加新产生的管道WorkerRegistration。管道里包含TaskExecutorGateway的代理, 其中handler为AkkaInvocationHandler, 且包含连接JobManager的ActorRef。</li>\n<li>JM对连接的TM添加监控。然后响应TM。</li>\n</ol>\n<h1 id=\"TM接收到JM响应\"><a href=\"#TM接收到JM响应\" class=\"headerlink\" title=\"TM接收到JM响应\"></a>TM接收到JM响应</h1><p>当TM接收到JM响应, 就会回调之前定义的TaskExecutorToResourceManagerConnection.onRegistrationSuccess()。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void establishResourceManagerConnection(</div><div class=\"line\">\t\tResourceManagerGateway resourceManagerGateway,</div><div class=\"line\">\t\tResourceID resourceManagerResourceId,</div><div class=\"line\">\t\tInstanceID taskExecutorRegistrationId,</div><div class=\"line\">\t\tClusterInformation clusterInformation) &#123;</div><div class=\"line\">\t// TM向JM会报本地slot的情况, 供JM来分配给申请者。</div><div class=\"line\">\tfinal CompletableFuture&lt;Acknowledge&gt; slotReportResponseFuture = resourceManagerGateway.sendSlotReport(</div><div class=\"line\">\t\tgetResourceID(),</div><div class=\"line\">\t\ttaskExecutorRegistrationId,</div><div class=\"line\">\t\ttaskSlotTable.createSlotReport(getResourceID()),</div><div class=\"line\">\t\ttaskManagerConfiguration.getTimeout());</div><div class=\"line\">\t// monitor the resource manager as heartbeat target</div><div class=\"line\">\tresourceManagerHeartbeatManager.monitorTarget(resourceManagerResourceId, new HeartbeatTarget&lt;SlotReport&gt;() &#123;</div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void receiveHeartbeat(ResourceID resourceID, SlotReport slotReport) &#123;</div><div class=\"line\">\t\t\tresourceManagerGateway.heartbeatFromTaskManager(resourceID, slotReport);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void requestHeartbeat(ResourceID resourceID, SlotReport slotReport) &#123;</div><div class=\"line\">\t\t\t// the TaskManager won&apos;t send heartbeat requests to the ResourceManager</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">\t// set the propagated blob server address</div><div class=\"line\">\tfinal InetSocketAddress blobServerAddress = new InetSocketAddress(</div><div class=\"line\">\t\tclusterInformation.getBlobServerHostname(),</div><div class=\"line\">\t\tclusterInformation.getBlobServerPort());</div><div class=\"line\">\tblobCacheService.setBlobServerAddress(blobServerAddress);</div><div class=\"line\">\testablishedResourceManagerConnection = new EstablishedResourceManagerConnection(</div><div class=\"line\">\t\tresourceManagerGateway,</div><div class=\"line\">\t\tresourceManagerResourceId,</div><div class=\"line\">\t\ttaskExecutorRegistrationId);</div><div class=\"line\">\tstopRegistrationTimeout();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>TM当收到Response, 回调函数做了如下事情:</p>\n<ol>\n<li>通过resourceManagerGateway.sendSlotReport向YarnResourceManager汇报当前TM可用slot, 可用slot都将保存在 JobManager ResourceManager.freeSlots里面。</li>\n<li>开始向ResourceManager上报心跳。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>可以看到, Akka通信最底层依靠的是Patterns.ask来完成, 整个通信流程也是比较清晰的。</p>\n"},{"title":"Flink原理-Container启动命令内存参数分析","date":"2019-06-08T11:22:29.000Z","toc":true,"_content":"如下是flink on yarn启动的一个示例:\n```.\n/bin/flink run -m yarn-cluster -yd -yjm 1024 -ys 2 -ytm 2048 clink-with-dependencies.jar  --topic_name topic1 --log_name --source_num 50  --sink_num 50\n```\n其中我们定义了JobManager的大小为1024M, TaskManager大小为2048M, 但是通过实际观察发现JobManager heap大小为424M, TaskManager heap memory大小为1304M, direct memory大小为744M , 参数值为啥是这个呢?\n#  JobManager内存参数设置\n可以看到, JM内存设置与实际严重不符, 我们直接上代码找下原因吧。\n```\n121390 YarnJobClusterEntrypoint -Xmx424m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000001/jobmanager.log -Dlogback.configurationFile=file:logback.xml -Dlog4j.configuration=file:log4j.properties\n```\nJM启动命令的产生是在AbstractYarnClusterDescriptor.startAppMaster()中, 最终进入了setupApplicationMasterContainer()中:\n```\n\tprotected ContainerLaunchContext setupApplicationMasterContainer(\n\t\t\tString yarnClusterEntrypoint, //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint\n\t\t\tboolean hasLogback,\n\t\t\tboolean hasLog4j,\n\t\t\tboolean hasKrb5,\n\t\t\tint jobManagerMemoryMb) {\n\t\t// ------------------ Prepare Application Master Container  ------------------------------\n\t\t// respect custom JVM options in the YAML file\n\t\tString javaOpts = flinkConfiguration.getString(CoreOptions.FLINK_JVM_OPTIONS);\n\t\tif (flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS).length() > 0) {\n\t\t\tjavaOpts += \" \" + flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS);\n\t\t}\n\t\t// Set up the container launch context for the application master\n\t\tContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);\n\t\tfinal  Map<String, String> startCommandValues = new HashMap<>();\n\t\tstartCommandValues.put(\"java\", \"$JAVA_HOME/bin/java\");\n\t\tstartCommandValues.put(\"jvmmem\", \"-Xmx\" +\n\t\t\tUtils.calculateHeapSize(jobManagerMemoryMb, flinkConfiguration) +\n\t\t\t\"m\");\n\t\tstartCommandValues.put(\"jvmopts\", javaOpts);\n\t\tString logging = \"\";\n\n       //构建启动命令，class指定了申请的container启动哪个主函数，也就是jm  applicationMaster的地址\n\t\tstartCommandValues.put(\"logging\", logging);\n\t\tstartCommandValues.put(\"class\", yarnClusterEntrypoint);   //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint\n\t\tstartCommandValues.put(\"redirects\",\n\t\t\t\"1> \" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/jobmanager.out \" +\n\t\t\t\"2> \" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/jobmanager.err\");\n\t\tstartCommandValues.put(\"args\", \"\");\n\n\t\tfinal String commandTemplate = flinkConfiguration  // jm 启动默认命令\n\t\t\t.getString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE,\n\t\t\t\tConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE);\n\t\tfinal String amCommand =\n\t\t\tBootstrapTools.getStartCommand(commandTemplate, startCommandValues); //获取真正的 jm  启动命令\n\n\t\t// 真正去通过yarn调度启动JM\n\t\tamContainer.setCommands(Collections.singletonList(amCommand));\n\t\treturn amContainer;\n\t}\n```\n可以看到, JM启动默认只设置了-Xmx, 在Utils.calculateHeapSize(jobManagerMemoryMb)中设置了,\n```\n\tpublic static int calculateHeapSize(int memory, org.apache.flink.configuration.Configuration conf) {\n        // container占用比率,containerized.heap-cutoff-ratio, 默认25%\n\t\tfloat memoryCutoffRatio = conf.getFloat(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);\n\t\t// container占用最小内存大小: containerized.heap-cutoff-min, 最少600mb\n\t\tint minCutoff = conf.getInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);\n\t\tif (memoryCutoffRatio > 1 || memoryCutoffRatio < 0) {\n\t\t\tthrow new IllegalArgumentException(\"The configuration value '\"\n\t\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO.key()\n\t\t\t\t+ \"' must be between 0 and 1. Value given=\" + memoryCutoffRatio);\n\t\t}\n\t\tif (minCutoff > memory) {\n\t\t\tthrow new IllegalArgumentException(\"The configuration value '\"\n\t\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN.key()\n\t\t\t\t+ \"' is higher (\" + minCutoff + \") than the requested amount of memory \" + memory);\n\t\t}\n\t\tint heapLimit = (int) ((float) memory * memoryCutoffRatio);\n\t\tif (heapLimit < minCutoff) {\n\t\t\theapLimit = minCutoff;\n\t\t}\n\t\treturn memory - heapLimit;\n\t}\n```\n可以看到, JM启动时, 去掉yarn container占用内存大小, 即为JM大小。 container大小为20%*heap, 但是不得小于600MB,  这里当然只能600M, 所以剩余JM heap大小为(1024-600)MB=424MB。\n\n#  TaskManager内存参数设置\n如下是TM启动后的参数, 可以发现, 堆内内存+对外内存=申请的内存, 那么这个内存如何确定比例的?\n```\n183863 YarnTaskExecutorRunner -Xms1304m -Xmx1304m -XX:MaxDirectMemorySize=744m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000003/taskmanager.log -Dlogback.configurationFile=file:./logback.xml -Dlog4j.configuration=file:./log4j.properties\n```\n当JM为TM申请container成功后, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E7%94%B3%E8%AF%B7container%E6%88%90%E5%8A%9F\">createTaskExecutorLaunchContext</a>中确定JM启动参数, 最终进入到了ContaineredTaskManagerParameters.create中:\n```\n\tpublic static ContaineredTaskManagerParameters create(\n\t\t\tConfiguration config,\n\t\t\tlong containerMemoryMB,\n\t\t\tint numSlots) {\n\t\t// (1) try to compute how much memory used by container\n\t\t// 首先确定yarn Container使用多少内存(算是堆外内存)\n\t\tfinal long cutoffMB = calculateCutoffMB(config, containerMemoryMB);\n\n\t\t// (2) split the remaining Java memory between heap and off-heap\n\t\t//确定堆内内存大小\n\t\tfinal long heapSizeMB = TaskManagerServices.calculateHeapSizeMB(containerMemoryMB - cutoffMB, config);\n\t\t// use the cut-off memory for off-heap (that was its intention)\n\t\t// 堆内内存以外的全是堆内内存\n\t\tfinal long offHeapSizeMB = containerMemoryMB - heapSizeMB;\n\n\t\t// (3) obtain the additional environment variables from the configuration\n\t\tfinal HashMap<String, String> envVars = new HashMap<>();\n\t\tfinal String prefix = ResourceManagerOptions.CONTAINERIZED_TASK_MANAGER_ENV_PREFIX;\n\n\t\tfor (String key : config.keySet()) {\n\t\t\tif (key.startsWith(prefix) && key.length() > prefix.length()) {\n\t\t\t\t// remove prefix\n\t\t\t\tString envVarKey = key.substring(prefix.length());\n\t\t\t\tenvVars.put(envVarKey, config.getString(key, null));\n\t\t\t}\n\t\t}\n\n\t\t// done\n\t\treturn new ContaineredTaskManagerParameters(\n\t\t\tcontainerMemoryMB, heapSizeMB, offHeapSizeMB, numSlots, envVars);\n\t}\n```\n该函数主要做了如下逻辑:\n1. 确定yarn container本身需要的内存(算是堆外内存)。\n2. 确定堆内的内存大小。\n3. 确定堆外内存大小, 不是堆内的内存就全部算是堆外内存。\n首先我们看下如何确定yarn container大小的:\n```\n\tpublic static long calculateCutoffMB(Configuration config, long containerMemoryMB) {\n\t\tPreconditions.checkArgument(containerMemoryMB > 0);\n\t\t// (1) check cutoff ratio  // 默认值0.25f\n\t\tfinal float memoryCutoffRatio = config.getFloat(\n\t\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);\n\t\t// (2) check min cutoff value   最少预留大小默认600MB\n\t\tfinal int minCutoff = config.getInteger(\n\t\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);\n\t\t// (3) check between heap and off-heap\n\t\tlong cutoff = (long) (containerMemoryMB * memoryCutoffRatio);\n\t\t//取最大值\n\t\tif (cutoff < minCutoff) {\n\t\t\tcutoff = minCutoff;\n\t\t}\n\t\treturn cutoff;  //至少预留600MB，\n\t}\n```\nyarn container大小取值原则: 在申请内存的containerized.heap-cutoff-ratio(默认25%)与containerized.heap-cutoff-min(默认600M)之前取最大值。本示例中, container占用600M\n接下来我们看下如何确定堆内内存的:\n```\n\tpublic static long calculateHeapSizeMB(long totalJavaMemorySizeMB, Configuration config) {\n\t\t// subtract the Java memory used for network buffers (always off-heap)\n\t\t//  网络buffer, 最小64M，最大1GB, 是totalJavaMemorySizeMB*0.1\n\t\tfinal long networkBufMB =\n\t\t\tcalculateNetworkBufferMemory(\n\t\t\t\ttotalJavaMemorySizeMB << 20, // megabytes to bytes\n\t\t\t\tconfig) >> 20; // bytes to megabytes\n\t\tfinal long remainingJavaMemorySizeMB = totalJavaMemorySizeMB - networkBufMB;\n\t\t// split the available Java memory between heap and off-heap\n\t\tfinal boolean useOffHeap = config.getBoolean(TaskManagerOptions.MEMORY_OFF_HEAP);  // 默认为false\n\n\t\tfinal long heapSizeMB;\n\t\tif (useOffHeap) {// 默认线上是关闭的\n\t\t\tlong offHeapSize;\n\t\t\tString managedMemorySizeDefaultVal = TaskManagerOptions.MANAGED_MEMORY_SIZE.defaultValue();\n\t\t\tif (!config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE).equals(managedMemorySizeDefaultVal)) {\n\t\t\t\ttry {// 将划去networkBuffer大小*一个堆外的系数（默认是0.7）得到其他的堆外内存\n\t\t\t\t\toffHeapSize = MemorySize.parse(config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE), MEGA_BYTES).getMebiBytes();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toffHeapSize = Long.valueOf(managedMemorySizeDefaultVal);\n\t\t\t}\n\n\t\t\tif (offHeapSize <= 0) {\n\t\t\t\t// calculate off-heap section via fraction\n\t\t\t\tdouble fraction = config.getFloat(TaskManagerOptions.MANAGED_MEMORY_FRACTION);\n\t\t\t\toffHeapSize = (long) (fraction * remainingJavaMemorySizeMB);\n\t\t\t}\n\n\t\t\tTaskManagerServicesConfiguration\n\t\t\t\t.checkConfigParameter(offHeapSize < remainingJavaMemorySizeMB, offHeapSize,\n\t\t\t\t\tTaskManagerOptions.MANAGED_MEMORY_SIZE.key(),\n\t\t\t\t\t\"Managed memory size too large for \" + networkBufMB +\n\t\t\t\t\t\t\" MB network buffer memory and a total of \" + totalJavaMemorySizeMB +\n\t\t\t\t\t\t\" MB JVM memory\");\n\t\t\theapSizeMB = remainingJavaMemorySizeMB - offHeapSize;\n\t\t} else {\n\t\t\theapSizeMB = remainingJavaMemorySizeMB;\n\t\t}\n\n\t\treturn heapSizeMB;\n\t}\n```\n内存大小确定过程:\n1. 首先确定网络buffer大小: 是totalJavaMemorySizeMB*0.1, 而且最小64M，最大1GB。 这里是(2048-600)*0.1MB=144.8M。\n2. 剩余内存大小为(2048-600)*0.9MB=1304MB。\n3. 在我们代码中, useOffHeap是false, 由taskmanager.memory.off-heap设置, 默认为false。\n那么, TM启动的参数就很明显了, HEAP为1304MB, OFF-HEAD为2048MB-1304MB=744MB(包括Container占用空闲+网络buffer)。\n\n","source":"_posts/Flink原理-Container启动命令内存参数分析.md","raw":"---\ntitle: Flink原理-Container启动命令内存参数分析\ndate: 2019-06-08 19:22:29\ntags:\ntoc: true\n---\n如下是flink on yarn启动的一个示例:\n```.\n/bin/flink run -m yarn-cluster -yd -yjm 1024 -ys 2 -ytm 2048 clink-with-dependencies.jar  --topic_name topic1 --log_name --source_num 50  --sink_num 50\n```\n其中我们定义了JobManager的大小为1024M, TaskManager大小为2048M, 但是通过实际观察发现JobManager heap大小为424M, TaskManager heap memory大小为1304M, direct memory大小为744M , 参数值为啥是这个呢?\n#  JobManager内存参数设置\n可以看到, JM内存设置与实际严重不符, 我们直接上代码找下原因吧。\n```\n121390 YarnJobClusterEntrypoint -Xmx424m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000001/jobmanager.log -Dlogback.configurationFile=file:logback.xml -Dlog4j.configuration=file:log4j.properties\n```\nJM启动命令的产生是在AbstractYarnClusterDescriptor.startAppMaster()中, 最终进入了setupApplicationMasterContainer()中:\n```\n\tprotected ContainerLaunchContext setupApplicationMasterContainer(\n\t\t\tString yarnClusterEntrypoint, //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint\n\t\t\tboolean hasLogback,\n\t\t\tboolean hasLog4j,\n\t\t\tboolean hasKrb5,\n\t\t\tint jobManagerMemoryMb) {\n\t\t// ------------------ Prepare Application Master Container  ------------------------------\n\t\t// respect custom JVM options in the YAML file\n\t\tString javaOpts = flinkConfiguration.getString(CoreOptions.FLINK_JVM_OPTIONS);\n\t\tif (flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS).length() > 0) {\n\t\t\tjavaOpts += \" \" + flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS);\n\t\t}\n\t\t// Set up the container launch context for the application master\n\t\tContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);\n\t\tfinal  Map<String, String> startCommandValues = new HashMap<>();\n\t\tstartCommandValues.put(\"java\", \"$JAVA_HOME/bin/java\");\n\t\tstartCommandValues.put(\"jvmmem\", \"-Xmx\" +\n\t\t\tUtils.calculateHeapSize(jobManagerMemoryMb, flinkConfiguration) +\n\t\t\t\"m\");\n\t\tstartCommandValues.put(\"jvmopts\", javaOpts);\n\t\tString logging = \"\";\n\n       //构建启动命令，class指定了申请的container启动哪个主函数，也就是jm  applicationMaster的地址\n\t\tstartCommandValues.put(\"logging\", logging);\n\t\tstartCommandValues.put(\"class\", yarnClusterEntrypoint);   //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint\n\t\tstartCommandValues.put(\"redirects\",\n\t\t\t\"1> \" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/jobmanager.out \" +\n\t\t\t\"2> \" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + \"/jobmanager.err\");\n\t\tstartCommandValues.put(\"args\", \"\");\n\n\t\tfinal String commandTemplate = flinkConfiguration  // jm 启动默认命令\n\t\t\t.getString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE,\n\t\t\t\tConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE);\n\t\tfinal String amCommand =\n\t\t\tBootstrapTools.getStartCommand(commandTemplate, startCommandValues); //获取真正的 jm  启动命令\n\n\t\t// 真正去通过yarn调度启动JM\n\t\tamContainer.setCommands(Collections.singletonList(amCommand));\n\t\treturn amContainer;\n\t}\n```\n可以看到, JM启动默认只设置了-Xmx, 在Utils.calculateHeapSize(jobManagerMemoryMb)中设置了,\n```\n\tpublic static int calculateHeapSize(int memory, org.apache.flink.configuration.Configuration conf) {\n        // container占用比率,containerized.heap-cutoff-ratio, 默认25%\n\t\tfloat memoryCutoffRatio = conf.getFloat(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);\n\t\t// container占用最小内存大小: containerized.heap-cutoff-min, 最少600mb\n\t\tint minCutoff = conf.getInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);\n\t\tif (memoryCutoffRatio > 1 || memoryCutoffRatio < 0) {\n\t\t\tthrow new IllegalArgumentException(\"The configuration value '\"\n\t\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO.key()\n\t\t\t\t+ \"' must be between 0 and 1. Value given=\" + memoryCutoffRatio);\n\t\t}\n\t\tif (minCutoff > memory) {\n\t\t\tthrow new IllegalArgumentException(\"The configuration value '\"\n\t\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN.key()\n\t\t\t\t+ \"' is higher (\" + minCutoff + \") than the requested amount of memory \" + memory);\n\t\t}\n\t\tint heapLimit = (int) ((float) memory * memoryCutoffRatio);\n\t\tif (heapLimit < minCutoff) {\n\t\t\theapLimit = minCutoff;\n\t\t}\n\t\treturn memory - heapLimit;\n\t}\n```\n可以看到, JM启动时, 去掉yarn container占用内存大小, 即为JM大小。 container大小为20%*heap, 但是不得小于600MB,  这里当然只能600M, 所以剩余JM heap大小为(1024-600)MB=424MB。\n\n#  TaskManager内存参数设置\n如下是TM启动后的参数, 可以发现, 堆内内存+对外内存=申请的内存, 那么这个内存如何确定比例的?\n```\n183863 YarnTaskExecutorRunner -Xms1304m -Xmx1304m -XX:MaxDirectMemorySize=744m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000003/taskmanager.log -Dlogback.configurationFile=file:./logback.xml -Dlog4j.configuration=file:./log4j.properties\n```\n当JM为TM申请container成功后, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E7%94%B3%E8%AF%B7container%E6%88%90%E5%8A%9F\">createTaskExecutorLaunchContext</a>中确定JM启动参数, 最终进入到了ContaineredTaskManagerParameters.create中:\n```\n\tpublic static ContaineredTaskManagerParameters create(\n\t\t\tConfiguration config,\n\t\t\tlong containerMemoryMB,\n\t\t\tint numSlots) {\n\t\t// (1) try to compute how much memory used by container\n\t\t// 首先确定yarn Container使用多少内存(算是堆外内存)\n\t\tfinal long cutoffMB = calculateCutoffMB(config, containerMemoryMB);\n\n\t\t// (2) split the remaining Java memory between heap and off-heap\n\t\t//确定堆内内存大小\n\t\tfinal long heapSizeMB = TaskManagerServices.calculateHeapSizeMB(containerMemoryMB - cutoffMB, config);\n\t\t// use the cut-off memory for off-heap (that was its intention)\n\t\t// 堆内内存以外的全是堆内内存\n\t\tfinal long offHeapSizeMB = containerMemoryMB - heapSizeMB;\n\n\t\t// (3) obtain the additional environment variables from the configuration\n\t\tfinal HashMap<String, String> envVars = new HashMap<>();\n\t\tfinal String prefix = ResourceManagerOptions.CONTAINERIZED_TASK_MANAGER_ENV_PREFIX;\n\n\t\tfor (String key : config.keySet()) {\n\t\t\tif (key.startsWith(prefix) && key.length() > prefix.length()) {\n\t\t\t\t// remove prefix\n\t\t\t\tString envVarKey = key.substring(prefix.length());\n\t\t\t\tenvVars.put(envVarKey, config.getString(key, null));\n\t\t\t}\n\t\t}\n\n\t\t// done\n\t\treturn new ContaineredTaskManagerParameters(\n\t\t\tcontainerMemoryMB, heapSizeMB, offHeapSizeMB, numSlots, envVars);\n\t}\n```\n该函数主要做了如下逻辑:\n1. 确定yarn container本身需要的内存(算是堆外内存)。\n2. 确定堆内的内存大小。\n3. 确定堆外内存大小, 不是堆内的内存就全部算是堆外内存。\n首先我们看下如何确定yarn container大小的:\n```\n\tpublic static long calculateCutoffMB(Configuration config, long containerMemoryMB) {\n\t\tPreconditions.checkArgument(containerMemoryMB > 0);\n\t\t// (1) check cutoff ratio  // 默认值0.25f\n\t\tfinal float memoryCutoffRatio = config.getFloat(\n\t\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);\n\t\t// (2) check min cutoff value   最少预留大小默认600MB\n\t\tfinal int minCutoff = config.getInteger(\n\t\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);\n\t\t// (3) check between heap and off-heap\n\t\tlong cutoff = (long) (containerMemoryMB * memoryCutoffRatio);\n\t\t//取最大值\n\t\tif (cutoff < minCutoff) {\n\t\t\tcutoff = minCutoff;\n\t\t}\n\t\treturn cutoff;  //至少预留600MB，\n\t}\n```\nyarn container大小取值原则: 在申请内存的containerized.heap-cutoff-ratio(默认25%)与containerized.heap-cutoff-min(默认600M)之前取最大值。本示例中, container占用600M\n接下来我们看下如何确定堆内内存的:\n```\n\tpublic static long calculateHeapSizeMB(long totalJavaMemorySizeMB, Configuration config) {\n\t\t// subtract the Java memory used for network buffers (always off-heap)\n\t\t//  网络buffer, 最小64M，最大1GB, 是totalJavaMemorySizeMB*0.1\n\t\tfinal long networkBufMB =\n\t\t\tcalculateNetworkBufferMemory(\n\t\t\t\ttotalJavaMemorySizeMB << 20, // megabytes to bytes\n\t\t\t\tconfig) >> 20; // bytes to megabytes\n\t\tfinal long remainingJavaMemorySizeMB = totalJavaMemorySizeMB - networkBufMB;\n\t\t// split the available Java memory between heap and off-heap\n\t\tfinal boolean useOffHeap = config.getBoolean(TaskManagerOptions.MEMORY_OFF_HEAP);  // 默认为false\n\n\t\tfinal long heapSizeMB;\n\t\tif (useOffHeap) {// 默认线上是关闭的\n\t\t\tlong offHeapSize;\n\t\t\tString managedMemorySizeDefaultVal = TaskManagerOptions.MANAGED_MEMORY_SIZE.defaultValue();\n\t\t\tif (!config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE).equals(managedMemorySizeDefaultVal)) {\n\t\t\t\ttry {// 将划去networkBuffer大小*一个堆外的系数（默认是0.7）得到其他的堆外内存\n\t\t\t\t\toffHeapSize = MemorySize.parse(config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE), MEGA_BYTES).getMebiBytes();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toffHeapSize = Long.valueOf(managedMemorySizeDefaultVal);\n\t\t\t}\n\n\t\t\tif (offHeapSize <= 0) {\n\t\t\t\t// calculate off-heap section via fraction\n\t\t\t\tdouble fraction = config.getFloat(TaskManagerOptions.MANAGED_MEMORY_FRACTION);\n\t\t\t\toffHeapSize = (long) (fraction * remainingJavaMemorySizeMB);\n\t\t\t}\n\n\t\t\tTaskManagerServicesConfiguration\n\t\t\t\t.checkConfigParameter(offHeapSize < remainingJavaMemorySizeMB, offHeapSize,\n\t\t\t\t\tTaskManagerOptions.MANAGED_MEMORY_SIZE.key(),\n\t\t\t\t\t\"Managed memory size too large for \" + networkBufMB +\n\t\t\t\t\t\t\" MB network buffer memory and a total of \" + totalJavaMemorySizeMB +\n\t\t\t\t\t\t\" MB JVM memory\");\n\t\t\theapSizeMB = remainingJavaMemorySizeMB - offHeapSize;\n\t\t} else {\n\t\t\theapSizeMB = remainingJavaMemorySizeMB;\n\t\t}\n\n\t\treturn heapSizeMB;\n\t}\n```\n内存大小确定过程:\n1. 首先确定网络buffer大小: 是totalJavaMemorySizeMB*0.1, 而且最小64M，最大1GB。 这里是(2048-600)*0.1MB=144.8M。\n2. 剩余内存大小为(2048-600)*0.9MB=1304MB。\n3. 在我们代码中, useOffHeap是false, 由taskmanager.memory.off-heap设置, 默认为false。\n那么, TM启动的参数就很明显了, HEAP为1304MB, OFF-HEAD为2048MB-1304MB=744MB(包括Container占用空闲+网络buffer)。\n\n","slug":"Flink原理-Container启动命令内存参数分析","published":1,"updated":"2019-06-24T02:25:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w3000bphu5rsexzl0p","content":"<p>如下是flink on yarn启动的一个示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/bin/flink run -m yarn-cluster -yd -yjm 1024 -ys 2 -ytm 2048 clink-with-dependencies.jar  --topic_name topic1 --log_name --source_num 50  --sink_num 50</div></pre></td></tr></table></figure></p>\n<p>其中我们定义了JobManager的大小为1024M, TaskManager大小为2048M, 但是通过实际观察发现JobManager heap大小为424M, TaskManager heap memory大小为1304M, direct memory大小为744M , 参数值为啥是这个呢?</p>\n<h1 id=\"JobManager内存参数设置\"><a href=\"#JobManager内存参数设置\" class=\"headerlink\" title=\"JobManager内存参数设置\"></a>JobManager内存参数设置</h1><p>可以看到, JM内存设置与实际严重不符, 我们直接上代码找下原因吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">121390 YarnJobClusterEntrypoint -Xmx424m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000001/jobmanager.log -Dlogback.configurationFile=file:logback.xml -Dlog4j.configuration=file:log4j.properties</div></pre></td></tr></table></figure></p>\n<p>JM启动命令的产生是在AbstractYarnClusterDescriptor.startAppMaster()中, 最终进入了setupApplicationMasterContainer()中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected ContainerLaunchContext setupApplicationMasterContainer(</div><div class=\"line\">\t\tString yarnClusterEntrypoint, //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint</div><div class=\"line\">\t\tboolean hasLogback,</div><div class=\"line\">\t\tboolean hasLog4j,</div><div class=\"line\">\t\tboolean hasKrb5,</div><div class=\"line\">\t\tint jobManagerMemoryMb) &#123;</div><div class=\"line\">\t// ------------------ Prepare Application Master Container  ------------------------------</div><div class=\"line\">\t// respect custom JVM options in the YAML file</div><div class=\"line\">\tString javaOpts = flinkConfiguration.getString(CoreOptions.FLINK_JVM_OPTIONS);</div><div class=\"line\">\tif (flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS).length() &gt; 0) &#123;</div><div class=\"line\">\t\tjavaOpts += &quot; &quot; + flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t// Set up the container launch context for the application master</div><div class=\"line\">\tContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);</div><div class=\"line\">\tfinal  Map&lt;String, String&gt; startCommandValues = new HashMap&lt;&gt;();</div><div class=\"line\">\tstartCommandValues.put(&quot;java&quot;, &quot;$JAVA_HOME/bin/java&quot;);</div><div class=\"line\">\tstartCommandValues.put(&quot;jvmmem&quot;, &quot;-Xmx&quot; +</div><div class=\"line\">\t\tUtils.calculateHeapSize(jobManagerMemoryMb, flinkConfiguration) +</div><div class=\"line\">\t\t&quot;m&quot;);</div><div class=\"line\">\tstartCommandValues.put(&quot;jvmopts&quot;, javaOpts);</div><div class=\"line\">\tString logging = &quot;&quot;;</div><div class=\"line\"></div><div class=\"line\">      //构建启动命令，class指定了申请的container启动哪个主函数，也就是jm  applicationMaster的地址</div><div class=\"line\">\tstartCommandValues.put(&quot;logging&quot;, logging);</div><div class=\"line\">\tstartCommandValues.put(&quot;class&quot;, yarnClusterEntrypoint);   //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint</div><div class=\"line\">\tstartCommandValues.put(&quot;redirects&quot;,</div><div class=\"line\">\t\t&quot;1&gt; &quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/jobmanager.out &quot; +</div><div class=\"line\">\t\t&quot;2&gt; &quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/jobmanager.err&quot;);</div><div class=\"line\">\tstartCommandValues.put(&quot;args&quot;, &quot;&quot;);</div><div class=\"line\"></div><div class=\"line\">\tfinal String commandTemplate = flinkConfiguration  // jm 启动默认命令</div><div class=\"line\">\t\t.getString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE,</div><div class=\"line\">\t\t\tConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE);</div><div class=\"line\">\tfinal String amCommand =</div><div class=\"line\">\t\tBootstrapTools.getStartCommand(commandTemplate, startCommandValues); //获取真正的 jm  启动命令</div><div class=\"line\"></div><div class=\"line\">\t// 真正去通过yarn调度启动JM</div><div class=\"line\">\tamContainer.setCommands(Collections.singletonList(amCommand));</div><div class=\"line\">\treturn amContainer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, JM启动默认只设置了-Xmx, 在Utils.calculateHeapSize(jobManagerMemoryMb)中设置了,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int calculateHeapSize(int memory, org.apache.flink.configuration.Configuration conf) &#123;</div><div class=\"line\">       // container占用比率,containerized.heap-cutoff-ratio, 默认25%</div><div class=\"line\">\tfloat memoryCutoffRatio = conf.getFloat(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);</div><div class=\"line\">\t// container占用最小内存大小: containerized.heap-cutoff-min, 最少600mb</div><div class=\"line\">\tint minCutoff = conf.getInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);</div><div class=\"line\">\tif (memoryCutoffRatio &gt; 1 || memoryCutoffRatio &lt; 0) &#123;</div><div class=\"line\">\t\tthrow new IllegalArgumentException(&quot;The configuration value &apos;&quot;</div><div class=\"line\">\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO.key()</div><div class=\"line\">\t\t\t+ &quot;&apos; must be between 0 and 1. Value given=&quot; + memoryCutoffRatio);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (minCutoff &gt; memory) &#123;</div><div class=\"line\">\t\tthrow new IllegalArgumentException(&quot;The configuration value &apos;&quot;</div><div class=\"line\">\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN.key()</div><div class=\"line\">\t\t\t+ &quot;&apos; is higher (&quot; + minCutoff + &quot;) than the requested amount of memory &quot; + memory);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tint heapLimit = (int) ((float) memory * memoryCutoffRatio);</div><div class=\"line\">\tif (heapLimit &lt; minCutoff) &#123;</div><div class=\"line\">\t\theapLimit = minCutoff;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn memory - heapLimit;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, JM启动时, 去掉yarn container占用内存大小, 即为JM大小。 container大小为20%*heap, 但是不得小于600MB,  这里当然只能600M, 所以剩余JM heap大小为(1024-600)MB=424MB。</p>\n<h1 id=\"TaskManager内存参数设置\"><a href=\"#TaskManager内存参数设置\" class=\"headerlink\" title=\"TaskManager内存参数设置\"></a>TaskManager内存参数设置</h1><p>如下是TM启动后的参数, 可以发现, 堆内内存+对外内存=申请的内存, 那么这个内存如何确定比例的?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">183863 YarnTaskExecutorRunner -Xms1304m -Xmx1304m -XX:MaxDirectMemorySize=744m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000003/taskmanager.log -Dlogback.configurationFile=file:./logback.xml -Dlog4j.configuration=file:./log4j.properties</div></pre></td></tr></table></figure></p>\n<p>当JM为TM申请container成功后, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E7%94%B3%E8%AF%B7container%E6%88%90%E5%8A%9F\">createTaskExecutorLaunchContext</a>中确定JM启动参数, 最终进入到了ContaineredTaskManagerParameters.create中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ContaineredTaskManagerParameters create(</div><div class=\"line\">\t\tConfiguration config,</div><div class=\"line\">\t\tlong containerMemoryMB,</div><div class=\"line\">\t\tint numSlots) &#123;</div><div class=\"line\">\t// (1) try to compute how much memory used by container</div><div class=\"line\">\t// 首先确定yarn Container使用多少内存(算是堆外内存)</div><div class=\"line\">\tfinal long cutoffMB = calculateCutoffMB(config, containerMemoryMB);</div><div class=\"line\"></div><div class=\"line\">\t// (2) split the remaining Java memory between heap and off-heap</div><div class=\"line\">\t//确定堆内内存大小</div><div class=\"line\">\tfinal long heapSizeMB = TaskManagerServices.calculateHeapSizeMB(containerMemoryMB - cutoffMB, config);</div><div class=\"line\">\t// use the cut-off memory for off-heap (that was its intention)</div><div class=\"line\">\t// 堆内内存以外的全是堆内内存</div><div class=\"line\">\tfinal long offHeapSizeMB = containerMemoryMB - heapSizeMB;</div><div class=\"line\"></div><div class=\"line\">\t// (3) obtain the additional environment variables from the configuration</div><div class=\"line\">\tfinal HashMap&lt;String, String&gt; envVars = new HashMap&lt;&gt;();</div><div class=\"line\">\tfinal String prefix = ResourceManagerOptions.CONTAINERIZED_TASK_MANAGER_ENV_PREFIX;</div><div class=\"line\"></div><div class=\"line\">\tfor (String key : config.keySet()) &#123;</div><div class=\"line\">\t\tif (key.startsWith(prefix) &amp;&amp; key.length() &gt; prefix.length()) &#123;</div><div class=\"line\">\t\t\t// remove prefix</div><div class=\"line\">\t\t\tString envVarKey = key.substring(prefix.length());</div><div class=\"line\">\t\t\tenvVars.put(envVarKey, config.getString(key, null));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// done</div><div class=\"line\">\treturn new ContaineredTaskManagerParameters(</div><div class=\"line\">\t\tcontainerMemoryMB, heapSizeMB, offHeapSizeMB, numSlots, envVars);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下逻辑:</p>\n<ol>\n<li>确定yarn container本身需要的内存(算是堆外内存)。</li>\n<li>确定堆内的内存大小。</li>\n<li>确定堆外内存大小, 不是堆内的内存就全部算是堆外内存。<br>首先我们看下如何确定yarn container大小的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static long calculateCutoffMB(Configuration config, long containerMemoryMB) &#123;</div><div class=\"line\">\tPreconditions.checkArgument(containerMemoryMB &gt; 0);</div><div class=\"line\">\t// (1) check cutoff ratio  // 默认值0.25f</div><div class=\"line\">\tfinal float memoryCutoffRatio = config.getFloat(</div><div class=\"line\">\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);</div><div class=\"line\">\t// (2) check min cutoff value   最少预留大小默认600MB</div><div class=\"line\">\tfinal int minCutoff = config.getInteger(</div><div class=\"line\">\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);</div><div class=\"line\">\t// (3) check between heap and off-heap</div><div class=\"line\">\tlong cutoff = (long) (containerMemoryMB * memoryCutoffRatio);</div><div class=\"line\">\t//取最大值</div><div class=\"line\">\tif (cutoff &lt; minCutoff) &#123;</div><div class=\"line\">\t\tcutoff = minCutoff;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn cutoff;  //至少预留600MB，</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>yarn container大小取值原则: 在申请内存的containerized.heap-cutoff-ratio(默认25%)与containerized.heap-cutoff-min(默认600M)之前取最大值。本示例中, container占用600M<br>接下来我们看下如何确定堆内内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static long calculateHeapSizeMB(long totalJavaMemorySizeMB, Configuration config) &#123;</div><div class=\"line\">\t// subtract the Java memory used for network buffers (always off-heap)</div><div class=\"line\">\t//  网络buffer, 最小64M，最大1GB, 是totalJavaMemorySizeMB*0.1</div><div class=\"line\">\tfinal long networkBufMB =</div><div class=\"line\">\t\tcalculateNetworkBufferMemory(</div><div class=\"line\">\t\t\ttotalJavaMemorySizeMB &lt;&lt; 20, // megabytes to bytes</div><div class=\"line\">\t\t\tconfig) &gt;&gt; 20; // bytes to megabytes</div><div class=\"line\">\tfinal long remainingJavaMemorySizeMB = totalJavaMemorySizeMB - networkBufMB;</div><div class=\"line\">\t// split the available Java memory between heap and off-heap</div><div class=\"line\">\tfinal boolean useOffHeap = config.getBoolean(TaskManagerOptions.MEMORY_OFF_HEAP);  // 默认为false</div><div class=\"line\"></div><div class=\"line\">\tfinal long heapSizeMB;</div><div class=\"line\">\tif (useOffHeap) &#123;// 默认线上是关闭的</div><div class=\"line\">\t\tlong offHeapSize;</div><div class=\"line\">\t\tString managedMemorySizeDefaultVal = TaskManagerOptions.MANAGED_MEMORY_SIZE.defaultValue();</div><div class=\"line\">\t\tif (!config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE).equals(managedMemorySizeDefaultVal)) &#123;</div><div class=\"line\">\t\t\ttry &#123;// 将划去networkBuffer大小*一个堆外的系数（默认是0.7）得到其他的堆外内存</div><div class=\"line\">\t\t\t\toffHeapSize = MemorySize.parse(config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE), MEGA_BYTES).getMebiBytes();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\toffHeapSize = Long.valueOf(managedMemorySizeDefaultVal);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tif (offHeapSize &lt;= 0) &#123;</div><div class=\"line\">\t\t\t// calculate off-heap section via fraction</div><div class=\"line\">\t\t\tdouble fraction = config.getFloat(TaskManagerOptions.MANAGED_MEMORY_FRACTION);</div><div class=\"line\">\t\t\toffHeapSize = (long) (fraction * remainingJavaMemorySizeMB);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tTaskManagerServicesConfiguration</div><div class=\"line\">\t\t\t.checkConfigParameter(offHeapSize &lt; remainingJavaMemorySizeMB, offHeapSize,</div><div class=\"line\">\t\t\t\tTaskManagerOptions.MANAGED_MEMORY_SIZE.key(),</div><div class=\"line\">\t\t\t\t&quot;Managed memory size too large for &quot; + networkBufMB +</div><div class=\"line\">\t\t\t\t\t&quot; MB network buffer memory and a total of &quot; + totalJavaMemorySizeMB +</div><div class=\"line\">\t\t\t\t\t&quot; MB JVM memory&quot;);</div><div class=\"line\">\t\theapSizeMB = remainingJavaMemorySizeMB - offHeapSize;</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\theapSizeMB = remainingJavaMemorySizeMB;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\treturn heapSizeMB;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>内存大小确定过程:</p>\n<ol>\n<li>首先确定网络buffer大小: 是totalJavaMemorySizeMB<em>0.1, 而且最小64M，最大1GB。 这里是(2048-600)</em>0.1MB=144.8M。</li>\n<li>剩余内存大小为(2048-600)*0.9MB=1304MB。</li>\n<li>在我们代码中, useOffHeap是false, 由taskmanager.memory.off-heap设置, 默认为false。<br>那么, TM启动的参数就很明显了, HEAP为1304MB, OFF-HEAD为2048MB-1304MB=744MB(包括Container占用空闲+网络buffer)。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>如下是flink on yarn启动的一个示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">/bin/flink run -m yarn-cluster -yd -yjm 1024 -ys 2 -ytm 2048 clink-with-dependencies.jar  --topic_name topic1 --log_name --source_num 50  --sink_num 50</div></pre></td></tr></table></figure></p>\n<p>其中我们定义了JobManager的大小为1024M, TaskManager大小为2048M, 但是通过实际观察发现JobManager heap大小为424M, TaskManager heap memory大小为1304M, direct memory大小为744M , 参数值为啥是这个呢?</p>\n<h1 id=\"JobManager内存参数设置\"><a href=\"#JobManager内存参数设置\" class=\"headerlink\" title=\"JobManager内存参数设置\"></a>JobManager内存参数设置</h1><p>可以看到, JM内存设置与实际严重不符, 我们直接上代码找下原因吧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">121390 YarnJobClusterEntrypoint -Xmx424m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000001/jobmanager.log -Dlogback.configurationFile=file:logback.xml -Dlog4j.configuration=file:log4j.properties</div></pre></td></tr></table></figure></p>\n<p>JM启动命令的产生是在AbstractYarnClusterDescriptor.startAppMaster()中, 最终进入了setupApplicationMasterContainer()中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected ContainerLaunchContext setupApplicationMasterContainer(</div><div class=\"line\">\t\tString yarnClusterEntrypoint, //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint</div><div class=\"line\">\t\tboolean hasLogback,</div><div class=\"line\">\t\tboolean hasLog4j,</div><div class=\"line\">\t\tboolean hasKrb5,</div><div class=\"line\">\t\tint jobManagerMemoryMb) &#123;</div><div class=\"line\">\t// ------------------ Prepare Application Master Container  ------------------------------</div><div class=\"line\">\t// respect custom JVM options in the YAML file</div><div class=\"line\">\tString javaOpts = flinkConfiguration.getString(CoreOptions.FLINK_JVM_OPTIONS);</div><div class=\"line\">\tif (flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS).length() &gt; 0) &#123;</div><div class=\"line\">\t\tjavaOpts += &quot; &quot; + flinkConfiguration.getString(CoreOptions.FLINK_JM_JVM_OPTIONS);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t// Set up the container launch context for the application master</div><div class=\"line\">\tContainerLaunchContext amContainer = Records.newRecord(ContainerLaunchContext.class);</div><div class=\"line\">\tfinal  Map&lt;String, String&gt; startCommandValues = new HashMap&lt;&gt;();</div><div class=\"line\">\tstartCommandValues.put(&quot;java&quot;, &quot;$JAVA_HOME/bin/java&quot;);</div><div class=\"line\">\tstartCommandValues.put(&quot;jvmmem&quot;, &quot;-Xmx&quot; +</div><div class=\"line\">\t\tUtils.calculateHeapSize(jobManagerMemoryMb, flinkConfiguration) +</div><div class=\"line\">\t\t&quot;m&quot;);</div><div class=\"line\">\tstartCommandValues.put(&quot;jvmopts&quot;, javaOpts);</div><div class=\"line\">\tString logging = &quot;&quot;;</div><div class=\"line\"></div><div class=\"line\">      //构建启动命令，class指定了申请的container启动哪个主函数，也就是jm  applicationMaster的地址</div><div class=\"line\">\tstartCommandValues.put(&quot;logging&quot;, logging);</div><div class=\"line\">\tstartCommandValues.put(&quot;class&quot;, yarnClusterEntrypoint);   //获取的是org.apache.flink.yarn.entrypoint.YarnJobClusterEntrypoint</div><div class=\"line\">\tstartCommandValues.put(&quot;redirects&quot;,</div><div class=\"line\">\t\t&quot;1&gt; &quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/jobmanager.out &quot; +</div><div class=\"line\">\t\t&quot;2&gt; &quot; + ApplicationConstants.LOG_DIR_EXPANSION_VAR + &quot;/jobmanager.err&quot;);</div><div class=\"line\">\tstartCommandValues.put(&quot;args&quot;, &quot;&quot;);</div><div class=\"line\"></div><div class=\"line\">\tfinal String commandTemplate = flinkConfiguration  // jm 启动默认命令</div><div class=\"line\">\t\t.getString(ConfigConstants.YARN_CONTAINER_START_COMMAND_TEMPLATE,</div><div class=\"line\">\t\t\tConfigConstants.DEFAULT_YARN_CONTAINER_START_COMMAND_TEMPLATE);</div><div class=\"line\">\tfinal String amCommand =</div><div class=\"line\">\t\tBootstrapTools.getStartCommand(commandTemplate, startCommandValues); //获取真正的 jm  启动命令</div><div class=\"line\"></div><div class=\"line\">\t// 真正去通过yarn调度启动JM</div><div class=\"line\">\tamContainer.setCommands(Collections.singletonList(amCommand));</div><div class=\"line\">\treturn amContainer;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, JM启动默认只设置了-Xmx, 在Utils.calculateHeapSize(jobManagerMemoryMb)中设置了,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static int calculateHeapSize(int memory, org.apache.flink.configuration.Configuration conf) &#123;</div><div class=\"line\">       // container占用比率,containerized.heap-cutoff-ratio, 默认25%</div><div class=\"line\">\tfloat memoryCutoffRatio = conf.getFloat(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);</div><div class=\"line\">\t// container占用最小内存大小: containerized.heap-cutoff-min, 最少600mb</div><div class=\"line\">\tint minCutoff = conf.getInteger(ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);</div><div class=\"line\">\tif (memoryCutoffRatio &gt; 1 || memoryCutoffRatio &lt; 0) &#123;</div><div class=\"line\">\t\tthrow new IllegalArgumentException(&quot;The configuration value &apos;&quot;</div><div class=\"line\">\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO.key()</div><div class=\"line\">\t\t\t+ &quot;&apos; must be between 0 and 1. Value given=&quot; + memoryCutoffRatio);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (minCutoff &gt; memory) &#123;</div><div class=\"line\">\t\tthrow new IllegalArgumentException(&quot;The configuration value &apos;&quot;</div><div class=\"line\">\t\t\t+ ResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN.key()</div><div class=\"line\">\t\t\t+ &quot;&apos; is higher (&quot; + minCutoff + &quot;) than the requested amount of memory &quot; + memory);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tint heapLimit = (int) ((float) memory * memoryCutoffRatio);</div><div class=\"line\">\tif (heapLimit &lt; minCutoff) &#123;</div><div class=\"line\">\t\theapLimit = minCutoff;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn memory - heapLimit;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, JM启动时, 去掉yarn container占用内存大小, 即为JM大小。 container大小为20%*heap, 但是不得小于600MB,  这里当然只能600M, 所以剩余JM heap大小为(1024-600)MB=424MB。</p>\n<h1 id=\"TaskManager内存参数设置\"><a href=\"#TaskManager内存参数设置\" class=\"headerlink\" title=\"TaskManager内存参数设置\"></a>TaskManager内存参数设置</h1><p>如下是TM启动后的参数, 可以发现, 堆内内存+对外内存=申请的内存, 那么这个内存如何确定比例的?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">183863 YarnTaskExecutorRunner -Xms1304m -Xmx1304m -XX:MaxDirectMemorySize=744m -Dlog.file=/opt/meituan/hadoop-flink/hadoop-2.7.1/logs/userlogs/application_1554212859057_0525/container_1554212859057_0525_01_000003/taskmanager.log -Dlogback.configurationFile=file:./logback.xml -Dlog4j.configuration=file:./log4j.properties</div></pre></td></tr></table></figure></p>\n<p>当JM为TM申请container成功后, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E7%94%B3%E8%AF%B7container%E6%88%90%E5%8A%9F\">createTaskExecutorLaunchContext</a>中确定JM启动参数, 最终进入到了ContaineredTaskManagerParameters.create中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ContaineredTaskManagerParameters create(</div><div class=\"line\">\t\tConfiguration config,</div><div class=\"line\">\t\tlong containerMemoryMB,</div><div class=\"line\">\t\tint numSlots) &#123;</div><div class=\"line\">\t// (1) try to compute how much memory used by container</div><div class=\"line\">\t// 首先确定yarn Container使用多少内存(算是堆外内存)</div><div class=\"line\">\tfinal long cutoffMB = calculateCutoffMB(config, containerMemoryMB);</div><div class=\"line\"></div><div class=\"line\">\t// (2) split the remaining Java memory between heap and off-heap</div><div class=\"line\">\t//确定堆内内存大小</div><div class=\"line\">\tfinal long heapSizeMB = TaskManagerServices.calculateHeapSizeMB(containerMemoryMB - cutoffMB, config);</div><div class=\"line\">\t// use the cut-off memory for off-heap (that was its intention)</div><div class=\"line\">\t// 堆内内存以外的全是堆内内存</div><div class=\"line\">\tfinal long offHeapSizeMB = containerMemoryMB - heapSizeMB;</div><div class=\"line\"></div><div class=\"line\">\t// (3) obtain the additional environment variables from the configuration</div><div class=\"line\">\tfinal HashMap&lt;String, String&gt; envVars = new HashMap&lt;&gt;();</div><div class=\"line\">\tfinal String prefix = ResourceManagerOptions.CONTAINERIZED_TASK_MANAGER_ENV_PREFIX;</div><div class=\"line\"></div><div class=\"line\">\tfor (String key : config.keySet()) &#123;</div><div class=\"line\">\t\tif (key.startsWith(prefix) &amp;&amp; key.length() &gt; prefix.length()) &#123;</div><div class=\"line\">\t\t\t// remove prefix</div><div class=\"line\">\t\t\tString envVarKey = key.substring(prefix.length());</div><div class=\"line\">\t\t\tenvVars.put(envVarKey, config.getString(key, null));</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t// done</div><div class=\"line\">\treturn new ContaineredTaskManagerParameters(</div><div class=\"line\">\t\tcontainerMemoryMB, heapSizeMB, offHeapSizeMB, numSlots, envVars);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下逻辑:</p>\n<ol>\n<li>确定yarn container本身需要的内存(算是堆外内存)。</li>\n<li>确定堆内的内存大小。</li>\n<li>确定堆外内存大小, 不是堆内的内存就全部算是堆外内存。<br>首先我们看下如何确定yarn container大小的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static long calculateCutoffMB(Configuration config, long containerMemoryMB) &#123;</div><div class=\"line\">\tPreconditions.checkArgument(containerMemoryMB &gt; 0);</div><div class=\"line\">\t// (1) check cutoff ratio  // 默认值0.25f</div><div class=\"line\">\tfinal float memoryCutoffRatio = config.getFloat(</div><div class=\"line\">\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_RATIO);</div><div class=\"line\">\t// (2) check min cutoff value   最少预留大小默认600MB</div><div class=\"line\">\tfinal int minCutoff = config.getInteger(</div><div class=\"line\">\t\tResourceManagerOptions.CONTAINERIZED_HEAP_CUTOFF_MIN);</div><div class=\"line\">\t// (3) check between heap and off-heap</div><div class=\"line\">\tlong cutoff = (long) (containerMemoryMB * memoryCutoffRatio);</div><div class=\"line\">\t//取最大值</div><div class=\"line\">\tif (cutoff &lt; minCutoff) &#123;</div><div class=\"line\">\t\tcutoff = minCutoff;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn cutoff;  //至少预留600MB，</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>yarn container大小取值原则: 在申请内存的containerized.heap-cutoff-ratio(默认25%)与containerized.heap-cutoff-min(默认600M)之前取最大值。本示例中, container占用600M<br>接下来我们看下如何确定堆内内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static long calculateHeapSizeMB(long totalJavaMemorySizeMB, Configuration config) &#123;</div><div class=\"line\">\t// subtract the Java memory used for network buffers (always off-heap)</div><div class=\"line\">\t//  网络buffer, 最小64M，最大1GB, 是totalJavaMemorySizeMB*0.1</div><div class=\"line\">\tfinal long networkBufMB =</div><div class=\"line\">\t\tcalculateNetworkBufferMemory(</div><div class=\"line\">\t\t\ttotalJavaMemorySizeMB &lt;&lt; 20, // megabytes to bytes</div><div class=\"line\">\t\t\tconfig) &gt;&gt; 20; // bytes to megabytes</div><div class=\"line\">\tfinal long remainingJavaMemorySizeMB = totalJavaMemorySizeMB - networkBufMB;</div><div class=\"line\">\t// split the available Java memory between heap and off-heap</div><div class=\"line\">\tfinal boolean useOffHeap = config.getBoolean(TaskManagerOptions.MEMORY_OFF_HEAP);  // 默认为false</div><div class=\"line\"></div><div class=\"line\">\tfinal long heapSizeMB;</div><div class=\"line\">\tif (useOffHeap) &#123;// 默认线上是关闭的</div><div class=\"line\">\t\tlong offHeapSize;</div><div class=\"line\">\t\tString managedMemorySizeDefaultVal = TaskManagerOptions.MANAGED_MEMORY_SIZE.defaultValue();</div><div class=\"line\">\t\tif (!config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE).equals(managedMemorySizeDefaultVal)) &#123;</div><div class=\"line\">\t\t\ttry &#123;// 将划去networkBuffer大小*一个堆外的系数（默认是0.7）得到其他的堆外内存</div><div class=\"line\">\t\t\t\toffHeapSize = MemorySize.parse(config.getString(TaskManagerOptions.MANAGED_MEMORY_SIZE), MEGA_BYTES).getMebiBytes();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\toffHeapSize = Long.valueOf(managedMemorySizeDefaultVal);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tif (offHeapSize &lt;= 0) &#123;</div><div class=\"line\">\t\t\t// calculate off-heap section via fraction</div><div class=\"line\">\t\t\tdouble fraction = config.getFloat(TaskManagerOptions.MANAGED_MEMORY_FRACTION);</div><div class=\"line\">\t\t\toffHeapSize = (long) (fraction * remainingJavaMemorySizeMB);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\tTaskManagerServicesConfiguration</div><div class=\"line\">\t\t\t.checkConfigParameter(offHeapSize &lt; remainingJavaMemorySizeMB, offHeapSize,</div><div class=\"line\">\t\t\t\tTaskManagerOptions.MANAGED_MEMORY_SIZE.key(),</div><div class=\"line\">\t\t\t\t&quot;Managed memory size too large for &quot; + networkBufMB +</div><div class=\"line\">\t\t\t\t\t&quot; MB network buffer memory and a total of &quot; + totalJavaMemorySizeMB +</div><div class=\"line\">\t\t\t\t\t&quot; MB JVM memory&quot;);</div><div class=\"line\">\t\theapSizeMB = remainingJavaMemorySizeMB - offHeapSize;</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\theapSizeMB = remainingJavaMemorySizeMB;</div><div class=\"line\">\t&#125;</div><div class=\"line\"></div><div class=\"line\">\treturn heapSizeMB;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>内存大小确定过程:</p>\n<ol>\n<li>首先确定网络buffer大小: 是totalJavaMemorySizeMB<em>0.1, 而且最小64M，最大1GB。 这里是(2048-600)</em>0.1MB=144.8M。</li>\n<li>剩余内存大小为(2048-600)*0.9MB=1304MB。</li>\n<li>在我们代码中, useOffHeap是false, 由taskmanager.memory.off-heap设置, 默认为false。<br>那么, TM启动的参数就很明显了, HEAP为1304MB, OFF-HEAD为2048MB-1304MB=744MB(包括Container占用空闲+网络buffer)。</li>\n</ol>\n"},{"title":"Flink原理-TaskManager处理SubTask","date":"2019-04-03T04:10:04.000Z","toc":true,"_content":"在了解TaskManager处理task之前, 我们先看下该JVM启动过程。 TaskManager端yarn启动的类为YarnTaskExecutorRunner, TM端存放当前可利用的slot信息存放在TaskManagerServices.taskSlotTable里面, slot默认资源为new ResourceProfile(cpu=1.0, men=42)。\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E9%83%A8%E7%BD%B2subTask%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84slot\">Flink原理-Slot申请及SubTask部署</a>中, 我们知道, subTask会在JobManager中通过TaskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask。TaskManager会通过TaskExecutor.subTask()接收到该部署请求。\n```public CompletableFuture<Acknowledge> submitTask(\n\t\t\tTaskDeploymentDescriptor tdd,\n\t\t\tJobMasterId jobMasterId,\n\t\t\tTime timeout) {\n\t\ttry {\n\t\t\tfinal JobID jobId = tdd.getJobId();\n\t\t\t//获得与jobManager通信的链接\n\t\t\tfinal JobManagerConnection jobManagerConnection = jobManagerTable.get(jobId);\n\t\t\t// re-integrate offloaded data:\n\t\t\ttry {\n\t\t\t\ttdd.loadBigData(blobCacheService.getPermanentBlobService()); //啥事不做\n\t\t\t} catch (IOException | ClassNotFoundException e) {\n\t\t\t\tthrow new TaskSubmissionException(\"Could not re-integrate offloaded TaskDeploymentDescriptor data.\", e);\n\t\t\t}\n\t\t\t// deserialize the pre-serialized information\n\t\t\tfinal JobInformation jobInformation;\n\t\t\tfinal TaskInformation taskInformation;\n\t\t\ttry {\n\t\t\t\tjobInformation = tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());\n\t\t\t\ttaskInformation = tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());\n\t\t\t}\n\t\t\tTask task = new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\ttdd.getExecutionAttemptId(),\n\t\t\t\ttdd.getAllocationId(),\n\t\t\t\ttdd.getSubtaskIndex(),\n\t\t\t\ttdd.getAttemptNumber(),\n\t\t\t\ttdd.getProducedPartitions(),\n\t\t\t\ttdd.getInputGates(),\n\t\t\t\ttdd.getTargetSlotNumber(),\n\t\t\t\ttaskExecutorServices.getMemoryManager(),\n\t\t\t\ttaskExecutorServices.getIOManager(),\n\t\t\t\ttaskExecutorServices.getNetworkEnvironment(),\n\t\t\t\ttaskExecutorServices.getBroadcastVariableManager(),\n\t\t\t\ttaskStateManager,\n\t\t\t\ttaskManagerActions,\n\t\t\t\tinputSplitProvider,\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobCacheService,\n\t\t\t\tlibraryCache,\n\t\t\t\tfileCache,\n\t\t\t\ttaskManagerConfiguration,\n\t\t\t\ttaskMetricGroup,\n\t\t\t\tresultPartitionConsumableNotifier,\n\t\t\t\tpartitionStateChecker,\n\t\t\t\tgetRpcService().getExecutor());\n\t\t\tlog.info(\"Received task {}.\", task.getTaskInfo().getTaskNameWithSubtasks());\n\t\t\tboolean taskAdded;\n\t\t\ttry {\n\t\t\t    // 将task放入taskSlotTable.taskSlotMappings中\n\t\t\t\ttaskAdded = taskSlotTable.addTask(task);\n\t\t\t}\n\t\t\tif (taskAdded) {\n\t\t\t    //这里比较重要，开始进行task执行\n\t\t\t\ttask.startTaskThread();\n\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t\t\t}\n\t\t}\n\t}\n\n```\nTM接收到请求后, 首先构建Task(Runnable), 然后通过task.startTaskThread()将这个线程运行起来, 真正执行任务的是run函数:\n```\npublic void run() {\n\n\t\t// ----------------------------\n\t\t//  Initial State transition\n\t\t// ----------------------------\n\t\twhile (true) {\n\t\t\tExecutionState current = this.executionState;\n\t\t\t// 首先将Task状态置为DEPLOYING状态, 状态不修改成功, 不停地尝试\n\t\t\tif (current == ExecutionState.CREATED) {\n\t\t\t\tif (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) {\n\t\t\t\t\t// success, we can start our work\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (current == ExecutionState.FAILED) {\n\t\t\t\t// we were immediately failed. tell the TaskManager that we reached our final state\n\t\t\t\tnotifyFinalState();\n\t\t\t\tif (metrics != null) {\n\t\t\t\t\tmetrics.close();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (current == ExecutionState.CANCELING) {\n\t\t\t\tif (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) {\n\t\t\t\t\t// we were immediately canceled. tell the TaskManager that we reached our final state\n\t\t\t\t\tnotifyFinalState();\n\t\t\t\t\tif (metrics != null) {\n\t\t\t\t\t\tmetrics.close();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// all resource acquisitions and registrations from here on\n\t\t// need to be undone in the end\n\t\tMap<String, Future<Path>> distributedCacheEntries = new HashMap<>();\n\t\tAbstractInvokable invokable = null;\n\n\t\ttry {\n\t\t\t// ----------------------------\n\t\t\t//  Task Bootstrap - We periodically\n\t\t\t//  check for canceling as a shortcut\n\t\t\t// ----------------------------\n\n\t\t\t// activate safety net for task thread\n\t\t\tLOG.info(\"Creating FileSystem stream leak safety net for task {}\", this);\n\t\t\tFileSystemSafetyNet.initializeSafetyNetForThread();\n\n\t\t\tblobService.getPermanentBlobService().registerJob(jobId);\n\n\t\t\t// first of all, get a user-code classloader\n\t\t\t// this may involve downloading the job's JAR files and/or classes\n\t\t\tLOG.info(\"Loading JAR files for task {}.\", this);\n\n\t\t\tuserCodeClassLoader = createUserCodeClassloader();\n\t\t\tfinal ExecutionConfig executionConfig = serializedExecutionConfig.deserializeValue(userCodeClassLoader);\n\n\t\t\tif (executionConfig.getTaskCancellationInterval() >= 0) {\n\t\t\t\t// override task cancellation interval from Flink config if set in ExecutionConfig\n\t\t\t\ttaskCancellationInterval = executionConfig.getTaskCancellationInterval();\n\t\t\t}\n\n\t\t\tif (executionConfig.getTaskCancellationTimeout() >= 0) {\n\t\t\t\t// override task cancellation timeout from Flink config if set in ExecutionConfig\n\t\t\t\ttaskCancellationTimeout = executionConfig.getTaskCancellationTimeout();\n\t\t\t}\n\n\t\t\tif (isCanceledOrFailed()) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t// register the task with the network stack\n\t\t\t// this operation may fail if the system does not have enough\n\t\t\t// memory to run the necessary data exchanges\n\t\t\t// the registration must also strictly be undone\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\tLOG.info(\"Registering task at network: {}.\", this);\n\n\t\t\tnetwork.registerTask(this);\n\n\t\t\t// add metrics for buffers\n\t\t\tthis.metrics.getIOMetricGroup().initializeBufferMetrics(this);\n\n\t\t\t// register detailed network metrics, if configured\n\t\t\tif (taskManagerConfig.getConfiguration().getBoolean(TaskManagerOptions.NETWORK_DETAILED_METRICS)) {\n\t\t\t\t// similar to MetricUtils.instantiateNetworkMetrics() but inside this IOMetricGroup\n\t\t\t\tMetricGroup networkGroup = this.metrics.getIOMetricGroup().addGroup(\"Network\");\n\t\t\t\tMetricGroup outputGroup = networkGroup.addGroup(\"Output\");\n\t\t\t\tMetricGroup inputGroup = networkGroup.addGroup(\"Input\");\n\n\t\t\t\t// output metrics\n\t\t\t\tfor (int i = 0; i < producedPartitions.length; i++) {\n\t\t\t\t\tResultPartitionMetrics.registerQueueLengthMetrics(\n\t\t\t\t\t\toutputGroup.addGroup(i), producedPartitions[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < inputGates.length; i++) {\n\t\t\t\t\tInputGateMetrics.registerQueueLengthMetrics(\n\t\t\t\t\t\tinputGroup.addGroup(i), inputGates[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// next, kick off the background copying of files for the distributed cache\n\t\t\ttry {\n\t\t\t\tfor (Map.Entry<String, DistributedCache.DistributedCacheEntry> entry :\n\t\t\t\t\t\tDistributedCache.readFileInfoFromConfig(jobConfiguration)) {\n\t\t\t\t\tLOG.info(\"Obtaining local cache file for '{}'.\", entry.getKey());\n\t\t\t\t\tFuture<Path> cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);\n\t\t\t\t\tdistributedCacheEntries.put(entry.getKey(), cp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCanceledOrFailed()) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t//  call the user code initialization methods\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\tTaskKvStateRegistry kvStateRegistry = network.createKvStateTaskRegistry(jobId, getJobVertexId());\n\n\t\t\tEnvironment env = new RuntimeEnvironment(\n\t\t\t\tjobId,\n\t\t\t\tvertexId,\n\t\t\t\texecutionId,\n\t\t\t\texecutionConfig,\n\t\t\t\ttaskInfo,\n\t\t\t\tjobConfiguration,\n\t\t\t\ttaskConfiguration,\n\t\t\t\tuserCodeClassLoader,\n\t\t\t\tmemoryManager,\n\t\t\t\tioManager,\n\t\t\t\tbroadcastVariableManager,\n\t\t\t\ttaskStateManager,\n\t\t\t\taccumulatorRegistry,\n\t\t\t\tkvStateRegistry,\n\t\t\t\tinputSplitProvider,\n\t\t\t\tdistributedCacheEntries,\n\t\t\t\tproducedPartitions,\n\t\t\t\tinputGates,\n\t\t\t\tnetwork.getTaskEventDispatcher(),\n\t\t\t\tcheckpointResponder,\n\t\t\t\ttaskManagerConfig,\n\t\t\t\tmetrics,\n\t\t\t\tthis);\n            // 加载用户Task, 比如SourceStreamTask(Source: Custom Source (2/2))\n\t\t\t// now load and instantiate the task's invokable code\n\t\t\tinvokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t//  actual task core work\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\t// we must make strictly sure that the invokable is accessible to the cancel() call\n\t\t\t// by the time we switched to running.\n\t\t\tthis.invokable = invokable;\n\n\t\t\t// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime\n\t\t\tif (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// notify everyone that we switched to running\n\t\t\tnotifyObservers(ExecutionState.RUNNING, null);\n\t\t\ttaskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));\n\n\t\t\t// make sure the user code classloader is accessible thread-locally\n\t\t\texecutingThread.setContextClassLoader(userCodeClassLoader);\n            // 真正开始执行这个task。\n\t\t\t// run the invokable\n\t\t\tinvokable.invoke();\n\n\t\t\t// make sure, we enter the catch block if the task leaves the invoke() method due\n\t\t\t// to the fact that it has been canceled\n\t\t\tif (isCanceledOrFailed()) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t//  finalization of a successful execution\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\t// finish the produced partitions. if this fails, we consider the execution failed.\n\t\t\tfor (ResultPartition partition : producedPartitions) {\n\t\t\t\tif (partition != null) {\n\t\t\t\t\tpartition.finish();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// try to mark the task as finished\n\t\t\t// if that fails, the task was canceled/failed in the meantime\n\t\t\tif (transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) {\n\t\t\t\tnotifyObservers(ExecutionState.FINISHED, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tLOG.info(\"Freeing task resources for {} ({}).\", taskNameWithSubtask, executionId);\n\n\t\t\t\t// clear the reference to the invokable. this helps guard against holding references\n\t\t\t\t// to the invokable and its structures in cases where this Task object is still referenced\n\t\t\t\tthis.invokable = null;\n\n\t\t\t\t// stop the async dispatcher.\n\t\t\t\t// copy dispatcher reference to stack, against concurrent release\n\t\t\t\tExecutorService dispatcher = this.asyncCallDispatcher;\n\t\t\t\tif (dispatcher != null && !dispatcher.isShutdown()) {\n\t\t\t\t\tdispatcher.shutdownNow();\n\t\t\t\t}\n\n\t\t\t\t// free the network resources\n\t\t\t\tnetwork.unregisterTask(this);\n\n\t\t\t\t// free memory resources\n\t\t\t\tif (invokable != null) {\n\t\t\t\t\tmemoryManager.releaseAll(invokable);\n\t\t\t\t}\n\n\t\t\t\t// remove all of the tasks library resources\n\t\t\t\tlibraryCache.unregisterTask(jobId, executionId);\n\t\t\t\tfileCache.releaseJob(jobId, executionId);\n\t\t\t\tblobService.getPermanentBlobService().releaseJob(jobId);\n\n\t\t\t\t// close and de-activate safety net for task thread\n\t\t\t\tLOG.info(\"Ensuring all FileSystem streams are closed for task {}\", this);\n\t\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();\n\n\t\t\t\tnotifyFinalState();\n\t\t\t}\n\t\t}\n\t}\n\n```\n该函数主要做了如下事情:\n1. 加载jar, 配置文件。\n2. 确认invoke函数, invoke函数在JobVertex产生的时候构建的, 比如在StreamingJobGraphGenerator.createJobVertex()中, 而这个invoke最初是在产生StreamNode时候赋值的, 比如在StreamingJobGraphGenerator.transform->transformOneInputTransform->StreamGraph.addOperator:\n```\npublic <IN, OUT> void addOperator(\n\t\t\tInteger vertexID,\n\t\t\tString slotSharingGroup,\n\t\t\t@Nullable String coLocationGroup,\n\t\t\tStreamOperator<OUT> operatorObject,\n\t\t\tTypeInformation<IN> inTypeInfo,\n\t\t\tTypeInformation<OUT> outTypeInfo,\n\t\t\tString operatorName) {\n\n\t\tif (operatorObject instanceof StoppableStreamSource) {\n\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, StoppableSourceStreamTask.class, operatorObject, operatorName);\n\t\t} else if (operatorObject instanceof StreamSource) {\n\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorObject, operatorName);\n\t\t} else {\n\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorObject, operatorName);\n\t\t}\n\t\t......\n```\n可以看到, invoke可以为SourceStreamTask.class或者 OneInputStreamTask.class。 我们以最常见的OneInputStreamTask.class继续讲解。invokable.invoke()最终将跑到OneInputStreamTask.run里面\n```\n\tprotected void run() throws Exception {\n\t\t// cache processor reference on the stack, to make the code more JIT friendly\n\t\tfinal StreamInputProcessor<IN> inputProcessor = this.inputProcessor;\n\n\t\twhile (running && inputProcessor.processInput()) {\n\t\t\t// all the work happens in the \"processInput\" method\n\t\t}\n\t}\n```\n可以看到, 每条数据就循环处理一次, 我们看下每条数据是如何处理的:\n```\n    public boolean processInput() throws Exception {\n\t\tif (isFinished) {\n\t\t\treturn false;\n\t\t}\n\t\tif (numRecordsIn == null) {\n\t\t\ttry {\n\t\t\t\tnumRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOG.warn(\"An exception occurred during the metrics setup.\", e);\n\t\t\t\tnumRecordsIn = new SimpleCounter();\n\t\t\t}\n\t\t}\n       //这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）\n\t\twhile (true) {            //2.会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作\n\t\t\tif (currentRecordDeserializer != null) {\n\t\t\t\tDeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate); //得到下一条数据\n\n\t\t\t\tif (result.isBufferConsumed()) {\n\t\t\t\t\tcurrentRecordDeserializer.getCurrentBuffer().recycleBuffer();\n\t\t\t\t\tcurrentRecordDeserializer = null;\n\t\t\t\t}\n\n\t\t\t\tif (result.isFullRecord()) {\n\t\t\t\t\tStreamElement recordOrMark = deserializationDelegate.getInstance();\n\t\t\t\t\t//如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在）\n\t\t\t\t\tif (recordOrMark.isWatermark()) {\n\t\t\t\t\t\t// handle watermark\n\t\t\t\t\t\tstatusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。\n\t\t\t\t\t} else if (recordOrMark.isStreamStatus()) {\n\t\t\t\t\t\t// handle stream status\n\t\t\t\t\t\tstatusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间\n\t\t\t\t\t} else if (recordOrMark.isLatencyMarker()) {\n\t\t\t\t\t\t// handle latency marker\n\t\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\t\tstreamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//这里就是真正的，用户的代码即将被执行的地方。\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// now we can do the actual processing\n\t\t\t\t\t\tStreamRecord<IN> record = recordOrMark.asRecord();\n\t\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\t\tnumRecordsIn.inc();\n\t\t\t\t\t\t\tstreamOperator.setKeyContextElement1(record);\n\t\t\t\t\t\t\t// 每个算子开始真正处理数据\n\t\t\t\t\t\t\tstreamOperator.processElement(record);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            //1.程序首先获取下一个buffer，这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器\n\t\t\tfinal BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();\n\t\t\tif (bufferOrEvent != null) {\n\t\t\t\tif (bufferOrEvent.isBuffer()) {\n\t\t\t\t\tcurrentChannel = bufferOrEvent.getChannelIndex();\n\t\t\t\t\tcurrentRecordDeserializer = recordDeserializers[currentChannel];\n\t\t\t\t\tcurrentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Event received\n\t\t\t\t\tfinal AbstractEvent event = bufferOrEvent.getEvent();\n\t\t\t\t\tif (event.getClass() != EndOfPartitionEvent.class) {\n\t\t\t\t\t\tthrow new IOException(\"Unexpected event: \" + event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tisFinished = true;\n\t\t\t\tif (!barrierHandler.isEmpty()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Trailing data in checkpoint barrier handler.\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n```\n每条数据都是通过streamOperator.processElement(record)来完成处理的, 以map算子为例, streamOperator为StreamMap:\n ```\n @Internal\npublic class StreamMap<IN, OUT>\n\t\textends AbstractUdfStreamOperator<OUT, MapFunction<IN, OUT>>\n\t\timplements OneInputStreamOperator<IN, OUT> {\n\tprivate static final long serialVersionUID = 1L;\n\tpublic StreamMap(MapFunction<IN, OUT> mapper) {\n\t\tsuper(mapper);\n\t\tchainingStrategy = ChainingStrategy.ALWAYS;\n\t}\n\t@Override\n\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\toutput.collect(element.replace(userFunction.map(element.getValue())));\n\t}\n}\n ```\n 可以看到, 我们只用负责定义map就可以了。","source":"_posts/Flink原理-TaskManager处理SubTask.md","raw":"---\ntitle: Flink原理-TaskManager处理SubTask\ndate: 2019-04-03 12:10:04\ntags:\ntoc: true\n---\n在了解TaskManager处理task之前, 我们先看下该JVM启动过程。 TaskManager端yarn启动的类为YarnTaskExecutorRunner, TM端存放当前可利用的slot信息存放在TaskManagerServices.taskSlotTable里面, slot默认资源为new ResourceProfile(cpu=1.0, men=42)。\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E9%83%A8%E7%BD%B2subTask%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84slot\">Flink原理-Slot申请及SubTask部署</a>中, 我们知道, subTask会在JobManager中通过TaskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask。TaskManager会通过TaskExecutor.subTask()接收到该部署请求。\n```public CompletableFuture<Acknowledge> submitTask(\n\t\t\tTaskDeploymentDescriptor tdd,\n\t\t\tJobMasterId jobMasterId,\n\t\t\tTime timeout) {\n\t\ttry {\n\t\t\tfinal JobID jobId = tdd.getJobId();\n\t\t\t//获得与jobManager通信的链接\n\t\t\tfinal JobManagerConnection jobManagerConnection = jobManagerTable.get(jobId);\n\t\t\t// re-integrate offloaded data:\n\t\t\ttry {\n\t\t\t\ttdd.loadBigData(blobCacheService.getPermanentBlobService()); //啥事不做\n\t\t\t} catch (IOException | ClassNotFoundException e) {\n\t\t\t\tthrow new TaskSubmissionException(\"Could not re-integrate offloaded TaskDeploymentDescriptor data.\", e);\n\t\t\t}\n\t\t\t// deserialize the pre-serialized information\n\t\t\tfinal JobInformation jobInformation;\n\t\t\tfinal TaskInformation taskInformation;\n\t\t\ttry {\n\t\t\t\tjobInformation = tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());\n\t\t\t\ttaskInformation = tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());\n\t\t\t}\n\t\t\tTask task = new Task(\n\t\t\t\tjobInformation,\n\t\t\t\ttaskInformation,\n\t\t\t\ttdd.getExecutionAttemptId(),\n\t\t\t\ttdd.getAllocationId(),\n\t\t\t\ttdd.getSubtaskIndex(),\n\t\t\t\ttdd.getAttemptNumber(),\n\t\t\t\ttdd.getProducedPartitions(),\n\t\t\t\ttdd.getInputGates(),\n\t\t\t\ttdd.getTargetSlotNumber(),\n\t\t\t\ttaskExecutorServices.getMemoryManager(),\n\t\t\t\ttaskExecutorServices.getIOManager(),\n\t\t\t\ttaskExecutorServices.getNetworkEnvironment(),\n\t\t\t\ttaskExecutorServices.getBroadcastVariableManager(),\n\t\t\t\ttaskStateManager,\n\t\t\t\ttaskManagerActions,\n\t\t\t\tinputSplitProvider,\n\t\t\t\tcheckpointResponder,\n\t\t\t\tblobCacheService,\n\t\t\t\tlibraryCache,\n\t\t\t\tfileCache,\n\t\t\t\ttaskManagerConfiguration,\n\t\t\t\ttaskMetricGroup,\n\t\t\t\tresultPartitionConsumableNotifier,\n\t\t\t\tpartitionStateChecker,\n\t\t\t\tgetRpcService().getExecutor());\n\t\t\tlog.info(\"Received task {}.\", task.getTaskInfo().getTaskNameWithSubtasks());\n\t\t\tboolean taskAdded;\n\t\t\ttry {\n\t\t\t    // 将task放入taskSlotTable.taskSlotMappings中\n\t\t\t\ttaskAdded = taskSlotTable.addTask(task);\n\t\t\t}\n\t\t\tif (taskAdded) {\n\t\t\t    //这里比较重要，开始进行task执行\n\t\t\t\ttask.startTaskThread();\n\t\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t\t\t}\n\t\t}\n\t}\n\n```\nTM接收到请求后, 首先构建Task(Runnable), 然后通过task.startTaskThread()将这个线程运行起来, 真正执行任务的是run函数:\n```\npublic void run() {\n\n\t\t// ----------------------------\n\t\t//  Initial State transition\n\t\t// ----------------------------\n\t\twhile (true) {\n\t\t\tExecutionState current = this.executionState;\n\t\t\t// 首先将Task状态置为DEPLOYING状态, 状态不修改成功, 不停地尝试\n\t\t\tif (current == ExecutionState.CREATED) {\n\t\t\t\tif (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) {\n\t\t\t\t\t// success, we can start our work\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (current == ExecutionState.FAILED) {\n\t\t\t\t// we were immediately failed. tell the TaskManager that we reached our final state\n\t\t\t\tnotifyFinalState();\n\t\t\t\tif (metrics != null) {\n\t\t\t\t\tmetrics.close();\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse if (current == ExecutionState.CANCELING) {\n\t\t\t\tif (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) {\n\t\t\t\t\t// we were immediately canceled. tell the TaskManager that we reached our final state\n\t\t\t\t\tnotifyFinalState();\n\t\t\t\t\tif (metrics != null) {\n\t\t\t\t\t\tmetrics.close();\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// all resource acquisitions and registrations from here on\n\t\t// need to be undone in the end\n\t\tMap<String, Future<Path>> distributedCacheEntries = new HashMap<>();\n\t\tAbstractInvokable invokable = null;\n\n\t\ttry {\n\t\t\t// ----------------------------\n\t\t\t//  Task Bootstrap - We periodically\n\t\t\t//  check for canceling as a shortcut\n\t\t\t// ----------------------------\n\n\t\t\t// activate safety net for task thread\n\t\t\tLOG.info(\"Creating FileSystem stream leak safety net for task {}\", this);\n\t\t\tFileSystemSafetyNet.initializeSafetyNetForThread();\n\n\t\t\tblobService.getPermanentBlobService().registerJob(jobId);\n\n\t\t\t// first of all, get a user-code classloader\n\t\t\t// this may involve downloading the job's JAR files and/or classes\n\t\t\tLOG.info(\"Loading JAR files for task {}.\", this);\n\n\t\t\tuserCodeClassLoader = createUserCodeClassloader();\n\t\t\tfinal ExecutionConfig executionConfig = serializedExecutionConfig.deserializeValue(userCodeClassLoader);\n\n\t\t\tif (executionConfig.getTaskCancellationInterval() >= 0) {\n\t\t\t\t// override task cancellation interval from Flink config if set in ExecutionConfig\n\t\t\t\ttaskCancellationInterval = executionConfig.getTaskCancellationInterval();\n\t\t\t}\n\n\t\t\tif (executionConfig.getTaskCancellationTimeout() >= 0) {\n\t\t\t\t// override task cancellation timeout from Flink config if set in ExecutionConfig\n\t\t\t\ttaskCancellationTimeout = executionConfig.getTaskCancellationTimeout();\n\t\t\t}\n\n\t\t\tif (isCanceledOrFailed()) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t// register the task with the network stack\n\t\t\t// this operation may fail if the system does not have enough\n\t\t\t// memory to run the necessary data exchanges\n\t\t\t// the registration must also strictly be undone\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\tLOG.info(\"Registering task at network: {}.\", this);\n\n\t\t\tnetwork.registerTask(this);\n\n\t\t\t// add metrics for buffers\n\t\t\tthis.metrics.getIOMetricGroup().initializeBufferMetrics(this);\n\n\t\t\t// register detailed network metrics, if configured\n\t\t\tif (taskManagerConfig.getConfiguration().getBoolean(TaskManagerOptions.NETWORK_DETAILED_METRICS)) {\n\t\t\t\t// similar to MetricUtils.instantiateNetworkMetrics() but inside this IOMetricGroup\n\t\t\t\tMetricGroup networkGroup = this.metrics.getIOMetricGroup().addGroup(\"Network\");\n\t\t\t\tMetricGroup outputGroup = networkGroup.addGroup(\"Output\");\n\t\t\t\tMetricGroup inputGroup = networkGroup.addGroup(\"Input\");\n\n\t\t\t\t// output metrics\n\t\t\t\tfor (int i = 0; i < producedPartitions.length; i++) {\n\t\t\t\t\tResultPartitionMetrics.registerQueueLengthMetrics(\n\t\t\t\t\t\toutputGroup.addGroup(i), producedPartitions[i]);\n\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < inputGates.length; i++) {\n\t\t\t\t\tInputGateMetrics.registerQueueLengthMetrics(\n\t\t\t\t\t\tinputGroup.addGroup(i), inputGates[i]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// next, kick off the background copying of files for the distributed cache\n\t\t\ttry {\n\t\t\t\tfor (Map.Entry<String, DistributedCache.DistributedCacheEntry> entry :\n\t\t\t\t\t\tDistributedCache.readFileInfoFromConfig(jobConfiguration)) {\n\t\t\t\t\tLOG.info(\"Obtaining local cache file for '{}'.\", entry.getKey());\n\t\t\t\t\tFuture<Path> cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);\n\t\t\t\t\tdistributedCacheEntries.put(entry.getKey(), cp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isCanceledOrFailed()) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t//  call the user code initialization methods\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\tTaskKvStateRegistry kvStateRegistry = network.createKvStateTaskRegistry(jobId, getJobVertexId());\n\n\t\t\tEnvironment env = new RuntimeEnvironment(\n\t\t\t\tjobId,\n\t\t\t\tvertexId,\n\t\t\t\texecutionId,\n\t\t\t\texecutionConfig,\n\t\t\t\ttaskInfo,\n\t\t\t\tjobConfiguration,\n\t\t\t\ttaskConfiguration,\n\t\t\t\tuserCodeClassLoader,\n\t\t\t\tmemoryManager,\n\t\t\t\tioManager,\n\t\t\t\tbroadcastVariableManager,\n\t\t\t\ttaskStateManager,\n\t\t\t\taccumulatorRegistry,\n\t\t\t\tkvStateRegistry,\n\t\t\t\tinputSplitProvider,\n\t\t\t\tdistributedCacheEntries,\n\t\t\t\tproducedPartitions,\n\t\t\t\tinputGates,\n\t\t\t\tnetwork.getTaskEventDispatcher(),\n\t\t\t\tcheckpointResponder,\n\t\t\t\ttaskManagerConfig,\n\t\t\t\tmetrics,\n\t\t\t\tthis);\n            // 加载用户Task, 比如SourceStreamTask(Source: Custom Source (2/2))\n\t\t\t// now load and instantiate the task's invokable code\n\t\t\tinvokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t//  actual task core work\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\t// we must make strictly sure that the invokable is accessible to the cancel() call\n\t\t\t// by the time we switched to running.\n\t\t\tthis.invokable = invokable;\n\n\t\t\t// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime\n\t\t\tif (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// notify everyone that we switched to running\n\t\t\tnotifyObservers(ExecutionState.RUNNING, null);\n\t\t\ttaskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));\n\n\t\t\t// make sure the user code classloader is accessible thread-locally\n\t\t\texecutingThread.setContextClassLoader(userCodeClassLoader);\n            // 真正开始执行这个task。\n\t\t\t// run the invokable\n\t\t\tinvokable.invoke();\n\n\t\t\t// make sure, we enter the catch block if the task leaves the invoke() method due\n\t\t\t// to the fact that it has been canceled\n\t\t\tif (isCanceledOrFailed()) {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\n\t\t\t// ----------------------------------------------------------------\n\t\t\t//  finalization of a successful execution\n\t\t\t// ----------------------------------------------------------------\n\n\t\t\t// finish the produced partitions. if this fails, we consider the execution failed.\n\t\t\tfor (ResultPartition partition : producedPartitions) {\n\t\t\t\tif (partition != null) {\n\t\t\t\t\tpartition.finish();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// try to mark the task as finished\n\t\t\t// if that fails, the task was canceled/failed in the meantime\n\t\t\tif (transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) {\n\t\t\t\tnotifyObservers(ExecutionState.FINISHED, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new CancelTaskException();\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\ttry {\n\t\t\t\tLOG.info(\"Freeing task resources for {} ({}).\", taskNameWithSubtask, executionId);\n\n\t\t\t\t// clear the reference to the invokable. this helps guard against holding references\n\t\t\t\t// to the invokable and its structures in cases where this Task object is still referenced\n\t\t\t\tthis.invokable = null;\n\n\t\t\t\t// stop the async dispatcher.\n\t\t\t\t// copy dispatcher reference to stack, against concurrent release\n\t\t\t\tExecutorService dispatcher = this.asyncCallDispatcher;\n\t\t\t\tif (dispatcher != null && !dispatcher.isShutdown()) {\n\t\t\t\t\tdispatcher.shutdownNow();\n\t\t\t\t}\n\n\t\t\t\t// free the network resources\n\t\t\t\tnetwork.unregisterTask(this);\n\n\t\t\t\t// free memory resources\n\t\t\t\tif (invokable != null) {\n\t\t\t\t\tmemoryManager.releaseAll(invokable);\n\t\t\t\t}\n\n\t\t\t\t// remove all of the tasks library resources\n\t\t\t\tlibraryCache.unregisterTask(jobId, executionId);\n\t\t\t\tfileCache.releaseJob(jobId, executionId);\n\t\t\t\tblobService.getPermanentBlobService().releaseJob(jobId);\n\n\t\t\t\t// close and de-activate safety net for task thread\n\t\t\t\tLOG.info(\"Ensuring all FileSystem streams are closed for task {}\", this);\n\t\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();\n\n\t\t\t\tnotifyFinalState();\n\t\t\t}\n\t\t}\n\t}\n\n```\n该函数主要做了如下事情:\n1. 加载jar, 配置文件。\n2. 确认invoke函数, invoke函数在JobVertex产生的时候构建的, 比如在StreamingJobGraphGenerator.createJobVertex()中, 而这个invoke最初是在产生StreamNode时候赋值的, 比如在StreamingJobGraphGenerator.transform->transformOneInputTransform->StreamGraph.addOperator:\n```\npublic <IN, OUT> void addOperator(\n\t\t\tInteger vertexID,\n\t\t\tString slotSharingGroup,\n\t\t\t@Nullable String coLocationGroup,\n\t\t\tStreamOperator<OUT> operatorObject,\n\t\t\tTypeInformation<IN> inTypeInfo,\n\t\t\tTypeInformation<OUT> outTypeInfo,\n\t\t\tString operatorName) {\n\n\t\tif (operatorObject instanceof StoppableStreamSource) {\n\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, StoppableSourceStreamTask.class, operatorObject, operatorName);\n\t\t} else if (operatorObject instanceof StreamSource) {\n\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorObject, operatorName);\n\t\t} else {\n\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorObject, operatorName);\n\t\t}\n\t\t......\n```\n可以看到, invoke可以为SourceStreamTask.class或者 OneInputStreamTask.class。 我们以最常见的OneInputStreamTask.class继续讲解。invokable.invoke()最终将跑到OneInputStreamTask.run里面\n```\n\tprotected void run() throws Exception {\n\t\t// cache processor reference on the stack, to make the code more JIT friendly\n\t\tfinal StreamInputProcessor<IN> inputProcessor = this.inputProcessor;\n\n\t\twhile (running && inputProcessor.processInput()) {\n\t\t\t// all the work happens in the \"processInput\" method\n\t\t}\n\t}\n```\n可以看到, 每条数据就循环处理一次, 我们看下每条数据是如何处理的:\n```\n    public boolean processInput() throws Exception {\n\t\tif (isFinished) {\n\t\t\treturn false;\n\t\t}\n\t\tif (numRecordsIn == null) {\n\t\t\ttry {\n\t\t\t\tnumRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();\n\t\t\t} catch (Exception e) {\n\t\t\t\tLOG.warn(\"An exception occurred during the metrics setup.\", e);\n\t\t\t\tnumRecordsIn = new SimpleCounter();\n\t\t\t}\n\t\t}\n       //这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）\n\t\twhile (true) {            //2.会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作\n\t\t\tif (currentRecordDeserializer != null) {\n\t\t\t\tDeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate); //得到下一条数据\n\n\t\t\t\tif (result.isBufferConsumed()) {\n\t\t\t\t\tcurrentRecordDeserializer.getCurrentBuffer().recycleBuffer();\n\t\t\t\t\tcurrentRecordDeserializer = null;\n\t\t\t\t}\n\n\t\t\t\tif (result.isFullRecord()) {\n\t\t\t\t\tStreamElement recordOrMark = deserializationDelegate.getInstance();\n\t\t\t\t\t//如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在）\n\t\t\t\t\tif (recordOrMark.isWatermark()) {\n\t\t\t\t\t\t// handle watermark\n\t\t\t\t\t\tstatusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。\n\t\t\t\t\t} else if (recordOrMark.isStreamStatus()) {\n\t\t\t\t\t\t// handle stream status\n\t\t\t\t\t\tstatusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间\n\t\t\t\t\t} else if (recordOrMark.isLatencyMarker()) {\n\t\t\t\t\t\t// handle latency marker\n\t\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\t\tstreamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t//这里就是真正的，用户的代码即将被执行的地方。\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// now we can do the actual processing\n\t\t\t\t\t\tStreamRecord<IN> record = recordOrMark.asRecord();\n\t\t\t\t\t\tsynchronized (lock) {\n\t\t\t\t\t\t\tnumRecordsIn.inc();\n\t\t\t\t\t\t\tstreamOperator.setKeyContextElement1(record);\n\t\t\t\t\t\t\t// 每个算子开始真正处理数据\n\t\t\t\t\t\t\tstreamOperator.processElement(record);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n            //1.程序首先获取下一个buffer，这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器\n\t\t\tfinal BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();\n\t\t\tif (bufferOrEvent != null) {\n\t\t\t\tif (bufferOrEvent.isBuffer()) {\n\t\t\t\t\tcurrentChannel = bufferOrEvent.getChannelIndex();\n\t\t\t\t\tcurrentRecordDeserializer = recordDeserializers[currentChannel];\n\t\t\t\t\tcurrentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Event received\n\t\t\t\t\tfinal AbstractEvent event = bufferOrEvent.getEvent();\n\t\t\t\t\tif (event.getClass() != EndOfPartitionEvent.class) {\n\t\t\t\t\t\tthrow new IOException(\"Unexpected event: \" + event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tisFinished = true;\n\t\t\t\tif (!barrierHandler.isEmpty()) {\n\t\t\t\t\tthrow new IllegalStateException(\"Trailing data in checkpoint barrier handler.\");\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n```\n每条数据都是通过streamOperator.processElement(record)来完成处理的, 以map算子为例, streamOperator为StreamMap:\n ```\n @Internal\npublic class StreamMap<IN, OUT>\n\t\textends AbstractUdfStreamOperator<OUT, MapFunction<IN, OUT>>\n\t\timplements OneInputStreamOperator<IN, OUT> {\n\tprivate static final long serialVersionUID = 1L;\n\tpublic StreamMap(MapFunction<IN, OUT> mapper) {\n\t\tsuper(mapper);\n\t\tchainingStrategy = ChainingStrategy.ALWAYS;\n\t}\n\t@Override\n\tpublic void processElement(StreamRecord<IN> element) throws Exception {\n\t\toutput.collect(element.replace(userFunction.map(element.getValue())));\n\t}\n}\n ```\n 可以看到, 我们只用负责定义map就可以了。","slug":"Flink原理-TaskManager处理SubTask","published":1,"updated":"2019-06-07T14:46:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w5000cphu5pc90mny5","content":"<p>在了解TaskManager处理task之前, 我们先看下该JVM启动过程。 TaskManager端yarn启动的类为YarnTaskExecutorRunner, TM端存放当前可利用的slot信息存放在TaskManagerServices.taskSlotTable里面, slot默认资源为new ResourceProfile(cpu=1.0, men=42)。<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E9%83%A8%E7%BD%B2subTask%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84slot\">Flink原理-Slot申请及SubTask部署</a>中, 我们知道, subTask会在JobManager中通过TaskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask。TaskManager会通过TaskExecutor.subTask()接收到该部署请求。<br><figure class=\"highlight plain\"><figcaption><span>CompletableFuture<acknowledge> submitTask(</acknowledge></span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\tTaskDeploymentDescriptor tdd,</div><div class=\"line\">\t\tJobMasterId jobMasterId,</div><div class=\"line\">\t\tTime timeout) &#123;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tfinal JobID jobId = tdd.getJobId();</div><div class=\"line\">\t\t//获得与jobManager通信的链接</div><div class=\"line\">\t\tfinal JobManagerConnection jobManagerConnection = jobManagerTable.get(jobId);</div><div class=\"line\">\t\t// re-integrate offloaded data:</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\ttdd.loadBigData(blobCacheService.getPermanentBlobService()); //啥事不做</div><div class=\"line\">\t\t&#125; catch (IOException | ClassNotFoundException e) &#123;</div><div class=\"line\">\t\t\tthrow new TaskSubmissionException(&quot;Could not re-integrate offloaded TaskDeploymentDescriptor data.&quot;, e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t// deserialize the pre-serialized information</div><div class=\"line\">\t\tfinal JobInformation jobInformation;</div><div class=\"line\">\t\tfinal TaskInformation taskInformation;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tjobInformation = tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());</div><div class=\"line\">\t\t\ttaskInformation = tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tTask task = new Task(</div><div class=\"line\">\t\t\tjobInformation,</div><div class=\"line\">\t\t\ttaskInformation,</div><div class=\"line\">\t\t\ttdd.getExecutionAttemptId(),</div><div class=\"line\">\t\t\ttdd.getAllocationId(),</div><div class=\"line\">\t\t\ttdd.getSubtaskIndex(),</div><div class=\"line\">\t\t\ttdd.getAttemptNumber(),</div><div class=\"line\">\t\t\ttdd.getProducedPartitions(),</div><div class=\"line\">\t\t\ttdd.getInputGates(),</div><div class=\"line\">\t\t\ttdd.getTargetSlotNumber(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getMemoryManager(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getIOManager(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getNetworkEnvironment(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getBroadcastVariableManager(),</div><div class=\"line\">\t\t\ttaskStateManager,</div><div class=\"line\">\t\t\ttaskManagerActions,</div><div class=\"line\">\t\t\tinputSplitProvider,</div><div class=\"line\">\t\t\tcheckpointResponder,</div><div class=\"line\">\t\t\tblobCacheService,</div><div class=\"line\">\t\t\tlibraryCache,</div><div class=\"line\">\t\t\tfileCache,</div><div class=\"line\">\t\t\ttaskManagerConfiguration,</div><div class=\"line\">\t\t\ttaskMetricGroup,</div><div class=\"line\">\t\t\tresultPartitionConsumableNotifier,</div><div class=\"line\">\t\t\tpartitionStateChecker,</div><div class=\"line\">\t\t\tgetRpcService().getExecutor());</div><div class=\"line\">\t\tlog.info(&quot;Received task &#123;&#125;.&quot;, task.getTaskInfo().getTaskNameWithSubtasks());</div><div class=\"line\">\t\tboolean taskAdded;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t    // 将task放入taskSlotTable.taskSlotMappings中</div><div class=\"line\">\t\t\ttaskAdded = taskSlotTable.addTask(task);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tif (taskAdded) &#123;</div><div class=\"line\">\t\t    //这里比较重要，开始进行task执行</div><div class=\"line\">\t\t\ttask.startTaskThread();</div><div class=\"line\">\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>TM接收到请求后, 首先构建Task(Runnable), 然后通过task.startTaskThread()将这个线程运行起来, 真正执行任务的是run函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t// ----------------------------</div><div class=\"line\">\t\t//  Initial State transition</div><div class=\"line\">\t\t// ----------------------------</div><div class=\"line\">\t\twhile (true) &#123;</div><div class=\"line\">\t\t\tExecutionState current = this.executionState;</div><div class=\"line\">\t\t\t// 首先将Task状态置为DEPLOYING状态, 状态不修改成功, 不停地尝试</div><div class=\"line\">\t\t\tif (current == ExecutionState.CREATED) &#123;</div><div class=\"line\">\t\t\t\tif (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</div><div class=\"line\">\t\t\t\t\t// success, we can start our work</div><div class=\"line\">\t\t\t\t\tbreak;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse if (current == ExecutionState.FAILED) &#123;</div><div class=\"line\">\t\t\t\t// we were immediately failed. tell the TaskManager that we reached our final state</div><div class=\"line\">\t\t\t\tnotifyFinalState();</div><div class=\"line\">\t\t\t\tif (metrics != null) &#123;</div><div class=\"line\">\t\t\t\t\tmetrics.close();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\treturn;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse if (current == ExecutionState.CANCELING) &#123;</div><div class=\"line\">\t\t\t\tif (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</div><div class=\"line\">\t\t\t\t\t// we were immediately canceled. tell the TaskManager that we reached our final state</div><div class=\"line\">\t\t\t\t\tnotifyFinalState();</div><div class=\"line\">\t\t\t\t\tif (metrics != null) &#123;</div><div class=\"line\">\t\t\t\t\t\tmetrics.close();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\treturn;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t// all resource acquisitions and registrations from here on</div><div class=\"line\">\t\t// need to be undone in the end</div><div class=\"line\">\t\tMap&lt;String, Future&lt;Path&gt;&gt; distributedCacheEntries = new HashMap&lt;&gt;();</div><div class=\"line\">\t\tAbstractInvokable invokable = null;</div><div class=\"line\"></div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\t// ----------------------------</div><div class=\"line\">\t\t\t//  Task Bootstrap - We periodically</div><div class=\"line\">\t\t\t//  check for canceling as a shortcut</div><div class=\"line\">\t\t\t// ----------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\t// activate safety net for task thread</div><div class=\"line\">\t\t\tLOG.info(&quot;Creating FileSystem stream leak safety net for task &#123;&#125;&quot;, this);</div><div class=\"line\">\t\t\tFileSystemSafetyNet.initializeSafetyNetForThread();</div><div class=\"line\"></div><div class=\"line\">\t\t\tblobService.getPermanentBlobService().registerJob(jobId);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// first of all, get a user-code classloader</div><div class=\"line\">\t\t\t// this may involve downloading the job&apos;s JAR files and/or classes</div><div class=\"line\">\t\t\tLOG.info(&quot;Loading JAR files for task &#123;&#125;.&quot;, this);</div><div class=\"line\"></div><div class=\"line\">\t\t\tuserCodeClassLoader = createUserCodeClassloader();</div><div class=\"line\">\t\t\tfinal ExecutionConfig executionConfig = serializedExecutionConfig.deserializeValue(userCodeClassLoader);</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (executionConfig.getTaskCancellationInterval() &gt;= 0) &#123;</div><div class=\"line\">\t\t\t\t// override task cancellation interval from Flink config if set in ExecutionConfig</div><div class=\"line\">\t\t\t\ttaskCancellationInterval = executionConfig.getTaskCancellationInterval();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (executionConfig.getTaskCancellationTimeout() &gt;= 0) &#123;</div><div class=\"line\">\t\t\t\t// override task cancellation timeout from Flink config if set in ExecutionConfig</div><div class=\"line\">\t\t\t\ttaskCancellationTimeout = executionConfig.getTaskCancellationTimeout();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (isCanceledOrFailed()) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t// register the task with the network stack</div><div class=\"line\">\t\t\t// this operation may fail if the system does not have enough</div><div class=\"line\">\t\t\t// memory to run the necessary data exchanges</div><div class=\"line\">\t\t\t// the registration must also strictly be undone</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\tLOG.info(&quot;Registering task at network: &#123;&#125;.&quot;, this);</div><div class=\"line\"></div><div class=\"line\">\t\t\tnetwork.registerTask(this);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// add metrics for buffers</div><div class=\"line\">\t\t\tthis.metrics.getIOMetricGroup().initializeBufferMetrics(this);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// register detailed network metrics, if configured</div><div class=\"line\">\t\t\tif (taskManagerConfig.getConfiguration().getBoolean(TaskManagerOptions.NETWORK_DETAILED_METRICS)) &#123;</div><div class=\"line\">\t\t\t\t// similar to MetricUtils.instantiateNetworkMetrics() but inside this IOMetricGroup</div><div class=\"line\">\t\t\t\tMetricGroup networkGroup = this.metrics.getIOMetricGroup().addGroup(&quot;Network&quot;);</div><div class=\"line\">\t\t\t\tMetricGroup outputGroup = networkGroup.addGroup(&quot;Output&quot;);</div><div class=\"line\">\t\t\t\tMetricGroup inputGroup = networkGroup.addGroup(&quot;Input&quot;);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// output metrics</div><div class=\"line\">\t\t\t\tfor (int i = 0; i &lt; producedPartitions.length; i++) &#123;</div><div class=\"line\">\t\t\t\t\tResultPartitionMetrics.registerQueueLengthMetrics(</div><div class=\"line\">\t\t\t\t\t\toutputGroup.addGroup(i), producedPartitions[i]);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tfor (int i = 0; i &lt; inputGates.length; i++) &#123;</div><div class=\"line\">\t\t\t\t\tInputGateMetrics.registerQueueLengthMetrics(</div><div class=\"line\">\t\t\t\t\t\tinputGroup.addGroup(i), inputGates[i]);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// next, kick off the background copying of files for the distributed cache</div><div class=\"line\">\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\tfor (Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt; entry :</div><div class=\"line\">\t\t\t\t\t\tDistributedCache.readFileInfoFromConfig(jobConfiguration)) &#123;</div><div class=\"line\">\t\t\t\t\tLOG.info(&quot;Obtaining local cache file for &apos;&#123;&#125;&apos;.&quot;, entry.getKey());</div><div class=\"line\">\t\t\t\t\tFuture&lt;Path&gt; cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);</div><div class=\"line\">\t\t\t\t\tdistributedCacheEntries.put(entry.getKey(), cp);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (isCanceledOrFailed()) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t//  call the user code initialization methods</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\tTaskKvStateRegistry kvStateRegistry = network.createKvStateTaskRegistry(jobId, getJobVertexId());</div><div class=\"line\"></div><div class=\"line\">\t\t\tEnvironment env = new RuntimeEnvironment(</div><div class=\"line\">\t\t\t\tjobId,</div><div class=\"line\">\t\t\t\tvertexId,</div><div class=\"line\">\t\t\t\texecutionId,</div><div class=\"line\">\t\t\t\texecutionConfig,</div><div class=\"line\">\t\t\t\ttaskInfo,</div><div class=\"line\">\t\t\t\tjobConfiguration,</div><div class=\"line\">\t\t\t\ttaskConfiguration,</div><div class=\"line\">\t\t\t\tuserCodeClassLoader,</div><div class=\"line\">\t\t\t\tmemoryManager,</div><div class=\"line\">\t\t\t\tioManager,</div><div class=\"line\">\t\t\t\tbroadcastVariableManager,</div><div class=\"line\">\t\t\t\ttaskStateManager,</div><div class=\"line\">\t\t\t\taccumulatorRegistry,</div><div class=\"line\">\t\t\t\tkvStateRegistry,</div><div class=\"line\">\t\t\t\tinputSplitProvider,</div><div class=\"line\">\t\t\t\tdistributedCacheEntries,</div><div class=\"line\">\t\t\t\tproducedPartitions,</div><div class=\"line\">\t\t\t\tinputGates,</div><div class=\"line\">\t\t\t\tnetwork.getTaskEventDispatcher(),</div><div class=\"line\">\t\t\t\tcheckpointResponder,</div><div class=\"line\">\t\t\t\ttaskManagerConfig,</div><div class=\"line\">\t\t\t\tmetrics,</div><div class=\"line\">\t\t\t\tthis);</div><div class=\"line\">            // 加载用户Task, 比如SourceStreamTask(Source: Custom Source (2/2))</div><div class=\"line\">\t\t\t// now load and instantiate the task&apos;s invokable code</div><div class=\"line\">\t\t\tinvokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t//  actual task core work</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\t// we must make strictly sure that the invokable is accessible to the cancel() call</div><div class=\"line\">\t\t\t// by the time we switched to running.</div><div class=\"line\">\t\t\tthis.invokable = invokable;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime</div><div class=\"line\">\t\t\tif (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// notify everyone that we switched to running</div><div class=\"line\">\t\t\tnotifyObservers(ExecutionState.RUNNING, null);</div><div class=\"line\">\t\t\ttaskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));</div><div class=\"line\"></div><div class=\"line\">\t\t\t// make sure the user code classloader is accessible thread-locally</div><div class=\"line\">\t\t\texecutingThread.setContextClassLoader(userCodeClassLoader);</div><div class=\"line\">            // 真正开始执行这个task。</div><div class=\"line\">\t\t\t// run the invokable</div><div class=\"line\">\t\t\tinvokable.invoke();</div><div class=\"line\"></div><div class=\"line\">\t\t\t// make sure, we enter the catch block if the task leaves the invoke() method due</div><div class=\"line\">\t\t\t// to the fact that it has been canceled</div><div class=\"line\">\t\t\tif (isCanceledOrFailed()) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t//  finalization of a successful execution</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\t// finish the produced partitions. if this fails, we consider the execution failed.</div><div class=\"line\">\t\t\tfor (ResultPartition partition : producedPartitions) &#123;</div><div class=\"line\">\t\t\t\tif (partition != null) &#123;</div><div class=\"line\">\t\t\t\t\tpartition.finish();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// try to mark the task as finished</div><div class=\"line\">\t\t\t// if that fails, the task was canceled/failed in the meantime</div><div class=\"line\">\t\t\tif (transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) &#123;</div><div class=\"line\">\t\t\t\tnotifyObservers(ExecutionState.FINISHED, null);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfinally &#123;</div><div class=\"line\">\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\tLOG.info(&quot;Freeing task resources for &#123;&#125; (&#123;&#125;).&quot;, taskNameWithSubtask, executionId);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// clear the reference to the invokable. this helps guard against holding references</div><div class=\"line\">\t\t\t\t// to the invokable and its structures in cases where this Task object is still referenced</div><div class=\"line\">\t\t\t\tthis.invokable = null;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// stop the async dispatcher.</div><div class=\"line\">\t\t\t\t// copy dispatcher reference to stack, against concurrent release</div><div class=\"line\">\t\t\t\tExecutorService dispatcher = this.asyncCallDispatcher;</div><div class=\"line\">\t\t\t\tif (dispatcher != null &amp;&amp; !dispatcher.isShutdown()) &#123;</div><div class=\"line\">\t\t\t\t\tdispatcher.shutdownNow();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// free the network resources</div><div class=\"line\">\t\t\t\tnetwork.unregisterTask(this);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// free memory resources</div><div class=\"line\">\t\t\t\tif (invokable != null) &#123;</div><div class=\"line\">\t\t\t\t\tmemoryManager.releaseAll(invokable);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// remove all of the tasks library resources</div><div class=\"line\">\t\t\t\tlibraryCache.unregisterTask(jobId, executionId);</div><div class=\"line\">\t\t\t\tfileCache.releaseJob(jobId, executionId);</div><div class=\"line\">\t\t\t\tblobService.getPermanentBlobService().releaseJob(jobId);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// close and de-activate safety net for task thread</div><div class=\"line\">\t\t\t\tLOG.info(&quot;Ensuring all FileSystem streams are closed for task &#123;&#125;&quot;, this);</div><div class=\"line\">\t\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tnotifyFinalState();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>加载jar, 配置文件。</li>\n<li>确认invoke函数, invoke函数在JobVertex产生的时候构建的, 比如在StreamingJobGraphGenerator.createJobVertex()中, 而这个invoke最初是在产生StreamNode时候赋值的, 比如在StreamingJobGraphGenerator.transform-&gt;transformOneInputTransform-&gt;StreamGraph.addOperator:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public &lt;IN, OUT&gt; void addOperator(</div><div class=\"line\">\t\t\tInteger vertexID,</div><div class=\"line\">\t\t\tString slotSharingGroup,</div><div class=\"line\">\t\t\t@Nullable String coLocationGroup,</div><div class=\"line\">\t\t\tStreamOperator&lt;OUT&gt; operatorObject,</div><div class=\"line\">\t\t\tTypeInformation&lt;IN&gt; inTypeInfo,</div><div class=\"line\">\t\t\tTypeInformation&lt;OUT&gt; outTypeInfo,</div><div class=\"line\">\t\t\tString operatorName) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif (operatorObject instanceof StoppableStreamSource) &#123;</div><div class=\"line\">\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, StoppableSourceStreamTask.class, operatorObject, operatorName);</div><div class=\"line\">\t\t&#125; else if (operatorObject instanceof StreamSource) &#123;</div><div class=\"line\">\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorObject, operatorName);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorObject, operatorName);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t......</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以看到, invoke可以为SourceStreamTask.class或者 OneInputStreamTask.class。 我们以最常见的OneInputStreamTask.class继续讲解。invokable.invoke()最终将跑到OneInputStreamTask.run里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void run() throws Exception &#123;</div><div class=\"line\">\t// cache processor reference on the stack, to make the code more JIT friendly</div><div class=\"line\">\tfinal StreamInputProcessor&lt;IN&gt; inputProcessor = this.inputProcessor;</div><div class=\"line\"></div><div class=\"line\">\twhile (running &amp;&amp; inputProcessor.processInput()) &#123;</div><div class=\"line\">\t\t// all the work happens in the &quot;processInput&quot; method</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, 每条数据就循环处理一次, 我们看下每条数据是如何处理的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public boolean processInput() throws Exception &#123;</div><div class=\"line\">\tif (isFinished) &#123;</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (numRecordsIn == null) &#123;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tnumRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\tLOG.warn(&quot;An exception occurred during the metrics setup.&quot;, e);</div><div class=\"line\">\t\t\tnumRecordsIn = new SimpleCounter();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">      //这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）</div><div class=\"line\">\twhile (true) &#123;            //2.会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作</div><div class=\"line\">\t\tif (currentRecordDeserializer != null) &#123;</div><div class=\"line\">\t\t\tDeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate); //得到下一条数据</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (result.isBufferConsumed()) &#123;</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer.getCurrentBuffer().recycleBuffer();</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer = null;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (result.isFullRecord()) &#123;</div><div class=\"line\">\t\t\t\tStreamElement recordOrMark = deserializationDelegate.getInstance();</div><div class=\"line\">\t\t\t\t//如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在）</div><div class=\"line\">\t\t\t\tif (recordOrMark.isWatermark()) &#123;</div><div class=\"line\">\t\t\t\t\t// handle watermark</div><div class=\"line\">\t\t\t\t\tstatusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);</div><div class=\"line\">\t\t\t\t\tcontinue;</div><div class=\"line\">\t\t\t\t//如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。</div><div class=\"line\">\t\t\t\t&#125; else if (recordOrMark.isStreamStatus()) &#123;</div><div class=\"line\">\t\t\t\t\t// handle stream status</div><div class=\"line\">\t\t\t\t\tstatusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);</div><div class=\"line\">\t\t\t\t\tcontinue;</div><div class=\"line\">\t\t\t\t//LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间</div><div class=\"line\">\t\t\t\t&#125; else if (recordOrMark.isLatencyMarker()) &#123;</div><div class=\"line\">\t\t\t\t\t// handle latency marker</div><div class=\"line\">\t\t\t\t\tsynchronized (lock) &#123;</div><div class=\"line\">\t\t\t\t\t\tstreamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\tcontinue;</div><div class=\"line\">\t\t\t\t//这里就是真正的，用户的代码即将被执行的地方。</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\t// now we can do the actual processing</div><div class=\"line\">\t\t\t\t\tStreamRecord&lt;IN&gt; record = recordOrMark.asRecord();</div><div class=\"line\">\t\t\t\t\tsynchronized (lock) &#123;</div><div class=\"line\">\t\t\t\t\t\tnumRecordsIn.inc();</div><div class=\"line\">\t\t\t\t\t\tstreamOperator.setKeyContextElement1(record);</div><div class=\"line\">\t\t\t\t\t\t// 每个算子开始真正处理数据</div><div class=\"line\">\t\t\t\t\t\tstreamOperator.processElement(record);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\treturn true;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">           //1.程序首先获取下一个buffer，这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器</div><div class=\"line\">\t\tfinal BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</div><div class=\"line\">\t\tif (bufferOrEvent != null) &#123;</div><div class=\"line\">\t\t\tif (bufferOrEvent.isBuffer()) &#123;</div><div class=\"line\">\t\t\t\tcurrentChannel = bufferOrEvent.getChannelIndex();</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer = recordDeserializers[currentChannel];</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse &#123;</div><div class=\"line\">\t\t\t\t// Event received</div><div class=\"line\">\t\t\t\tfinal AbstractEvent event = bufferOrEvent.getEvent();</div><div class=\"line\">\t\t\t\tif (event.getClass() != EndOfPartitionEvent.class) &#123;</div><div class=\"line\">\t\t\t\t\tthrow new IOException(&quot;Unexpected event: &quot; + event);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse &#123;</div><div class=\"line\">\t\t\tisFinished = true;</div><div class=\"line\">\t\t\tif (!barrierHandler.isEmpty()) &#123;</div><div class=\"line\">\t\t\t\tthrow new IllegalStateException(&quot;Trailing data in checkpoint barrier handler.&quot;);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\treturn false;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每条数据都是通过streamOperator.processElement(record)来完成处理的, 以map算子为例, streamOperator为StreamMap:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> @Internal</div><div class=\"line\">public class StreamMap&lt;IN, OUT&gt;</div><div class=\"line\">\t\textends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt;</div><div class=\"line\">\t\timplements OneInputStreamOperator&lt;IN, OUT&gt; &#123;</div><div class=\"line\">\tprivate static final long serialVersionUID = 1L;</div><div class=\"line\">\tpublic StreamMap(MapFunction&lt;IN, OUT&gt; mapper) &#123;</div><div class=\"line\">\t\tsuper(mapper);</div><div class=\"line\">\t\tchainingStrategy = ChainingStrategy.ALWAYS;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</div><div class=\"line\">\t\toutput.collect(element.replace(userFunction.map(element.getValue())));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 可以看到, 我们只用负责定义map就可以了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在了解TaskManager处理task之前, 我们先看下该JVM启动过程。 TaskManager端yarn启动的类为YarnTaskExecutorRunner, TM端存放当前可利用的slot信息存放在TaskManagerServices.taskSlotTable里面, slot默认资源为new ResourceProfile(cpu=1.0, men=42)。<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/03/12/Flink%E5%8E%9F%E7%90%86-slot%E5%88%86%E9%85%8D/#%E9%83%A8%E7%BD%B2subTask%E5%88%B0%E5%AF%B9%E5%BA%94%E7%9A%84slot\">Flink原理-Slot申请及SubTask部署</a>中, 我们知道, subTask会在JobManager中通过TaskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask。TaskManager会通过TaskExecutor.subTask()接收到该部署请求。<br><figure class=\"highlight plain\"><figcaption><span>CompletableFuture<acknowledge> submitTask(</acknowledge></span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div></pre></td><td class=\"code\"><pre><div class=\"line\">\t\tTaskDeploymentDescriptor tdd,</div><div class=\"line\">\t\tJobMasterId jobMasterId,</div><div class=\"line\">\t\tTime timeout) &#123;</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tfinal JobID jobId = tdd.getJobId();</div><div class=\"line\">\t\t//获得与jobManager通信的链接</div><div class=\"line\">\t\tfinal JobManagerConnection jobManagerConnection = jobManagerTable.get(jobId);</div><div class=\"line\">\t\t// re-integrate offloaded data:</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\ttdd.loadBigData(blobCacheService.getPermanentBlobService()); //啥事不做</div><div class=\"line\">\t\t&#125; catch (IOException | ClassNotFoundException e) &#123;</div><div class=\"line\">\t\t\tthrow new TaskSubmissionException(&quot;Could not re-integrate offloaded TaskDeploymentDescriptor data.&quot;, e);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t// deserialize the pre-serialized information</div><div class=\"line\">\t\tfinal JobInformation jobInformation;</div><div class=\"line\">\t\tfinal TaskInformation taskInformation;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tjobInformation = tdd.getSerializedJobInformation().deserializeValue(getClass().getClassLoader());</div><div class=\"line\">\t\t\ttaskInformation = tdd.getSerializedTaskInformation().deserializeValue(getClass().getClassLoader());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tTask task = new Task(</div><div class=\"line\">\t\t\tjobInformation,</div><div class=\"line\">\t\t\ttaskInformation,</div><div class=\"line\">\t\t\ttdd.getExecutionAttemptId(),</div><div class=\"line\">\t\t\ttdd.getAllocationId(),</div><div class=\"line\">\t\t\ttdd.getSubtaskIndex(),</div><div class=\"line\">\t\t\ttdd.getAttemptNumber(),</div><div class=\"line\">\t\t\ttdd.getProducedPartitions(),</div><div class=\"line\">\t\t\ttdd.getInputGates(),</div><div class=\"line\">\t\t\ttdd.getTargetSlotNumber(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getMemoryManager(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getIOManager(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getNetworkEnvironment(),</div><div class=\"line\">\t\t\ttaskExecutorServices.getBroadcastVariableManager(),</div><div class=\"line\">\t\t\ttaskStateManager,</div><div class=\"line\">\t\t\ttaskManagerActions,</div><div class=\"line\">\t\t\tinputSplitProvider,</div><div class=\"line\">\t\t\tcheckpointResponder,</div><div class=\"line\">\t\t\tblobCacheService,</div><div class=\"line\">\t\t\tlibraryCache,</div><div class=\"line\">\t\t\tfileCache,</div><div class=\"line\">\t\t\ttaskManagerConfiguration,</div><div class=\"line\">\t\t\ttaskMetricGroup,</div><div class=\"line\">\t\t\tresultPartitionConsumableNotifier,</div><div class=\"line\">\t\t\tpartitionStateChecker,</div><div class=\"line\">\t\t\tgetRpcService().getExecutor());</div><div class=\"line\">\t\tlog.info(&quot;Received task &#123;&#125;.&quot;, task.getTaskInfo().getTaskNameWithSubtasks());</div><div class=\"line\">\t\tboolean taskAdded;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t    // 将task放入taskSlotTable.taskSlotMappings中</div><div class=\"line\">\t\t\ttaskAdded = taskSlotTable.addTask(task);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tif (taskAdded) &#123;</div><div class=\"line\">\t\t    //这里比较重要，开始进行task执行</div><div class=\"line\">\t\t\ttask.startTaskThread();</div><div class=\"line\">\t\t\treturn CompletableFuture.completedFuture(Acknowledge.get());</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>TM接收到请求后, 首先构建Task(Runnable), 然后通过task.startTaskThread()将这个线程运行起来, 真正执行任务的是run函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div><div class=\"line\">187</div><div class=\"line\">188</div><div class=\"line\">189</div><div class=\"line\">190</div><div class=\"line\">191</div><div class=\"line\">192</div><div class=\"line\">193</div><div class=\"line\">194</div><div class=\"line\">195</div><div class=\"line\">196</div><div class=\"line\">197</div><div class=\"line\">198</div><div class=\"line\">199</div><div class=\"line\">200</div><div class=\"line\">201</div><div class=\"line\">202</div><div class=\"line\">203</div><div class=\"line\">204</div><div class=\"line\">205</div><div class=\"line\">206</div><div class=\"line\">207</div><div class=\"line\">208</div><div class=\"line\">209</div><div class=\"line\">210</div><div class=\"line\">211</div><div class=\"line\">212</div><div class=\"line\">213</div><div class=\"line\">214</div><div class=\"line\">215</div><div class=\"line\">216</div><div class=\"line\">217</div><div class=\"line\">218</div><div class=\"line\">219</div><div class=\"line\">220</div><div class=\"line\">221</div><div class=\"line\">222</div><div class=\"line\">223</div><div class=\"line\">224</div><div class=\"line\">225</div><div class=\"line\">226</div><div class=\"line\">227</div><div class=\"line\">228</div><div class=\"line\">229</div><div class=\"line\">230</div><div class=\"line\">231</div><div class=\"line\">232</div><div class=\"line\">233</div><div class=\"line\">234</div><div class=\"line\">235</div><div class=\"line\">236</div><div class=\"line\">237</div><div class=\"line\">238</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void run() &#123;</div><div class=\"line\"></div><div class=\"line\">\t\t// ----------------------------</div><div class=\"line\">\t\t//  Initial State transition</div><div class=\"line\">\t\t// ----------------------------</div><div class=\"line\">\t\twhile (true) &#123;</div><div class=\"line\">\t\t\tExecutionState current = this.executionState;</div><div class=\"line\">\t\t\t// 首先将Task状态置为DEPLOYING状态, 状态不修改成功, 不停地尝试</div><div class=\"line\">\t\t\tif (current == ExecutionState.CREATED) &#123;</div><div class=\"line\">\t\t\t\tif (transitionState(ExecutionState.CREATED, ExecutionState.DEPLOYING)) &#123;</div><div class=\"line\">\t\t\t\t\t// success, we can start our work</div><div class=\"line\">\t\t\t\t\tbreak;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse if (current == ExecutionState.FAILED) &#123;</div><div class=\"line\">\t\t\t\t// we were immediately failed. tell the TaskManager that we reached our final state</div><div class=\"line\">\t\t\t\tnotifyFinalState();</div><div class=\"line\">\t\t\t\tif (metrics != null) &#123;</div><div class=\"line\">\t\t\t\t\tmetrics.close();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\treturn;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse if (current == ExecutionState.CANCELING) &#123;</div><div class=\"line\">\t\t\t\tif (transitionState(ExecutionState.CANCELING, ExecutionState.CANCELED)) &#123;</div><div class=\"line\">\t\t\t\t\t// we were immediately canceled. tell the TaskManager that we reached our final state</div><div class=\"line\">\t\t\t\t\tnotifyFinalState();</div><div class=\"line\">\t\t\t\t\tif (metrics != null) &#123;</div><div class=\"line\">\t\t\t\t\t\tmetrics.close();</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\treturn;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t// all resource acquisitions and registrations from here on</div><div class=\"line\">\t\t// need to be undone in the end</div><div class=\"line\">\t\tMap&lt;String, Future&lt;Path&gt;&gt; distributedCacheEntries = new HashMap&lt;&gt;();</div><div class=\"line\">\t\tAbstractInvokable invokable = null;</div><div class=\"line\"></div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\t// ----------------------------</div><div class=\"line\">\t\t\t//  Task Bootstrap - We periodically</div><div class=\"line\">\t\t\t//  check for canceling as a shortcut</div><div class=\"line\">\t\t\t// ----------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\t// activate safety net for task thread</div><div class=\"line\">\t\t\tLOG.info(&quot;Creating FileSystem stream leak safety net for task &#123;&#125;&quot;, this);</div><div class=\"line\">\t\t\tFileSystemSafetyNet.initializeSafetyNetForThread();</div><div class=\"line\"></div><div class=\"line\">\t\t\tblobService.getPermanentBlobService().registerJob(jobId);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// first of all, get a user-code classloader</div><div class=\"line\">\t\t\t// this may involve downloading the job&apos;s JAR files and/or classes</div><div class=\"line\">\t\t\tLOG.info(&quot;Loading JAR files for task &#123;&#125;.&quot;, this);</div><div class=\"line\"></div><div class=\"line\">\t\t\tuserCodeClassLoader = createUserCodeClassloader();</div><div class=\"line\">\t\t\tfinal ExecutionConfig executionConfig = serializedExecutionConfig.deserializeValue(userCodeClassLoader);</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (executionConfig.getTaskCancellationInterval() &gt;= 0) &#123;</div><div class=\"line\">\t\t\t\t// override task cancellation interval from Flink config if set in ExecutionConfig</div><div class=\"line\">\t\t\t\ttaskCancellationInterval = executionConfig.getTaskCancellationInterval();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (executionConfig.getTaskCancellationTimeout() &gt;= 0) &#123;</div><div class=\"line\">\t\t\t\t// override task cancellation timeout from Flink config if set in ExecutionConfig</div><div class=\"line\">\t\t\t\ttaskCancellationTimeout = executionConfig.getTaskCancellationTimeout();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (isCanceledOrFailed()) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t// register the task with the network stack</div><div class=\"line\">\t\t\t// this operation may fail if the system does not have enough</div><div class=\"line\">\t\t\t// memory to run the necessary data exchanges</div><div class=\"line\">\t\t\t// the registration must also strictly be undone</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\tLOG.info(&quot;Registering task at network: &#123;&#125;.&quot;, this);</div><div class=\"line\"></div><div class=\"line\">\t\t\tnetwork.registerTask(this);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// add metrics for buffers</div><div class=\"line\">\t\t\tthis.metrics.getIOMetricGroup().initializeBufferMetrics(this);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// register detailed network metrics, if configured</div><div class=\"line\">\t\t\tif (taskManagerConfig.getConfiguration().getBoolean(TaskManagerOptions.NETWORK_DETAILED_METRICS)) &#123;</div><div class=\"line\">\t\t\t\t// similar to MetricUtils.instantiateNetworkMetrics() but inside this IOMetricGroup</div><div class=\"line\">\t\t\t\tMetricGroup networkGroup = this.metrics.getIOMetricGroup().addGroup(&quot;Network&quot;);</div><div class=\"line\">\t\t\t\tMetricGroup outputGroup = networkGroup.addGroup(&quot;Output&quot;);</div><div class=\"line\">\t\t\t\tMetricGroup inputGroup = networkGroup.addGroup(&quot;Input&quot;);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// output metrics</div><div class=\"line\">\t\t\t\tfor (int i = 0; i &lt; producedPartitions.length; i++) &#123;</div><div class=\"line\">\t\t\t\t\tResultPartitionMetrics.registerQueueLengthMetrics(</div><div class=\"line\">\t\t\t\t\t\toutputGroup.addGroup(i), producedPartitions[i]);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tfor (int i = 0; i &lt; inputGates.length; i++) &#123;</div><div class=\"line\">\t\t\t\t\tInputGateMetrics.registerQueueLengthMetrics(</div><div class=\"line\">\t\t\t\t\t\tinputGroup.addGroup(i), inputGates[i]);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// next, kick off the background copying of files for the distributed cache</div><div class=\"line\">\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\tfor (Map.Entry&lt;String, DistributedCache.DistributedCacheEntry&gt; entry :</div><div class=\"line\">\t\t\t\t\t\tDistributedCache.readFileInfoFromConfig(jobConfiguration)) &#123;</div><div class=\"line\">\t\t\t\t\tLOG.info(&quot;Obtaining local cache file for &apos;&#123;&#125;&apos;.&quot;, entry.getKey());</div><div class=\"line\">\t\t\t\t\tFuture&lt;Path&gt; cp = fileCache.createTmpFile(entry.getKey(), entry.getValue(), jobId, executionId);</div><div class=\"line\">\t\t\t\t\tdistributedCacheEntries.put(entry.getKey(), cp);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (isCanceledOrFailed()) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t//  call the user code initialization methods</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\tTaskKvStateRegistry kvStateRegistry = network.createKvStateTaskRegistry(jobId, getJobVertexId());</div><div class=\"line\"></div><div class=\"line\">\t\t\tEnvironment env = new RuntimeEnvironment(</div><div class=\"line\">\t\t\t\tjobId,</div><div class=\"line\">\t\t\t\tvertexId,</div><div class=\"line\">\t\t\t\texecutionId,</div><div class=\"line\">\t\t\t\texecutionConfig,</div><div class=\"line\">\t\t\t\ttaskInfo,</div><div class=\"line\">\t\t\t\tjobConfiguration,</div><div class=\"line\">\t\t\t\ttaskConfiguration,</div><div class=\"line\">\t\t\t\tuserCodeClassLoader,</div><div class=\"line\">\t\t\t\tmemoryManager,</div><div class=\"line\">\t\t\t\tioManager,</div><div class=\"line\">\t\t\t\tbroadcastVariableManager,</div><div class=\"line\">\t\t\t\ttaskStateManager,</div><div class=\"line\">\t\t\t\taccumulatorRegistry,</div><div class=\"line\">\t\t\t\tkvStateRegistry,</div><div class=\"line\">\t\t\t\tinputSplitProvider,</div><div class=\"line\">\t\t\t\tdistributedCacheEntries,</div><div class=\"line\">\t\t\t\tproducedPartitions,</div><div class=\"line\">\t\t\t\tinputGates,</div><div class=\"line\">\t\t\t\tnetwork.getTaskEventDispatcher(),</div><div class=\"line\">\t\t\t\tcheckpointResponder,</div><div class=\"line\">\t\t\t\ttaskManagerConfig,</div><div class=\"line\">\t\t\t\tmetrics,</div><div class=\"line\">\t\t\t\tthis);</div><div class=\"line\">            // 加载用户Task, 比如SourceStreamTask(Source: Custom Source (2/2))</div><div class=\"line\">\t\t\t// now load and instantiate the task&apos;s invokable code</div><div class=\"line\">\t\t\tinvokable = loadAndInstantiateInvokable(userCodeClassLoader, nameOfInvokableClass, env);</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t//  actual task core work</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\t// we must make strictly sure that the invokable is accessible to the cancel() call</div><div class=\"line\">\t\t\t// by the time we switched to running.</div><div class=\"line\">\t\t\tthis.invokable = invokable;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime</div><div class=\"line\">\t\t\tif (!transitionState(ExecutionState.DEPLOYING, ExecutionState.RUNNING)) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// notify everyone that we switched to running</div><div class=\"line\">\t\t\tnotifyObservers(ExecutionState.RUNNING, null);</div><div class=\"line\">\t\t\ttaskManagerActions.updateTaskExecutionState(new TaskExecutionState(jobId, executionId, ExecutionState.RUNNING));</div><div class=\"line\"></div><div class=\"line\">\t\t\t// make sure the user code classloader is accessible thread-locally</div><div class=\"line\">\t\t\texecutingThread.setContextClassLoader(userCodeClassLoader);</div><div class=\"line\">            // 真正开始执行这个task。</div><div class=\"line\">\t\t\t// run the invokable</div><div class=\"line\">\t\t\tinvokable.invoke();</div><div class=\"line\"></div><div class=\"line\">\t\t\t// make sure, we enter the catch block if the task leaves the invoke() method due</div><div class=\"line\">\t\t\t// to the fact that it has been canceled</div><div class=\"line\">\t\t\tif (isCanceledOrFailed()) &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\">\t\t\t//  finalization of a successful execution</div><div class=\"line\">\t\t\t// ----------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">\t\t\t// finish the produced partitions. if this fails, we consider the execution failed.</div><div class=\"line\">\t\t\tfor (ResultPartition partition : producedPartitions) &#123;</div><div class=\"line\">\t\t\t\tif (partition != null) &#123;</div><div class=\"line\">\t\t\t\t\tpartition.finish();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t// try to mark the task as finished</div><div class=\"line\">\t\t\t// if that fails, the task was canceled/failed in the meantime</div><div class=\"line\">\t\t\tif (transitionState(ExecutionState.RUNNING, ExecutionState.FINISHED)) &#123;</div><div class=\"line\">\t\t\t\tnotifyObservers(ExecutionState.FINISHED, null);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse &#123;</div><div class=\"line\">\t\t\t\tthrow new CancelTaskException();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfinally &#123;</div><div class=\"line\">\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\tLOG.info(&quot;Freeing task resources for &#123;&#125; (&#123;&#125;).&quot;, taskNameWithSubtask, executionId);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// clear the reference to the invokable. this helps guard against holding references</div><div class=\"line\">\t\t\t\t// to the invokable and its structures in cases where this Task object is still referenced</div><div class=\"line\">\t\t\t\tthis.invokable = null;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// stop the async dispatcher.</div><div class=\"line\">\t\t\t\t// copy dispatcher reference to stack, against concurrent release</div><div class=\"line\">\t\t\t\tExecutorService dispatcher = this.asyncCallDispatcher;</div><div class=\"line\">\t\t\t\tif (dispatcher != null &amp;&amp; !dispatcher.isShutdown()) &#123;</div><div class=\"line\">\t\t\t\t\tdispatcher.shutdownNow();</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// free the network resources</div><div class=\"line\">\t\t\t\tnetwork.unregisterTask(this);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// free memory resources</div><div class=\"line\">\t\t\t\tif (invokable != null) &#123;</div><div class=\"line\">\t\t\t\t\tmemoryManager.releaseAll(invokable);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// remove all of the tasks library resources</div><div class=\"line\">\t\t\t\tlibraryCache.unregisterTask(jobId, executionId);</div><div class=\"line\">\t\t\t\tfileCache.releaseJob(jobId, executionId);</div><div class=\"line\">\t\t\t\tblobService.getPermanentBlobService().releaseJob(jobId);</div><div class=\"line\"></div><div class=\"line\">\t\t\t\t// close and de-activate safety net for task thread</div><div class=\"line\">\t\t\t\tLOG.info(&quot;Ensuring all FileSystem streams are closed for task &#123;&#125;&quot;, this);</div><div class=\"line\">\t\t\t\tFileSystemSafetyNet.closeSafetyNetAndGuardedResourcesForThread();</div><div class=\"line\"></div><div class=\"line\">\t\t\t\tnotifyFinalState();</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>加载jar, 配置文件。</li>\n<li>确认invoke函数, invoke函数在JobVertex产生的时候构建的, 比如在StreamingJobGraphGenerator.createJobVertex()中, 而这个invoke最初是在产生StreamNode时候赋值的, 比如在StreamingJobGraphGenerator.transform-&gt;transformOneInputTransform-&gt;StreamGraph.addOperator:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public &lt;IN, OUT&gt; void addOperator(</div><div class=\"line\">\t\t\tInteger vertexID,</div><div class=\"line\">\t\t\tString slotSharingGroup,</div><div class=\"line\">\t\t\t@Nullable String coLocationGroup,</div><div class=\"line\">\t\t\tStreamOperator&lt;OUT&gt; operatorObject,</div><div class=\"line\">\t\t\tTypeInformation&lt;IN&gt; inTypeInfo,</div><div class=\"line\">\t\t\tTypeInformation&lt;OUT&gt; outTypeInfo,</div><div class=\"line\">\t\t\tString operatorName) &#123;</div><div class=\"line\"></div><div class=\"line\">\t\tif (operatorObject instanceof StoppableStreamSource) &#123;</div><div class=\"line\">\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, StoppableSourceStreamTask.class, operatorObject, operatorName);</div><div class=\"line\">\t\t&#125; else if (operatorObject instanceof StreamSource) &#123;</div><div class=\"line\">\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, SourceStreamTask.class, operatorObject, operatorName);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\taddNode(vertexID, slotSharingGroup, coLocationGroup, OneInputStreamTask.class, operatorObject, operatorName);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t......</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以看到, invoke可以为SourceStreamTask.class或者 OneInputStreamTask.class。 我们以最常见的OneInputStreamTask.class继续讲解。invokable.invoke()最终将跑到OneInputStreamTask.run里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void run() throws Exception &#123;</div><div class=\"line\">\t// cache processor reference on the stack, to make the code more JIT friendly</div><div class=\"line\">\tfinal StreamInputProcessor&lt;IN&gt; inputProcessor = this.inputProcessor;</div><div class=\"line\"></div><div class=\"line\">\twhile (running &amp;&amp; inputProcessor.processInput()) &#123;</div><div class=\"line\">\t\t// all the work happens in the &quot;processInput&quot; method</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, 每条数据就循环处理一次, 我们看下每条数据是如何处理的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public boolean processInput() throws Exception &#123;</div><div class=\"line\">\tif (isFinished) &#123;</div><div class=\"line\">\t\treturn false;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tif (numRecordsIn == null) &#123;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tnumRecordsIn = ((OperatorMetricGroup) streamOperator.getMetricGroup()).getIOMetricGroup().getNumRecordsInCounter();</div><div class=\"line\">\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\tLOG.warn(&quot;An exception occurred during the metrics setup.&quot;, e);</div><div class=\"line\">\t\t\tnumRecordsIn = new SimpleCounter();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">      //这个while是用来处理单个元素的（不要想当然以为是循环处理元素的）</div><div class=\"line\">\twhile (true) &#123;            //2.会利用这个反序列化器得到下一个数据记录，并进行解析（是用户数据还是watermark等等），然后进行对应的操作</div><div class=\"line\">\t\tif (currentRecordDeserializer != null) &#123;</div><div class=\"line\">\t\t\tDeserializationResult result = currentRecordDeserializer.getNextRecord(deserializationDelegate); //得到下一条数据</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (result.isBufferConsumed()) &#123;</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer.getCurrentBuffer().recycleBuffer();</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer = null;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t\tif (result.isFullRecord()) &#123;</div><div class=\"line\">\t\t\t\tStreamElement recordOrMark = deserializationDelegate.getInstance();</div><div class=\"line\">\t\t\t\t//如果元素是watermark，就准备更新当前channel的watermark值（并不是简单赋值，因为有乱序存在）</div><div class=\"line\">\t\t\t\tif (recordOrMark.isWatermark()) &#123;</div><div class=\"line\">\t\t\t\t\t// handle watermark</div><div class=\"line\">\t\t\t\t\tstatusWatermarkValve.inputWatermark(recordOrMark.asWatermark(), currentChannel);</div><div class=\"line\">\t\t\t\t\tcontinue;</div><div class=\"line\">\t\t\t\t//如果元素是status，就进行相应处理。可以看作是一个flag，标志着当前stream接下来即将没有元素输入（idle），或者当前即将由空闲状态转为有元素状态（active）。同时，StreamStatus还对如何处理watermark有影响。通过发送status，上游的operator可以很方便的通知下游当前的数据流的状态。</div><div class=\"line\">\t\t\t\t&#125; else if (recordOrMark.isStreamStatus()) &#123;</div><div class=\"line\">\t\t\t\t\t// handle stream status</div><div class=\"line\">\t\t\t\t\tstatusWatermarkValve.inputStreamStatus(recordOrMark.asStreamStatus(), currentChannel);</div><div class=\"line\">\t\t\t\t\tcontinue;</div><div class=\"line\">\t\t\t\t//LatencyMarker是用来衡量代码执行时间的。在Source处创建，携带创建时的时间戳，流到Sink时就可以知道经过了多长时间</div><div class=\"line\">\t\t\t\t&#125; else if (recordOrMark.isLatencyMarker()) &#123;</div><div class=\"line\">\t\t\t\t\t// handle latency marker</div><div class=\"line\">\t\t\t\t\tsynchronized (lock) &#123;</div><div class=\"line\">\t\t\t\t\t\tstreamOperator.processLatencyMarker(recordOrMark.asLatencyMarker());</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\tcontinue;</div><div class=\"line\">\t\t\t\t//这里就是真正的，用户的代码即将被执行的地方。</div><div class=\"line\">\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\t// now we can do the actual processing</div><div class=\"line\">\t\t\t\t\tStreamRecord&lt;IN&gt; record = recordOrMark.asRecord();</div><div class=\"line\">\t\t\t\t\tsynchronized (lock) &#123;</div><div class=\"line\">\t\t\t\t\t\tnumRecordsIn.inc();</div><div class=\"line\">\t\t\t\t\t\tstreamOperator.setKeyContextElement1(record);</div><div class=\"line\">\t\t\t\t\t\t// 每个算子开始真正处理数据</div><div class=\"line\">\t\t\t\t\t\tstreamOperator.processElement(record);</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\treturn true;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">           //1.程序首先获取下一个buffer，这一段代码是服务于flink的FaultTorrent机制的，后面我会讲到，这里只需理解到它会尝试获取buffer，然后赋值给当前的反序列化器</div><div class=\"line\">\t\tfinal BufferOrEvent bufferOrEvent = barrierHandler.getNextNonBlocked();</div><div class=\"line\">\t\tif (bufferOrEvent != null) &#123;</div><div class=\"line\">\t\t\tif (bufferOrEvent.isBuffer()) &#123;</div><div class=\"line\">\t\t\t\tcurrentChannel = bufferOrEvent.getChannelIndex();</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer = recordDeserializers[currentChannel];</div><div class=\"line\">\t\t\t\tcurrentRecordDeserializer.setNextBuffer(bufferOrEvent.getBuffer());</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\telse &#123;</div><div class=\"line\">\t\t\t\t// Event received</div><div class=\"line\">\t\t\t\tfinal AbstractEvent event = bufferOrEvent.getEvent();</div><div class=\"line\">\t\t\t\tif (event.getClass() != EndOfPartitionEvent.class) &#123;</div><div class=\"line\">\t\t\t\t\tthrow new IOException(&quot;Unexpected event: &quot; + event);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse &#123;</div><div class=\"line\">\t\t\tisFinished = true;</div><div class=\"line\">\t\t\tif (!barrierHandler.isEmpty()) &#123;</div><div class=\"line\">\t\t\t\tthrow new IllegalStateException(&quot;Trailing data in checkpoint barrier handler.&quot;);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\treturn false;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每条数据都是通过streamOperator.processElement(record)来完成处理的, 以map算子为例, streamOperator为StreamMap:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> @Internal</div><div class=\"line\">public class StreamMap&lt;IN, OUT&gt;</div><div class=\"line\">\t\textends AbstractUdfStreamOperator&lt;OUT, MapFunction&lt;IN, OUT&gt;&gt;</div><div class=\"line\">\t\timplements OneInputStreamOperator&lt;IN, OUT&gt; &#123;</div><div class=\"line\">\tprivate static final long serialVersionUID = 1L;</div><div class=\"line\">\tpublic StreamMap(MapFunction&lt;IN, OUT&gt; mapper) &#123;</div><div class=\"line\">\t\tsuper(mapper);</div><div class=\"line\">\t\tchainingStrategy = ChainingStrategy.ALWAYS;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t@Override</div><div class=\"line\">\tpublic void processElement(StreamRecord&lt;IN&gt; element) throws Exception &#123;</div><div class=\"line\">\t\toutput.collect(element.replace(userFunction.map(element.getValue())));</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p> 可以看到, 我们只用负责定义map就可以了。</p>\n"},{"title":"JAVA JNI实现hello world","date":"2017-06-15T10:15:08.000Z","toc":true,"_content":"jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。\n# 使用\n```\npublic class Native1{\n    public native void  sayHello();\n\n    public static void main(String[] args) {\n        System.loadLibrary(\"hellworld\");\n        new Native1().sayHello();\n    }\n}\n```\n我们定义了sayHello函数为native属性的。这里System.loadLibrary(\"hellworld\")必不可少, 否则会报如下异常\n```\nException in thread \"main\" java.lang.UnsatisfiedLinkError: Native1.sayHello()V\n        at Native1.sayHello(Native Method)\n        at Native1.main(Native1.java:6)\n```\n之后再讲解这行代码, 主要步骤如下:\n1. 首先执行javac Native1.java, 这样获得了Native1.class文件\n2. 执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下\n```\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class Native1 */\n\n#ifndef _Included_Native1\n#define _Included_Native1\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     Native1\n * Method:    sayHello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_Native1_sayHello\n  (JNIEnv *, jobject);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\njava的native方法转变为c++函数的规则如下：Java_{package_and_classname}_{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：\n++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数\n++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass\n我们需要在myNative.c(.cpp文件也是支持的, 此文件名称不需要与java类名一致, 只需要动态链接库名与调用的库名有对应关系即可)里面实现Java_Native_sayHello函数:\n```\n#include \"/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h\"\n#include <stdio.h>\nJNIEXPORT void JNICALL Java_Native1_sayHello(JNIEnv *env, jobject thisObj)\n{\n    printf(\"Hello，JNI\");\n}\n```\n头文件指明了Native1.h。这里主要定义了Java_Native1_sayHello函数。\n3. 生成动态链接库libhelloworld.jnilib\n`gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib`\n这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(\"hellworld\"); 系统才能正常识别。\n4. 执行java -Djava.library.path=$path{libhelloworld.jnilib} Native1, 获得如下结果(这里需要声明动态文件库位置)。\n```\nHello，JNI%\n```\n\n# 参考\nhttps://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\nhttps://blog.csdn.net/createchance/article/details/53783490\nhttps://blog.csdn.net/abc5382334/article/details/18052757","source":"_posts/JAVA-JNI实现hello-world.md","raw":"---\ntitle: JAVA JNI实现hello world\ndate: 2017-06-15 18:15:08\ntags:\ntoc: true\n---\njvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。\n# 使用\n```\npublic class Native1{\n    public native void  sayHello();\n\n    public static void main(String[] args) {\n        System.loadLibrary(\"hellworld\");\n        new Native1().sayHello();\n    }\n}\n```\n我们定义了sayHello函数为native属性的。这里System.loadLibrary(\"hellworld\")必不可少, 否则会报如下异常\n```\nException in thread \"main\" java.lang.UnsatisfiedLinkError: Native1.sayHello()V\n        at Native1.sayHello(Native Method)\n        at Native1.main(Native1.java:6)\n```\n之后再讲解这行代码, 主要步骤如下:\n1. 首先执行javac Native1.java, 这样获得了Native1.class文件\n2. 执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下\n```\n/* DO NOT EDIT THIS FILE - it is machine generated */\n#include <jni.h>\n/* Header for class Native1 */\n\n#ifndef _Included_Native1\n#define _Included_Native1\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n/*\n * Class:     Native1\n * Method:    sayHello\n * Signature: ()V\n */\nJNIEXPORT void JNICALL Java_Native1_sayHello\n  (JNIEnv *, jobject);\n#ifdef __cplusplus\n}\n#endif\n#endif\n```\njava的native方法转变为c++函数的规则如下：Java_{package_and_classname}_{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：\n++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数\n++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass\n我们需要在myNative.c(.cpp文件也是支持的, 此文件名称不需要与java类名一致, 只需要动态链接库名与调用的库名有对应关系即可)里面实现Java_Native_sayHello函数:\n```\n#include \"/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h\"\n#include <stdio.h>\nJNIEXPORT void JNICALL Java_Native1_sayHello(JNIEnv *env, jobject thisObj)\n{\n    printf(\"Hello，JNI\");\n}\n```\n头文件指明了Native1.h。这里主要定义了Java_Native1_sayHello函数。\n3. 生成动态链接库libhelloworld.jnilib\n`gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib`\n这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(\"hellworld\"); 系统才能正常识别。\n4. 执行java -Djava.library.path=$path{libhelloworld.jnilib} Native1, 获得如下结果(这里需要声明动态文件库位置)。\n```\nHello，JNI%\n```\n\n# 参考\nhttps://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\nhttps://blog.csdn.net/createchance/article/details/53783490\nhttps://blog.csdn.net/abc5382334/article/details/18052757","slug":"JAVA-JNI实现hello-world","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w7000dphu5lumrhit1","content":"<p>jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Native1&#123;</div><div class=\"line\">    public native void  sayHello();</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        System.loadLibrary(&quot;hellworld&quot;);</div><div class=\"line\">        new Native1().sayHello();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们定义了sayHello函数为native属性的。这里System.loadLibrary(“hellworld”)必不可少, 否则会报如下异常<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: Native1.sayHello()V</div><div class=\"line\">        at Native1.sayHello(Native Method)</div><div class=\"line\">        at Native1.main(Native1.java:6)</div></pre></td></tr></table></figure></p>\n<p>之后再讲解这行代码, 主要步骤如下:</p>\n<ol>\n<li>首先执行javac Native1.java, 这样获得了Native1.class文件</li>\n<li>执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* DO NOT EDIT THIS FILE - it is machine generated */</div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">/* Header for class Native1 */</div><div class=\"line\"></div><div class=\"line\">#ifndef _Included_Native1</div><div class=\"line\">#define _Included_Native1</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">extern &quot;C&quot; &#123;</div><div class=\"line\">#endif</div><div class=\"line\">/*</div><div class=\"line\"> * Class:     Native1</div><div class=\"line\"> * Method:    sayHello</div><div class=\"line\"> * Signature: ()V</div><div class=\"line\"> */</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native1_sayHello</div><div class=\"line\">  (JNIEnv *, jobject);</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">&#125;</div><div class=\"line\">#endif</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>java的native方法转变为c++函数的规则如下：Java_{package_and<em>classname}</em>{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：<br>++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数<br>++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass<br>我们需要在myNative.c(.cpp文件也是支持的, 此文件名称不需要与java类名一致, 只需要动态链接库名与调用的库名有对应关系即可)里面实现Java_Native_sayHello函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h&quot;</div><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native1_sayHello(JNIEnv *env, jobject thisObj)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Hello，JNI&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>头文件指明了Native1.h。这里主要定义了Java_Native1_sayHello函数。</p>\n<ol>\n<li>生成动态链接库libhelloworld.jnilib<br><code>gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib</code><br>这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(“hellworld”); 系统才能正常识别。</li>\n<li>执行java -Djava.library.path=$path{libhelloworld.jnilib} Native1, 获得如下结果(这里需要声明动态文件库位置)。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello，JNI%</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\" target=\"_blank\" rel=\"external\">https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp</a><br><a href=\"https://blog.csdn.net/createchance/article/details/53783490\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/createchance/article/details/53783490</a><br><a href=\"https://blog.csdn.net/abc5382334/article/details/18052757\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/abc5382334/article/details/18052757</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Native1&#123;</div><div class=\"line\">    public native void  sayHello();</div><div class=\"line\"></div><div class=\"line\">    public static void main(String[] args) &#123;</div><div class=\"line\">        System.loadLibrary(&quot;hellworld&quot;);</div><div class=\"line\">        new Native1().sayHello();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们定义了sayHello函数为native属性的。这里System.loadLibrary(“hellworld”)必不可少, 否则会报如下异常<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Exception in thread &quot;main&quot; java.lang.UnsatisfiedLinkError: Native1.sayHello()V</div><div class=\"line\">        at Native1.sayHello(Native Method)</div><div class=\"line\">        at Native1.main(Native1.java:6)</div></pre></td></tr></table></figure></p>\n<p>之后再讲解这行代码, 主要步骤如下:</p>\n<ol>\n<li>首先执行javac Native1.java, 这样获得了Native1.class文件</li>\n<li>执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/* DO NOT EDIT THIS FILE - it is machine generated */</div><div class=\"line\">#include &lt;jni.h&gt;</div><div class=\"line\">/* Header for class Native1 */</div><div class=\"line\"></div><div class=\"line\">#ifndef _Included_Native1</div><div class=\"line\">#define _Included_Native1</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">extern &quot;C&quot; &#123;</div><div class=\"line\">#endif</div><div class=\"line\">/*</div><div class=\"line\"> * Class:     Native1</div><div class=\"line\"> * Method:    sayHello</div><div class=\"line\"> * Signature: ()V</div><div class=\"line\"> */</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native1_sayHello</div><div class=\"line\">  (JNIEnv *, jobject);</div><div class=\"line\">#ifdef __cplusplus</div><div class=\"line\">&#125;</div><div class=\"line\">#endif</div><div class=\"line\">#endif</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>java的native方法转变为c++函数的规则如下：Java_{package_and<em>classname}</em>{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：<br>++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数<br>++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass<br>我们需要在myNative.c(.cpp文件也是支持的, 此文件名称不需要与java类名一致, 只需要动态链接库名与调用的库名有对应关系即可)里面实现Java_Native_sayHello函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">#include &quot;/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h&quot;</div><div class=\"line\">#include &lt;stdio.h&gt;</div><div class=\"line\">JNIEXPORT void JNICALL Java_Native1_sayHello(JNIEnv *env, jobject thisObj)</div><div class=\"line\">&#123;</div><div class=\"line\">    printf(&quot;Hello，JNI&quot;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>头文件指明了Native1.h。这里主要定义了Java_Native1_sayHello函数。</p>\n<ol>\n<li>生成动态链接库libhelloworld.jnilib<br><code>gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib</code><br>这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary(“hellworld”); 系统才能正常识别。</li>\n<li>执行java -Djava.library.path=$path{libhelloworld.jnilib} Native1, 获得如下结果(这里需要声明动态文件库位置)。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Hello，JNI%</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp\" target=\"_blank\" rel=\"external\">https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp</a><br><a href=\"https://blog.csdn.net/createchance/article/details/53783490\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/createchance/article/details/53783490</a><br><a href=\"https://blog.csdn.net/abc5382334/article/details/18052757\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/abc5382334/article/details/18052757</a></p>\n"},{"title":"Java 线程知识小结(-)","date":"2016-10-27T06:18:30.000Z","toc":true,"_content":"# wait/notify/notifyAll:\nwait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:\n```\npublic static Object lock = new Object();\n\npublic void run(){//线程A\n        try {\n            synchronized (lock) {\n                lock.wait(); //进入睡眠进行等待\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\npublic void run(){//线程B\n        try {\n            synchronized (lock) {\n                lock.notify(); //唤醒A线程\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\n```\n线程执行状态如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/wait_notify.png\" height=\"300\" width=\"800\"/>\n需要注意一下几点:\n+ wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;\n+ 线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是`线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中`, 线程A的状态由wait变化为blocked\n+ 线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。\n+ 若线程A与B之间调用顺序不能反了, 若B先执行的话, 那么A将永远不能被唤醒。与LockSupport(park/unpark)相比很大的区别\nnotify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。\n\n# Join\njoin函数的作用是等别的线程退出后再继续执行, 基本使用如下:\n```\n        Thread thread = new Thread(new a2());\n        thread.start();\n        thread.join();\n```\n当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:\n```\n     public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (millis == 0) {//没有设置超时时间\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {//超时等待的话\n            while (isAlive()) { //循环检查\n                long delay = millis - now;\n                if (delay <= 0) { //超时时间到了之后退出\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。","source":"_posts/Java线程知识小结.md","raw":"---\ntitle: Java 线程知识小结(-)\ndate: 2016-10-27 14:18:30\ntags:\ntoc: true\n---\n# wait/notify/notifyAll:\nwait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:\n```\npublic static Object lock = new Object();\n\npublic void run(){//线程A\n        try {\n            synchronized (lock) {\n                lock.wait(); //进入睡眠进行等待\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\npublic void run(){//线程B\n        try {\n            synchronized (lock) {\n                lock.notify(); //唤醒A线程\n                ...\n            }\n\n        } catch (Exception e) {\n            ...\n        }\n}\n\n```\n线程执行状态如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/wait_notify.png\" height=\"300\" width=\"800\"/>\n需要注意一下几点:\n+ wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;\n+ 线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是`线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中`, 线程A的状态由wait变化为blocked\n+ 线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。\n+ 若线程A与B之间调用顺序不能反了, 若B先执行的话, 那么A将永远不能被唤醒。与LockSupport(park/unpark)相比很大的区别\nnotify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。\n\n# Join\njoin函数的作用是等别的线程退出后再继续执行, 基本使用如下:\n```\n        Thread thread = new Thread(new a2());\n        thread.start();\n        thread.join();\n```\n当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:\n```\n     public final synchronized void join(long millis) throws InterruptedException {\n        long base = System.currentTimeMillis();\n        long now = 0;\n        if (millis < 0) {\n            throw new IllegalArgumentException(\"timeout value is negative\");\n        }\n\n        if (millis == 0) {//没有设置超时时间\n            while (isAlive()) {\n                wait(0);\n            }\n        } else {//超时等待的话\n            while (isAlive()) { //循环检查\n                long delay = millis - now;\n                if (delay <= 0) { //超时时间到了之后退出\n                    break;\n                }\n                wait(delay);\n                now = System.currentTimeMillis() - base;\n            }\n        }\n    }\n```\n实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。","slug":"Java线程知识小结","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w8000ephu5v8j11v6x","content":"<h1 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait/notify/notifyAll:\"></a>wait/notify/notifyAll:</h1><p>wait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Object lock = new Object();</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程A</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.wait(); //进入睡眠进行等待</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程B</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.notify(); //唤醒A线程</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>线程执行状态如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/wait_notify.png\" height=\"300\" width=\"800\"><br>需要注意一下几点:</p>\n<ul>\n<li>wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;</li>\n<li>线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是<code>线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中</code>, 线程A的状态由wait变化为blocked</li>\n<li>线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。</li>\n<li>若线程A与B之间调用顺序不能反了, 若B先执行的话, 那么A将永远不能被唤醒。与LockSupport(park/unpark)相比很大的区别<br>notify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。</li>\n</ul>\n<h1 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h1><p>join函数的作用是等别的线程退出后再继续执行, 基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread thread = new Thread(new a2());</div><div class=\"line\">thread.start();</div><div class=\"line\">thread.join();</div></pre></td></tr></table></figure></p>\n<p>当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final synchronized void join(long millis) throws InterruptedException &#123;</div><div class=\"line\">    long base = System.currentTimeMillis();</div><div class=\"line\">    long now = 0;</div><div class=\"line\">    if (millis &lt; 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (millis == 0) &#123;//没有设置超时时间</div><div class=\"line\">        while (isAlive()) &#123;</div><div class=\"line\">            wait(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;//超时等待的话</div><div class=\"line\">        while (isAlive()) &#123; //循环检查</div><div class=\"line\">            long delay = millis - now;</div><div class=\"line\">            if (delay &lt;= 0) &#123; //超时时间到了之后退出</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            wait(delay);</div><div class=\"line\">            now = System.currentTimeMillis() - base;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"wait-notify-notifyAll\"><a href=\"#wait-notify-notifyAll\" class=\"headerlink\" title=\"wait/notify/notifyAll:\"></a>wait/notify/notifyAll:</h1><p>wait/notify用于线程通信的等待/通知模型, 这两个函数被定义在java.lang.Object类中, 被声明为final函数, 不可复写。使用时, 线程A调用object.wait(), 释放cpu进入等待; 线程B调用object.notify()来唤醒A线程。以下是基本的用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static Object lock = new Object();</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程A</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.wait(); //进入睡眠进行等待</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public void run()&#123;//线程B</div><div class=\"line\">        try &#123;</div><div class=\"line\">            synchronized (lock) &#123;</div><div class=\"line\">                lock.notify(); //唤醒A线程</div><div class=\"line\">                ...</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            ...</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>线程执行状态如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/wait_notify.png\" height=\"300\" width=\"800\"><br>需要注意一下几点:</p>\n<ul>\n<li>wait/notify两个操作都必须要和synchronized(lock)配合使用, 这里可以这么理解: 每个object都拥有一个WatiQueue等待队列, 存放着调用lock.lock()被阻塞的线程, 每次向这个等待队列添加或者删除线程时, 为了保证对该队列操作的互斥性, 使用synchronized来达到目的;</li>\n<li>线程B调用lock.notify()后, 线程A并不能立刻从lock.wait()中醒来, 此时只是<code>线程B把线程A从lock对象的WatiQueue中移动到了SynchrozizedQueue中</code>, 线程A的状态由wait变化为blocked</li>\n<li>线程B完全执行完 synchronized(lock){}块后, 线程A才能继续执行。也就是说A从wait()返回的前提是获取到了锁。</li>\n<li>若线程A与B之间调用顺序不能反了, 若B先执行的话, 那么A将永远不能被唤醒。与LockSupport(park/unpark)相比很大的区别<br>notify的作用只是唤醒一个object.wait()状态的线程, 唤醒哪个线程, 与线程优先级等有关 notifyAll的作用是唤醒全部object.wait()的线程。</li>\n</ul>\n<h1 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h1><p>join函数的作用是等别的线程退出后再继续执行, 基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Thread thread = new Thread(new a2());</div><div class=\"line\">thread.start();</div><div class=\"line\">thread.join();</div></pre></td></tr></table></figure></p>\n<p>当前线程调用thread.join()之后, 便会等待thread执行完再继续执行, join函数代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final synchronized void join(long millis) throws InterruptedException &#123;</div><div class=\"line\">    long base = System.currentTimeMillis();</div><div class=\"line\">    long now = 0;</div><div class=\"line\">    if (millis &lt; 0) &#123;</div><div class=\"line\">        throw new IllegalArgumentException(&quot;timeout value is negative&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (millis == 0) &#123;//没有设置超时时间</div><div class=\"line\">        while (isAlive()) &#123;</div><div class=\"line\">            wait(0);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;//超时等待的话</div><div class=\"line\">        while (isAlive()) &#123; //循环检查</div><div class=\"line\">            long delay = millis - now;</div><div class=\"line\">            if (delay &lt;= 0) &#123; //超时时间到了之后退出</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            wait(delay);</div><div class=\"line\">            now = System.currentTimeMillis() - base;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际底层依靠的是wait(delay)函数 + 循环来达到等待的效果, 当wait等待时, cpu释放了资源, 则join()等待过程也是释放了cpu。</p>\n"},{"title":"Flink原理-JobManager端的SubTask申请slot及部署","date":"2019-03-12T12:04:11.000Z","toc":true,"_content":"本文将从ExecutionGraph开始向后讲起, ExecutionGraph定义了Job的并发逻辑结构, 作为任务执行的以后一层逻辑结构, 也是最核心数据结构。为了让大家有全局的了解, 先盗一张广为引用的Graph转换图:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_Graph.png\" height=\"900\" width=\"800\"/>\n具体来说, 本文讲述在JobManager端subTask申请slot以及部署到TaskManager上的过程。\n# Task分配slot及部署\n代码将从ExecutionGraph.scheduleExecutionGraph()开始讲解, 进入:\n```\n\tpublic void scheduleForExecution() throws JobException {\n\t\tfinal long currentGlobalModVersion = globalModVersion;\n\t\tif (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {\n\t\t\tfinal CompletableFuture<Void> newSchedulingFuture;\n\t\t\tswitch (scheduleMode) {\n\t\t\t\tcase LAZY_FROM_SOURCES:\n\t\t\t\t\tnewSchedulingFuture = scheduleLazy(slotProvider);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EAGER:\n\t\t\t\t\tnewSchedulingFuture = scheduleEager(slotProvider, allocationTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JobException(\"Schedule mode is invalid.\");\n\t\t\t}\n\t\t}\n\t\t...\n\t}\n```\n其中, scheduleMode分EAGER和LAZY_FROM_SOURCES, EAGER表示立刻去调度部署所有的Task。实际scheduleMode是从JobGraph.getScheduleMode()取值的, 为eager。\n我们再进入scheduleEager看是如何调度task的。\n```\n    private CompletableFuture<Void> scheduleEager(SlotProvider slotProvider, final Time timeout) {\n\t    ......\n\t\t //都是每个JobGraph\n\t\tfor (ExecutionJobVertex ejv : getVerticesTopologically()) {\n\t\t\t// these calls are not blocking, they only return futures\n\t\t\tCollection<CompletableFuture<Execution>> allocationFutures = ejv.allocateResourcesForAll(\n\t\t\t\tslotProvider, // SlotPool$ProviderAndOwner\n\t\t\t\tqueued,\n\t\t\t\tLocationPreferenceConstraint.ALL,\n\t\t\t\tallPreviousAllocationIds,\n\t\t\t\ttimeout);\n\t\t\tallAllocationFutures.addAll(allocationFutures);\n\t\t}\n\t\t//只有当所有Execution都分配到了槽位才继续进行部署\n\t\tfinal ConjunctFuture<Collection<Execution>> allAllocationsFuture = FutureUtils.combineAll(allAllocationFutures);\n\t\tfinal CompletableFuture<Void> currentSchedulingFuture = allAllocationsFuture\n\t\t\t.thenAccept(\n\t\t\t\t(Collection<Execution> executionsToDeploy) -> {\n\t\t\t\t\tfor (Execution execution : executionsToDeploy) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t   // 最后挨个调用execution.deploy()进行部署子task，部署的模式是发送命令到\n\t\t\t\t\t\t   execution.deploy();\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t   ......\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t......\n\t\treturn currentSchedulingFuture;\n\t}`\n```\nscheduleEager主要做了两件事:\n+ 通过allocateResourcesForAll确定每个subTask将要部署的slot。若没有合适的TaskManager, 那么通过yarn去申请TaskManager。\n+ 当所有的subTask都确定好部署TaskManager的slot后, 通过execution.deploy()将subTask部署上去。\n接下来, 将分别围绕这两件事讲解。\n## 确定subTask分配的slot\n通过getVerticesTopologically()获取所有的ExecutionJobVertex, 然后依次轮询给每个ExecutionJobVertex都分配一个slot, 其中轮询的ExecutionJobVertex是有先后顺序的, 从source开始分配slot, 直到sink。后面可以看到, 上游分配到哪个tm上, 会影响下游的slot分配。 我们进入allocateResourcesForAll看下是如何给一个ExecutionJobVertex所有的subTask分配slot的。\n```\n    public Collection<CompletableFuture<Execution>> allocateResourcesForAll(\n\t\t\tSlotProvider resourceProvider, // SlotPool$ProviderAndOwner\n\t\t\tboolean queued,  //true\n\t\t\tLocationPreferenceConstraint locationPreferenceConstraint, //ALL\n\t\t\t@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,\n\t\t\tTime allocationTimeout) {\n\t\tfinal ExecutionVertex[] vertices = this.taskVertices;\n\t\tfinal CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length];\n\t\tfor (int i = 0; i < vertices.length; i++) {\n\t\t\tfinal Execution exec = vertices[i].getCurrentExecutionAttempt();\n\t\t\tfinal CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(\n\t\t\t\tresourceProvider,\n\t\t\t\tqueued,\n\t\t\t\tlocationPreferenceConstraint,\n\t\t\t\tallPreviousExecutionGraphAllocationIds,\n\t\t\t\tallocationTimeout);\n\t\t\tslots[i] = allocationFuture;\n\t\t}\n\t\treturn Arrays.asList(slots);\n\t}\n```\n每一个ExecutionJobVertex都对应着一批ExecutionVertex(也就是subTask), 可以看到, 这里轮询每个ExecutionVertex进行申请一个slot。\n```\n    public CompletableFuture<Execution> allocateAndAssignSlotForExecution(\n\t\t\tSlotProvider slotProvider, //SlotPool$ProviderAndOwner\n\t\t\tboolean queued,\n\t\t\tLocationPreferenceConstraint locationPreferenceConstraint,  //ALL\n\t\t\t@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,\n\t\t\tTime allocationTimeout) throws IllegalExecutionStateException {\n\t\tfinal SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();\n\t\tif (transitionState(CREATED, SCHEDULED)) {\n\t\t    // 默认情况下, 所有的subTask的共享组均为default\n\t\t\tfinal SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null;\n\t\t\t/** 获取subTask即将分配的\"偏好位置集合\"，也就是分配时，优先考虑分配在这些节点上，一般是input节点所在节点 */\n\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint);\n\t\t    //上游子task地方全部确定了，才能继续确定下游子task位置\n\t\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n\t\t\tfinal CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture\n\t\t\t\t.thenCompose(\n\t\t\t\t\t(Collection<TaskManagerLocation> preferredLocations) ->\n\t\t\t\t\t\tslotProvider.allocateSlot(//SlotPool$ProviderAndOwner\n\t\t\t\t\t\t\tslotRequestId,\n\t\t\t\t\t\t\ttoSchedule,\n\t\t\t\t\t\t\tqueued,\n\t\t\t\t\t\t\tnew SlotProfile(\n\t\t\t\t\t\t\t\tResourceProfile.UNKNOWN,\n\t\t\t\t\t\t\t\tpreferredLocations,\n\t\t\t\t\t\t\t\tpreviousAllocationIDs,\n\t\t\t\t\t\t\t\tallPreviousExecutionGraphAllocationIds),\n\t\t\t\t\t\t\tallocationTimeout));\n\t\t\treturn logicalSlotFuture.thenApply(\n\t\t\t\t(LogicalSlot logicalSlot) -> {\n\t\t\t\t    //\n\t\t\t\t\tif (tryAssignResource(logicalSlot)) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t}\n```\n该函数主要做了两件事情:\n+ 在calculatePreferredLocations中确定从该subTask对应ExecutionJobVertex的所有上游中找到最合适的上游\"偏向位置集合\"。\n+ 通过SlotPool$ProviderAndOwner.allocateSlot继续确定从\"偏向位置集合\"找到一个共享slot。\n我们知道, 多个subTask允许共享slot, 细节后面会详细描述。 那么当前subTask与哪些已经分配的subTask共享slot呢? 下游subTask与哪个上游subTask共享slot呢?\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate.png\" height=\"300\" width=\"350\"/>\n\nflink会根据subTask上游slot的分配来确定当前slot的分配:\n```\npublic Collection<CompletableFuture<TaskManagerLocation>> getPreferredLocationsBasedOnInputs() {\n\t\t// 如果没有输入，则返回空集合，否则，基于上游分布确定偏好位置\n\t\tif (inputEdges == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\telse {\n\t\t\tSet<CompletableFuture<TaskManagerLocation>> locations = new HashSet<>(getTotalNumberOfParallelSubtasks());\n\t\t\tSet<CompletableFuture<TaskManagerLocation>> inputLocations = new HashSet<>(getTotalNumberOfParallelSubtasks());\n\t\t\t// go over all inputs\n\t\t\tfor (int i = 0; i < inputEdges.length; i++) {\n\t\t\t\tinputLocations.clear();\n\t\t\t\tExecutionEdge[] sources = inputEdges[i];\n\t\t\t\tif (sources != null) {\n\t\t\t\t\tfor (int k = 0; k < sources.length; k++) {\n\t\t\t\t\t\t// 获取当前source源所属的taskManager位置\n\t\t\t\t\t\tCompletableFuture<TaskManagerLocation> locationFuture = sources[k].getSource().getProducer().getCurrentTaskManagerLocationFuture();\n\t\t\t\t\t\t// add input location\n\t\t\t\t\t\tinputLocations.add(locationFuture);\n\t\t\t\t\t\t// inputs which have too many distinct sources are not considered\n\t\t\t\t\t\t// 如果某个输入源有太多的节点分布，则不考虑这个输入源的节点位置了\n\t\t\t\t\t\tif (inputLocations.size() > MAX_DISTINCT_LOCATIONS_TO_CONSIDER) {\n\t\t\t\t\t\t\tinputLocations.clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}// 保留具有最少分布位置的输入的位置\n\t\t\t\t// keep the locations of the input with the least preferred locations\n\t\t\t\tif (locations.isEmpty() || // nothing assigned yet  第一个source\n\t\t\t\t        // 找到上游节点所处tm最少的的那个上游\n\t\t\t\t\t\t(!inputLocations.isEmpty() && inputLocations.size() < locations.size())) {\n\t\t\t\t\tlocations.clear();\n\t\t\t\t\tlocations.addAll(inputLocations);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn locations.isEmpty() ? Collections.emptyList() : locations;\n\t\t}\n\t}\n```\n处理过程如下:\n+ 若该ExecutionVertex没有上游(例如source), 那么返回为空, 没有\"偏好位置集合\", 之后将申请新的slot。\n+ 若当前ExecutionVertex有属于不同JobVertex多个ExecutionJobVertex的上游, 那么当前sub分配到哪些共享slot的可选路径只能是: 属于同一个JobVertex的上游节点个数最少。上图的话, 就会选择source2的所有subTask作为\"偏好位置集合\"。我们接下来看第二步, 最终会进入到allocateSharedSlot决定subTask分配到哪些\"偏好位置集合\"里slot上。\n```\nprivate CompletableFuture<LogicalSlot> allocateSharedSlot(\n\t\tSlotRequestId slotRequestId,\n\t\tScheduledUnit task,\n\t\tSlotProfile slotProfile,\n\t\tboolean allowQueuedScheduling,\n\t\tTime allocationTimeout) {\n\t\t// allocate slot with slot sharing\n\t\tfinal SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(\n\t\t\t //默认都是一个, default对应的那个\n\t\t\ttask.getSlotSharingGroupId(),\n\t\t\tid -> new SlotSharingManager(\n\t\t\t\tid,\n\t\t\t\tthis,\n\t\t\t\tproviderAndOwner));\n\t\tfinal SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;\n\t\ttry {\n\t\t\tif (task.getCoLocationConstraint() != null) {\n\t\t\t\tmultiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(\n\t\t\t\t\ttask.getCoLocationConstraint(),\n\t\t\t\t\tmultiTaskSlotManager,\n\t\t\t\t\tslotProfile,\n\t\t\t\t\tallowQueuedScheduling,\n\t\t\t\t\tallocationTimeout);\n\t\t\t} else {\n\t\t\t     // 跑到这里\n\t\t\t\tmultiTaskSlotLocality = allocateMultiTaskSlot(\n\t\t\t\t\ttask.getJobVertexId(),\n\t\t\t\t\tmultiTaskSlotManager,\n\t\t\t\t\tslotProfile,\n\t\t\t\t\tallowQueuedScheduling,\n\t\t\t\t\tallocationTimeout);\n\t\t\t}\n\t\t}\n\t\tfinal SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(\n\t\t\tslotRequestId,\n\t\t\ttask.getJobVertexId(),\n\t\t\tmultiTaskSlotLocality.getLocality());\n\t\treturn leaf.getLogicalSlotFuture();\n\t}\n```\n该函数主要做了两件事:\n1. 通过allocateMultiTaskSlot产生MultiTaskSlotLocality, 里面包含从\"偏向位置集合\"中选取的部署当前subTask共享的slot。\n2. 产生SingleTaskSlot, 当前SingleTaskSlot作为MultiTaskSlot的一个子叶子节点。\n再继续跟进代码前, 我们需要了解两个变量resolvedRootSlots、unresolvedRootSlots。共享slot都会从这两个变量中获取, 这两个变量为共享组所拥有, 默认共享组为default。\nunresolvedRootSlots: 当当前subTask正在确认部署到那个slot中时, 会将该slot保存在unresolvedRootSlots; 当确定好部署到哪个slot时, 会将该信息从unresolvedRootSlots中移除, 并放入resolvedRootSlots中  当我们查找是否有可利用的slot时, 会从这些变量中查找。\n我们再进入正题, 看allocateMultiTaskSlot看是如何给subTask分配slot的:\n```\n\tprivate SlotSharingManager.MultiTaskSlotLocality allocateMultiTaskSlot(\n\t\t\t//groupId指的同一个JobVertex的id\n\t\t\tAbstractID groupId,\n\t\t\tSlotSharingManager slotSharingManager,\n\t\t\tSlotProfile slotProfile,\n\t\t\tboolean allowQueuedScheduling,\n\t\t\tTime allocationTimeout) throws NoResourceAvailableException {\n\t\t//过滤\"偏好位置集合\"的位置中不属于相同groupId的位置, 这里主要是为了避免同一个ExecutionJobVertex中不同的SubTask分配到同一个slot中。\n\t\t// check first whether we have a resolved root slot which we can use\n\t\tSlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = slotSharingManager.getResolvedRootSlot(\n\t\t\tgroupId,\n\t\t\t//  LocationPreferenceSchedulingStrategy\n\t\t\tschedulingStrategy,\n\t\t\tslotProfile);\n\t    //从\"偏好位置集合\"中到合适的slot后, 就直接返回了。\n\t\tif (multiTaskSlotLocality != null && multiTaskSlotLocality.getLocality() == Locality.LOCAL) {\n\t\t\treturn multiTaskSlotLocality;\n\t\t}\n\t\t......\n\t\tif (allowQueuedScheduling) {\n\t\t\t//在unresolvedRootSlots中查找不属于同一个JobVertex的slot\n\t\t\tSlotSharingManager.MultiTaskSlot multiTaskSlotFuture = slotSharingManager.getUnresolvedRootSlot(groupId);  // 为null\n\t\t\tif (multiTaskSlotFuture == null) {\n\t\t\t\t//没有找到合适的可利用的的slot, 那么将去向ResurceNameger申请新的TaskManger, 这是最后一步\n\t\t\t\tfinal CompletableFuture<AllocatedSlot> futureSlot = requestNewAllocatedSlot(\n\t\t\t\t\tallocatedSlotRequestId,\n\t\t\t\t\tslotProfile.getResourceProfile(),\n\t\t\t\t\tallocationTimeout); //300s\n\t\t\t\t//将新产生的futureSlot, 放入resolvedRootSlots中, 这样之后申请slot时, 该slot可以被共享。\n\t\t\t\tmultiTaskSlotFuture = slotSharingManager.createRootSlot(\n\t\t\t\t\tmultiTaskSlotRequestId,\n\t\t\t\t\tfutureSlot,\n\t\t\t\t\tallocatedSlotRequestId);\n\t\t\t\tfutureSlot.whenComplete(\n\t\t\t\t\t(AllocatedSlot allocatedSlot, Throwable throwable) -> {\n\t\t\t\t\t\tfinal SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId);\n\t\t\t\t\t\tif (taskSlot != null) {\n\t\t\t\t\t\t\t// still valid\n\t\t\t\t\t\t\tif (!(taskSlot instanceof SlotSharingManager.MultiTaskSlot) || throwable != null) {\n\t\t\t\t\t\t\t\ttaskSlot.release(throwable);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) {\n\t\t\t\t\t\t\t\t\ttaskSlot.release(new FlinkException(\"Could not assign payload to allocated slot \" +\n\t\t\t\t\t\t\t\t\t\tallocatedSlot.getAllocationId() + '.'));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t\treturn SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlotFuture, Locality.UNKNOWN);\n\t\t}\n\t}\n```\n该函数主要逻辑如下:\n+ 从resolvedRootSlots、unresolvedRootSlots中查找是否有可共享的slot。\n+ 若没有, 向ResourceManager申请TaskManager以获取slot。\n+ 将申请的slot信息也存放入unresolvedRootSlots中, 等成功申请后再存放入resolvedRootSlots。\n我们再接着看是如何向ResourceManager申请TaskManager的。\n```\n\tprivate CompletableFuture<AllocatedSlot> requestNewAllocatedSlot(\n\t\t\tSlotRequestId slotRequestId,\n\t\t\tResourceProfile resourceProfile,\n\t\t\tTime allocationTimeout) {\n\t\tfinal PendingRequest pendingRequest = new PendingRequest(\n\t\t\tslotRequestId,\n\t\t\tresourceProfile);\n\t\t// register request timeout\n\t\tFutureUtils  //30s超时\n\t\t\t.orTimeout(pendingRequest.getAllocatedSlotFuture(), allocationTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)\n\t\t\t.whenCompleteAsync(  //当结束完成时需要做的事情\n\t\t\t\t(AllocatedSlot ignored, Throwable throwable) -> {\n\t\t\t\t\tif (throwable instanceof TimeoutException) {\n\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetMainThreadExecutor());\n\t\tif (resourceManagerGateway == null) {  // 为null\n\t\t\tstashRequestWaitingForResourceManager(pendingRequest);  // 会跑到这里\n\t\t} else {\n\t\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);\n\t\t}\n\t\treturn pendingRequest.getAllocatedSlotFuture();\n\t}\n```\n可以看到:\n+ 首先查看resourceManagerGateway是否连接上, 若没有连接上, 将请求暂时缓存起来, 待连接上之后再申请。\n+ 若已经初始化之后, 会去向ResourceManager申请TaskManager。\n### 缓存申请Slot的请求\n大致思路是先缓存申请slot的请求, 直到flink ResourceManager注册完成后, 再去申请, 我们看下整体细节。首先去查看哪里开始对resourceManagerGateway进行初始化的。 首先回到最开始准备执行ExecutionGraph的时候:\n```\n     private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception {\n\t\t //这里会开始尝试连接rm， 会去和resourceManager建立联系\n\t\tstartJobMasterServices();\n\t\tresetAndScheduleExecutionGraph();\n     }\n     private void startJobMasterServices() throws Exception {\n\t\tslotPool.start(getFencingToken(), getAddress());\n\t\t// 这里比较重要，会进去启动申请tm的请求\n\t\treconnectToResourceManager(new FlinkException(\"Starting JobMaster component.\"));\n\t\t// StandaloneLeaderRetrievalService\n\t\tresourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());\n\t}\n```\n在reconnectToResourceManager中, 会去尝试初始化, 调用connectToResourceManager:\n```\nprivate void connectToResourceManager() {\n\t\tresourceManagerConnection = new ResourceManagerConnection( //很重要\n\t\t\tlog,\n\t\t\tjobGraph.getJobID(),\n\t\t\tresourceId,\n\t\t\tgetAddress(),\n\t\t\tgetFencingToken(),\n\t\t\tresourceManagerAddress.getAddress(),\n\t\t\tresourceManagerAddress.getResourceManagerId(),\n\t\t\tscheduledExecutorService);\n\t\tresourceManagerConnection.start();  //从这里进去，获取注册ResourceManger\n\t}\n```\n在ResourceManagerConnection中定义了onRegistrationSuccess, 会去调用establishResourceManagerConnection()函数, 我们进入resourceManagerConnection.start()看下如何建立注册的。\n```\n    public void start() {\n        // ResourceManagerConnection\n        final RetryingRegistration<F, G, S> newRegistrationn = createNewRegistration();\n\t\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {\n\t\t    //会从这里进去，很重要，比如注册ResourceManager\n\t\t\tnewRegistration.startRegistration();\n\t\t}\n\t}\n```\n在createNewRegistration中, 新建注册:\n```\n\tprivate RetryingRegistration<F, G, S> createNewRegistration() {\n\t\tRetryingRegistration<F, G, S> newRegistration = checkNotNull(generateRegistration());  //跑进去\n\t\tCompletableFuture<Tuple2<G, S>> future = newRegistration.getFuture();\n\t\tfuture.whenCompleteAsync(\n\t\t\t(Tuple2<G, S> result, Throwable failure) -> {\n\t\t\t\tif (failure != null) {\n\t\t\t\t......\n\t\t\t\t} else {\n\t\t\t\t\ttargetGateway = result.f0;\n\t\t\t\t\t//注意进来，进行pending task分配，调用ResourceManagerConnection.onRegistrationSuccess()\n\t\t\t\t\tonRegistrationSuccess(result.f1);\n\t\t\t\t}\n\t\t\t}, executor);\n\t\treturn newRegistration;\n\t}\n```\n当注册完成并且没有抛出异常时, 说明注册完成了, 则调用之前的ResourceManagerConnection.onRegistrationSuccess()进行连接, 最终会进去SlotPool.connectToResourceManager()\n```\npublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n\t\t// 开始申请之前被pending的请求\n\t\tfor (PendingRequest pendingRequest : waitingForResourceManager.values()) {\n\t\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);\n\t\t}\n\t\twaitingForResourceManager.clear();\n\t}\n```\n当完成flink ResourceManager注册、连接后, 我们会逐个申请之前被挂起的请求。然后开始走之后描述的正常申请slot流程。\n\n### 向ResourceManager申请slot\n从requestSlotFromResourceManager()中最终会进入registerSlotRequest\n```\n    public boolean registerSlotRequest(SlotRequest slotRequest) throws SlotManagerException {\n\t    PendingSlotRequest pendingSlotRequest = new PendingSlotRequest(slotRequest);\n\t\tpendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);\n\t\ttry {\n\t\t    internalRequestSlot(pendingSlotRequest);\n\t\t}\n\t\treturn true;\n    }\n    private void internalRequestSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException {\n\t\t//是否发现目前拥有的slot\n\t\tTaskManagerSlot taskManagerSlot = findMatchingSlot(pendingSlotRequest.getResourceProfile());\n\t\tif (taskManagerSlot != null) {\n\t\t\tallocateSlot(taskManagerSlot, pendingSlotRequest);\n\t\t} else {\n\t\t\tresourceActions.allocateResource(pendingSlotRequest.getResourceProfile()); //跑到这里\n\t\t}\n\t}\n```\ninternalRequestSlot做了如下逻辑:\n+ 通过findMatchingSlot检查是否有现成可用的slot, 其中freeSlots包含着availiable slot. 比如在每当有新的TaskManager向JobManager注册时, 就会调用SlotManager.registerSlotRequest(), 在freeSlots中注册该TM可用的slot。若有可用slot时候, 就会调用allocateSlot进行分配。\n+ 若没有可用空闲slot, 通过allocateResource申请TM, 最终会调用YarnResourceManager.requestYarnContainer进行申请。\n我们再分别以这两种情况继续介绍。\n#### JobManager端有某个TM注册的可用slot\n若JM端有某个TM注册的可用slot, 那么就会进入allocateSlot来将这个slot分配给这个SubTask:\n```\n\tprivate void allocateSlot(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest) {\n\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n\n\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n\t\tfinal AllocationID allocationId = pendingSlotRequest.getAllocationId();\n\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n\t\tfinal InstanceID instanceID = taskManagerSlot.getInstanceId();\n\n\t\ttaskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);\n\t\tpendingSlotRequest.setRequestFuture(completableFuture);\n\n\t\tTaskManagerRegistration taskManagerRegistration = taskManagerRegistrations.get(instanceID);\n        // 既然这个TM上报的slot, 那么这个TM一定已经有注册信息了\n\t\tif (taskManagerRegistration == null) {\n\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n\t\t\t\tinstanceID + '.');\n\t\t}\n\t\ttaskManagerRegistration.markUsed();\n\t\t去向TM通信, 告诉TM这个slot已经被请求了\n\t\t// RPC call to the task manager\n\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n\t\t\tslotId,\n\t\t\tpendingSlotRequest.getJobId(),\n\t\t\tallocationId,\n\t\t\tpendingSlotRequest.getTargetAddress(),\n\t\t\tresourceManagerId,\n\t\t\ttaskManagerRequestTimeout);\n\n\t\trequestFuture.whenComplete(\n\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n\t\t\t\tif (acknowledge != null) {\n\t\t\t\t\tcompletableFuture.complete(acknowledge);\n\t\t\t\t}\n\t\t\t});\n\n\t\tcompletableFuture.whenCompleteAsync(\n\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n\t\t\t\ttry {  //去更新本地slot状态, 从可用空闲slot中删掉\n\t\t\t\t\tif (acknowledge != null) {\n\t\t\t\t\t\tupdateSlot(slotId, allocationId, pendingSlotRequest.getJobId());\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.error(\"Error while completing the slot allocation.\", e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tmainThreadExecutor);\n\t}\n```\nJM请求某个slot逻辑也比较简单:\n1. JM直接告诉slot对应TM, 这个slot将被申请\n2. JM修改这个slot的状态, 并且从本地可用slot中删掉。然后等待subTask被部署到这个TM的slot上\n我们看下第一步JM是怎么告诉TM这个slot被申请的,  gateway.requestSlot直接通过RPC(通信逻辑<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">参考</a>)直接向TM的TaskExecutor.requestSlot去了, 我们看下TM是如何做处理的:\n```\n    /**\n\t * Add the given job to be monitored. This means that the service tries to detect leaders for\n\t * this job and then tries to establish a connection to it.\n\t */\n\tpublic CompletableFuture<Acknowledge> requestSlot(\n\t\tfinal SlotID slotId,\n\t\tfinal JobID jobId,\n\t\tfinal AllocationID allocationId,\n\t\tfinal String targetAddress,\n\t\tfinal ResourceManagerId resourceManagerId,\n\t\tfinal Time timeout) {\n\t\tlog.info(\"Receive slot request {} for job {} from resource manager with leader id {}.\",\n\t\t\tallocationId, jobId, resourceManagerId);\n\t\ttry {\n\t\t\tif (taskSlotTable.isSlotFree(slotId.getSlotNumber())) {\n\t\t\t\tif (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) {\n\t\t\t\t\tlog.info(\"Allocated slot for {}.\", allocationId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jobManagerTable.contains(jobId)) {\n\t\t\t\tofferSlotsToJobManager(jobId);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tjobLeaderService.addJob(jobId, targetAddress);  // 跑进去\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t}\n```\n主要逻辑如下:\n1. TM接收到JM的请求后, TM首先检查这个slot是否是空闲的, 若空闲的话, 就开始调用taskSlotTable.allocateSlot(), 将这个slot置为已分配。\n2. TM调用jobLeaderService.addJob将这个Job监控起来(每当有新的Job请求slot, 就会去检测job的leader, 并去和这个job leader建立链接),最终调用JobManagerLeaderListener.notifyLeaderAddress()->JobManagerRegisteredRpcConnection.start():\n```\n    public void start() {\n\t\tcheckState(!closed, \"The RPC connection is already closed\");\n\t\tcheckState(!isConnected() && pendingRegistration == null, \"The RPC connection is already started\");\n\t\tfinal RetryingRegistration<F, G, S> newRegistration = createNewRegistration();\n\t\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {\n\t\t\tnewRegistration.startRegistration();\n\t\t} else {\n\t\t\t// concurrent start operation\n\t\t\tnewRegistration.cancel();\n\t\t}\n\t}\n```\n这里是不是有点熟悉, 可以参考下<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">这里</a>, startRegistration主要是向JM发送申请成功通知, TM成功后回调JobManagerRegisteredRpcConnection.onRegistrationSuccess, 最终调用TaskExecutor.establishJobManagerConnection:\n```\n\tprivate void establishJobManagerConnection(JobID jobId, final JobMasterGateway jobMasterGateway, JMTMRegistrationSuccess registrationSuccess) {\n\t\tif (jobManagerTable.contains(jobId)) {\n\t\t\tJobManagerConnection oldJobManagerConnection = jobManagerTable.get(jobId);\n\n\t\t\tif (Objects.equals(oldJobManagerConnection.getJobMasterId(), jobMasterGateway.getFencingToken())) {\n\t\t\t\t// we already are connected to the given job manager\n\t\t\t\tlog.debug(\"Ignore JobManager gained leadership message for {} because we are already connected to it.\", jobMasterGateway.getFencingToken());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tResourceID jobManagerResourceID = registrationSuccess.getResourceID();\n\t\tJobManagerConnection newJobManagerConnection = associateWithJobManager(\n\t\t\t\tjobId,\n\t\t\t\tjobManagerResourceID,\n\t\t\t\tjobMasterGateway);\n\t\tjobManagerConnections.put(jobManagerResourceID, newJobManagerConnection);\n\t\tjobManagerTable.put(jobId, newJobManagerConnection);  // 设置的是每个Job在TM这里的注册\n\n\t\t// monitor the job manager as heartbeat target\n\t\tjobManagerHeartbeatManager.monitorTarget(jobManagerResourceID, new HeartbeatTarget<AccumulatorReport>() {\n\t\t\t@Override\n\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, AccumulatorReport payload) {\n\t\t\t\tjobMasterGateway.heartbeatFromTaskManager(resourceID, payload);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void requestHeartbeat(ResourceID resourceID, AccumulatorReport payload) {\n\t\t\t\t// request heartbeat will never be called on the task manager side\n\t\t\t}\n\t\t});\n\n\t\tofferSlotsToJobManager(jobId);\n\t}\n```\n主要做了如下事情:\n1. 检查这个job是否已经在TM端注册了, 若注册了, 那么就直接返回\n2. 否则建立job->JobManagerConnection, 将映射关系放入TaskExecutor的jobManagerTable中, 然后监控这个job master。\n3. 调用offerSlotsToJobManager, 告诉JM, 分配给Task这个slot。\n\n#### JobManager端没有TM注册的可用slot\n若没有可用slot的话, 那么就只能去申请TM, 申请的TM会上报可用slot, 然后再向这个TM申请部署SubTask, 此时就回到了有可用slot的情况了。我们看下是如何申请TM的。\n```\n    // //resource 是当前申请的container情况，比如<memory:6552, vCores:4>\n    private void requestYarnContainer(Resource resource, Priority priority) {\n        //获取当前实际正在申请的slot个数\n\t\tint pendingSlotRequests = getNumberPendingSlotRequests();\n\t\t// 通过当前正在申请的Contaainer个数*numberOfTaskSlots计算出预计当前正在申请的slot个数\n\t\tint pendingSlotAllocation = numPendingContainerRequests * numberOfTaskSlots;\n\t\t//若当前实际申请的slot个数 > 预计申请的slot个数, 那么需要去申请新的container, 来满足实际申请的slot个数\n\t\tif (pendingSlotRequests > pendingSlotAllocation) {\n\t\t    // 向yarn 发送申请container的请求。\n\t\t\tresourceManagerClient.addContainerRequest(new AMRMClient.ContainerRequest(resource, null, null, priority));\n\t\t\tresourceManagerClient.setHeartbeatInterval(FAST_YARN_HEARTBEAT_INTERVAL_MS);\n\t\t\t//正在申请的container统计自增\n\t\t\tnumPendingContainerRequests++;\n\t\t}\n\t}\n```\n### 申请container成功\n当向yarn成功申请到container之后, 会回调YarnResourceManager.onContainersAllocated通知jobManager。\n```\n\tpublic void onContainersAllocated(List<Container> containers) {\n\t\trunAsync(() -> {\n\t\t\tfor (Container container : containers) {\n\t\t\t\tif (numPendingContainerRequests > 0) {\n\t\t\t\t\tnumPendingContainerRequests--;\n\t\t\t\t\tfinal String containerIdStr = container.getId().toString();\n\t\t\t\t\tfinal ResourceID resourceId = new ResourceID(containerIdStr);\n\t\t\t\t\tworkerNodeMap.put(resourceId, new YarnWorkerNode(container));\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// 产生tm启动命令\n\t\t\t\t\t\tContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(\n\t\t\t\t\t\t\tcontainer.getResource(),\n\t\t\t\t\t\t\tcontainerIdStr,\n\t\t\t\t\t\t\tcontainer.getNodeId().getHost());\n                       // 启动TaskManager\n\t\t\t\t\t\tnodeManagerClient.startContainer(container, taskExecutorLaunchContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if we are waiting for no further containers, we can go to the\n\t\t\t// regular heartbeat interval\n\t\t\tif (numPendingContainerRequests <= 0) {\n\t\t\t\tresourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis);\n\t\t\t}\n\t\t});\n\t}\n```\n回调函数主要做了如下逻辑:\n1. 确定启动taskManager的命令。\n2. 通过yarn启动taskManager。\n我们来放一张整体JobManager端分配Slot的流程图:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate1.png\" height=\"300\" width=\"800\"/>\n\n## 部署subTask到对应的slot\n当确定好subTask部署到一个TaskManager的slot上之后, 在scheduleEager中就开始调用Execution.deploy()进行部署。\n```\npublic void deploy() throws JobException {\n\t\tfinal LogicalSlot slot  = assignedResource;  // SingleLogicalSlot\n\t\ttry {\n\t\t\tfinal TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(\n\t\t\t\tattemptId,\n\t\t\t\tslot, // SingleLogicalSlot\n\t\t\t\ttaskRestore,\n\t\t\t\tattemptNumber);\n\t\t\t// null taskRestore to let it be GC'ed\n\t\t\ttaskRestore = null;\n\t\t\tfinal TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();\n\t\t\tfinal CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout);\n\t\t}\n\t}\n    public CompletableFuture<Acknowledge> submitTask(TaskDeploymentDescriptor tdd, Time timeout) {\n        // 实际会去调用AkkaInvocationHandler，而去和tm通信，而不是跑到TaskExecutor.submitTask\n\t\treturn taskExecutorGateway.submitTask(tdd, jobMasterId, timeout);\n    }\n```\n可以看到:\n+ 首先生成TaskDeploymentDescriptor, 包含部署subTask的所有信息。\n+ 调用taskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask, JM接收RPC可参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/\">link原理-Akka通信原理</a> 。\nTaskManager端通过TaskExecutor.subTask()接受到JobManager发出的部署SubTask的申请, 这样就完成SubTask部署了。\n\n# SlotSharingGroup及共享slot\nFlink 允许相同SlotSharingGroup的subTask共享同一个slot, 好处主要有俩:\n+ A Flink cluster needs exactly as many task slots as the highest parallelism used in the job. No need to calculate how many tasks (with varying parallelism) a program contains in total.\n+ It is easier to get better resource utilization. Without slot sharing, the non-intensive source/map() subtasks would block as many resources as the resource intensive window subtasks. With slot sharing, increasing the base parallelism in our example from two to six yields full utilization of the slotted resources, while making sure that the heavy subtasks are fairly distributed among the TaskManagers.\n默认情况下, SubTask使用相同的slot共享组: Default, task共享slot过程可以参考:<a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html#task-slots-and-resources\">如何共享slot</a>\n这里将阐述SlotSharingGroup是如何生成并起作用的:\n在JobGraph产生的时候调用setSlotSharingAndCoLocation()函数:\n```\n\tprivate void setSlotSharingAndCoLocation() {\n\t\tfinal HashMap<String, SlotSharingGroup> slotSharingGroups = new HashMap<>();\n\t\tfor (Entry<Integer, JobVertex> entry : jobVertices.entrySet()) {\n\t\t\tfinal StreamNode node = streamGraph.getStreamNode(entry.getKey());\n\t\t\tfinal JobVertex vertex = entry.getValue();// slotSharingGroupKey为默认值default\n\t\t\tfinal String slotSharingGroupKey = node.getSlotSharingGroup();\n\t\t\tfinal SlotSharingGroup sharingGroup;\n\t\t\tif (slotSharingGroupKey != null) {\n\t\t\t    // 可以看到, 所有的task的group都为default, 都将放入到同一个SlotSharingGroup中\n\t\t\t\tsharingGroup = slotSharingGroups.computeIfAbsent(slotSharingGroupKey, (k) -> new SlotSharingGroup());\n\t\t\t\tvertex.setSlotSharingGroup(sharingGroup);\n\t\t\t} else {\n\t\t\t\tsharingGroup = null;\n\t\t\t}\n```\n这样, 所有的JobVertex都引用了同一个SlotSharingGroup。 而\n```\n    public void setSlotSharingGroup(SlotSharingGroup grp) {\n\t\tif (this.slotSharingGroup != null) {\n\t\t\tthis.slotSharingGroup.removeVertexFromGroup(id);\n\t\t}\n\t\tthis.slotSharingGroup = grp;\n\t\tif (grp != null) {\n\t\t\tgrp.addVertexToGroup(id);\n\t\t}\n\t}\n```\n每个共享组的id都是相同的。\n\n# MultiTaskSlot及SingleTaskSlot\nMultiTaskSlot及SingleTaskSlot都继承TaskSlot, 每当subTask申请到一个未被共享的slot时, 就会产生一个MultiTaskSlot, 它代表着一个TM上的slot, 管理着该slot被共享的情况。 实际分配给每个subTask时, 会单独产生一个SingleTaskSlot, 然后每次被MultiTaskSlot管理着。之后若共享slot时, 分配到的都是同一个MultiTaskSlot, 不同的是每次每次分配都产生新的SingleTaskSlot。\n\n# 参考文档\nhttps://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html\nhttps://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html\nhttp://wuchong.me/blog/2016/05/03/flink-internals-overview/\nhttp://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/","source":"_posts/Flink原理-slot分配.md","raw":"---\ntitle: Flink原理-JobManager端的SubTask申请slot及部署\ndate: 2019-03-12 20:04:11\ntags: Flink、Slot分配、SubTask申请slot, SubTask部署\ntoc: true\n---\n本文将从ExecutionGraph开始向后讲起, ExecutionGraph定义了Job的并发逻辑结构, 作为任务执行的以后一层逻辑结构, 也是最核心数据结构。为了让大家有全局的了解, 先盗一张广为引用的Graph转换图:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_Graph.png\" height=\"900\" width=\"800\"/>\n具体来说, 本文讲述在JobManager端subTask申请slot以及部署到TaskManager上的过程。\n# Task分配slot及部署\n代码将从ExecutionGraph.scheduleExecutionGraph()开始讲解, 进入:\n```\n\tpublic void scheduleForExecution() throws JobException {\n\t\tfinal long currentGlobalModVersion = globalModVersion;\n\t\tif (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) {\n\t\t\tfinal CompletableFuture<Void> newSchedulingFuture;\n\t\t\tswitch (scheduleMode) {\n\t\t\t\tcase LAZY_FROM_SOURCES:\n\t\t\t\t\tnewSchedulingFuture = scheduleLazy(slotProvider);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EAGER:\n\t\t\t\t\tnewSchedulingFuture = scheduleEager(slotProvider, allocationTimeout);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new JobException(\"Schedule mode is invalid.\");\n\t\t\t}\n\t\t}\n\t\t...\n\t}\n```\n其中, scheduleMode分EAGER和LAZY_FROM_SOURCES, EAGER表示立刻去调度部署所有的Task。实际scheduleMode是从JobGraph.getScheduleMode()取值的, 为eager。\n我们再进入scheduleEager看是如何调度task的。\n```\n    private CompletableFuture<Void> scheduleEager(SlotProvider slotProvider, final Time timeout) {\n\t    ......\n\t\t //都是每个JobGraph\n\t\tfor (ExecutionJobVertex ejv : getVerticesTopologically()) {\n\t\t\t// these calls are not blocking, they only return futures\n\t\t\tCollection<CompletableFuture<Execution>> allocationFutures = ejv.allocateResourcesForAll(\n\t\t\t\tslotProvider, // SlotPool$ProviderAndOwner\n\t\t\t\tqueued,\n\t\t\t\tLocationPreferenceConstraint.ALL,\n\t\t\t\tallPreviousAllocationIds,\n\t\t\t\ttimeout);\n\t\t\tallAllocationFutures.addAll(allocationFutures);\n\t\t}\n\t\t//只有当所有Execution都分配到了槽位才继续进行部署\n\t\tfinal ConjunctFuture<Collection<Execution>> allAllocationsFuture = FutureUtils.combineAll(allAllocationFutures);\n\t\tfinal CompletableFuture<Void> currentSchedulingFuture = allAllocationsFuture\n\t\t\t.thenAccept(\n\t\t\t\t(Collection<Execution> executionsToDeploy) -> {\n\t\t\t\t\tfor (Execution execution : executionsToDeploy) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t   // 最后挨个调用execution.deploy()进行部署子task，部署的模式是发送命令到\n\t\t\t\t\t\t   execution.deploy();\n\t\t\t\t\t\t} catch (Throwable t) {\n\t\t\t\t\t\t   ......\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t......\n\t\treturn currentSchedulingFuture;\n\t}`\n```\nscheduleEager主要做了两件事:\n+ 通过allocateResourcesForAll确定每个subTask将要部署的slot。若没有合适的TaskManager, 那么通过yarn去申请TaskManager。\n+ 当所有的subTask都确定好部署TaskManager的slot后, 通过execution.deploy()将subTask部署上去。\n接下来, 将分别围绕这两件事讲解。\n## 确定subTask分配的slot\n通过getVerticesTopologically()获取所有的ExecutionJobVertex, 然后依次轮询给每个ExecutionJobVertex都分配一个slot, 其中轮询的ExecutionJobVertex是有先后顺序的, 从source开始分配slot, 直到sink。后面可以看到, 上游分配到哪个tm上, 会影响下游的slot分配。 我们进入allocateResourcesForAll看下是如何给一个ExecutionJobVertex所有的subTask分配slot的。\n```\n    public Collection<CompletableFuture<Execution>> allocateResourcesForAll(\n\t\t\tSlotProvider resourceProvider, // SlotPool$ProviderAndOwner\n\t\t\tboolean queued,  //true\n\t\t\tLocationPreferenceConstraint locationPreferenceConstraint, //ALL\n\t\t\t@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,\n\t\t\tTime allocationTimeout) {\n\t\tfinal ExecutionVertex[] vertices = this.taskVertices;\n\t\tfinal CompletableFuture<Execution>[] slots = new CompletableFuture[vertices.length];\n\t\tfor (int i = 0; i < vertices.length; i++) {\n\t\t\tfinal Execution exec = vertices[i].getCurrentExecutionAttempt();\n\t\t\tfinal CompletableFuture<Execution> allocationFuture = exec.allocateAndAssignSlotForExecution(\n\t\t\t\tresourceProvider,\n\t\t\t\tqueued,\n\t\t\t\tlocationPreferenceConstraint,\n\t\t\t\tallPreviousExecutionGraphAllocationIds,\n\t\t\t\tallocationTimeout);\n\t\t\tslots[i] = allocationFuture;\n\t\t}\n\t\treturn Arrays.asList(slots);\n\t}\n```\n每一个ExecutionJobVertex都对应着一批ExecutionVertex(也就是subTask), 可以看到, 这里轮询每个ExecutionVertex进行申请一个slot。\n```\n    public CompletableFuture<Execution> allocateAndAssignSlotForExecution(\n\t\t\tSlotProvider slotProvider, //SlotPool$ProviderAndOwner\n\t\t\tboolean queued,\n\t\t\tLocationPreferenceConstraint locationPreferenceConstraint,  //ALL\n\t\t\t@Nonnull Set<AllocationID> allPreviousExecutionGraphAllocationIds,\n\t\t\tTime allocationTimeout) throws IllegalExecutionStateException {\n\t\tfinal SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();\n\t\tif (transitionState(CREATED, SCHEDULED)) {\n\t\t    // 默认情况下, 所有的subTask的共享组均为default\n\t\t\tfinal SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null;\n\t\t\t/** 获取subTask即将分配的\"偏好位置集合\"，也就是分配时，优先考虑分配在这些节点上，一般是input节点所在节点 */\n\t\t\tfinal CompletableFuture<Collection<TaskManagerLocation>> preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint);\n\t\t    //上游子task地方全部确定了，才能继续确定下游子task位置\n\t\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();\n\t\t\tfinal CompletableFuture<LogicalSlot> logicalSlotFuture = preferredLocationsFuture\n\t\t\t\t.thenCompose(\n\t\t\t\t\t(Collection<TaskManagerLocation> preferredLocations) ->\n\t\t\t\t\t\tslotProvider.allocateSlot(//SlotPool$ProviderAndOwner\n\t\t\t\t\t\t\tslotRequestId,\n\t\t\t\t\t\t\ttoSchedule,\n\t\t\t\t\t\t\tqueued,\n\t\t\t\t\t\t\tnew SlotProfile(\n\t\t\t\t\t\t\t\tResourceProfile.UNKNOWN,\n\t\t\t\t\t\t\t\tpreferredLocations,\n\t\t\t\t\t\t\t\tpreviousAllocationIDs,\n\t\t\t\t\t\t\t\tallPreviousExecutionGraphAllocationIds),\n\t\t\t\t\t\t\tallocationTimeout));\n\t\t\treturn logicalSlotFuture.thenApply(\n\t\t\t\t(LogicalSlot logicalSlot) -> {\n\t\t\t\t    //\n\t\t\t\t\tif (tryAssignResource(logicalSlot)) {\n\t\t\t\t\t\treturn this;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t}\n\t}\n```\n该函数主要做了两件事情:\n+ 在calculatePreferredLocations中确定从该subTask对应ExecutionJobVertex的所有上游中找到最合适的上游\"偏向位置集合\"。\n+ 通过SlotPool$ProviderAndOwner.allocateSlot继续确定从\"偏向位置集合\"找到一个共享slot。\n我们知道, 多个subTask允许共享slot, 细节后面会详细描述。 那么当前subTask与哪些已经分配的subTask共享slot呢? 下游subTask与哪个上游subTask共享slot呢?\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate.png\" height=\"300\" width=\"350\"/>\n\nflink会根据subTask上游slot的分配来确定当前slot的分配:\n```\npublic Collection<CompletableFuture<TaskManagerLocation>> getPreferredLocationsBasedOnInputs() {\n\t\t// 如果没有输入，则返回空集合，否则，基于上游分布确定偏好位置\n\t\tif (inputEdges == null) {\n\t\t\treturn Collections.emptySet();\n\t\t}\n\t\telse {\n\t\t\tSet<CompletableFuture<TaskManagerLocation>> locations = new HashSet<>(getTotalNumberOfParallelSubtasks());\n\t\t\tSet<CompletableFuture<TaskManagerLocation>> inputLocations = new HashSet<>(getTotalNumberOfParallelSubtasks());\n\t\t\t// go over all inputs\n\t\t\tfor (int i = 0; i < inputEdges.length; i++) {\n\t\t\t\tinputLocations.clear();\n\t\t\t\tExecutionEdge[] sources = inputEdges[i];\n\t\t\t\tif (sources != null) {\n\t\t\t\t\tfor (int k = 0; k < sources.length; k++) {\n\t\t\t\t\t\t// 获取当前source源所属的taskManager位置\n\t\t\t\t\t\tCompletableFuture<TaskManagerLocation> locationFuture = sources[k].getSource().getProducer().getCurrentTaskManagerLocationFuture();\n\t\t\t\t\t\t// add input location\n\t\t\t\t\t\tinputLocations.add(locationFuture);\n\t\t\t\t\t\t// inputs which have too many distinct sources are not considered\n\t\t\t\t\t\t// 如果某个输入源有太多的节点分布，则不考虑这个输入源的节点位置了\n\t\t\t\t\t\tif (inputLocations.size() > MAX_DISTINCT_LOCATIONS_TO_CONSIDER) {\n\t\t\t\t\t\t\tinputLocations.clear();\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}// 保留具有最少分布位置的输入的位置\n\t\t\t\t// keep the locations of the input with the least preferred locations\n\t\t\t\tif (locations.isEmpty() || // nothing assigned yet  第一个source\n\t\t\t\t        // 找到上游节点所处tm最少的的那个上游\n\t\t\t\t\t\t(!inputLocations.isEmpty() && inputLocations.size() < locations.size())) {\n\t\t\t\t\tlocations.clear();\n\t\t\t\t\tlocations.addAll(inputLocations);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn locations.isEmpty() ? Collections.emptyList() : locations;\n\t\t}\n\t}\n```\n处理过程如下:\n+ 若该ExecutionVertex没有上游(例如source), 那么返回为空, 没有\"偏好位置集合\", 之后将申请新的slot。\n+ 若当前ExecutionVertex有属于不同JobVertex多个ExecutionJobVertex的上游, 那么当前sub分配到哪些共享slot的可选路径只能是: 属于同一个JobVertex的上游节点个数最少。上图的话, 就会选择source2的所有subTask作为\"偏好位置集合\"。我们接下来看第二步, 最终会进入到allocateSharedSlot决定subTask分配到哪些\"偏好位置集合\"里slot上。\n```\nprivate CompletableFuture<LogicalSlot> allocateSharedSlot(\n\t\tSlotRequestId slotRequestId,\n\t\tScheduledUnit task,\n\t\tSlotProfile slotProfile,\n\t\tboolean allowQueuedScheduling,\n\t\tTime allocationTimeout) {\n\t\t// allocate slot with slot sharing\n\t\tfinal SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(\n\t\t\t //默认都是一个, default对应的那个\n\t\t\ttask.getSlotSharingGroupId(),\n\t\t\tid -> new SlotSharingManager(\n\t\t\t\tid,\n\t\t\t\tthis,\n\t\t\t\tproviderAndOwner));\n\t\tfinal SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;\n\t\ttry {\n\t\t\tif (task.getCoLocationConstraint() != null) {\n\t\t\t\tmultiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(\n\t\t\t\t\ttask.getCoLocationConstraint(),\n\t\t\t\t\tmultiTaskSlotManager,\n\t\t\t\t\tslotProfile,\n\t\t\t\t\tallowQueuedScheduling,\n\t\t\t\t\tallocationTimeout);\n\t\t\t} else {\n\t\t\t     // 跑到这里\n\t\t\t\tmultiTaskSlotLocality = allocateMultiTaskSlot(\n\t\t\t\t\ttask.getJobVertexId(),\n\t\t\t\t\tmultiTaskSlotManager,\n\t\t\t\t\tslotProfile,\n\t\t\t\t\tallowQueuedScheduling,\n\t\t\t\t\tallocationTimeout);\n\t\t\t}\n\t\t}\n\t\tfinal SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(\n\t\t\tslotRequestId,\n\t\t\ttask.getJobVertexId(),\n\t\t\tmultiTaskSlotLocality.getLocality());\n\t\treturn leaf.getLogicalSlotFuture();\n\t}\n```\n该函数主要做了两件事:\n1. 通过allocateMultiTaskSlot产生MultiTaskSlotLocality, 里面包含从\"偏向位置集合\"中选取的部署当前subTask共享的slot。\n2. 产生SingleTaskSlot, 当前SingleTaskSlot作为MultiTaskSlot的一个子叶子节点。\n再继续跟进代码前, 我们需要了解两个变量resolvedRootSlots、unresolvedRootSlots。共享slot都会从这两个变量中获取, 这两个变量为共享组所拥有, 默认共享组为default。\nunresolvedRootSlots: 当当前subTask正在确认部署到那个slot中时, 会将该slot保存在unresolvedRootSlots; 当确定好部署到哪个slot时, 会将该信息从unresolvedRootSlots中移除, 并放入resolvedRootSlots中  当我们查找是否有可利用的slot时, 会从这些变量中查找。\n我们再进入正题, 看allocateMultiTaskSlot看是如何给subTask分配slot的:\n```\n\tprivate SlotSharingManager.MultiTaskSlotLocality allocateMultiTaskSlot(\n\t\t\t//groupId指的同一个JobVertex的id\n\t\t\tAbstractID groupId,\n\t\t\tSlotSharingManager slotSharingManager,\n\t\t\tSlotProfile slotProfile,\n\t\t\tboolean allowQueuedScheduling,\n\t\t\tTime allocationTimeout) throws NoResourceAvailableException {\n\t\t//过滤\"偏好位置集合\"的位置中不属于相同groupId的位置, 这里主要是为了避免同一个ExecutionJobVertex中不同的SubTask分配到同一个slot中。\n\t\t// check first whether we have a resolved root slot which we can use\n\t\tSlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = slotSharingManager.getResolvedRootSlot(\n\t\t\tgroupId,\n\t\t\t//  LocationPreferenceSchedulingStrategy\n\t\t\tschedulingStrategy,\n\t\t\tslotProfile);\n\t    //从\"偏好位置集合\"中到合适的slot后, 就直接返回了。\n\t\tif (multiTaskSlotLocality != null && multiTaskSlotLocality.getLocality() == Locality.LOCAL) {\n\t\t\treturn multiTaskSlotLocality;\n\t\t}\n\t\t......\n\t\tif (allowQueuedScheduling) {\n\t\t\t//在unresolvedRootSlots中查找不属于同一个JobVertex的slot\n\t\t\tSlotSharingManager.MultiTaskSlot multiTaskSlotFuture = slotSharingManager.getUnresolvedRootSlot(groupId);  // 为null\n\t\t\tif (multiTaskSlotFuture == null) {\n\t\t\t\t//没有找到合适的可利用的的slot, 那么将去向ResurceNameger申请新的TaskManger, 这是最后一步\n\t\t\t\tfinal CompletableFuture<AllocatedSlot> futureSlot = requestNewAllocatedSlot(\n\t\t\t\t\tallocatedSlotRequestId,\n\t\t\t\t\tslotProfile.getResourceProfile(),\n\t\t\t\t\tallocationTimeout); //300s\n\t\t\t\t//将新产生的futureSlot, 放入resolvedRootSlots中, 这样之后申请slot时, 该slot可以被共享。\n\t\t\t\tmultiTaskSlotFuture = slotSharingManager.createRootSlot(\n\t\t\t\t\tmultiTaskSlotRequestId,\n\t\t\t\t\tfutureSlot,\n\t\t\t\t\tallocatedSlotRequestId);\n\t\t\t\tfutureSlot.whenComplete(\n\t\t\t\t\t(AllocatedSlot allocatedSlot, Throwable throwable) -> {\n\t\t\t\t\t\tfinal SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId);\n\t\t\t\t\t\tif (taskSlot != null) {\n\t\t\t\t\t\t\t// still valid\n\t\t\t\t\t\t\tif (!(taskSlot instanceof SlotSharingManager.MultiTaskSlot) || throwable != null) {\n\t\t\t\t\t\t\t\ttaskSlot.release(throwable);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) {\n\t\t\t\t\t\t\t\t\ttaskSlot.release(new FlinkException(\"Could not assign payload to allocated slot \" +\n\t\t\t\t\t\t\t\t\t\tallocatedSlot.getAllocationId() + '.'));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t}\n\t\t\treturn SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlotFuture, Locality.UNKNOWN);\n\t\t}\n\t}\n```\n该函数主要逻辑如下:\n+ 从resolvedRootSlots、unresolvedRootSlots中查找是否有可共享的slot。\n+ 若没有, 向ResourceManager申请TaskManager以获取slot。\n+ 将申请的slot信息也存放入unresolvedRootSlots中, 等成功申请后再存放入resolvedRootSlots。\n我们再接着看是如何向ResourceManager申请TaskManager的。\n```\n\tprivate CompletableFuture<AllocatedSlot> requestNewAllocatedSlot(\n\t\t\tSlotRequestId slotRequestId,\n\t\t\tResourceProfile resourceProfile,\n\t\t\tTime allocationTimeout) {\n\t\tfinal PendingRequest pendingRequest = new PendingRequest(\n\t\t\tslotRequestId,\n\t\t\tresourceProfile);\n\t\t// register request timeout\n\t\tFutureUtils  //30s超时\n\t\t\t.orTimeout(pendingRequest.getAllocatedSlotFuture(), allocationTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)\n\t\t\t.whenCompleteAsync(  //当结束完成时需要做的事情\n\t\t\t\t(AllocatedSlot ignored, Throwable throwable) -> {\n\t\t\t\t\tif (throwable instanceof TimeoutException) {\n\t\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tgetMainThreadExecutor());\n\t\tif (resourceManagerGateway == null) {  // 为null\n\t\t\tstashRequestWaitingForResourceManager(pendingRequest);  // 会跑到这里\n\t\t} else {\n\t\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);\n\t\t}\n\t\treturn pendingRequest.getAllocatedSlotFuture();\n\t}\n```\n可以看到:\n+ 首先查看resourceManagerGateway是否连接上, 若没有连接上, 将请求暂时缓存起来, 待连接上之后再申请。\n+ 若已经初始化之后, 会去向ResourceManager申请TaskManager。\n### 缓存申请Slot的请求\n大致思路是先缓存申请slot的请求, 直到flink ResourceManager注册完成后, 再去申请, 我们看下整体细节。首先去查看哪里开始对resourceManagerGateway进行初始化的。 首先回到最开始准备执行ExecutionGraph的时候:\n```\n     private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception {\n\t\t //这里会开始尝试连接rm， 会去和resourceManager建立联系\n\t\tstartJobMasterServices();\n\t\tresetAndScheduleExecutionGraph();\n     }\n     private void startJobMasterServices() throws Exception {\n\t\tslotPool.start(getFencingToken(), getAddress());\n\t\t// 这里比较重要，会进去启动申请tm的请求\n\t\treconnectToResourceManager(new FlinkException(\"Starting JobMaster component.\"));\n\t\t// StandaloneLeaderRetrievalService\n\t\tresourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());\n\t}\n```\n在reconnectToResourceManager中, 会去尝试初始化, 调用connectToResourceManager:\n```\nprivate void connectToResourceManager() {\n\t\tresourceManagerConnection = new ResourceManagerConnection( //很重要\n\t\t\tlog,\n\t\t\tjobGraph.getJobID(),\n\t\t\tresourceId,\n\t\t\tgetAddress(),\n\t\t\tgetFencingToken(),\n\t\t\tresourceManagerAddress.getAddress(),\n\t\t\tresourceManagerAddress.getResourceManagerId(),\n\t\t\tscheduledExecutorService);\n\t\tresourceManagerConnection.start();  //从这里进去，获取注册ResourceManger\n\t}\n```\n在ResourceManagerConnection中定义了onRegistrationSuccess, 会去调用establishResourceManagerConnection()函数, 我们进入resourceManagerConnection.start()看下如何建立注册的。\n```\n    public void start() {\n        // ResourceManagerConnection\n        final RetryingRegistration<F, G, S> newRegistrationn = createNewRegistration();\n\t\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {\n\t\t    //会从这里进去，很重要，比如注册ResourceManager\n\t\t\tnewRegistration.startRegistration();\n\t\t}\n\t}\n```\n在createNewRegistration中, 新建注册:\n```\n\tprivate RetryingRegistration<F, G, S> createNewRegistration() {\n\t\tRetryingRegistration<F, G, S> newRegistration = checkNotNull(generateRegistration());  //跑进去\n\t\tCompletableFuture<Tuple2<G, S>> future = newRegistration.getFuture();\n\t\tfuture.whenCompleteAsync(\n\t\t\t(Tuple2<G, S> result, Throwable failure) -> {\n\t\t\t\tif (failure != null) {\n\t\t\t\t......\n\t\t\t\t} else {\n\t\t\t\t\ttargetGateway = result.f0;\n\t\t\t\t\t//注意进来，进行pending task分配，调用ResourceManagerConnection.onRegistrationSuccess()\n\t\t\t\t\tonRegistrationSuccess(result.f1);\n\t\t\t\t}\n\t\t\t}, executor);\n\t\treturn newRegistration;\n\t}\n```\n当注册完成并且没有抛出异常时, 说明注册完成了, 则调用之前的ResourceManagerConnection.onRegistrationSuccess()进行连接, 最终会进去SlotPool.connectToResourceManager()\n```\npublic void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) {\n\t\t// 开始申请之前被pending的请求\n\t\tfor (PendingRequest pendingRequest : waitingForResourceManager.values()) {\n\t\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);\n\t\t}\n\t\twaitingForResourceManager.clear();\n\t}\n```\n当完成flink ResourceManager注册、连接后, 我们会逐个申请之前被挂起的请求。然后开始走之后描述的正常申请slot流程。\n\n### 向ResourceManager申请slot\n从requestSlotFromResourceManager()中最终会进入registerSlotRequest\n```\n    public boolean registerSlotRequest(SlotRequest slotRequest) throws SlotManagerException {\n\t    PendingSlotRequest pendingSlotRequest = new PendingSlotRequest(slotRequest);\n\t\tpendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);\n\t\ttry {\n\t\t    internalRequestSlot(pendingSlotRequest);\n\t\t}\n\t\treturn true;\n    }\n    private void internalRequestSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException {\n\t\t//是否发现目前拥有的slot\n\t\tTaskManagerSlot taskManagerSlot = findMatchingSlot(pendingSlotRequest.getResourceProfile());\n\t\tif (taskManagerSlot != null) {\n\t\t\tallocateSlot(taskManagerSlot, pendingSlotRequest);\n\t\t} else {\n\t\t\tresourceActions.allocateResource(pendingSlotRequest.getResourceProfile()); //跑到这里\n\t\t}\n\t}\n```\ninternalRequestSlot做了如下逻辑:\n+ 通过findMatchingSlot检查是否有现成可用的slot, 其中freeSlots包含着availiable slot. 比如在每当有新的TaskManager向JobManager注册时, 就会调用SlotManager.registerSlotRequest(), 在freeSlots中注册该TM可用的slot。若有可用slot时候, 就会调用allocateSlot进行分配。\n+ 若没有可用空闲slot, 通过allocateResource申请TM, 最终会调用YarnResourceManager.requestYarnContainer进行申请。\n我们再分别以这两种情况继续介绍。\n#### JobManager端有某个TM注册的可用slot\n若JM端有某个TM注册的可用slot, 那么就会进入allocateSlot来将这个slot分配给这个SubTask:\n```\n\tprivate void allocateSlot(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest) {\n\t\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();\n\t\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();\n\n\t\tfinal CompletableFuture<Acknowledge> completableFuture = new CompletableFuture<>();\n\t\tfinal AllocationID allocationId = pendingSlotRequest.getAllocationId();\n\t\tfinal SlotID slotId = taskManagerSlot.getSlotId();\n\t\tfinal InstanceID instanceID = taskManagerSlot.getInstanceId();\n\n\t\ttaskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);\n\t\tpendingSlotRequest.setRequestFuture(completableFuture);\n\n\t\tTaskManagerRegistration taskManagerRegistration = taskManagerRegistrations.get(instanceID);\n        // 既然这个TM上报的slot, 那么这个TM一定已经有注册信息了\n\t\tif (taskManagerRegistration == null) {\n\t\t\tthrow new IllegalStateException(\"Could not find a registered task manager for instance id \" +\n\t\t\t\tinstanceID + '.');\n\t\t}\n\t\ttaskManagerRegistration.markUsed();\n\t\t去向TM通信, 告诉TM这个slot已经被请求了\n\t\t// RPC call to the task manager\n\t\tCompletableFuture<Acknowledge> requestFuture = gateway.requestSlot(\n\t\t\tslotId,\n\t\t\tpendingSlotRequest.getJobId(),\n\t\t\tallocationId,\n\t\t\tpendingSlotRequest.getTargetAddress(),\n\t\t\tresourceManagerId,\n\t\t\ttaskManagerRequestTimeout);\n\n\t\trequestFuture.whenComplete(\n\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n\t\t\t\tif (acknowledge != null) {\n\t\t\t\t\tcompletableFuture.complete(acknowledge);\n\t\t\t\t}\n\t\t\t});\n\n\t\tcompletableFuture.whenCompleteAsync(\n\t\t\t(Acknowledge acknowledge, Throwable throwable) -> {\n\t\t\t\ttry {  //去更新本地slot状态, 从可用空闲slot中删掉\n\t\t\t\t\tif (acknowledge != null) {\n\t\t\t\t\t\tupdateSlot(slotId, allocationId, pendingSlotRequest.getJobId());\n\t\t\t\t\t}\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.error(\"Error while completing the slot allocation.\", e);\n\t\t\t\t}\n\t\t\t},\n\t\t\tmainThreadExecutor);\n\t}\n```\nJM请求某个slot逻辑也比较简单:\n1. JM直接告诉slot对应TM, 这个slot将被申请\n2. JM修改这个slot的状态, 并且从本地可用slot中删掉。然后等待subTask被部署到这个TM的slot上\n我们看下第一步JM是怎么告诉TM这个slot被申请的,  gateway.requestSlot直接通过RPC(通信逻辑<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">参考</a>)直接向TM的TaskExecutor.requestSlot去了, 我们看下TM是如何做处理的:\n```\n    /**\n\t * Add the given job to be monitored. This means that the service tries to detect leaders for\n\t * this job and then tries to establish a connection to it.\n\t */\n\tpublic CompletableFuture<Acknowledge> requestSlot(\n\t\tfinal SlotID slotId,\n\t\tfinal JobID jobId,\n\t\tfinal AllocationID allocationId,\n\t\tfinal String targetAddress,\n\t\tfinal ResourceManagerId resourceManagerId,\n\t\tfinal Time timeout) {\n\t\tlog.info(\"Receive slot request {} for job {} from resource manager with leader id {}.\",\n\t\t\tallocationId, jobId, resourceManagerId);\n\t\ttry {\n\t\t\tif (taskSlotTable.isSlotFree(slotId.getSlotNumber())) {\n\t\t\t\tif (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) {\n\t\t\t\t\tlog.info(\"Allocated slot for {}.\", allocationId);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (jobManagerTable.contains(jobId)) {\n\t\t\t\tofferSlotsToJobManager(jobId);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tjobLeaderService.addJob(jobId, targetAddress);  // 跑进去\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn CompletableFuture.completedFuture(Acknowledge.get());\n\t}\n```\n主要逻辑如下:\n1. TM接收到JM的请求后, TM首先检查这个slot是否是空闲的, 若空闲的话, 就开始调用taskSlotTable.allocateSlot(), 将这个slot置为已分配。\n2. TM调用jobLeaderService.addJob将这个Job监控起来(每当有新的Job请求slot, 就会去检测job的leader, 并去和这个job leader建立链接),最终调用JobManagerLeaderListener.notifyLeaderAddress()->JobManagerRegisteredRpcConnection.start():\n```\n    public void start() {\n\t\tcheckState(!closed, \"The RPC connection is already closed\");\n\t\tcheckState(!isConnected() && pendingRegistration == null, \"The RPC connection is already started\");\n\t\tfinal RetryingRegistration<F, G, S> newRegistration = createNewRegistration();\n\t\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) {\n\t\t\tnewRegistration.startRegistration();\n\t\t} else {\n\t\t\t// concurrent start operation\n\t\t\tnewRegistration.cancel();\n\t\t}\n\t}\n```\n这里是不是有点熟悉, 可以参考下<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">这里</a>, startRegistration主要是向JM发送申请成功通知, TM成功后回调JobManagerRegisteredRpcConnection.onRegistrationSuccess, 最终调用TaskExecutor.establishJobManagerConnection:\n```\n\tprivate void establishJobManagerConnection(JobID jobId, final JobMasterGateway jobMasterGateway, JMTMRegistrationSuccess registrationSuccess) {\n\t\tif (jobManagerTable.contains(jobId)) {\n\t\t\tJobManagerConnection oldJobManagerConnection = jobManagerTable.get(jobId);\n\n\t\t\tif (Objects.equals(oldJobManagerConnection.getJobMasterId(), jobMasterGateway.getFencingToken())) {\n\t\t\t\t// we already are connected to the given job manager\n\t\t\t\tlog.debug(\"Ignore JobManager gained leadership message for {} because we are already connected to it.\", jobMasterGateway.getFencingToken());\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tResourceID jobManagerResourceID = registrationSuccess.getResourceID();\n\t\tJobManagerConnection newJobManagerConnection = associateWithJobManager(\n\t\t\t\tjobId,\n\t\t\t\tjobManagerResourceID,\n\t\t\t\tjobMasterGateway);\n\t\tjobManagerConnections.put(jobManagerResourceID, newJobManagerConnection);\n\t\tjobManagerTable.put(jobId, newJobManagerConnection);  // 设置的是每个Job在TM这里的注册\n\n\t\t// monitor the job manager as heartbeat target\n\t\tjobManagerHeartbeatManager.monitorTarget(jobManagerResourceID, new HeartbeatTarget<AccumulatorReport>() {\n\t\t\t@Override\n\t\t\tpublic void receiveHeartbeat(ResourceID resourceID, AccumulatorReport payload) {\n\t\t\t\tjobMasterGateway.heartbeatFromTaskManager(resourceID, payload);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void requestHeartbeat(ResourceID resourceID, AccumulatorReport payload) {\n\t\t\t\t// request heartbeat will never be called on the task manager side\n\t\t\t}\n\t\t});\n\n\t\tofferSlotsToJobManager(jobId);\n\t}\n```\n主要做了如下事情:\n1. 检查这个job是否已经在TM端注册了, 若注册了, 那么就直接返回\n2. 否则建立job->JobManagerConnection, 将映射关系放入TaskExecutor的jobManagerTable中, 然后监控这个job master。\n3. 调用offerSlotsToJobManager, 告诉JM, 分配给Task这个slot。\n\n#### JobManager端没有TM注册的可用slot\n若没有可用slot的话, 那么就只能去申请TM, 申请的TM会上报可用slot, 然后再向这个TM申请部署SubTask, 此时就回到了有可用slot的情况了。我们看下是如何申请TM的。\n```\n    // //resource 是当前申请的container情况，比如<memory:6552, vCores:4>\n    private void requestYarnContainer(Resource resource, Priority priority) {\n        //获取当前实际正在申请的slot个数\n\t\tint pendingSlotRequests = getNumberPendingSlotRequests();\n\t\t// 通过当前正在申请的Contaainer个数*numberOfTaskSlots计算出预计当前正在申请的slot个数\n\t\tint pendingSlotAllocation = numPendingContainerRequests * numberOfTaskSlots;\n\t\t//若当前实际申请的slot个数 > 预计申请的slot个数, 那么需要去申请新的container, 来满足实际申请的slot个数\n\t\tif (pendingSlotRequests > pendingSlotAllocation) {\n\t\t    // 向yarn 发送申请container的请求。\n\t\t\tresourceManagerClient.addContainerRequest(new AMRMClient.ContainerRequest(resource, null, null, priority));\n\t\t\tresourceManagerClient.setHeartbeatInterval(FAST_YARN_HEARTBEAT_INTERVAL_MS);\n\t\t\t//正在申请的container统计自增\n\t\t\tnumPendingContainerRequests++;\n\t\t}\n\t}\n```\n### 申请container成功\n当向yarn成功申请到container之后, 会回调YarnResourceManager.onContainersAllocated通知jobManager。\n```\n\tpublic void onContainersAllocated(List<Container> containers) {\n\t\trunAsync(() -> {\n\t\t\tfor (Container container : containers) {\n\t\t\t\tif (numPendingContainerRequests > 0) {\n\t\t\t\t\tnumPendingContainerRequests--;\n\t\t\t\t\tfinal String containerIdStr = container.getId().toString();\n\t\t\t\t\tfinal ResourceID resourceId = new ResourceID(containerIdStr);\n\t\t\t\t\tworkerNodeMap.put(resourceId, new YarnWorkerNode(container));\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// 产生tm启动命令\n\t\t\t\t\t\tContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(\n\t\t\t\t\t\t\tcontainer.getResource(),\n\t\t\t\t\t\t\tcontainerIdStr,\n\t\t\t\t\t\t\tcontainer.getNodeId().getHost());\n                       // 启动TaskManager\n\t\t\t\t\t\tnodeManagerClient.startContainer(container, taskExecutorLaunchContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if we are waiting for no further containers, we can go to the\n\t\t\t// regular heartbeat interval\n\t\t\tif (numPendingContainerRequests <= 0) {\n\t\t\t\tresourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis);\n\t\t\t}\n\t\t});\n\t}\n```\n回调函数主要做了如下逻辑:\n1. 确定启动taskManager的命令。\n2. 通过yarn启动taskManager。\n我们来放一张整体JobManager端分配Slot的流程图:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate1.png\" height=\"300\" width=\"800\"/>\n\n## 部署subTask到对应的slot\n当确定好subTask部署到一个TaskManager的slot上之后, 在scheduleEager中就开始调用Execution.deploy()进行部署。\n```\npublic void deploy() throws JobException {\n\t\tfinal LogicalSlot slot  = assignedResource;  // SingleLogicalSlot\n\t\ttry {\n\t\t\tfinal TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(\n\t\t\t\tattemptId,\n\t\t\t\tslot, // SingleLogicalSlot\n\t\t\t\ttaskRestore,\n\t\t\t\tattemptNumber);\n\t\t\t// null taskRestore to let it be GC'ed\n\t\t\ttaskRestore = null;\n\t\t\tfinal TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();\n\t\t\tfinal CompletableFuture<Acknowledge> submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout);\n\t\t}\n\t}\n    public CompletableFuture<Acknowledge> submitTask(TaskDeploymentDescriptor tdd, Time timeout) {\n        // 实际会去调用AkkaInvocationHandler，而去和tm通信，而不是跑到TaskExecutor.submitTask\n\t\treturn taskExecutorGateway.submitTask(tdd, jobMasterId, timeout);\n    }\n```\n可以看到:\n+ 首先生成TaskDeploymentDescriptor, 包含部署subTask的所有信息。\n+ 调用taskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask, JM接收RPC可参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/\">link原理-Akka通信原理</a> 。\nTaskManager端通过TaskExecutor.subTask()接受到JobManager发出的部署SubTask的申请, 这样就完成SubTask部署了。\n\n# SlotSharingGroup及共享slot\nFlink 允许相同SlotSharingGroup的subTask共享同一个slot, 好处主要有俩:\n+ A Flink cluster needs exactly as many task slots as the highest parallelism used in the job. No need to calculate how many tasks (with varying parallelism) a program contains in total.\n+ It is easier to get better resource utilization. Without slot sharing, the non-intensive source/map() subtasks would block as many resources as the resource intensive window subtasks. With slot sharing, increasing the base parallelism in our example from two to six yields full utilization of the slotted resources, while making sure that the heavy subtasks are fairly distributed among the TaskManagers.\n默认情况下, SubTask使用相同的slot共享组: Default, task共享slot过程可以参考:<a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html#task-slots-and-resources\">如何共享slot</a>\n这里将阐述SlotSharingGroup是如何生成并起作用的:\n在JobGraph产生的时候调用setSlotSharingAndCoLocation()函数:\n```\n\tprivate void setSlotSharingAndCoLocation() {\n\t\tfinal HashMap<String, SlotSharingGroup> slotSharingGroups = new HashMap<>();\n\t\tfor (Entry<Integer, JobVertex> entry : jobVertices.entrySet()) {\n\t\t\tfinal StreamNode node = streamGraph.getStreamNode(entry.getKey());\n\t\t\tfinal JobVertex vertex = entry.getValue();// slotSharingGroupKey为默认值default\n\t\t\tfinal String slotSharingGroupKey = node.getSlotSharingGroup();\n\t\t\tfinal SlotSharingGroup sharingGroup;\n\t\t\tif (slotSharingGroupKey != null) {\n\t\t\t    // 可以看到, 所有的task的group都为default, 都将放入到同一个SlotSharingGroup中\n\t\t\t\tsharingGroup = slotSharingGroups.computeIfAbsent(slotSharingGroupKey, (k) -> new SlotSharingGroup());\n\t\t\t\tvertex.setSlotSharingGroup(sharingGroup);\n\t\t\t} else {\n\t\t\t\tsharingGroup = null;\n\t\t\t}\n```\n这样, 所有的JobVertex都引用了同一个SlotSharingGroup。 而\n```\n    public void setSlotSharingGroup(SlotSharingGroup grp) {\n\t\tif (this.slotSharingGroup != null) {\n\t\t\tthis.slotSharingGroup.removeVertexFromGroup(id);\n\t\t}\n\t\tthis.slotSharingGroup = grp;\n\t\tif (grp != null) {\n\t\t\tgrp.addVertexToGroup(id);\n\t\t}\n\t}\n```\n每个共享组的id都是相同的。\n\n# MultiTaskSlot及SingleTaskSlot\nMultiTaskSlot及SingleTaskSlot都继承TaskSlot, 每当subTask申请到一个未被共享的slot时, 就会产生一个MultiTaskSlot, 它代表着一个TM上的slot, 管理着该slot被共享的情况。 实际分配给每个subTask时, 会单独产生一个SingleTaskSlot, 然后每次被MultiTaskSlot管理着。之后若共享slot时, 分配到的都是同一个MultiTaskSlot, 不同的是每次每次分配都产生新的SingleTaskSlot。\n\n# 参考文档\nhttps://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html\nhttps://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html\nhttp://wuchong.me/blog/2016/05/03/flink-internals-overview/\nhttp://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/","slug":"Flink原理-slot分配","published":1,"updated":"2019-06-06T18:03:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w8000fphu5m7qov15i","content":"<p>本文将从ExecutionGraph开始向后讲起, ExecutionGraph定义了Job的并发逻辑结构, 作为任务执行的以后一层逻辑结构, 也是最核心数据结构。为了让大家有全局的了解, 先盗一张广为引用的Graph转换图:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_Graph.png\" height=\"900\" width=\"800\"><br>具体来说, 本文讲述在JobManager端subTask申请slot以及部署到TaskManager上的过程。</p>\n<h1 id=\"Task分配slot及部署\"><a href=\"#Task分配slot及部署\" class=\"headerlink\" title=\"Task分配slot及部署\"></a>Task分配slot及部署</h1><p>代码将从ExecutionGraph.scheduleExecutionGraph()开始讲解, 进入:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleForExecution() throws JobException &#123;</div><div class=\"line\">\tfinal long currentGlobalModVersion = globalModVersion;</div><div class=\"line\">\tif (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</div><div class=\"line\">\t\tfinal CompletableFuture&lt;Void&gt; newSchedulingFuture;</div><div class=\"line\">\t\tswitch (scheduleMode) &#123;</div><div class=\"line\">\t\t\tcase LAZY_FROM_SOURCES:</div><div class=\"line\">\t\t\t\tnewSchedulingFuture = scheduleLazy(slotProvider);</div><div class=\"line\">\t\t\t\tbreak;</div><div class=\"line\">\t\t\tcase EAGER:</div><div class=\"line\">\t\t\t\tnewSchedulingFuture = scheduleEager(slotProvider, allocationTimeout);</div><div class=\"line\">\t\t\t\tbreak;</div><div class=\"line\">\t\t\tdefault:</div><div class=\"line\">\t\t\t\tthrow new JobException(&quot;Schedule mode is invalid.&quot;);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中, scheduleMode分EAGER和LAZY_FROM_SOURCES, EAGER表示立刻去调度部署所有的Task。实际scheduleMode是从JobGraph.getScheduleMode()取值的, 为eager。<br>我们再进入scheduleEager看是如何调度task的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private CompletableFuture&lt;Void&gt; scheduleEager(SlotProvider slotProvider, final Time timeout) &#123;</div><div class=\"line\">    ......</div><div class=\"line\">\t //都是每个JobGraph</div><div class=\"line\">\tfor (ExecutionJobVertex ejv : getVerticesTopologically()) &#123;</div><div class=\"line\">\t\t// these calls are not blocking, they only return futures</div><div class=\"line\">\t\tCollection&lt;CompletableFuture&lt;Execution&gt;&gt; allocationFutures = ejv.allocateResourcesForAll(</div><div class=\"line\">\t\t\tslotProvider, // SlotPool$ProviderAndOwner</div><div class=\"line\">\t\t\tqueued,</div><div class=\"line\">\t\t\tLocationPreferenceConstraint.ALL,</div><div class=\"line\">\t\t\tallPreviousAllocationIds,</div><div class=\"line\">\t\t\ttimeout);</div><div class=\"line\">\t\tallAllocationFutures.addAll(allocationFutures);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//只有当所有Execution都分配到了槽位才继续进行部署</div><div class=\"line\">\tfinal ConjunctFuture&lt;Collection&lt;Execution&gt;&gt; allAllocationsFuture = FutureUtils.combineAll(allAllocationFutures);</div><div class=\"line\">\tfinal CompletableFuture&lt;Void&gt; currentSchedulingFuture = allAllocationsFuture</div><div class=\"line\">\t\t.thenAccept(</div><div class=\"line\">\t\t\t(Collection&lt;Execution&gt; executionsToDeploy) -&gt; &#123;</div><div class=\"line\">\t\t\t\tfor (Execution execution : executionsToDeploy) &#123;</div><div class=\"line\">\t\t\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\t\t   // 最后挨个调用execution.deploy()进行部署子task，部署的模式是发送命令到</div><div class=\"line\">\t\t\t\t\t   execution.deploy();</div><div class=\"line\">\t\t\t\t\t&#125; catch (Throwable t) &#123;</div><div class=\"line\">\t\t\t\t\t   ......</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;)</div><div class=\"line\">\t\t......</div><div class=\"line\">\treturn currentSchedulingFuture;</div><div class=\"line\">&#125;`</div></pre></td></tr></table></figure></p>\n<p>scheduleEager主要做了两件事:</p>\n<ul>\n<li>通过allocateResourcesForAll确定每个subTask将要部署的slot。若没有合适的TaskManager, 那么通过yarn去申请TaskManager。</li>\n<li>当所有的subTask都确定好部署TaskManager的slot后, 通过execution.deploy()将subTask部署上去。<br>接下来, 将分别围绕这两件事讲解。<h2 id=\"确定subTask分配的slot\"><a href=\"#确定subTask分配的slot\" class=\"headerlink\" title=\"确定subTask分配的slot\"></a>确定subTask分配的slot</h2>通过getVerticesTopologically()获取所有的ExecutionJobVertex, 然后依次轮询给每个ExecutionJobVertex都分配一个slot, 其中轮询的ExecutionJobVertex是有先后顺序的, 从source开始分配slot, 直到sink。后面可以看到, 上游分配到哪个tm上, 会影响下游的slot分配。 我们进入allocateResourcesForAll看下是如何给一个ExecutionJobVertex所有的subTask分配slot的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public Collection&lt;CompletableFuture&lt;Execution&gt;&gt; allocateResourcesForAll(</div><div class=\"line\">\t\tSlotProvider resourceProvider, // SlotPool$ProviderAndOwner</div><div class=\"line\">\t\tboolean queued,  //true</div><div class=\"line\">\t\tLocationPreferenceConstraint locationPreferenceConstraint, //ALL</div><div class=\"line\">\t\t@Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds,</div><div class=\"line\">\t\tTime allocationTimeout) &#123;</div><div class=\"line\">\tfinal ExecutionVertex[] vertices = this.taskVertices;</div><div class=\"line\">\tfinal CompletableFuture&lt;Execution&gt;[] slots = new CompletableFuture[vertices.length];</div><div class=\"line\">\tfor (int i = 0; i &lt; vertices.length; i++) &#123;</div><div class=\"line\">\t\tfinal Execution exec = vertices[i].getCurrentExecutionAttempt();</div><div class=\"line\">\t\tfinal CompletableFuture&lt;Execution&gt; allocationFuture = exec.allocateAndAssignSlotForExecution(</div><div class=\"line\">\t\t\tresourceProvider,</div><div class=\"line\">\t\t\tqueued,</div><div class=\"line\">\t\t\tlocationPreferenceConstraint,</div><div class=\"line\">\t\t\tallPreviousExecutionGraphAllocationIds,</div><div class=\"line\">\t\t\tallocationTimeout);</div><div class=\"line\">\t\tslots[i] = allocationFuture;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn Arrays.asList(slots);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每一个ExecutionJobVertex都对应着一批ExecutionVertex(也就是subTask), 可以看到, 这里轮询每个ExecutionVertex进行申请一个slot。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public CompletableFuture&lt;Execution&gt; allocateAndAssignSlotForExecution(</div><div class=\"line\">\t\tSlotProvider slotProvider, //SlotPool$ProviderAndOwner</div><div class=\"line\">\t\tboolean queued,</div><div class=\"line\">\t\tLocationPreferenceConstraint locationPreferenceConstraint,  //ALL</div><div class=\"line\">\t\t@Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds,</div><div class=\"line\">\t\tTime allocationTimeout) throws IllegalExecutionStateException &#123;</div><div class=\"line\">\tfinal SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();</div><div class=\"line\">\tif (transitionState(CREATED, SCHEDULED)) &#123;</div><div class=\"line\">\t    // 默认情况下, 所有的subTask的共享组均为default</div><div class=\"line\">\t\tfinal SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null;</div><div class=\"line\">\t\t/** 获取subTask即将分配的&quot;偏好位置集合&quot;，也就是分配时，优先考虑分配在这些节点上，一般是input节点所在节点 */</div><div class=\"line\">\t\tfinal CompletableFuture&lt;Collection&lt;TaskManagerLocation&gt;&gt; preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint);</div><div class=\"line\">\t    //上游子task地方全部确定了，才能继续确定下游子task位置</div><div class=\"line\">\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();</div><div class=\"line\">\t\tfinal CompletableFuture&lt;LogicalSlot&gt; logicalSlotFuture = preferredLocationsFuture</div><div class=\"line\">\t\t\t.thenCompose(</div><div class=\"line\">\t\t\t\t(Collection&lt;TaskManagerLocation&gt; preferredLocations) -&gt;</div><div class=\"line\">\t\t\t\t\tslotProvider.allocateSlot(//SlotPool$ProviderAndOwner</div><div class=\"line\">\t\t\t\t\t\tslotRequestId,</div><div class=\"line\">\t\t\t\t\t\ttoSchedule,</div><div class=\"line\">\t\t\t\t\t\tqueued,</div><div class=\"line\">\t\t\t\t\t\tnew SlotProfile(</div><div class=\"line\">\t\t\t\t\t\t\tResourceProfile.UNKNOWN,</div><div class=\"line\">\t\t\t\t\t\t\tpreferredLocations,</div><div class=\"line\">\t\t\t\t\t\t\tpreviousAllocationIDs,</div><div class=\"line\">\t\t\t\t\t\t\tallPreviousExecutionGraphAllocationIds),</div><div class=\"line\">\t\t\t\t\t\tallocationTimeout));</div><div class=\"line\">\t\treturn logicalSlotFuture.thenApply(</div><div class=\"line\">\t\t\t(LogicalSlot logicalSlot) -&gt; &#123;</div><div class=\"line\">\t\t\t    //</div><div class=\"line\">\t\t\t\tif (tryAssignResource(logicalSlot)) &#123;</div><div class=\"line\">\t\t\t\t\treturn this;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了两件事情:</p>\n<ul>\n<li>在calculatePreferredLocations中确定从该subTask对应ExecutionJobVertex的所有上游中找到最合适的上游”偏向位置集合”。</li>\n<li>通过SlotPool$ProviderAndOwner.allocateSlot继续确定从”偏向位置集合”找到一个共享slot。<br>我们知道, 多个subTask允许共享slot, 细节后面会详细描述。 那么当前subTask与哪些已经分配的subTask共享slot呢? 下游subTask与哪个上游subTask共享slot呢?<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate.png\" height=\"300\" width=\"350\"></li>\n</ul>\n<p>flink会根据subTask上游slot的分配来确定当前slot的分配:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; getPreferredLocationsBasedOnInputs() &#123;</div><div class=\"line\">\t\t// 如果没有输入，则返回空集合，否则，基于上游分布确定偏好位置</div><div class=\"line\">\t\tif (inputEdges == null) &#123;</div><div class=\"line\">\t\t\treturn Collections.emptySet();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse &#123;</div><div class=\"line\">\t\t\tSet&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; locations = new HashSet&lt;&gt;(getTotalNumberOfParallelSubtasks());</div><div class=\"line\">\t\t\tSet&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; inputLocations = new HashSet&lt;&gt;(getTotalNumberOfParallelSubtasks());</div><div class=\"line\">\t\t\t// go over all inputs</div><div class=\"line\">\t\t\tfor (int i = 0; i &lt; inputEdges.length; i++) &#123;</div><div class=\"line\">\t\t\t\tinputLocations.clear();</div><div class=\"line\">\t\t\t\tExecutionEdge[] sources = inputEdges[i];</div><div class=\"line\">\t\t\t\tif (sources != null) &#123;</div><div class=\"line\">\t\t\t\t\tfor (int k = 0; k &lt; sources.length; k++) &#123;</div><div class=\"line\">\t\t\t\t\t\t// 获取当前source源所属的taskManager位置</div><div class=\"line\">\t\t\t\t\t\tCompletableFuture&lt;TaskManagerLocation&gt; locationFuture = sources[k].getSource().getProducer().getCurrentTaskManagerLocationFuture();</div><div class=\"line\">\t\t\t\t\t\t// add input location</div><div class=\"line\">\t\t\t\t\t\tinputLocations.add(locationFuture);</div><div class=\"line\">\t\t\t\t\t\t// inputs which have too many distinct sources are not considered</div><div class=\"line\">\t\t\t\t\t\t// 如果某个输入源有太多的节点分布，则不考虑这个输入源的节点位置了</div><div class=\"line\">\t\t\t\t\t\tif (inputLocations.size() &gt; MAX_DISTINCT_LOCATIONS_TO_CONSIDER) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tinputLocations.clear();</div><div class=\"line\">\t\t\t\t\t\t\tbreak;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;// 保留具有最少分布位置的输入的位置</div><div class=\"line\">\t\t\t\t// keep the locations of the input with the least preferred locations</div><div class=\"line\">\t\t\t\tif (locations.isEmpty() || // nothing assigned yet  第一个source</div><div class=\"line\">\t\t\t\t        // 找到上游节点所处tm最少的的那个上游</div><div class=\"line\">\t\t\t\t\t\t(!inputLocations.isEmpty() &amp;&amp; inputLocations.size() &lt; locations.size())) &#123;</div><div class=\"line\">\t\t\t\t\tlocations.clear();</div><div class=\"line\">\t\t\t\t\tlocations.addAll(inputLocations);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\treturn locations.isEmpty() ? Collections.emptyList() : locations;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>处理过程如下:</p>\n<ul>\n<li>若该ExecutionVertex没有上游(例如source), 那么返回为空, 没有”偏好位置集合”, 之后将申请新的slot。</li>\n<li>若当前ExecutionVertex有属于不同JobVertex多个ExecutionJobVertex的上游, 那么当前sub分配到哪些共享slot的可选路径只能是: 属于同一个JobVertex的上游节点个数最少。上图的话, 就会选择source2的所有subTask作为”偏好位置集合”。我们接下来看第二步, 最终会进入到allocateSharedSlot决定subTask分配到哪些”偏好位置集合”里slot上。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">private CompletableFuture&lt;LogicalSlot&gt; allocateSharedSlot(</div><div class=\"line\">\t\tSlotRequestId slotRequestId,</div><div class=\"line\">\t\tScheduledUnit task,</div><div class=\"line\">\t\tSlotProfile slotProfile,</div><div class=\"line\">\t\tboolean allowQueuedScheduling,</div><div class=\"line\">\t\tTime allocationTimeout) &#123;</div><div class=\"line\">\t\t// allocate slot with slot sharing</div><div class=\"line\">\t\tfinal SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(</div><div class=\"line\">\t\t\t //默认都是一个, default对应的那个</div><div class=\"line\">\t\t\ttask.getSlotSharingGroupId(),</div><div class=\"line\">\t\t\tid -&gt; new SlotSharingManager(</div><div class=\"line\">\t\t\t\tid,</div><div class=\"line\">\t\t\t\tthis,</div><div class=\"line\">\t\t\t\tproviderAndOwner));</div><div class=\"line\">\t\tfinal SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tif (task.getCoLocationConstraint() != null) &#123;</div><div class=\"line\">\t\t\t\tmultiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(</div><div class=\"line\">\t\t\t\t\ttask.getCoLocationConstraint(),</div><div class=\"line\">\t\t\t\t\tmultiTaskSlotManager,</div><div class=\"line\">\t\t\t\t\tslotProfile,</div><div class=\"line\">\t\t\t\t\tallowQueuedScheduling,</div><div class=\"line\">\t\t\t\t\tallocationTimeout);</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t     // 跑到这里</div><div class=\"line\">\t\t\t\tmultiTaskSlotLocality = allocateMultiTaskSlot(</div><div class=\"line\">\t\t\t\t\ttask.getJobVertexId(),</div><div class=\"line\">\t\t\t\t\tmultiTaskSlotManager,</div><div class=\"line\">\t\t\t\t\tslotProfile,</div><div class=\"line\">\t\t\t\t\tallowQueuedScheduling,</div><div class=\"line\">\t\t\t\t\tallocationTimeout);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfinal SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(</div><div class=\"line\">\t\t\tslotRequestId,</div><div class=\"line\">\t\t\ttask.getJobVertexId(),</div><div class=\"line\">\t\t\tmultiTaskSlotLocality.getLocality());</div><div class=\"line\">\t\treturn leaf.getLogicalSlotFuture();</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该函数主要做了两件事:</p>\n<ol>\n<li>通过allocateMultiTaskSlot产生MultiTaskSlotLocality, 里面包含从”偏向位置集合”中选取的部署当前subTask共享的slot。</li>\n<li>产生SingleTaskSlot, 当前SingleTaskSlot作为MultiTaskSlot的一个子叶子节点。<br>再继续跟进代码前, 我们需要了解两个变量resolvedRootSlots、unresolvedRootSlots。共享slot都会从这两个变量中获取, 这两个变量为共享组所拥有, 默认共享组为default。<br>unresolvedRootSlots: 当当前subTask正在确认部署到那个slot中时, 会将该slot保存在unresolvedRootSlots; 当确定好部署到哪个slot时, 会将该信息从unresolvedRootSlots中移除, 并放入resolvedRootSlots中  当我们查找是否有可利用的slot时, 会从这些变量中查找。<br>我们再进入正题, 看allocateMultiTaskSlot看是如何给subTask分配slot的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">private SlotSharingManager.MultiTaskSlotLocality allocateMultiTaskSlot(</div><div class=\"line\">\t\t//groupId指的同一个JobVertex的id</div><div class=\"line\">\t\tAbstractID groupId,</div><div class=\"line\">\t\tSlotSharingManager slotSharingManager,</div><div class=\"line\">\t\tSlotProfile slotProfile,</div><div class=\"line\">\t\tboolean allowQueuedScheduling,</div><div class=\"line\">\t\tTime allocationTimeout) throws NoResourceAvailableException &#123;</div><div class=\"line\">\t//过滤&quot;偏好位置集合&quot;的位置中不属于相同groupId的位置, 这里主要是为了避免同一个ExecutionJobVertex中不同的SubTask分配到同一个slot中。</div><div class=\"line\">\t// check first whether we have a resolved root slot which we can use</div><div class=\"line\">\tSlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = slotSharingManager.getResolvedRootSlot(</div><div class=\"line\">\t\tgroupId,</div><div class=\"line\">\t\t//  LocationPreferenceSchedulingStrategy</div><div class=\"line\">\t\tschedulingStrategy,</div><div class=\"line\">\t\tslotProfile);</div><div class=\"line\">    //从&quot;偏好位置集合&quot;中到合适的slot后, 就直接返回了。</div><div class=\"line\">\tif (multiTaskSlotLocality != null &amp;&amp; multiTaskSlotLocality.getLocality() == Locality.LOCAL) &#123;</div><div class=\"line\">\t\treturn multiTaskSlotLocality;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t......</div><div class=\"line\">\tif (allowQueuedScheduling) &#123;</div><div class=\"line\">\t\t//在unresolvedRootSlots中查找不属于同一个JobVertex的slot</div><div class=\"line\">\t\tSlotSharingManager.MultiTaskSlot multiTaskSlotFuture = slotSharingManager.getUnresolvedRootSlot(groupId);  // 为null</div><div class=\"line\">\t\tif (multiTaskSlotFuture == null) &#123;</div><div class=\"line\">\t\t\t//没有找到合适的可利用的的slot, 那么将去向ResurceNameger申请新的TaskManger, 这是最后一步</div><div class=\"line\">\t\t\tfinal CompletableFuture&lt;AllocatedSlot&gt; futureSlot = requestNewAllocatedSlot(</div><div class=\"line\">\t\t\t\tallocatedSlotRequestId,</div><div class=\"line\">\t\t\t\tslotProfile.getResourceProfile(),</div><div class=\"line\">\t\t\t\tallocationTimeout); //300s</div><div class=\"line\">\t\t\t//将新产生的futureSlot, 放入resolvedRootSlots中, 这样之后申请slot时, 该slot可以被共享。</div><div class=\"line\">\t\t\tmultiTaskSlotFuture = slotSharingManager.createRootSlot(</div><div class=\"line\">\t\t\t\tmultiTaskSlotRequestId,</div><div class=\"line\">\t\t\t\tfutureSlot,</div><div class=\"line\">\t\t\t\tallocatedSlotRequestId);</div><div class=\"line\">\t\t\tfutureSlot.whenComplete(</div><div class=\"line\">\t\t\t\t(AllocatedSlot allocatedSlot, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\t\t\tfinal SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId);</div><div class=\"line\">\t\t\t\t\tif (taskSlot != null) &#123;</div><div class=\"line\">\t\t\t\t\t\t// still valid</div><div class=\"line\">\t\t\t\t\t\tif (!(taskSlot instanceof SlotSharingManager.MultiTaskSlot) || throwable != null) &#123;</div><div class=\"line\">\t\t\t\t\t\t\ttaskSlot.release(throwable);</div><div class=\"line\">\t\t\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\t\t\tif (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\ttaskSlot.release(new FlinkException(&quot;Could not assign payload to allocated slot &quot; +</div><div class=\"line\">\t\t\t\t\t\t\t\t\tallocatedSlot.getAllocationId() + &apos;.&apos;));</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlotFuture, Locality.UNKNOWN);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要逻辑如下:</p>\n<ul>\n<li>从resolvedRootSlots、unresolvedRootSlots中查找是否有可共享的slot。</li>\n<li>若没有, 向ResourceManager申请TaskManager以获取slot。</li>\n<li>将申请的slot信息也存放入unresolvedRootSlots中, 等成功申请后再存放入resolvedRootSlots。<br>我们再接着看是如何向ResourceManager申请TaskManager的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private CompletableFuture&lt;AllocatedSlot&gt; requestNewAllocatedSlot(</div><div class=\"line\">\t\tSlotRequestId slotRequestId,</div><div class=\"line\">\t\tResourceProfile resourceProfile,</div><div class=\"line\">\t\tTime allocationTimeout) &#123;</div><div class=\"line\">\tfinal PendingRequest pendingRequest = new PendingRequest(</div><div class=\"line\">\t\tslotRequestId,</div><div class=\"line\">\t\tresourceProfile);</div><div class=\"line\">\t// register request timeout</div><div class=\"line\">\tFutureUtils  //30s超时</div><div class=\"line\">\t\t.orTimeout(pendingRequest.getAllocatedSlotFuture(), allocationTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)</div><div class=\"line\">\t\t.whenCompleteAsync(  //当结束完成时需要做的事情</div><div class=\"line\">\t\t\t(AllocatedSlot ignored, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\t\tif (throwable instanceof TimeoutException) &#123;</div><div class=\"line\">\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\tgetMainThreadExecutor());</div><div class=\"line\">\tif (resourceManagerGateway == null) &#123;  // 为null</div><div class=\"line\">\t\tstashRequestWaitingForResourceManager(pendingRequest);  // 会跑到这里</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn pendingRequest.getAllocatedSlotFuture();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先查看resourceManagerGateway是否连接上, 若没有连接上, 将请求暂时缓存起来, 待连接上之后再申请。</li>\n<li>若已经初始化之后, 会去向ResourceManager申请TaskManager。<h3 id=\"缓存申请Slot的请求\"><a href=\"#缓存申请Slot的请求\" class=\"headerlink\" title=\"缓存申请Slot的请求\"></a>缓存申请Slot的请求</h3>大致思路是先缓存申请slot的请求, 直到flink ResourceManager注册完成后, 再去申请, 我们看下整体细节。首先去查看哪里开始对resourceManagerGateway进行初始化的。 首先回到最开始准备执行ExecutionGraph的时候:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception &#123;</div><div class=\"line\">\t //这里会开始尝试连接rm， 会去和resourceManager建立联系</div><div class=\"line\">\tstartJobMasterServices();</div><div class=\"line\">\tresetAndScheduleExecutionGraph();</div><div class=\"line\">    &#125;</div><div class=\"line\">    private void startJobMasterServices() throws Exception &#123;</div><div class=\"line\">\tslotPool.start(getFencingToken(), getAddress());</div><div class=\"line\">\t// 这里比较重要，会进去启动申请tm的请求</div><div class=\"line\">\treconnectToResourceManager(new FlinkException(&quot;Starting JobMaster component.&quot;));</div><div class=\"line\">\t// StandaloneLeaderRetrievalService</div><div class=\"line\">\tresourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在reconnectToResourceManager中, 会去尝试初始化, 调用connectToResourceManager:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void connectToResourceManager() &#123;</div><div class=\"line\">\t\tresourceManagerConnection = new ResourceManagerConnection( //很重要</div><div class=\"line\">\t\t\tlog,</div><div class=\"line\">\t\t\tjobGraph.getJobID(),</div><div class=\"line\">\t\t\tresourceId,</div><div class=\"line\">\t\t\tgetAddress(),</div><div class=\"line\">\t\t\tgetFencingToken(),</div><div class=\"line\">\t\t\tresourceManagerAddress.getAddress(),</div><div class=\"line\">\t\t\tresourceManagerAddress.getResourceManagerId(),</div><div class=\"line\">\t\t\tscheduledExecutorService);</div><div class=\"line\">\t\tresourceManagerConnection.start();  //从这里进去，获取注册ResourceManger</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>在ResourceManagerConnection中定义了onRegistrationSuccess, 会去调用establishResourceManagerConnection()函数, 我们进入resourceManagerConnection.start()看下如何建立注册的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void start() &#123;</div><div class=\"line\">       // ResourceManagerConnection</div><div class=\"line\">       final RetryingRegistration&lt;F, G, S&gt; newRegistrationn = createNewRegistration();</div><div class=\"line\">\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</div><div class=\"line\">\t    //会从这里进去，很重要，比如注册ResourceManager</div><div class=\"line\">\t\tnewRegistration.startRegistration();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在createNewRegistration中, 新建注册:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private RetryingRegistration&lt;F, G, S&gt; createNewRegistration() &#123;</div><div class=\"line\">\tRetryingRegistration&lt;F, G, S&gt; newRegistration = checkNotNull(generateRegistration());  //跑进去</div><div class=\"line\">\tCompletableFuture&lt;Tuple2&lt;G, S&gt;&gt; future = newRegistration.getFuture();</div><div class=\"line\">\tfuture.whenCompleteAsync(</div><div class=\"line\">\t\t(Tuple2&lt;G, S&gt; result, Throwable failure) -&gt; &#123;</div><div class=\"line\">\t\t\tif (failure != null) &#123;</div><div class=\"line\">\t\t\t......</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\ttargetGateway = result.f0;</div><div class=\"line\">\t\t\t\t//注意进来，进行pending task分配，调用ResourceManagerConnection.onRegistrationSuccess()</div><div class=\"line\">\t\t\t\tonRegistrationSuccess(result.f1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;, executor);</div><div class=\"line\">\treturn newRegistration;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当注册完成并且没有抛出异常时, 说明注册完成了, 则调用之前的ResourceManagerConnection.onRegistrationSuccess()进行连接, 最终会进去SlotPool.connectToResourceManager()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) &#123;</div><div class=\"line\">\t\t// 开始申请之前被pending的请求</div><div class=\"line\">\t\tfor (PendingRequest pendingRequest : waitingForResourceManager.values()) &#123;</div><div class=\"line\">\t\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\twaitingForResourceManager.clear();</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>当完成flink ResourceManager注册、连接后, 我们会逐个申请之前被挂起的请求。然后开始走之后描述的正常申请slot流程。</p>\n<h3 id=\"向ResourceManager申请slot\"><a href=\"#向ResourceManager申请slot\" class=\"headerlink\" title=\"向ResourceManager申请slot\"></a>向ResourceManager申请slot</h3><p>从requestSlotFromResourceManager()中最终会进入registerSlotRequest<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public boolean registerSlotRequest(SlotRequest slotRequest) throws SlotManagerException &#123;</div><div class=\"line\">    PendingSlotRequest pendingSlotRequest = new PendingSlotRequest(slotRequest);</div><div class=\"line\">\tpendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t    internalRequestSlot(pendingSlotRequest);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn true;</div><div class=\"line\">   &#125;</div><div class=\"line\">   private void internalRequestSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException &#123;</div><div class=\"line\">\t//是否发现目前拥有的slot</div><div class=\"line\">\tTaskManagerSlot taskManagerSlot = findMatchingSlot(pendingSlotRequest.getResourceProfile());</div><div class=\"line\">\tif (taskManagerSlot != null) &#123;</div><div class=\"line\">\t\tallocateSlot(taskManagerSlot, pendingSlotRequest);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\tresourceActions.allocateResource(pendingSlotRequest.getResourceProfile()); //跑到这里</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>internalRequestSlot做了如下逻辑:</p>\n<ul>\n<li>通过findMatchingSlot检查是否有现成可用的slot, 其中freeSlots包含着availiable slot. 比如在每当有新的TaskManager向JobManager注册时, 就会调用SlotManager.registerSlotRequest(), 在freeSlots中注册该TM可用的slot。若有可用slot时候, 就会调用allocateSlot进行分配。</li>\n<li>若没有可用空闲slot, 通过allocateResource申请TM, 最终会调用YarnResourceManager.requestYarnContainer进行申请。<br>我们再分别以这两种情况继续介绍。<h4 id=\"JobManager端有某个TM注册的可用slot\"><a href=\"#JobManager端有某个TM注册的可用slot\" class=\"headerlink\" title=\"JobManager端有某个TM注册的可用slot\"></a>JobManager端有某个TM注册的可用slot</h4>若JM端有某个TM注册的可用slot, 那么就会进入allocateSlot来将这个slot分配给这个SubTask:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocateSlot(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest) &#123;</div><div class=\"line\">\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();</div><div class=\"line\">\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();</div><div class=\"line\"></div><div class=\"line\">\tfinal CompletableFuture&lt;Acknowledge&gt; completableFuture = new CompletableFuture&lt;&gt;();</div><div class=\"line\">\tfinal AllocationID allocationId = pendingSlotRequest.getAllocationId();</div><div class=\"line\">\tfinal SlotID slotId = taskManagerSlot.getSlotId();</div><div class=\"line\">\tfinal InstanceID instanceID = taskManagerSlot.getInstanceId();</div><div class=\"line\"></div><div class=\"line\">\ttaskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);</div><div class=\"line\">\tpendingSlotRequest.setRequestFuture(completableFuture);</div><div class=\"line\"></div><div class=\"line\">\tTaskManagerRegistration taskManagerRegistration = taskManagerRegistrations.get(instanceID);</div><div class=\"line\">       // 既然这个TM上报的slot, 那么这个TM一定已经有注册信息了</div><div class=\"line\">\tif (taskManagerRegistration == null) &#123;</div><div class=\"line\">\t\tthrow new IllegalStateException(&quot;Could not find a registered task manager for instance id &quot; +</div><div class=\"line\">\t\t\tinstanceID + &apos;.&apos;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ttaskManagerRegistration.markUsed();</div><div class=\"line\">\t去向TM通信, 告诉TM这个slot已经被请求了</div><div class=\"line\">\t// RPC call to the task manager</div><div class=\"line\">\tCompletableFuture&lt;Acknowledge&gt; requestFuture = gateway.requestSlot(</div><div class=\"line\">\t\tslotId,</div><div class=\"line\">\t\tpendingSlotRequest.getJobId(),</div><div class=\"line\">\t\tallocationId,</div><div class=\"line\">\t\tpendingSlotRequest.getTargetAddress(),</div><div class=\"line\">\t\tresourceManagerId,</div><div class=\"line\">\t\ttaskManagerRequestTimeout);</div><div class=\"line\"></div><div class=\"line\">\trequestFuture.whenComplete(</div><div class=\"line\">\t\t(Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\tif (acknowledge != null) &#123;</div><div class=\"line\">\t\t\t\tcompletableFuture.complete(acknowledge);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tcompletableFuture.whenCompleteAsync(</div><div class=\"line\">\t\t(Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\ttry &#123;  //去更新本地slot状态, 从可用空闲slot中删掉</div><div class=\"line\">\t\t\t\tif (acknowledge != null) &#123;</div><div class=\"line\">\t\t\t\t\tupdateSlot(slotId, allocationId, pendingSlotRequest.getJobId());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\t\tLOG.error(&quot;Error while completing the slot allocation.&quot;, e);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\tmainThreadExecutor);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JM请求某个slot逻辑也比较简单:</p>\n<ol>\n<li>JM直接告诉slot对应TM, 这个slot将被申请</li>\n<li>JM修改这个slot的状态, 并且从本地可用slot中删掉。然后等待subTask被部署到这个TM的slot上<br>我们看下第一步JM是怎么告诉TM这个slot被申请的,  gateway.requestSlot直接通过RPC(通信逻辑<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">参考</a>)直接向TM的TaskExecutor.requestSlot去了, 我们看下TM是如何做处理的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">   /**</div><div class=\"line\"> * Add the given job to be monitored. This means that the service tries to detect leaders for</div><div class=\"line\"> * this job and then tries to establish a connection to it.</div><div class=\"line\"> */</div><div class=\"line\">public CompletableFuture&lt;Acknowledge&gt; requestSlot(</div><div class=\"line\">\tfinal SlotID slotId,</div><div class=\"line\">\tfinal JobID jobId,</div><div class=\"line\">\tfinal AllocationID allocationId,</div><div class=\"line\">\tfinal String targetAddress,</div><div class=\"line\">\tfinal ResourceManagerId resourceManagerId,</div><div class=\"line\">\tfinal Time timeout) &#123;</div><div class=\"line\">\tlog.info(&quot;Receive slot request &#123;&#125; for job &#123;&#125; from resource manager with leader id &#123;&#125;.&quot;,</div><div class=\"line\">\t\tallocationId, jobId, resourceManagerId);</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tif (taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</div><div class=\"line\">\t\t\tif (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) &#123;</div><div class=\"line\">\t\t\t\tlog.info(&quot;Allocated slot for &#123;&#125;.&quot;, allocationId);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tif (jobManagerTable.contains(jobId)) &#123;</div><div class=\"line\">\t\t\tofferSlotsToJobManager(jobId);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\tjobLeaderService.addJob(jobId, targetAddress);  // 跑进去</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn CompletableFuture.completedFuture(Acknowledge.get());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要逻辑如下:</p>\n<ol>\n<li>TM接收到JM的请求后, TM首先检查这个slot是否是空闲的, 若空闲的话, 就开始调用taskSlotTable.allocateSlot(), 将这个slot置为已分配。</li>\n<li>TM调用jobLeaderService.addJob将这个Job监控起来(每当有新的Job请求slot, 就会去检测job的leader, 并去和这个job leader建立链接),最终调用JobManagerLeaderListener.notifyLeaderAddress()-&gt;JobManagerRegisteredRpcConnection.start():<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void start() &#123;</div><div class=\"line\">\tcheckState(!closed, &quot;The RPC connection is already closed&quot;);</div><div class=\"line\">\tcheckState(!isConnected() &amp;&amp; pendingRegistration == null, &quot;The RPC connection is already started&quot;);</div><div class=\"line\">\tfinal RetryingRegistration&lt;F, G, S&gt; newRegistration = createNewRegistration();</div><div class=\"line\">\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</div><div class=\"line\">\t\tnewRegistration.startRegistration();</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\t// concurrent start operation</div><div class=\"line\">\t\tnewRegistration.cancel();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里是不是有点熟悉, 可以参考下<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">这里</a>, startRegistration主要是向JM发送申请成功通知, TM成功后回调JobManagerRegisteredRpcConnection.onRegistrationSuccess, 最终调用TaskExecutor.establishJobManagerConnection:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void establishJobManagerConnection(JobID jobId, final JobMasterGateway jobMasterGateway, JMTMRegistrationSuccess registrationSuccess) &#123;</div><div class=\"line\">\tif (jobManagerTable.contains(jobId)) &#123;</div><div class=\"line\">\t\tJobManagerConnection oldJobManagerConnection = jobManagerTable.get(jobId);</div><div class=\"line\"></div><div class=\"line\">\t\tif (Objects.equals(oldJobManagerConnection.getJobMasterId(), jobMasterGateway.getFencingToken())) &#123;</div><div class=\"line\">\t\t\t// we already are connected to the given job manager</div><div class=\"line\">\t\t\tlog.debug(&quot;Ignore JobManager gained leadership message for &#123;&#125; because we are already connected to it.&quot;, jobMasterGateway.getFencingToken());</div><div class=\"line\">\t\t\treturn;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tResourceID jobManagerResourceID = registrationSuccess.getResourceID();</div><div class=\"line\">\tJobManagerConnection newJobManagerConnection = associateWithJobManager(</div><div class=\"line\">\t\t\tjobId,</div><div class=\"line\">\t\t\tjobManagerResourceID,</div><div class=\"line\">\t\t\tjobMasterGateway);</div><div class=\"line\">\tjobManagerConnections.put(jobManagerResourceID, newJobManagerConnection);</div><div class=\"line\">\tjobManagerTable.put(jobId, newJobManagerConnection);  // 设置的是每个Job在TM这里的注册</div><div class=\"line\"></div><div class=\"line\">\t// monitor the job manager as heartbeat target</div><div class=\"line\">\tjobManagerHeartbeatManager.monitorTarget(jobManagerResourceID, new HeartbeatTarget&lt;AccumulatorReport&gt;() &#123;</div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void receiveHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</div><div class=\"line\">\t\t\tjobMasterGateway.heartbeatFromTaskManager(resourceID, payload);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void requestHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</div><div class=\"line\">\t\t\t// request heartbeat will never be called on the task manager side</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tofferSlotsToJobManager(jobId);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ol>\n<li>检查这个job是否已经在TM端注册了, 若注册了, 那么就直接返回</li>\n<li>否则建立job-&gt;JobManagerConnection, 将映射关系放入TaskExecutor的jobManagerTable中, 然后监控这个job master。</li>\n<li>调用offerSlotsToJobManager, 告诉JM, 分配给Task这个slot。</li>\n</ol>\n<h4 id=\"JobManager端没有TM注册的可用slot\"><a href=\"#JobManager端没有TM注册的可用slot\" class=\"headerlink\" title=\"JobManager端没有TM注册的可用slot\"></a>JobManager端没有TM注册的可用slot</h4><p>若没有可用slot的话, 那么就只能去申请TM, 申请的TM会上报可用slot, 然后再向这个TM申请部署SubTask, 此时就回到了有可用slot的情况了。我们看下是如何申请TM的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">   // //resource 是当前申请的container情况，比如&lt;memory:6552, vCores:4&gt;</div><div class=\"line\">   private void requestYarnContainer(Resource resource, Priority priority) &#123;</div><div class=\"line\">       //获取当前实际正在申请的slot个数</div><div class=\"line\">\tint pendingSlotRequests = getNumberPendingSlotRequests();</div><div class=\"line\">\t// 通过当前正在申请的Contaainer个数*numberOfTaskSlots计算出预计当前正在申请的slot个数</div><div class=\"line\">\tint pendingSlotAllocation = numPendingContainerRequests * numberOfTaskSlots;</div><div class=\"line\">\t//若当前实际申请的slot个数 &gt; 预计申请的slot个数, 那么需要去申请新的container, 来满足实际申请的slot个数</div><div class=\"line\">\tif (pendingSlotRequests &gt; pendingSlotAllocation) &#123;</div><div class=\"line\">\t    // 向yarn 发送申请container的请求。</div><div class=\"line\">\t\tresourceManagerClient.addContainerRequest(new AMRMClient.ContainerRequest(resource, null, null, priority));</div><div class=\"line\">\t\tresourceManagerClient.setHeartbeatInterval(FAST_YARN_HEARTBEAT_INTERVAL_MS);</div><div class=\"line\">\t\t//正在申请的container统计自增</div><div class=\"line\">\t\tnumPendingContainerRequests++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"申请container成功\"><a href=\"#申请container成功\" class=\"headerlink\" title=\"申请container成功\"></a>申请container成功</h3><p>当向yarn成功申请到container之后, 会回调YarnResourceManager.onContainersAllocated通知jobManager。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onContainersAllocated(List&lt;Container&gt; containers) &#123;</div><div class=\"line\">\trunAsync(() -&gt; &#123;</div><div class=\"line\">\t\tfor (Container container : containers) &#123;</div><div class=\"line\">\t\t\tif (numPendingContainerRequests &gt; 0) &#123;</div><div class=\"line\">\t\t\t\tnumPendingContainerRequests--;</div><div class=\"line\">\t\t\t\tfinal String containerIdStr = container.getId().toString();</div><div class=\"line\">\t\t\t\tfinal ResourceID resourceId = new ResourceID(containerIdStr);</div><div class=\"line\">\t\t\t\tworkerNodeMap.put(resourceId, new YarnWorkerNode(container));</div><div class=\"line\">\t\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\t\t// 产生tm启动命令</div><div class=\"line\">\t\t\t\t\tContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(</div><div class=\"line\">\t\t\t\t\t\tcontainer.getResource(),</div><div class=\"line\">\t\t\t\t\t\tcontainerIdStr,</div><div class=\"line\">\t\t\t\t\t\tcontainer.getNodeId().getHost());</div><div class=\"line\">                      // 启动TaskManager</div><div class=\"line\">\t\t\t\t\tnodeManagerClient.startContainer(container, taskExecutorLaunchContext);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t// if we are waiting for no further containers, we can go to the</div><div class=\"line\">\t\t// regular heartbeat interval</div><div class=\"line\">\t\tif (numPendingContainerRequests &lt;= 0) &#123;</div><div class=\"line\">\t\t\tresourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>回调函数主要做了如下逻辑:</p>\n<ol>\n<li>确定启动taskManager的命令。</li>\n<li>通过yarn启动taskManager。<br>我们来放一张整体JobManager端分配Slot的流程图:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate1.png\" height=\"300\" width=\"800\"></li>\n</ol>\n<h2 id=\"部署subTask到对应的slot\"><a href=\"#部署subTask到对应的slot\" class=\"headerlink\" title=\"部署subTask到对应的slot\"></a>部署subTask到对应的slot</h2><p>当确定好subTask部署到一个TaskManager的slot上之后, 在scheduleEager中就开始调用Execution.deploy()进行部署。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void deploy() throws JobException &#123;</div><div class=\"line\">\t\tfinal LogicalSlot slot  = assignedResource;  // SingleLogicalSlot</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tfinal TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(</div><div class=\"line\">\t\t\t\tattemptId,</div><div class=\"line\">\t\t\t\tslot, // SingleLogicalSlot</div><div class=\"line\">\t\t\t\ttaskRestore,</div><div class=\"line\">\t\t\t\tattemptNumber);</div><div class=\"line\">\t\t\t// null taskRestore to let it be GC&apos;ed</div><div class=\"line\">\t\t\ttaskRestore = null;</div><div class=\"line\">\t\t\tfinal TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();</div><div class=\"line\">\t\t\tfinal CompletableFuture&lt;Acknowledge&gt; submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">    public CompletableFuture&lt;Acknowledge&gt; submitTask(TaskDeploymentDescriptor tdd, Time timeout) &#123;</div><div class=\"line\">        // 实际会去调用AkkaInvocationHandler，而去和tm通信，而不是跑到TaskExecutor.submitTask</div><div class=\"line\">\t\treturn taskExecutorGateway.submitTask(tdd, jobMasterId, timeout);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ul>\n<li>首先生成TaskDeploymentDescriptor, 包含部署subTask的所有信息。</li>\n<li>调用taskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask, JM接收RPC可参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/\">link原理-Akka通信原理</a> 。<br>TaskManager端通过TaskExecutor.subTask()接受到JobManager发出的部署SubTask的申请, 这样就完成SubTask部署了。</li>\n</ul>\n<h1 id=\"SlotSharingGroup及共享slot\"><a href=\"#SlotSharingGroup及共享slot\" class=\"headerlink\" title=\"SlotSharingGroup及共享slot\"></a>SlotSharingGroup及共享slot</h1><p>Flink 允许相同SlotSharingGroup的subTask共享同一个slot, 好处主要有俩:</p>\n<ul>\n<li>A Flink cluster needs exactly as many task slots as the highest parallelism used in the job. No need to calculate how many tasks (with varying parallelism) a program contains in total.</li>\n<li>It is easier to get better resource utilization. Without slot sharing, the non-intensive source/map() subtasks would block as many resources as the resource intensive window subtasks. With slot sharing, increasing the base parallelism in our example from two to six yields full utilization of the slotted resources, while making sure that the heavy subtasks are fairly distributed among the TaskManagers.<br>默认情况下, SubTask使用相同的slot共享组: Default, task共享slot过程可以参考:<a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html#task-slots-and-resources\" target=\"_blank\" rel=\"external\">如何共享slot</a><br>这里将阐述SlotSharingGroup是如何生成并起作用的:<br>在JobGraph产生的时候调用setSlotSharingAndCoLocation()函数:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setSlotSharingAndCoLocation() &#123;</div><div class=\"line\">\tfinal HashMap&lt;String, SlotSharingGroup&gt; slotSharingGroups = new HashMap&lt;&gt;();</div><div class=\"line\">\tfor (Entry&lt;Integer, JobVertex&gt; entry : jobVertices.entrySet()) &#123;</div><div class=\"line\">\t\tfinal StreamNode node = streamGraph.getStreamNode(entry.getKey());</div><div class=\"line\">\t\tfinal JobVertex vertex = entry.getValue();// slotSharingGroupKey为默认值default</div><div class=\"line\">\t\tfinal String slotSharingGroupKey = node.getSlotSharingGroup();</div><div class=\"line\">\t\tfinal SlotSharingGroup sharingGroup;</div><div class=\"line\">\t\tif (slotSharingGroupKey != null) &#123;</div><div class=\"line\">\t\t    // 可以看到, 所有的task的group都为default, 都将放入到同一个SlotSharingGroup中</div><div class=\"line\">\t\t\tsharingGroup = slotSharingGroups.computeIfAbsent(slotSharingGroupKey, (k) -&gt; new SlotSharingGroup());</div><div class=\"line\">\t\t\tvertex.setSlotSharingGroup(sharingGroup);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tsharingGroup = null;</div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样, 所有的JobVertex都引用了同一个SlotSharingGroup。 而<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void setSlotSharingGroup(SlotSharingGroup grp) &#123;</div><div class=\"line\">\tif (this.slotSharingGroup != null) &#123;</div><div class=\"line\">\t\tthis.slotSharingGroup.removeVertexFromGroup(id);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tthis.slotSharingGroup = grp;</div><div class=\"line\">\tif (grp != null) &#123;</div><div class=\"line\">\t\tgrp.addVertexToGroup(id);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每个共享组的id都是相同的。</p>\n<h1 id=\"MultiTaskSlot及SingleTaskSlot\"><a href=\"#MultiTaskSlot及SingleTaskSlot\" class=\"headerlink\" title=\"MultiTaskSlot及SingleTaskSlot\"></a>MultiTaskSlot及SingleTaskSlot</h1><p>MultiTaskSlot及SingleTaskSlot都继承TaskSlot, 每当subTask申请到一个未被共享的slot时, 就会产生一个MultiTaskSlot, 它代表着一个TM上的slot, 管理着该slot被共享的情况。 实际分配给每个subTask时, 会单独产生一个SingleTaskSlot, 然后每次被MultiTaskSlot管理着。之后若共享slot时, 分配到的都是同一个MultiTaskSlot, 不同的是每次每次分配都产生新的SingleTaskSlot。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html\" target=\"_blank\" rel=\"external\">https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html</a><br><a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html\" target=\"_blank\" rel=\"external\">https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html</a><br><a href=\"http://wuchong.me/blog/2016/05/03/flink-internals-overview/\" target=\"_blank\" rel=\"external\">http://wuchong.me/blog/2016/05/03/flink-internals-overview/</a><br><a href=\"http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/\" target=\"_blank\" rel=\"external\">http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文将从ExecutionGraph开始向后讲起, ExecutionGraph定义了Job的并发逻辑结构, 作为任务执行的以后一层逻辑结构, 也是最核心数据结构。为了让大家有全局的了解, 先盗一张广为引用的Graph转换图:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_Graph.png\" height=\"900\" width=\"800\"><br>具体来说, 本文讲述在JobManager端subTask申请slot以及部署到TaskManager上的过程。</p>\n<h1 id=\"Task分配slot及部署\"><a href=\"#Task分配slot及部署\" class=\"headerlink\" title=\"Task分配slot及部署\"></a>Task分配slot及部署</h1><p>代码将从ExecutionGraph.scheduleExecutionGraph()开始讲解, 进入:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void scheduleForExecution() throws JobException &#123;</div><div class=\"line\">\tfinal long currentGlobalModVersion = globalModVersion;</div><div class=\"line\">\tif (transitionState(JobStatus.CREATED, JobStatus.RUNNING)) &#123;</div><div class=\"line\">\t\tfinal CompletableFuture&lt;Void&gt; newSchedulingFuture;</div><div class=\"line\">\t\tswitch (scheduleMode) &#123;</div><div class=\"line\">\t\t\tcase LAZY_FROM_SOURCES:</div><div class=\"line\">\t\t\t\tnewSchedulingFuture = scheduleLazy(slotProvider);</div><div class=\"line\">\t\t\t\tbreak;</div><div class=\"line\">\t\t\tcase EAGER:</div><div class=\"line\">\t\t\t\tnewSchedulingFuture = scheduleEager(slotProvider, allocationTimeout);</div><div class=\"line\">\t\t\t\tbreak;</div><div class=\"line\">\t\t\tdefault:</div><div class=\"line\">\t\t\t\tthrow new JobException(&quot;Schedule mode is invalid.&quot;);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中, scheduleMode分EAGER和LAZY_FROM_SOURCES, EAGER表示立刻去调度部署所有的Task。实际scheduleMode是从JobGraph.getScheduleMode()取值的, 为eager。<br>我们再进入scheduleEager看是如何调度task的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">   private CompletableFuture&lt;Void&gt; scheduleEager(SlotProvider slotProvider, final Time timeout) &#123;</div><div class=\"line\">    ......</div><div class=\"line\">\t //都是每个JobGraph</div><div class=\"line\">\tfor (ExecutionJobVertex ejv : getVerticesTopologically()) &#123;</div><div class=\"line\">\t\t// these calls are not blocking, they only return futures</div><div class=\"line\">\t\tCollection&lt;CompletableFuture&lt;Execution&gt;&gt; allocationFutures = ejv.allocateResourcesForAll(</div><div class=\"line\">\t\t\tslotProvider, // SlotPool$ProviderAndOwner</div><div class=\"line\">\t\t\tqueued,</div><div class=\"line\">\t\t\tLocationPreferenceConstraint.ALL,</div><div class=\"line\">\t\t\tallPreviousAllocationIds,</div><div class=\"line\">\t\t\ttimeout);</div><div class=\"line\">\t\tallAllocationFutures.addAll(allocationFutures);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t//只有当所有Execution都分配到了槽位才继续进行部署</div><div class=\"line\">\tfinal ConjunctFuture&lt;Collection&lt;Execution&gt;&gt; allAllocationsFuture = FutureUtils.combineAll(allAllocationFutures);</div><div class=\"line\">\tfinal CompletableFuture&lt;Void&gt; currentSchedulingFuture = allAllocationsFuture</div><div class=\"line\">\t\t.thenAccept(</div><div class=\"line\">\t\t\t(Collection&lt;Execution&gt; executionsToDeploy) -&gt; &#123;</div><div class=\"line\">\t\t\t\tfor (Execution execution : executionsToDeploy) &#123;</div><div class=\"line\">\t\t\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\t\t   // 最后挨个调用execution.deploy()进行部署子task，部署的模式是发送命令到</div><div class=\"line\">\t\t\t\t\t   execution.deploy();</div><div class=\"line\">\t\t\t\t\t&#125; catch (Throwable t) &#123;</div><div class=\"line\">\t\t\t\t\t   ......</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;)</div><div class=\"line\">\t\t......</div><div class=\"line\">\treturn currentSchedulingFuture;</div><div class=\"line\">&#125;`</div></pre></td></tr></table></figure></p>\n<p>scheduleEager主要做了两件事:</p>\n<ul>\n<li>通过allocateResourcesForAll确定每个subTask将要部署的slot。若没有合适的TaskManager, 那么通过yarn去申请TaskManager。</li>\n<li>当所有的subTask都确定好部署TaskManager的slot后, 通过execution.deploy()将subTask部署上去。<br>接下来, 将分别围绕这两件事讲解。<h2 id=\"确定subTask分配的slot\"><a href=\"#确定subTask分配的slot\" class=\"headerlink\" title=\"确定subTask分配的slot\"></a>确定subTask分配的slot</h2>通过getVerticesTopologically()获取所有的ExecutionJobVertex, 然后依次轮询给每个ExecutionJobVertex都分配一个slot, 其中轮询的ExecutionJobVertex是有先后顺序的, 从source开始分配slot, 直到sink。后面可以看到, 上游分配到哪个tm上, 会影响下游的slot分配。 我们进入allocateResourcesForAll看下是如何给一个ExecutionJobVertex所有的subTask分配slot的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public Collection&lt;CompletableFuture&lt;Execution&gt;&gt; allocateResourcesForAll(</div><div class=\"line\">\t\tSlotProvider resourceProvider, // SlotPool$ProviderAndOwner</div><div class=\"line\">\t\tboolean queued,  //true</div><div class=\"line\">\t\tLocationPreferenceConstraint locationPreferenceConstraint, //ALL</div><div class=\"line\">\t\t@Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds,</div><div class=\"line\">\t\tTime allocationTimeout) &#123;</div><div class=\"line\">\tfinal ExecutionVertex[] vertices = this.taskVertices;</div><div class=\"line\">\tfinal CompletableFuture&lt;Execution&gt;[] slots = new CompletableFuture[vertices.length];</div><div class=\"line\">\tfor (int i = 0; i &lt; vertices.length; i++) &#123;</div><div class=\"line\">\t\tfinal Execution exec = vertices[i].getCurrentExecutionAttempt();</div><div class=\"line\">\t\tfinal CompletableFuture&lt;Execution&gt; allocationFuture = exec.allocateAndAssignSlotForExecution(</div><div class=\"line\">\t\t\tresourceProvider,</div><div class=\"line\">\t\t\tqueued,</div><div class=\"line\">\t\t\tlocationPreferenceConstraint,</div><div class=\"line\">\t\t\tallPreviousExecutionGraphAllocationIds,</div><div class=\"line\">\t\t\tallocationTimeout);</div><div class=\"line\">\t\tslots[i] = allocationFuture;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn Arrays.asList(slots);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每一个ExecutionJobVertex都对应着一批ExecutionVertex(也就是subTask), 可以看到, 这里轮询每个ExecutionVertex进行申请一个slot。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public CompletableFuture&lt;Execution&gt; allocateAndAssignSlotForExecution(</div><div class=\"line\">\t\tSlotProvider slotProvider, //SlotPool$ProviderAndOwner</div><div class=\"line\">\t\tboolean queued,</div><div class=\"line\">\t\tLocationPreferenceConstraint locationPreferenceConstraint,  //ALL</div><div class=\"line\">\t\t@Nonnull Set&lt;AllocationID&gt; allPreviousExecutionGraphAllocationIds,</div><div class=\"line\">\t\tTime allocationTimeout) throws IllegalExecutionStateException &#123;</div><div class=\"line\">\tfinal SlotSharingGroup sharingGroup = vertex.getJobVertex().getSlotSharingGroup();</div><div class=\"line\">\tif (transitionState(CREATED, SCHEDULED)) &#123;</div><div class=\"line\">\t    // 默认情况下, 所有的subTask的共享组均为default</div><div class=\"line\">\t\tfinal SlotSharingGroupId slotSharingGroupId = sharingGroup != null ? sharingGroup.getSlotSharingGroupId() : null;</div><div class=\"line\">\t\t/** 获取subTask即将分配的&quot;偏好位置集合&quot;，也就是分配时，优先考虑分配在这些节点上，一般是input节点所在节点 */</div><div class=\"line\">\t\tfinal CompletableFuture&lt;Collection&lt;TaskManagerLocation&gt;&gt; preferredLocationsFuture = calculatePreferredLocations(locationPreferenceConstraint);</div><div class=\"line\">\t    //上游子task地方全部确定了，才能继续确定下游子task位置</div><div class=\"line\">\t\tfinal SlotRequestId slotRequestId = new SlotRequestId();</div><div class=\"line\">\t\tfinal CompletableFuture&lt;LogicalSlot&gt; logicalSlotFuture = preferredLocationsFuture</div><div class=\"line\">\t\t\t.thenCompose(</div><div class=\"line\">\t\t\t\t(Collection&lt;TaskManagerLocation&gt; preferredLocations) -&gt;</div><div class=\"line\">\t\t\t\t\tslotProvider.allocateSlot(//SlotPool$ProviderAndOwner</div><div class=\"line\">\t\t\t\t\t\tslotRequestId,</div><div class=\"line\">\t\t\t\t\t\ttoSchedule,</div><div class=\"line\">\t\t\t\t\t\tqueued,</div><div class=\"line\">\t\t\t\t\t\tnew SlotProfile(</div><div class=\"line\">\t\t\t\t\t\t\tResourceProfile.UNKNOWN,</div><div class=\"line\">\t\t\t\t\t\t\tpreferredLocations,</div><div class=\"line\">\t\t\t\t\t\t\tpreviousAllocationIDs,</div><div class=\"line\">\t\t\t\t\t\t\tallPreviousExecutionGraphAllocationIds),</div><div class=\"line\">\t\t\t\t\t\tallocationTimeout));</div><div class=\"line\">\t\treturn logicalSlotFuture.thenApply(</div><div class=\"line\">\t\t\t(LogicalSlot logicalSlot) -&gt; &#123;</div><div class=\"line\">\t\t\t    //</div><div class=\"line\">\t\t\t\tif (tryAssignResource(logicalSlot)) &#123;</div><div class=\"line\">\t\t\t\t\treturn this;</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>该函数主要做了两件事情:</p>\n<ul>\n<li>在calculatePreferredLocations中确定从该subTask对应ExecutionJobVertex的所有上游中找到最合适的上游”偏向位置集合”。</li>\n<li>通过SlotPool$ProviderAndOwner.allocateSlot继续确定从”偏向位置集合”找到一个共享slot。<br>我们知道, 多个subTask允许共享slot, 细节后面会详细描述。 那么当前subTask与哪些已经分配的subTask共享slot呢? 下游subTask与哪个上游subTask共享slot呢?<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate.png\" height=\"300\" width=\"350\"></li>\n</ul>\n<p>flink会根据subTask上游slot的分配来确定当前slot的分配:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">public Collection&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; getPreferredLocationsBasedOnInputs() &#123;</div><div class=\"line\">\t\t// 如果没有输入，则返回空集合，否则，基于上游分布确定偏好位置</div><div class=\"line\">\t\tif (inputEdges == null) &#123;</div><div class=\"line\">\t\t\treturn Collections.emptySet();</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\telse &#123;</div><div class=\"line\">\t\t\tSet&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; locations = new HashSet&lt;&gt;(getTotalNumberOfParallelSubtasks());</div><div class=\"line\">\t\t\tSet&lt;CompletableFuture&lt;TaskManagerLocation&gt;&gt; inputLocations = new HashSet&lt;&gt;(getTotalNumberOfParallelSubtasks());</div><div class=\"line\">\t\t\t// go over all inputs</div><div class=\"line\">\t\t\tfor (int i = 0; i &lt; inputEdges.length; i++) &#123;</div><div class=\"line\">\t\t\t\tinputLocations.clear();</div><div class=\"line\">\t\t\t\tExecutionEdge[] sources = inputEdges[i];</div><div class=\"line\">\t\t\t\tif (sources != null) &#123;</div><div class=\"line\">\t\t\t\t\tfor (int k = 0; k &lt; sources.length; k++) &#123;</div><div class=\"line\">\t\t\t\t\t\t// 获取当前source源所属的taskManager位置</div><div class=\"line\">\t\t\t\t\t\tCompletableFuture&lt;TaskManagerLocation&gt; locationFuture = sources[k].getSource().getProducer().getCurrentTaskManagerLocationFuture();</div><div class=\"line\">\t\t\t\t\t\t// add input location</div><div class=\"line\">\t\t\t\t\t\tinputLocations.add(locationFuture);</div><div class=\"line\">\t\t\t\t\t\t// inputs which have too many distinct sources are not considered</div><div class=\"line\">\t\t\t\t\t\t// 如果某个输入源有太多的节点分布，则不考虑这个输入源的节点位置了</div><div class=\"line\">\t\t\t\t\t\tif (inputLocations.size() &gt; MAX_DISTINCT_LOCATIONS_TO_CONSIDER) &#123;</div><div class=\"line\">\t\t\t\t\t\t\tinputLocations.clear();</div><div class=\"line\">\t\t\t\t\t\t\tbreak;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;// 保留具有最少分布位置的输入的位置</div><div class=\"line\">\t\t\t\t// keep the locations of the input with the least preferred locations</div><div class=\"line\">\t\t\t\tif (locations.isEmpty() || // nothing assigned yet  第一个source</div><div class=\"line\">\t\t\t\t        // 找到上游节点所处tm最少的的那个上游</div><div class=\"line\">\t\t\t\t\t\t(!inputLocations.isEmpty() &amp;&amp; inputLocations.size() &lt; locations.size())) &#123;</div><div class=\"line\">\t\t\t\t\tlocations.clear();</div><div class=\"line\">\t\t\t\t\tlocations.addAll(inputLocations);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t\treturn locations.isEmpty() ? Collections.emptyList() : locations;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>处理过程如下:</p>\n<ul>\n<li>若该ExecutionVertex没有上游(例如source), 那么返回为空, 没有”偏好位置集合”, 之后将申请新的slot。</li>\n<li>若当前ExecutionVertex有属于不同JobVertex多个ExecutionJobVertex的上游, 那么当前sub分配到哪些共享slot的可选路径只能是: 属于同一个JobVertex的上游节点个数最少。上图的话, 就会选择source2的所有subTask作为”偏好位置集合”。我们接下来看第二步, 最终会进入到allocateSharedSlot决定subTask分配到哪些”偏好位置集合”里slot上。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div></pre></td><td class=\"code\"><pre><div class=\"line\">private CompletableFuture&lt;LogicalSlot&gt; allocateSharedSlot(</div><div class=\"line\">\t\tSlotRequestId slotRequestId,</div><div class=\"line\">\t\tScheduledUnit task,</div><div class=\"line\">\t\tSlotProfile slotProfile,</div><div class=\"line\">\t\tboolean allowQueuedScheduling,</div><div class=\"line\">\t\tTime allocationTimeout) &#123;</div><div class=\"line\">\t\t// allocate slot with slot sharing</div><div class=\"line\">\t\tfinal SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(</div><div class=\"line\">\t\t\t //默认都是一个, default对应的那个</div><div class=\"line\">\t\t\ttask.getSlotSharingGroupId(),</div><div class=\"line\">\t\t\tid -&gt; new SlotSharingManager(</div><div class=\"line\">\t\t\t\tid,</div><div class=\"line\">\t\t\t\tthis,</div><div class=\"line\">\t\t\t\tproviderAndOwner));</div><div class=\"line\">\t\tfinal SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tif (task.getCoLocationConstraint() != null) &#123;</div><div class=\"line\">\t\t\t\tmultiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(</div><div class=\"line\">\t\t\t\t\ttask.getCoLocationConstraint(),</div><div class=\"line\">\t\t\t\t\tmultiTaskSlotManager,</div><div class=\"line\">\t\t\t\t\tslotProfile,</div><div class=\"line\">\t\t\t\t\tallowQueuedScheduling,</div><div class=\"line\">\t\t\t\t\tallocationTimeout);</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t     // 跑到这里</div><div class=\"line\">\t\t\t\tmultiTaskSlotLocality = allocateMultiTaskSlot(</div><div class=\"line\">\t\t\t\t\ttask.getJobVertexId(),</div><div class=\"line\">\t\t\t\t\tmultiTaskSlotManager,</div><div class=\"line\">\t\t\t\t\tslotProfile,</div><div class=\"line\">\t\t\t\t\tallowQueuedScheduling,</div><div class=\"line\">\t\t\t\t\tallocationTimeout);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tfinal SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(</div><div class=\"line\">\t\t\tslotRequestId,</div><div class=\"line\">\t\t\ttask.getJobVertexId(),</div><div class=\"line\">\t\t\tmultiTaskSlotLocality.getLocality());</div><div class=\"line\">\t\treturn leaf.getLogicalSlotFuture();</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该函数主要做了两件事:</p>\n<ol>\n<li>通过allocateMultiTaskSlot产生MultiTaskSlotLocality, 里面包含从”偏向位置集合”中选取的部署当前subTask共享的slot。</li>\n<li>产生SingleTaskSlot, 当前SingleTaskSlot作为MultiTaskSlot的一个子叶子节点。<br>再继续跟进代码前, 我们需要了解两个变量resolvedRootSlots、unresolvedRootSlots。共享slot都会从这两个变量中获取, 这两个变量为共享组所拥有, 默认共享组为default。<br>unresolvedRootSlots: 当当前subTask正在确认部署到那个slot中时, 会将该slot保存在unresolvedRootSlots; 当确定好部署到哪个slot时, 会将该信息从unresolvedRootSlots中移除, 并放入resolvedRootSlots中  当我们查找是否有可利用的slot时, 会从这些变量中查找。<br>我们再进入正题, 看allocateMultiTaskSlot看是如何给subTask分配slot的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div></pre></td><td class=\"code\"><pre><div class=\"line\">private SlotSharingManager.MultiTaskSlotLocality allocateMultiTaskSlot(</div><div class=\"line\">\t\t//groupId指的同一个JobVertex的id</div><div class=\"line\">\t\tAbstractID groupId,</div><div class=\"line\">\t\tSlotSharingManager slotSharingManager,</div><div class=\"line\">\t\tSlotProfile slotProfile,</div><div class=\"line\">\t\tboolean allowQueuedScheduling,</div><div class=\"line\">\t\tTime allocationTimeout) throws NoResourceAvailableException &#123;</div><div class=\"line\">\t//过滤&quot;偏好位置集合&quot;的位置中不属于相同groupId的位置, 这里主要是为了避免同一个ExecutionJobVertex中不同的SubTask分配到同一个slot中。</div><div class=\"line\">\t// check first whether we have a resolved root slot which we can use</div><div class=\"line\">\tSlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = slotSharingManager.getResolvedRootSlot(</div><div class=\"line\">\t\tgroupId,</div><div class=\"line\">\t\t//  LocationPreferenceSchedulingStrategy</div><div class=\"line\">\t\tschedulingStrategy,</div><div class=\"line\">\t\tslotProfile);</div><div class=\"line\">    //从&quot;偏好位置集合&quot;中到合适的slot后, 就直接返回了。</div><div class=\"line\">\tif (multiTaskSlotLocality != null &amp;&amp; multiTaskSlotLocality.getLocality() == Locality.LOCAL) &#123;</div><div class=\"line\">\t\treturn multiTaskSlotLocality;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\t......</div><div class=\"line\">\tif (allowQueuedScheduling) &#123;</div><div class=\"line\">\t\t//在unresolvedRootSlots中查找不属于同一个JobVertex的slot</div><div class=\"line\">\t\tSlotSharingManager.MultiTaskSlot multiTaskSlotFuture = slotSharingManager.getUnresolvedRootSlot(groupId);  // 为null</div><div class=\"line\">\t\tif (multiTaskSlotFuture == null) &#123;</div><div class=\"line\">\t\t\t//没有找到合适的可利用的的slot, 那么将去向ResurceNameger申请新的TaskManger, 这是最后一步</div><div class=\"line\">\t\t\tfinal CompletableFuture&lt;AllocatedSlot&gt; futureSlot = requestNewAllocatedSlot(</div><div class=\"line\">\t\t\t\tallocatedSlotRequestId,</div><div class=\"line\">\t\t\t\tslotProfile.getResourceProfile(),</div><div class=\"line\">\t\t\t\tallocationTimeout); //300s</div><div class=\"line\">\t\t\t//将新产生的futureSlot, 放入resolvedRootSlots中, 这样之后申请slot时, 该slot可以被共享。</div><div class=\"line\">\t\t\tmultiTaskSlotFuture = slotSharingManager.createRootSlot(</div><div class=\"line\">\t\t\t\tmultiTaskSlotRequestId,</div><div class=\"line\">\t\t\t\tfutureSlot,</div><div class=\"line\">\t\t\t\tallocatedSlotRequestId);</div><div class=\"line\">\t\t\tfutureSlot.whenComplete(</div><div class=\"line\">\t\t\t\t(AllocatedSlot allocatedSlot, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\t\t\tfinal SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId);</div><div class=\"line\">\t\t\t\t\tif (taskSlot != null) &#123;</div><div class=\"line\">\t\t\t\t\t\t// still valid</div><div class=\"line\">\t\t\t\t\t\tif (!(taskSlot instanceof SlotSharingManager.MultiTaskSlot) || throwable != null) &#123;</div><div class=\"line\">\t\t\t\t\t\t\ttaskSlot.release(throwable);</div><div class=\"line\">\t\t\t\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\t\t\t\tif (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) &#123;</div><div class=\"line\">\t\t\t\t\t\t\t\ttaskSlot.release(new FlinkException(&quot;Could not assign payload to allocated slot &quot; +</div><div class=\"line\">\t\t\t\t\t\t\t\t\tallocatedSlot.getAllocationId() + &apos;.&apos;));</div><div class=\"line\">\t\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t\t&#125;</div><div class=\"line\">\t\t\t\t&#125;);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\treturn SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlotFuture, Locality.UNKNOWN);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要逻辑如下:</p>\n<ul>\n<li>从resolvedRootSlots、unresolvedRootSlots中查找是否有可共享的slot。</li>\n<li>若没有, 向ResourceManager申请TaskManager以获取slot。</li>\n<li>将申请的slot信息也存放入unresolvedRootSlots中, 等成功申请后再存放入resolvedRootSlots。<br>我们再接着看是如何向ResourceManager申请TaskManager的。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private CompletableFuture&lt;AllocatedSlot&gt; requestNewAllocatedSlot(</div><div class=\"line\">\t\tSlotRequestId slotRequestId,</div><div class=\"line\">\t\tResourceProfile resourceProfile,</div><div class=\"line\">\t\tTime allocationTimeout) &#123;</div><div class=\"line\">\tfinal PendingRequest pendingRequest = new PendingRequest(</div><div class=\"line\">\t\tslotRequestId,</div><div class=\"line\">\t\tresourceProfile);</div><div class=\"line\">\t// register request timeout</div><div class=\"line\">\tFutureUtils  //30s超时</div><div class=\"line\">\t\t.orTimeout(pendingRequest.getAllocatedSlotFuture(), allocationTimeout.toMilliseconds(), TimeUnit.MILLISECONDS)</div><div class=\"line\">\t\t.whenCompleteAsync(  //当结束完成时需要做的事情</div><div class=\"line\">\t\t\t(AllocatedSlot ignored, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\t\tif (throwable instanceof TimeoutException) &#123;</div><div class=\"line\">\t\t\t\t\ttimeoutPendingSlotRequest(slotRequestId);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;,</div><div class=\"line\">\t\t\tgetMainThreadExecutor());</div><div class=\"line\">\tif (resourceManagerGateway == null) &#123;  // 为null</div><div class=\"line\">\t\tstashRequestWaitingForResourceManager(pendingRequest);  // 会跑到这里</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn pendingRequest.getAllocatedSlotFuture();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先查看resourceManagerGateway是否连接上, 若没有连接上, 将请求暂时缓存起来, 待连接上之后再申请。</li>\n<li>若已经初始化之后, 会去向ResourceManager申请TaskManager。<h3 id=\"缓存申请Slot的请求\"><a href=\"#缓存申请Slot的请求\" class=\"headerlink\" title=\"缓存申请Slot的请求\"></a>缓存申请Slot的请求</h3>大致思路是先缓存申请slot的请求, 直到flink ResourceManager注册完成后, 再去申请, 我们看下整体细节。首先去查看哪里开始对resourceManagerGateway进行初始化的。 首先回到最开始准备执行ExecutionGraph的时候:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">    private Acknowledge startJobExecution(JobMasterId newJobMasterId) throws Exception &#123;</div><div class=\"line\">\t //这里会开始尝试连接rm， 会去和resourceManager建立联系</div><div class=\"line\">\tstartJobMasterServices();</div><div class=\"line\">\tresetAndScheduleExecutionGraph();</div><div class=\"line\">    &#125;</div><div class=\"line\">    private void startJobMasterServices() throws Exception &#123;</div><div class=\"line\">\tslotPool.start(getFencingToken(), getAddress());</div><div class=\"line\">\t// 这里比较重要，会进去启动申请tm的请求</div><div class=\"line\">\treconnectToResourceManager(new FlinkException(&quot;Starting JobMaster component.&quot;));</div><div class=\"line\">\t// StandaloneLeaderRetrievalService</div><div class=\"line\">\tresourceManagerLeaderRetriever.start(new ResourceManagerLeaderListener());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在reconnectToResourceManager中, 会去尝试初始化, 调用connectToResourceManager:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void connectToResourceManager() &#123;</div><div class=\"line\">\t\tresourceManagerConnection = new ResourceManagerConnection( //很重要</div><div class=\"line\">\t\t\tlog,</div><div class=\"line\">\t\t\tjobGraph.getJobID(),</div><div class=\"line\">\t\t\tresourceId,</div><div class=\"line\">\t\t\tgetAddress(),</div><div class=\"line\">\t\t\tgetFencingToken(),</div><div class=\"line\">\t\t\tresourceManagerAddress.getAddress(),</div><div class=\"line\">\t\t\tresourceManagerAddress.getResourceManagerId(),</div><div class=\"line\">\t\t\tscheduledExecutorService);</div><div class=\"line\">\t\tresourceManagerConnection.start();  //从这里进去，获取注册ResourceManger</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>在ResourceManagerConnection中定义了onRegistrationSuccess, 会去调用establishResourceManagerConnection()函数, 我们进入resourceManagerConnection.start()看下如何建立注册的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void start() &#123;</div><div class=\"line\">       // ResourceManagerConnection</div><div class=\"line\">       final RetryingRegistration&lt;F, G, S&gt; newRegistrationn = createNewRegistration();</div><div class=\"line\">\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</div><div class=\"line\">\t    //会从这里进去，很重要，比如注册ResourceManager</div><div class=\"line\">\t\tnewRegistration.startRegistration();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在createNewRegistration中, 新建注册:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private RetryingRegistration&lt;F, G, S&gt; createNewRegistration() &#123;</div><div class=\"line\">\tRetryingRegistration&lt;F, G, S&gt; newRegistration = checkNotNull(generateRegistration());  //跑进去</div><div class=\"line\">\tCompletableFuture&lt;Tuple2&lt;G, S&gt;&gt; future = newRegistration.getFuture();</div><div class=\"line\">\tfuture.whenCompleteAsync(</div><div class=\"line\">\t\t(Tuple2&lt;G, S&gt; result, Throwable failure) -&gt; &#123;</div><div class=\"line\">\t\t\tif (failure != null) &#123;</div><div class=\"line\">\t\t\t......</div><div class=\"line\">\t\t\t&#125; else &#123;</div><div class=\"line\">\t\t\t\ttargetGateway = result.f0;</div><div class=\"line\">\t\t\t\t//注意进来，进行pending task分配，调用ResourceManagerConnection.onRegistrationSuccess()</div><div class=\"line\">\t\t\t\tonRegistrationSuccess(result.f1);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;, executor);</div><div class=\"line\">\treturn newRegistration;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当注册完成并且没有抛出异常时, 说明注册完成了, 则调用之前的ResourceManagerConnection.onRegistrationSuccess()进行连接, 最终会进去SlotPool.connectToResourceManager()<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void connectToResourceManager(ResourceManagerGateway resourceManagerGateway) &#123;</div><div class=\"line\">\t\t// 开始申请之前被pending的请求</div><div class=\"line\">\t\tfor (PendingRequest pendingRequest : waitingForResourceManager.values()) &#123;</div><div class=\"line\">\t\t\trequestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\twaitingForResourceManager.clear();</div><div class=\"line\">\t&#125;</div></pre></td></tr></table></figure></p>\n<p>当完成flink ResourceManager注册、连接后, 我们会逐个申请之前被挂起的请求。然后开始走之后描述的正常申请slot流程。</p>\n<h3 id=\"向ResourceManager申请slot\"><a href=\"#向ResourceManager申请slot\" class=\"headerlink\" title=\"向ResourceManager申请slot\"></a>向ResourceManager申请slot</h3><p>从requestSlotFromResourceManager()中最终会进入registerSlotRequest<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public boolean registerSlotRequest(SlotRequest slotRequest) throws SlotManagerException &#123;</div><div class=\"line\">    PendingSlotRequest pendingSlotRequest = new PendingSlotRequest(slotRequest);</div><div class=\"line\">\tpendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t    internalRequestSlot(pendingSlotRequest);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn true;</div><div class=\"line\">   &#125;</div><div class=\"line\">   private void internalRequestSlot(PendingSlotRequest pendingSlotRequest) throws ResourceManagerException &#123;</div><div class=\"line\">\t//是否发现目前拥有的slot</div><div class=\"line\">\tTaskManagerSlot taskManagerSlot = findMatchingSlot(pendingSlotRequest.getResourceProfile());</div><div class=\"line\">\tif (taskManagerSlot != null) &#123;</div><div class=\"line\">\t\tallocateSlot(taskManagerSlot, pendingSlotRequest);</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\tresourceActions.allocateResource(pendingSlotRequest.getResourceProfile()); //跑到这里</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>internalRequestSlot做了如下逻辑:</p>\n<ul>\n<li>通过findMatchingSlot检查是否有现成可用的slot, 其中freeSlots包含着availiable slot. 比如在每当有新的TaskManager向JobManager注册时, 就会调用SlotManager.registerSlotRequest(), 在freeSlots中注册该TM可用的slot。若有可用slot时候, 就会调用allocateSlot进行分配。</li>\n<li>若没有可用空闲slot, 通过allocateResource申请TM, 最终会调用YarnResourceManager.requestYarnContainer进行申请。<br>我们再分别以这两种情况继续介绍。<h4 id=\"JobManager端有某个TM注册的可用slot\"><a href=\"#JobManager端有某个TM注册的可用slot\" class=\"headerlink\" title=\"JobManager端有某个TM注册的可用slot\"></a>JobManager端有某个TM注册的可用slot</h4>若JM端有某个TM注册的可用slot, 那么就会进入allocateSlot来将这个slot分配给这个SubTask:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocateSlot(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest) &#123;</div><div class=\"line\">\tTaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();</div><div class=\"line\">\tTaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();</div><div class=\"line\"></div><div class=\"line\">\tfinal CompletableFuture&lt;Acknowledge&gt; completableFuture = new CompletableFuture&lt;&gt;();</div><div class=\"line\">\tfinal AllocationID allocationId = pendingSlotRequest.getAllocationId();</div><div class=\"line\">\tfinal SlotID slotId = taskManagerSlot.getSlotId();</div><div class=\"line\">\tfinal InstanceID instanceID = taskManagerSlot.getInstanceId();</div><div class=\"line\"></div><div class=\"line\">\ttaskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);</div><div class=\"line\">\tpendingSlotRequest.setRequestFuture(completableFuture);</div><div class=\"line\"></div><div class=\"line\">\tTaskManagerRegistration taskManagerRegistration = taskManagerRegistrations.get(instanceID);</div><div class=\"line\">       // 既然这个TM上报的slot, 那么这个TM一定已经有注册信息了</div><div class=\"line\">\tif (taskManagerRegistration == null) &#123;</div><div class=\"line\">\t\tthrow new IllegalStateException(&quot;Could not find a registered task manager for instance id &quot; +</div><div class=\"line\">\t\t\tinstanceID + &apos;.&apos;);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\ttaskManagerRegistration.markUsed();</div><div class=\"line\">\t去向TM通信, 告诉TM这个slot已经被请求了</div><div class=\"line\">\t// RPC call to the task manager</div><div class=\"line\">\tCompletableFuture&lt;Acknowledge&gt; requestFuture = gateway.requestSlot(</div><div class=\"line\">\t\tslotId,</div><div class=\"line\">\t\tpendingSlotRequest.getJobId(),</div><div class=\"line\">\t\tallocationId,</div><div class=\"line\">\t\tpendingSlotRequest.getTargetAddress(),</div><div class=\"line\">\t\tresourceManagerId,</div><div class=\"line\">\t\ttaskManagerRequestTimeout);</div><div class=\"line\"></div><div class=\"line\">\trequestFuture.whenComplete(</div><div class=\"line\">\t\t(Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\tif (acknowledge != null) &#123;</div><div class=\"line\">\t\t\t\tcompletableFuture.complete(acknowledge);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tcompletableFuture.whenCompleteAsync(</div><div class=\"line\">\t\t(Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</div><div class=\"line\">\t\t\ttry &#123;  //去更新本地slot状态, 从可用空闲slot中删掉</div><div class=\"line\">\t\t\t\tif (acknowledge != null) &#123;</div><div class=\"line\">\t\t\t\t\tupdateSlot(slotId, allocationId, pendingSlotRequest.getJobId());</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125; catch (Exception e) &#123;</div><div class=\"line\">\t\t\t\tLOG.error(&quot;Error while completing the slot allocation.&quot;, e);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;,</div><div class=\"line\">\t\tmainThreadExecutor);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JM请求某个slot逻辑也比较简单:</p>\n<ol>\n<li>JM直接告诉slot对应TM, 这个slot将被申请</li>\n<li>JM修改这个slot的状态, 并且从本地可用slot中删掉。然后等待subTask被部署到这个TM的slot上<br>我们看下第一步JM是怎么告诉TM这个slot被申请的,  gateway.requestSlot直接通过RPC(通信逻辑<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">参考</a>)直接向TM的TaskExecutor.requestSlot去了, 我们看下TM是如何做处理的:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">   /**</div><div class=\"line\"> * Add the given job to be monitored. This means that the service tries to detect leaders for</div><div class=\"line\"> * this job and then tries to establish a connection to it.</div><div class=\"line\"> */</div><div class=\"line\">public CompletableFuture&lt;Acknowledge&gt; requestSlot(</div><div class=\"line\">\tfinal SlotID slotId,</div><div class=\"line\">\tfinal JobID jobId,</div><div class=\"line\">\tfinal AllocationID allocationId,</div><div class=\"line\">\tfinal String targetAddress,</div><div class=\"line\">\tfinal ResourceManagerId resourceManagerId,</div><div class=\"line\">\tfinal Time timeout) &#123;</div><div class=\"line\">\tlog.info(&quot;Receive slot request &#123;&#125; for job &#123;&#125; from resource manager with leader id &#123;&#125;.&quot;,</div><div class=\"line\">\t\tallocationId, jobId, resourceManagerId);</div><div class=\"line\">\ttry &#123;</div><div class=\"line\">\t\tif (taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</div><div class=\"line\">\t\t\tif (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) &#123;</div><div class=\"line\">\t\t\t\tlog.info(&quot;Allocated slot for &#123;&#125;.&quot;, allocationId);</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\tif (jobManagerTable.contains(jobId)) &#123;</div><div class=\"line\">\t\t\tofferSlotsToJobManager(jobId);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\tjobLeaderService.addJob(jobId, targetAddress);  // 跑进去</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\treturn CompletableFuture.completedFuture(Acknowledge.get());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要逻辑如下:</p>\n<ol>\n<li>TM接收到JM的请求后, TM首先检查这个slot是否是空闲的, 若空闲的话, 就开始调用taskSlotTable.allocateSlot(), 将这个slot置为已分配。</li>\n<li>TM调用jobLeaderService.addJob将这个Job监控起来(每当有新的Job请求slot, 就会去检测job的leader, 并去和这个job leader建立链接),最终调用JobManagerLeaderListener.notifyLeaderAddress()-&gt;JobManagerRegisteredRpcConnection.start():<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void start() &#123;</div><div class=\"line\">\tcheckState(!closed, &quot;The RPC connection is already closed&quot;);</div><div class=\"line\">\tcheckState(!isConnected() &amp;&amp; pendingRegistration == null, &quot;The RPC connection is already started&quot;);</div><div class=\"line\">\tfinal RetryingRegistration&lt;F, G, S&gt; newRegistration = createNewRegistration();</div><div class=\"line\">\tif (REGISTRATION_UPDATER.compareAndSet(this, null, newRegistration)) &#123;</div><div class=\"line\">\t\tnewRegistration.startRegistration();</div><div class=\"line\">\t&#125; else &#123;</div><div class=\"line\">\t\t// concurrent start operation</div><div class=\"line\">\t\tnewRegistration.cancel();</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里是不是有点熟悉, 可以参考下<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/#TM%E5%90%91JM%E6%B3%A8%E5%86%8C\">这里</a>, startRegistration主要是向JM发送申请成功通知, TM成功后回调JobManagerRegisteredRpcConnection.onRegistrationSuccess, 最终调用TaskExecutor.establishJobManagerConnection:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void establishJobManagerConnection(JobID jobId, final JobMasterGateway jobMasterGateway, JMTMRegistrationSuccess registrationSuccess) &#123;</div><div class=\"line\">\tif (jobManagerTable.contains(jobId)) &#123;</div><div class=\"line\">\t\tJobManagerConnection oldJobManagerConnection = jobManagerTable.get(jobId);</div><div class=\"line\"></div><div class=\"line\">\t\tif (Objects.equals(oldJobManagerConnection.getJobMasterId(), jobMasterGateway.getFencingToken())) &#123;</div><div class=\"line\">\t\t\t// we already are connected to the given job manager</div><div class=\"line\">\t\t\tlog.debug(&quot;Ignore JobManager gained leadership message for &#123;&#125; because we are already connected to it.&quot;, jobMasterGateway.getFencingToken());</div><div class=\"line\">\t\t\treturn;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tResourceID jobManagerResourceID = registrationSuccess.getResourceID();</div><div class=\"line\">\tJobManagerConnection newJobManagerConnection = associateWithJobManager(</div><div class=\"line\">\t\t\tjobId,</div><div class=\"line\">\t\t\tjobManagerResourceID,</div><div class=\"line\">\t\t\tjobMasterGateway);</div><div class=\"line\">\tjobManagerConnections.put(jobManagerResourceID, newJobManagerConnection);</div><div class=\"line\">\tjobManagerTable.put(jobId, newJobManagerConnection);  // 设置的是每个Job在TM这里的注册</div><div class=\"line\"></div><div class=\"line\">\t// monitor the job manager as heartbeat target</div><div class=\"line\">\tjobManagerHeartbeatManager.monitorTarget(jobManagerResourceID, new HeartbeatTarget&lt;AccumulatorReport&gt;() &#123;</div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void receiveHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</div><div class=\"line\">\t\t\tjobMasterGateway.heartbeatFromTaskManager(resourceID, payload);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\"></div><div class=\"line\">\t\t@Override</div><div class=\"line\">\t\tpublic void requestHeartbeat(ResourceID resourceID, AccumulatorReport payload) &#123;</div><div class=\"line\">\t\t\t// request heartbeat will never be called on the task manager side</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\"></div><div class=\"line\">\tofferSlotsToJobManager(jobId);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ol>\n<li>检查这个job是否已经在TM端注册了, 若注册了, 那么就直接返回</li>\n<li>否则建立job-&gt;JobManagerConnection, 将映射关系放入TaskExecutor的jobManagerTable中, 然后监控这个job master。</li>\n<li>调用offerSlotsToJobManager, 告诉JM, 分配给Task这个slot。</li>\n</ol>\n<h4 id=\"JobManager端没有TM注册的可用slot\"><a href=\"#JobManager端没有TM注册的可用slot\" class=\"headerlink\" title=\"JobManager端没有TM注册的可用slot\"></a>JobManager端没有TM注册的可用slot</h4><p>若没有可用slot的话, 那么就只能去申请TM, 申请的TM会上报可用slot, 然后再向这个TM申请部署SubTask, 此时就回到了有可用slot的情况了。我们看下是如何申请TM的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">   // //resource 是当前申请的container情况，比如&lt;memory:6552, vCores:4&gt;</div><div class=\"line\">   private void requestYarnContainer(Resource resource, Priority priority) &#123;</div><div class=\"line\">       //获取当前实际正在申请的slot个数</div><div class=\"line\">\tint pendingSlotRequests = getNumberPendingSlotRequests();</div><div class=\"line\">\t// 通过当前正在申请的Contaainer个数*numberOfTaskSlots计算出预计当前正在申请的slot个数</div><div class=\"line\">\tint pendingSlotAllocation = numPendingContainerRequests * numberOfTaskSlots;</div><div class=\"line\">\t//若当前实际申请的slot个数 &gt; 预计申请的slot个数, 那么需要去申请新的container, 来满足实际申请的slot个数</div><div class=\"line\">\tif (pendingSlotRequests &gt; pendingSlotAllocation) &#123;</div><div class=\"line\">\t    // 向yarn 发送申请container的请求。</div><div class=\"line\">\t\tresourceManagerClient.addContainerRequest(new AMRMClient.ContainerRequest(resource, null, null, priority));</div><div class=\"line\">\t\tresourceManagerClient.setHeartbeatInterval(FAST_YARN_HEARTBEAT_INTERVAL_MS);</div><div class=\"line\">\t\t//正在申请的container统计自增</div><div class=\"line\">\t\tnumPendingContainerRequests++;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"申请container成功\"><a href=\"#申请container成功\" class=\"headerlink\" title=\"申请container成功\"></a>申请container成功</h3><p>当向yarn成功申请到container之后, 会回调YarnResourceManager.onContainersAllocated通知jobManager。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void onContainersAllocated(List&lt;Container&gt; containers) &#123;</div><div class=\"line\">\trunAsync(() -&gt; &#123;</div><div class=\"line\">\t\tfor (Container container : containers) &#123;</div><div class=\"line\">\t\t\tif (numPendingContainerRequests &gt; 0) &#123;</div><div class=\"line\">\t\t\t\tnumPendingContainerRequests--;</div><div class=\"line\">\t\t\t\tfinal String containerIdStr = container.getId().toString();</div><div class=\"line\">\t\t\t\tfinal ResourceID resourceId = new ResourceID(containerIdStr);</div><div class=\"line\">\t\t\t\tworkerNodeMap.put(resourceId, new YarnWorkerNode(container));</div><div class=\"line\">\t\t\t\ttry &#123;</div><div class=\"line\">\t\t\t\t\t// 产生tm启动命令</div><div class=\"line\">\t\t\t\t\tContainerLaunchContext taskExecutorLaunchContext = createTaskExecutorLaunchContext(</div><div class=\"line\">\t\t\t\t\t\tcontainer.getResource(),</div><div class=\"line\">\t\t\t\t\t\tcontainerIdStr,</div><div class=\"line\">\t\t\t\t\t\tcontainer.getNodeId().getHost());</div><div class=\"line\">                      // 启动TaskManager</div><div class=\"line\">\t\t\t\t\tnodeManagerClient.startContainer(container, taskExecutorLaunchContext);</div><div class=\"line\">\t\t\t\t&#125;</div><div class=\"line\">\t\t\t&#125;</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t\t// if we are waiting for no further containers, we can go to the</div><div class=\"line\">\t\t// regular heartbeat interval</div><div class=\"line\">\t\tif (numPendingContainerRequests &lt;= 0) &#123;</div><div class=\"line\">\t\t\tresourceManagerClient.setHeartbeatInterval(yarnHeartbeatIntervalMillis);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>回调函数主要做了如下逻辑:</p>\n<ol>\n<li>确定启动taskManager的命令。</li>\n<li>通过yarn启动taskManager。<br>我们来放一张整体JobManager端分配Slot的流程图:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Flink_slot_allocate1.png\" height=\"300\" width=\"800\"></li>\n</ol>\n<h2 id=\"部署subTask到对应的slot\"><a href=\"#部署subTask到对应的slot\" class=\"headerlink\" title=\"部署subTask到对应的slot\"></a>部署subTask到对应的slot</h2><p>当确定好subTask部署到一个TaskManager的slot上之后, 在scheduleEager中就开始调用Execution.deploy()进行部署。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void deploy() throws JobException &#123;</div><div class=\"line\">\t\tfinal LogicalSlot slot  = assignedResource;  // SingleLogicalSlot</div><div class=\"line\">\t\ttry &#123;</div><div class=\"line\">\t\t\tfinal TaskDeploymentDescriptor deployment = vertex.createDeploymentDescriptor(</div><div class=\"line\">\t\t\t\tattemptId,</div><div class=\"line\">\t\t\t\tslot, // SingleLogicalSlot</div><div class=\"line\">\t\t\t\ttaskRestore,</div><div class=\"line\">\t\t\t\tattemptNumber);</div><div class=\"line\">\t\t\t// null taskRestore to let it be GC&apos;ed</div><div class=\"line\">\t\t\ttaskRestore = null;</div><div class=\"line\">\t\t\tfinal TaskManagerGateway taskManagerGateway = slot.getTaskManagerGateway();</div><div class=\"line\">\t\t\tfinal CompletableFuture&lt;Acknowledge&gt; submitResultFuture = taskManagerGateway.submitTask(deployment, rpcTimeout);</div><div class=\"line\">\t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">    public CompletableFuture&lt;Acknowledge&gt; submitTask(TaskDeploymentDescriptor tdd, Time timeout) &#123;</div><div class=\"line\">        // 实际会去调用AkkaInvocationHandler，而去和tm通信，而不是跑到TaskExecutor.submitTask</div><div class=\"line\">\t\treturn taskExecutorGateway.submitTask(tdd, jobMasterId, timeout);</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到:</p>\n<ul>\n<li>首先生成TaskDeploymentDescriptor, 包含部署subTask的所有信息。</li>\n<li>调用taskManagerGateway.submitTask(deployment, rpcTimeout)进行部署subTask, JM接收RPC可参考:<a href=\"https://kkewwei.github.io/elasticsearch_learning/2019/04/20/Flink%E5%8E%9F%E7%90%86-Akka%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9D%97/\">link原理-Akka通信原理</a> 。<br>TaskManager端通过TaskExecutor.subTask()接受到JobManager发出的部署SubTask的申请, 这样就完成SubTask部署了。</li>\n</ul>\n<h1 id=\"SlotSharingGroup及共享slot\"><a href=\"#SlotSharingGroup及共享slot\" class=\"headerlink\" title=\"SlotSharingGroup及共享slot\"></a>SlotSharingGroup及共享slot</h1><p>Flink 允许相同SlotSharingGroup的subTask共享同一个slot, 好处主要有俩:</p>\n<ul>\n<li>A Flink cluster needs exactly as many task slots as the highest parallelism used in the job. No need to calculate how many tasks (with varying parallelism) a program contains in total.</li>\n<li>It is easier to get better resource utilization. Without slot sharing, the non-intensive source/map() subtasks would block as many resources as the resource intensive window subtasks. With slot sharing, increasing the base parallelism in our example from two to six yields full utilization of the slotted resources, while making sure that the heavy subtasks are fairly distributed among the TaskManagers.<br>默认情况下, SubTask使用相同的slot共享组: Default, task共享slot过程可以参考:<a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html#task-slots-and-resources\" target=\"_blank\" rel=\"external\">如何共享slot</a><br>这里将阐述SlotSharingGroup是如何生成并起作用的:<br>在JobGraph产生的时候调用setSlotSharingAndCoLocation()函数:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void setSlotSharingAndCoLocation() &#123;</div><div class=\"line\">\tfinal HashMap&lt;String, SlotSharingGroup&gt; slotSharingGroups = new HashMap&lt;&gt;();</div><div class=\"line\">\tfor (Entry&lt;Integer, JobVertex&gt; entry : jobVertices.entrySet()) &#123;</div><div class=\"line\">\t\tfinal StreamNode node = streamGraph.getStreamNode(entry.getKey());</div><div class=\"line\">\t\tfinal JobVertex vertex = entry.getValue();// slotSharingGroupKey为默认值default</div><div class=\"line\">\t\tfinal String slotSharingGroupKey = node.getSlotSharingGroup();</div><div class=\"line\">\t\tfinal SlotSharingGroup sharingGroup;</div><div class=\"line\">\t\tif (slotSharingGroupKey != null) &#123;</div><div class=\"line\">\t\t    // 可以看到, 所有的task的group都为default, 都将放入到同一个SlotSharingGroup中</div><div class=\"line\">\t\t\tsharingGroup = slotSharingGroups.computeIfAbsent(slotSharingGroupKey, (k) -&gt; new SlotSharingGroup());</div><div class=\"line\">\t\t\tvertex.setSlotSharingGroup(sharingGroup);</div><div class=\"line\">\t\t&#125; else &#123;</div><div class=\"line\">\t\t\tsharingGroup = null;</div><div class=\"line\">\t\t&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样, 所有的JobVertex都引用了同一个SlotSharingGroup。 而<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">   public void setSlotSharingGroup(SlotSharingGroup grp) &#123;</div><div class=\"line\">\tif (this.slotSharingGroup != null) &#123;</div><div class=\"line\">\t\tthis.slotSharingGroup.removeVertexFromGroup(id);</div><div class=\"line\">\t&#125;</div><div class=\"line\">\tthis.slotSharingGroup = grp;</div><div class=\"line\">\tif (grp != null) &#123;</div><div class=\"line\">\t\tgrp.addVertexToGroup(id);</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>每个共享组的id都是相同的。</p>\n<h1 id=\"MultiTaskSlot及SingleTaskSlot\"><a href=\"#MultiTaskSlot及SingleTaskSlot\" class=\"headerlink\" title=\"MultiTaskSlot及SingleTaskSlot\"></a>MultiTaskSlot及SingleTaskSlot</h1><p>MultiTaskSlot及SingleTaskSlot都继承TaskSlot, 每当subTask申请到一个未被共享的slot时, 就会产生一个MultiTaskSlot, 它代表着一个TM上的slot, 管理着该slot被共享的情况。 实际分配给每个subTask时, 会单独产生一个SingleTaskSlot, 然后每次被MultiTaskSlot管理着。之后若共享slot时, 分配到的都是同一个MultiTaskSlot, 不同的是每次每次分配都产生新的SingleTaskSlot。</p>\n<h1 id=\"参考文档\"><a href=\"#参考文档\" class=\"headerlink\" title=\"参考文档\"></a>参考文档</h1><p><a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html\" target=\"_blank\" rel=\"external\">https://ci.apache.org/projects/flink/flink-docs-release-1.8/concepts/runtime.html</a><br><a href=\"https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html\" target=\"_blank\" rel=\"external\">https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/job_scheduling.html</a><br><a href=\"http://wuchong.me/blog/2016/05/03/flink-internals-overview/\" target=\"_blank\" rel=\"external\">http://wuchong.me/blog/2016/05/03/flink-internals-overview/</a><br><a href=\"http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/\" target=\"_blank\" rel=\"external\">http://wuchong.me/blog/2016/05/09/flink-internals-understanding-execution-resources/</a></p>\n"},{"title":"LinkedTransferQueue原理分析","date":"2018-12-15T10:59:58.000Z","toc":true,"_content":"LinkedTransferQueue作为无边界的阻塞队列, 同时继承了TransferQueue和AbstractQueue。 相较于其他的阻塞队列:  LinkedTransferQueue特殊之处在于TransferQueue接口。 TransferQueue说明如下:\n>* Transfers the element to a waiting consumer immediately, if possible. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in {@link #take} or timed {@link #poll(long,TimeUnit) poll}), otherwise returning {@code false} without enqueuing the element.\n\n说的是LinkedTransferQueue不仅实现了普通BlockingQueue的功能, 另一个优点就是: 当有消费者等待数据时, 生产者可以直接将数据交给消费者而不是再进入队列。 与LinkedBlockingQueue相比, LinkedBlockingQueue在take和put操作时, 都是通过lock来控制, 当高并发操作take和put操作, 锁的获取和释放都是比较影响性能的。 而LinkedTransferQueue对这种使用进行了改进, 当生产者存放数据时, 发现有消费者等待消费数据, 生产者可以调用transfer直接将数据交给消费者, 而不用通过阻塞队列来传递数据, 减少了锁的释放与获取。\n# LinkedTransferQueue类简介\nLinkedTransferQueue的阻塞队列的节点Node设计如下:\n```\n static final class Node {\n        // 若为true, 则说明节点是个数据节点, 否则, 则说明是个请求节点\n        final boolean isData;\n         // initially non-null if isData; CASed to match\n        volatile Object item;\n        volatile Node next;\n         // null until waiting  若不为null，则说明是reservation，有一个线程在等待\n        volatile Thread waiter;\n}\n```\nLinkedTransferQueue中的阻塞队列节点分为两种, 数据节点和请求节点。当生产者调用put时, 若没有消费者需要数据, 直接将数据存放入阻塞队列中, 那么将生成数据节点(isData=true、item为用户存放的数据, waiter为该被阻塞的线程)。当调用take节点时, 若没有数据可供取走, 那么将在阻塞队列中建立请求节点(isData=false、item为null, waiter为该被阻塞的线程)。若阻塞队列未匹配节点为请求节点, 新来的也为请求, 那么将通过尾加的方式存放; 若新来一个数据节点, 那么就可以和阻塞队列中的节点匹配, 数据就不会放到阻塞队列中。注意: 阻塞队列中未匹配节点模式一致, 而不是说阻塞队列所有节点模式一致。 阻塞队列中被匹配的节点Node变化情况如下:\n\n|阻塞队列节点被匹配前后|数据节点|阻塞节点|\n|:------:|:------:|:------:|\n|匹配前|isData=true, item=data|isData=false, item=null|\n|匹配后|isData=true, item=null|isData=false, item=this|\n由此, 无论是数据节点还是阻塞节点, 我们可以总结出如下结论:\n+ 匹配前: ((item != null) == isData ) && (item != this)\n+ 匹配后: ((item == null) == isData ) || (item == this)\n该结论将在之后的代码中可见。我们也需要了解一个概念, 匹配:阻塞队列中数据节点或者请求节点, 若没有对应的线程来消费它, 那么这个节点就是未匹配的。反之就是匹配的。被匹配过的节点会延迟脱离队列, 为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾。\n在LinkedTransferQueue从阻塞队列中存放数据的函数:\n```\n   public void put(E e) {\n        xfer(e, true, ASYNC, 0);\n   }\n   public boolean offer(E e, long timeout, TimeUnit unit) {\n        xfer(e, true, ASYNC, 0);\n        return true;\n   }\n   public boolean add(E e) {\n        xfer(e, true, ASYNC, 0);\n        return true;\n    }\n    public boolean tryTransfer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n        if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)\n            return true;\n        if (!Thread.interrupted())\n            return false;\n        throw new InterruptedException();\n    }\n```\n从阻塞队列中取数据的函数:\n```\n    public E poll() {\n        return xfer(null, false, NOW, 0);\n    }\n    public E take() throws InterruptedException {\n        E e = xfer(null, false, SYNC, 0);\n        if (e != null)\n            return e;\n        Thread.interrupted(); //清空中断， 抛出异常\n        throw new InterruptedException();\n    }\n    public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        E e = xfer(null, false, TIMED, unit.toNanos(timeout));\n        if (e != null || !Thread.interrupted())\n            return e;\n        throw new InterruptedException();\n    }\n```\n有两个点需要我们注意下:\n1. 这些函数读取/插入数据实际调用的都是xfer这一个函数, 是不是觉得很神奇, 我们将在之后详细介绍该函数的实现。\n2. xfer中区别中包含NOW, SYNC, TIMED等参数的不同。\n```\n    /*\n     * Possible values for \"how\" argument in xfer method.\n     */\n    // for untimed poll, tryTransfer  NOW就是取数据时, 发现没有数据, 线程立刻返回不追加元素到阻塞队列中等待。\n    private static final int NOW   = 0;\n\n    // for offer, put, add  ASYNC就是添加数据时, 若消费者来不及消费, 只是将数据放到阻塞队列中, 而线程正常返回。\n    //这部分是LinkedTransferQueue作为阻塞队列正常用法\n    private static final int ASYNC = 1;\n\n    // for transfer, take  SYNC用于消费/生产者存放/拉去数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程也将阻塞\n     //这部分是LinkedTransferQueue的特性所在\n    private static final int SYNC  = 2;\n\n    // for timed poll, tryTransfer  TIMED用于超时时间内读取或者存放数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程超时阻塞。\n    private static final int TIMED = 3;\n```\n\n# xfer函数\nxfer作为LinkedTransferQueue里面最核心的函数, 在读取数据都依赖它, 接下来将看具体的实现。\n```\nprivate E xfer(E e, boolean haveData, int how, long nanos) {\n        //首先检查传递的数据是否符合要求\n        if (haveData && (e == null))\n            throw new NullPointerException();\n        Node s = null;                        // the node to append, if needed\n        //这里将不断循环重试+goto跳转, 直到明确return\n        retry:\n        for (;;) {// restart on append race\n            // find & match first node, 从头开始查找\n            for (Node h = head, p = h; p != null;) {\n                boolean isData = p.isData;\n                Object item = p.item;\n                // unmatched: 若是生产者说明生产者在等待消费者拿数据; 若是消费者说明在等待生产者生产数据\n                if (item != p && (item != null) == isData) {\n                     //can't match 模式一致的话, 那么只能将\n                    if (isData == haveData)\n                        break;  //两个节点是相同类型，不用match了，去下一步\n                    // match 数据类型不同，要么放数据， 要么取数据，不成功，则循环重试\n                    1. 当生产者存放数据时, 发现队列中已经有消费者在等待了, 那么直接将数据交给消费者\n                    2. 当消费者获取数据时, 发现队列中已经有生产者在等待被消费, 那么消费者直接拿走数据。\n                    //cas成功意味着匹配完成。如果本次是请求，则item原本是数据，e就为null反之则e是数据，item原本为null\n                    if (p.casItem(item, e)) {\n                          //head指针可能在p的上游\n                        //循环的目的是：发现当前被使用的节点不是head节点, 那么就会清理head节点, 确保松弛距离<2\n                        for (Node q = p; q != h;) {\n                            Node n = q.next;  // update by 2 unless singleton\n                            //发现head还没有变化, 将head指向当前节点的下一个节点\n                            if (head == h && casHead(h, n == null ? q : n)) {\n                                //设置next等于自己，从队列中移除了，等待被GC\n                                h.forgetNext();\n                                break;\n                            }\n                             // advance and retry， 发现变化了, 则移动head ,尽量保持head与未匹配节点的距离<2\n                            if ((h = head)   == null ||\n                                  //cas 失败后则检查当前head指针距离下一个有效节点是否大于2.大于则再次循环，否则退出。头节点的松弛长度由这段代码决定。从代码上可以看出，松弛距离是2.\n                                (q = h.next) == null || !q.isMatched())\n                                break;        // 除非松弛度小于2(head节点向后到未匹配节点距离小于2才退出)\n                        }\n                        //唤醒那个节点, 若不是线程阻塞, 那么waiter将为null\n                        LockSupport.unpark(p.waiter);\n                        return LinkedTransferQueue.<E>cast(item);\n                    }\n                }\n                Node n = p.next; //找下一个节点\n                // Use head if p offlist  如果p已经脱离队列，则从head继续找\n                p = (p != n) ? n : (h = head);\n            }\n            //操作不是立刻返回的\n            if (how != NOW) {                 // No matches available\n                if (s == null)  //第一个进来的\n                    s = new Node(e, haveData);\n                 //ASYNC, SYNC, TIMED类型接口都会将请求追加到队尾，返回队列的上一个节点\n                Node pred = tryAppend(s, haveData);\n                if (pred == null)\n                    continue retry;           // lost race vs opposite mode\n                if (how != ASYNC)\n                    //只有SYNC或者TINED情况, 线程才会被阻塞。只有部分接口才会阻塞线程\n                    return awaitMatch(s, pred, e, (how == TIMED), nanos);\n            }\n            return e; // not waiting   立刻返回的，\n        }\n    }\n```\nxfer函数做了如下事情:\n+ 检查传递进来的isData与e是否匹配的。\n+ 从阻塞队列头开始进行查找是否有节点未匹配&&与本次请求匹配, 若与本次请求匹配, 本次请求直接返回, 唤醒睡眠的那个线程(有线程睡眠), 同时清理队列, 保持head与未匹配节点的距离<2(松弛距离)。\n+ 若发现队列第一个未匹配节点与本次请求模式一致的, 本请求将会加入阻塞队列中(tryAppend)。\n+ 若请求类型是异步或者超时等待的, 那么将同时阻塞线程(awaitMatch)。\n阻塞队列为了减轻并发带来的效率问题, 引入了松弛距离的概念: 向阻塞队列中添加或者读取元素时, 并不会立刻去修改head或者tail指针, 而是只需保证:head向后与未匹配的节点距离不能超过2; tail向后与真正链表末尾节点距离不能超过2, 如下图所示:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue1.png\" height=\"250\" width=\"500\"/>\nhead的松散距离<2会在节点与线程匹配之后、当发现匹配节点不为head时就会进行检查, 而tail的松散距离检查会在tryAppend中存放数据后进行。\n```\n    //tryAppend就是尽全力将节点追加到队列最后\n    private Node tryAppend(Node s, boolean haveData) {\n        //从tail开始循环, tail不一定是队列真正最后的节点\n        for (Node t = tail, p = t;;) {        // move p to last node and append\n            Node n, u;                        // temps for reads of next & tail\n            //当队列没有任何节点时\n            if (p == null && (p = head) == null) {\n                if (casHead(null, s))\n                    return s;                 // initialize\n            }\n            //检查队列当前节点是否可成为s的前继节点: 模式一致&&当前节点未被匹配, 模式不同的两个节点同时想成为head就会出现这种情况\n            else if (p.cannotPrecede(haveData))\n                return null; // lost race vs opposite mode 否则返回从头开始检查\n            //若发现tail不是最后一个的话, 还可以向后移动\n            else if ((n = p.next) != null)    // not last; keep traversing\n                //tail节点发生变化的话, p直接指向tail; 或者p后移一个继续检查。\n                p = p != t && t != (u = tail) ? (t = u) : // stale tail\n                    (p != n) ? n : null;      // restart if off list\n            //如果CAS失败，那么说明别的节点修改了next指针, 这往后移动一个重来一次。\n            else if (!p.casNext(null, s))\n            //此时说明p一定找到了最后一个节点,\n                p = p.next;                   // re-read on CAS failure\n            else {\n                 //开始检查p与tail的松弛距离, 如果tail距离最终节点距离>2, 则tail继续向后移动。\n                if (p != t) {                 // update if slack now >= 2，\n                    while ((tail != t || !casTail(t, s)) &&    //t为tail时候\n                           (t = tail)   != null &&    //tail不为null\n                           (s = t.next) != null && // advance and retry      //tail后面一个也不为null\n                           (s = s.next) != null && s != t);    //tail的后面的后面也不为null。即有节点的话，就一直往后面找\n                }\n                return p; //返回添加节点的上一个节点\n            }\n        }\n    }\n```\n\n若当前请求得不到满足的话, 那么当前线程将以节点形式加入队列而被阻塞:\n```\n//为了减少睡眠后的线程切换消耗, 这里线程不会立马阻塞, 而是会循环一段时间, 发现没有被别的模式相反的节点屁屁额, 没有希望了才会去睡眠\nprivate E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        Thread w = Thread.currentThread();\n        int spins = -1; // initialized after first item and cancel checks\n        //randomYields为了满足并发场景下的随机数获取, 为了解决在同一时刻多个线程获取随机数时的不一致问题。\n        ThreadLocalRandom randomYields = null; // bound if needed\n        for (;;) {\n            Object item = s.item;\n            if (item != e) {\n                //matched  说明该节点被别的线程唤醒了，被匹配后, 节点item要么被置位null, 要么被放元素。\n                // assert item != s;\n                //item置为为本身, 则节点脱离集群, 更容易被回收; waiter置为null\n                s.forgetContents();           // avoid garbage\n                return LinkedTransferQueue.<E>cast(item);\n            }\n            //若有中断信号, 或者超超时小于0 , 则从队列中清除当前线程\n            if ((w.isInterrupted() || (timed && nanos <= 0)) &&\n                    s.casItem(e, s)) {        // cancel ，让item等于自己，这样类似匹配过了的效果\n                unsplice(pred, s);\n                return e;\n            }\n            //根据不同的模式考虑循环多少次, 若队列模式已经变了, 那么当前节点很快被匹配, 会旋转192次; 若pre被匹配了, 那么本节点也很快被匹配; 或者旋转128次\n            if (spins < 0) {                  // establish spins at/near front\n                if ((spins = spinsFor(pred, s.isData)) > 0)\n                    randomYields = ThreadLocalRandom.current();\n            }\n            else if (spins > 0) {             // spin\n                --spins;\n                if (randomYields.nextInt(CHAINED_SPINS) == 0)   //偶发性释放cpu， 64次可能释放一次\n                    Thread.yield();           // occasionally yield\n            }\n            //spins=0，已经循环了spins词，那么 设置当前线程为s节点上的阻塞线程， 然后下次循环就会调用park\n            else if (s.waiter == null) {\n                s.waiter = w;                 // request unpark then recheck\n            }\n            else if (timed) {\n                nanos = deadline - System.nanoTime();\n                if (nanos > 0L)\n                    LockSupport.parkNanos(this, nanos);\n            }\n            else {\n                LockSupport.park(this);\n            }\n        }\n    }\n```\n# 示例\n由于过程比较繁琐, 为了更好理解, 接下来将顺序展示不同线程执行tansfer(a), transfer(b), tansfer(c), take(), take(), take(), transfer(d)/take()的操作。\n1. 线程thread1、thread2、thread3分别进行tansfer(a)、tansfer(b)、tansfer(c), 过程比较简单, 没啥好说的。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue2.png\" height=\"200\" width=\"300\"/>\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue3.png\" height=\"200\" width=\"350\"/>\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue4.png\" height=\"200\" width=\"400\"/>\ntansfer()主要是将节点尾插法进入队列; 若tail离最后的节点相差大于2, 则移动tail满足需求。\n2. 线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue5.png\" height=\"400\" width=\"650\"/>\n线程thread5执行take()时, 找到匹配的节点, 置位null, 并唤醒thread2. 发现当前匹配节点不是head节点, 那么则移动head节点直到松弛距离为2。 thread2还会将item=this, waiter=null。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue6.png\" height=\"400\" width=\"700\"/>\n线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue7.png\" height=\"350\" width=\"600\"/>\n3. 若此时线程thread7进行了tansfer(c), 仅仅将线程thread7以数据节点添加至队列中。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue8.png\" height=\"250\" width=\"800\"/>\n若此时线程thread7进行了take(), 此时也添加到了末尾, 注意此时队列模式发生了变化。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue9.png\" height=\"250\" width=\"750\"/>\n4. 可能有人会好奇, 队列真正的头结点无法遍历, 这样会不会存在内存泄露的问题? 我们大可不必担心, 仍然以例子来说明, 在thread7进行了take()的基础上, thread8线程进行了put(4)操作:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue10.png\" height=\"400\" width=\"900\"/>\n可以看到, 队列头两个无用的节点会自动脱离队列, 自然会被回收。\n\n# 总结\nLinkedTransferQueue与其他阻塞队列相比, 比较大的区别就是也可以阻塞put线程, 此时当有当take()操作时, take线程是不会进入队列的, 而是直接将put()线程唤醒。 结构上采取松弛距离<2来达到在高并发下减少互斥锁的操作而加快了效率。\n\n# 参考\nhttps://segmentfault.com/a/1190000016460411\nhttps://www.zybuluo.com/eric1989/note/698826\nhttp://ifeve.com/buglinkedtransferqueue-bug/","source":"_posts/LinkedTransferQueue原理解读.md","raw":"---\ntitle: LinkedTransferQueue原理分析\ndate: 2018-12-15 18:59:58\ntags:\ntoc: true\n---\nLinkedTransferQueue作为无边界的阻塞队列, 同时继承了TransferQueue和AbstractQueue。 相较于其他的阻塞队列:  LinkedTransferQueue特殊之处在于TransferQueue接口。 TransferQueue说明如下:\n>* Transfers the element to a waiting consumer immediately, if possible. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in {@link #take} or timed {@link #poll(long,TimeUnit) poll}), otherwise returning {@code false} without enqueuing the element.\n\n说的是LinkedTransferQueue不仅实现了普通BlockingQueue的功能, 另一个优点就是: 当有消费者等待数据时, 生产者可以直接将数据交给消费者而不是再进入队列。 与LinkedBlockingQueue相比, LinkedBlockingQueue在take和put操作时, 都是通过lock来控制, 当高并发操作take和put操作, 锁的获取和释放都是比较影响性能的。 而LinkedTransferQueue对这种使用进行了改进, 当生产者存放数据时, 发现有消费者等待消费数据, 生产者可以调用transfer直接将数据交给消费者, 而不用通过阻塞队列来传递数据, 减少了锁的释放与获取。\n# LinkedTransferQueue类简介\nLinkedTransferQueue的阻塞队列的节点Node设计如下:\n```\n static final class Node {\n        // 若为true, 则说明节点是个数据节点, 否则, 则说明是个请求节点\n        final boolean isData;\n         // initially non-null if isData; CASed to match\n        volatile Object item;\n        volatile Node next;\n         // null until waiting  若不为null，则说明是reservation，有一个线程在等待\n        volatile Thread waiter;\n}\n```\nLinkedTransferQueue中的阻塞队列节点分为两种, 数据节点和请求节点。当生产者调用put时, 若没有消费者需要数据, 直接将数据存放入阻塞队列中, 那么将生成数据节点(isData=true、item为用户存放的数据, waiter为该被阻塞的线程)。当调用take节点时, 若没有数据可供取走, 那么将在阻塞队列中建立请求节点(isData=false、item为null, waiter为该被阻塞的线程)。若阻塞队列未匹配节点为请求节点, 新来的也为请求, 那么将通过尾加的方式存放; 若新来一个数据节点, 那么就可以和阻塞队列中的节点匹配, 数据就不会放到阻塞队列中。注意: 阻塞队列中未匹配节点模式一致, 而不是说阻塞队列所有节点模式一致。 阻塞队列中被匹配的节点Node变化情况如下:\n\n|阻塞队列节点被匹配前后|数据节点|阻塞节点|\n|:------:|:------:|:------:|\n|匹配前|isData=true, item=data|isData=false, item=null|\n|匹配后|isData=true, item=null|isData=false, item=this|\n由此, 无论是数据节点还是阻塞节点, 我们可以总结出如下结论:\n+ 匹配前: ((item != null) == isData ) && (item != this)\n+ 匹配后: ((item == null) == isData ) || (item == this)\n该结论将在之后的代码中可见。我们也需要了解一个概念, 匹配:阻塞队列中数据节点或者请求节点, 若没有对应的线程来消费它, 那么这个节点就是未匹配的。反之就是匹配的。被匹配过的节点会延迟脱离队列, 为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾。\n在LinkedTransferQueue从阻塞队列中存放数据的函数:\n```\n   public void put(E e) {\n        xfer(e, true, ASYNC, 0);\n   }\n   public boolean offer(E e, long timeout, TimeUnit unit) {\n        xfer(e, true, ASYNC, 0);\n        return true;\n   }\n   public boolean add(E e) {\n        xfer(e, true, ASYNC, 0);\n        return true;\n    }\n    public boolean tryTransfer(E e, long timeout, TimeUnit unit)\n        throws InterruptedException {\n        if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)\n            return true;\n        if (!Thread.interrupted())\n            return false;\n        throw new InterruptedException();\n    }\n```\n从阻塞队列中取数据的函数:\n```\n    public E poll() {\n        return xfer(null, false, NOW, 0);\n    }\n    public E take() throws InterruptedException {\n        E e = xfer(null, false, SYNC, 0);\n        if (e != null)\n            return e;\n        Thread.interrupted(); //清空中断， 抛出异常\n        throw new InterruptedException();\n    }\n    public E poll(long timeout, TimeUnit unit) throws InterruptedException {\n        E e = xfer(null, false, TIMED, unit.toNanos(timeout));\n        if (e != null || !Thread.interrupted())\n            return e;\n        throw new InterruptedException();\n    }\n```\n有两个点需要我们注意下:\n1. 这些函数读取/插入数据实际调用的都是xfer这一个函数, 是不是觉得很神奇, 我们将在之后详细介绍该函数的实现。\n2. xfer中区别中包含NOW, SYNC, TIMED等参数的不同。\n```\n    /*\n     * Possible values for \"how\" argument in xfer method.\n     */\n    // for untimed poll, tryTransfer  NOW就是取数据时, 发现没有数据, 线程立刻返回不追加元素到阻塞队列中等待。\n    private static final int NOW   = 0;\n\n    // for offer, put, add  ASYNC就是添加数据时, 若消费者来不及消费, 只是将数据放到阻塞队列中, 而线程正常返回。\n    //这部分是LinkedTransferQueue作为阻塞队列正常用法\n    private static final int ASYNC = 1;\n\n    // for transfer, take  SYNC用于消费/生产者存放/拉去数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程也将阻塞\n     //这部分是LinkedTransferQueue的特性所在\n    private static final int SYNC  = 2;\n\n    // for timed poll, tryTransfer  TIMED用于超时时间内读取或者存放数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程超时阻塞。\n    private static final int TIMED = 3;\n```\n\n# xfer函数\nxfer作为LinkedTransferQueue里面最核心的函数, 在读取数据都依赖它, 接下来将看具体的实现。\n```\nprivate E xfer(E e, boolean haveData, int how, long nanos) {\n        //首先检查传递的数据是否符合要求\n        if (haveData && (e == null))\n            throw new NullPointerException();\n        Node s = null;                        // the node to append, if needed\n        //这里将不断循环重试+goto跳转, 直到明确return\n        retry:\n        for (;;) {// restart on append race\n            // find & match first node, 从头开始查找\n            for (Node h = head, p = h; p != null;) {\n                boolean isData = p.isData;\n                Object item = p.item;\n                // unmatched: 若是生产者说明生产者在等待消费者拿数据; 若是消费者说明在等待生产者生产数据\n                if (item != p && (item != null) == isData) {\n                     //can't match 模式一致的话, 那么只能将\n                    if (isData == haveData)\n                        break;  //两个节点是相同类型，不用match了，去下一步\n                    // match 数据类型不同，要么放数据， 要么取数据，不成功，则循环重试\n                    1. 当生产者存放数据时, 发现队列中已经有消费者在等待了, 那么直接将数据交给消费者\n                    2. 当消费者获取数据时, 发现队列中已经有生产者在等待被消费, 那么消费者直接拿走数据。\n                    //cas成功意味着匹配完成。如果本次是请求，则item原本是数据，e就为null反之则e是数据，item原本为null\n                    if (p.casItem(item, e)) {\n                          //head指针可能在p的上游\n                        //循环的目的是：发现当前被使用的节点不是head节点, 那么就会清理head节点, 确保松弛距离<2\n                        for (Node q = p; q != h;) {\n                            Node n = q.next;  // update by 2 unless singleton\n                            //发现head还没有变化, 将head指向当前节点的下一个节点\n                            if (head == h && casHead(h, n == null ? q : n)) {\n                                //设置next等于自己，从队列中移除了，等待被GC\n                                h.forgetNext();\n                                break;\n                            }\n                             // advance and retry， 发现变化了, 则移动head ,尽量保持head与未匹配节点的距离<2\n                            if ((h = head)   == null ||\n                                  //cas 失败后则检查当前head指针距离下一个有效节点是否大于2.大于则再次循环，否则退出。头节点的松弛长度由这段代码决定。从代码上可以看出，松弛距离是2.\n                                (q = h.next) == null || !q.isMatched())\n                                break;        // 除非松弛度小于2(head节点向后到未匹配节点距离小于2才退出)\n                        }\n                        //唤醒那个节点, 若不是线程阻塞, 那么waiter将为null\n                        LockSupport.unpark(p.waiter);\n                        return LinkedTransferQueue.<E>cast(item);\n                    }\n                }\n                Node n = p.next; //找下一个节点\n                // Use head if p offlist  如果p已经脱离队列，则从head继续找\n                p = (p != n) ? n : (h = head);\n            }\n            //操作不是立刻返回的\n            if (how != NOW) {                 // No matches available\n                if (s == null)  //第一个进来的\n                    s = new Node(e, haveData);\n                 //ASYNC, SYNC, TIMED类型接口都会将请求追加到队尾，返回队列的上一个节点\n                Node pred = tryAppend(s, haveData);\n                if (pred == null)\n                    continue retry;           // lost race vs opposite mode\n                if (how != ASYNC)\n                    //只有SYNC或者TINED情况, 线程才会被阻塞。只有部分接口才会阻塞线程\n                    return awaitMatch(s, pred, e, (how == TIMED), nanos);\n            }\n            return e; // not waiting   立刻返回的，\n        }\n    }\n```\nxfer函数做了如下事情:\n+ 检查传递进来的isData与e是否匹配的。\n+ 从阻塞队列头开始进行查找是否有节点未匹配&&与本次请求匹配, 若与本次请求匹配, 本次请求直接返回, 唤醒睡眠的那个线程(有线程睡眠), 同时清理队列, 保持head与未匹配节点的距离<2(松弛距离)。\n+ 若发现队列第一个未匹配节点与本次请求模式一致的, 本请求将会加入阻塞队列中(tryAppend)。\n+ 若请求类型是异步或者超时等待的, 那么将同时阻塞线程(awaitMatch)。\n阻塞队列为了减轻并发带来的效率问题, 引入了松弛距离的概念: 向阻塞队列中添加或者读取元素时, 并不会立刻去修改head或者tail指针, 而是只需保证:head向后与未匹配的节点距离不能超过2; tail向后与真正链表末尾节点距离不能超过2, 如下图所示:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue1.png\" height=\"250\" width=\"500\"/>\nhead的松散距离<2会在节点与线程匹配之后、当发现匹配节点不为head时就会进行检查, 而tail的松散距离检查会在tryAppend中存放数据后进行。\n```\n    //tryAppend就是尽全力将节点追加到队列最后\n    private Node tryAppend(Node s, boolean haveData) {\n        //从tail开始循环, tail不一定是队列真正最后的节点\n        for (Node t = tail, p = t;;) {        // move p to last node and append\n            Node n, u;                        // temps for reads of next & tail\n            //当队列没有任何节点时\n            if (p == null && (p = head) == null) {\n                if (casHead(null, s))\n                    return s;                 // initialize\n            }\n            //检查队列当前节点是否可成为s的前继节点: 模式一致&&当前节点未被匹配, 模式不同的两个节点同时想成为head就会出现这种情况\n            else if (p.cannotPrecede(haveData))\n                return null; // lost race vs opposite mode 否则返回从头开始检查\n            //若发现tail不是最后一个的话, 还可以向后移动\n            else if ((n = p.next) != null)    // not last; keep traversing\n                //tail节点发生变化的话, p直接指向tail; 或者p后移一个继续检查。\n                p = p != t && t != (u = tail) ? (t = u) : // stale tail\n                    (p != n) ? n : null;      // restart if off list\n            //如果CAS失败，那么说明别的节点修改了next指针, 这往后移动一个重来一次。\n            else if (!p.casNext(null, s))\n            //此时说明p一定找到了最后一个节点,\n                p = p.next;                   // re-read on CAS failure\n            else {\n                 //开始检查p与tail的松弛距离, 如果tail距离最终节点距离>2, 则tail继续向后移动。\n                if (p != t) {                 // update if slack now >= 2，\n                    while ((tail != t || !casTail(t, s)) &&    //t为tail时候\n                           (t = tail)   != null &&    //tail不为null\n                           (s = t.next) != null && // advance and retry      //tail后面一个也不为null\n                           (s = s.next) != null && s != t);    //tail的后面的后面也不为null。即有节点的话，就一直往后面找\n                }\n                return p; //返回添加节点的上一个节点\n            }\n        }\n    }\n```\n\n若当前请求得不到满足的话, 那么当前线程将以节点形式加入队列而被阻塞:\n```\n//为了减少睡眠后的线程切换消耗, 这里线程不会立马阻塞, 而是会循环一段时间, 发现没有被别的模式相反的节点屁屁额, 没有希望了才会去睡眠\nprivate E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) {\n        final long deadline = timed ? System.nanoTime() + nanos : 0L;\n        Thread w = Thread.currentThread();\n        int spins = -1; // initialized after first item and cancel checks\n        //randomYields为了满足并发场景下的随机数获取, 为了解决在同一时刻多个线程获取随机数时的不一致问题。\n        ThreadLocalRandom randomYields = null; // bound if needed\n        for (;;) {\n            Object item = s.item;\n            if (item != e) {\n                //matched  说明该节点被别的线程唤醒了，被匹配后, 节点item要么被置位null, 要么被放元素。\n                // assert item != s;\n                //item置为为本身, 则节点脱离集群, 更容易被回收; waiter置为null\n                s.forgetContents();           // avoid garbage\n                return LinkedTransferQueue.<E>cast(item);\n            }\n            //若有中断信号, 或者超超时小于0 , 则从队列中清除当前线程\n            if ((w.isInterrupted() || (timed && nanos <= 0)) &&\n                    s.casItem(e, s)) {        // cancel ，让item等于自己，这样类似匹配过了的效果\n                unsplice(pred, s);\n                return e;\n            }\n            //根据不同的模式考虑循环多少次, 若队列模式已经变了, 那么当前节点很快被匹配, 会旋转192次; 若pre被匹配了, 那么本节点也很快被匹配; 或者旋转128次\n            if (spins < 0) {                  // establish spins at/near front\n                if ((spins = spinsFor(pred, s.isData)) > 0)\n                    randomYields = ThreadLocalRandom.current();\n            }\n            else if (spins > 0) {             // spin\n                --spins;\n                if (randomYields.nextInt(CHAINED_SPINS) == 0)   //偶发性释放cpu， 64次可能释放一次\n                    Thread.yield();           // occasionally yield\n            }\n            //spins=0，已经循环了spins词，那么 设置当前线程为s节点上的阻塞线程， 然后下次循环就会调用park\n            else if (s.waiter == null) {\n                s.waiter = w;                 // request unpark then recheck\n            }\n            else if (timed) {\n                nanos = deadline - System.nanoTime();\n                if (nanos > 0L)\n                    LockSupport.parkNanos(this, nanos);\n            }\n            else {\n                LockSupport.park(this);\n            }\n        }\n    }\n```\n# 示例\n由于过程比较繁琐, 为了更好理解, 接下来将顺序展示不同线程执行tansfer(a), transfer(b), tansfer(c), take(), take(), take(), transfer(d)/take()的操作。\n1. 线程thread1、thread2、thread3分别进行tansfer(a)、tansfer(b)、tansfer(c), 过程比较简单, 没啥好说的。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue2.png\" height=\"200\" width=\"300\"/>\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue3.png\" height=\"200\" width=\"350\"/>\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue4.png\" height=\"200\" width=\"400\"/>\ntansfer()主要是将节点尾插法进入队列; 若tail离最后的节点相差大于2, 则移动tail满足需求。\n2. 线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue5.png\" height=\"400\" width=\"650\"/>\n线程thread5执行take()时, 找到匹配的节点, 置位null, 并唤醒thread2. 发现当前匹配节点不是head节点, 那么则移动head节点直到松弛距离为2。 thread2还会将item=this, waiter=null。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue6.png\" height=\"400\" width=\"700\"/>\n线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue7.png\" height=\"350\" width=\"600\"/>\n3. 若此时线程thread7进行了tansfer(c), 仅仅将线程thread7以数据节点添加至队列中。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue8.png\" height=\"250\" width=\"800\"/>\n若此时线程thread7进行了take(), 此时也添加到了末尾, 注意此时队列模式发生了变化。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue9.png\" height=\"250\" width=\"750\"/>\n4. 可能有人会好奇, 队列真正的头结点无法遍历, 这样会不会存在内存泄露的问题? 我们大可不必担心, 仍然以例子来说明, 在thread7进行了take()的基础上, thread8线程进行了put(4)操作:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue10.png\" height=\"400\" width=\"900\"/>\n可以看到, 队列头两个无用的节点会自动脱离队列, 自然会被回收。\n\n# 总结\nLinkedTransferQueue与其他阻塞队列相比, 比较大的区别就是也可以阻塞put线程, 此时当有当take()操作时, take线程是不会进入队列的, 而是直接将put()线程唤醒。 结构上采取松弛距离<2来达到在高并发下减少互斥锁的操作而加快了效率。\n\n# 参考\nhttps://segmentfault.com/a/1190000016460411\nhttps://www.zybuluo.com/eric1989/note/698826\nhttp://ifeve.com/buglinkedtransferqueue-bug/","slug":"LinkedTransferQueue原理解读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8w9000gphu58phfskhm","content":"<p>LinkedTransferQueue作为无边界的阻塞队列, 同时继承了TransferQueue和AbstractQueue。 相较于其他的阻塞队列:  LinkedTransferQueue特殊之处在于TransferQueue接口。 TransferQueue说明如下:</p>\n<blockquote>\n<ul>\n<li>Transfers the element to a waiting consumer immediately, if possible. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in {@link #take} or timed {@link #poll(long,TimeUnit) poll}), otherwise returning {@code false} without enqueuing the element.</li>\n</ul>\n</blockquote>\n<p>说的是LinkedTransferQueue不仅实现了普通BlockingQueue的功能, 另一个优点就是: 当有消费者等待数据时, 生产者可以直接将数据交给消费者而不是再进入队列。 与LinkedBlockingQueue相比, LinkedBlockingQueue在take和put操作时, 都是通过lock来控制, 当高并发操作take和put操作, 锁的获取和释放都是比较影响性能的。 而LinkedTransferQueue对这种使用进行了改进, 当生产者存放数据时, 发现有消费者等待消费数据, 生产者可以调用transfer直接将数据交给消费者, 而不用通过阻塞队列来传递数据, 减少了锁的释放与获取。</p>\n<h1 id=\"LinkedTransferQueue类简介\"><a href=\"#LinkedTransferQueue类简介\" class=\"headerlink\" title=\"LinkedTransferQueue类简介\"></a>LinkedTransferQueue类简介</h1><p>LinkedTransferQueue的阻塞队列的节点Node设计如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static final class Node &#123;</div><div class=\"line\">        // 若为true, 则说明节点是个数据节点, 否则, 则说明是个请求节点</div><div class=\"line\">        final boolean isData;</div><div class=\"line\">         // initially non-null if isData; CASed to match</div><div class=\"line\">        volatile Object item;</div><div class=\"line\">        volatile Node next;</div><div class=\"line\">         // null until waiting  若不为null，则说明是reservation，有一个线程在等待</div><div class=\"line\">        volatile Thread waiter;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>LinkedTransferQueue中的阻塞队列节点分为两种, 数据节点和请求节点。当生产者调用put时, 若没有消费者需要数据, 直接将数据存放入阻塞队列中, 那么将生成数据节点(isData=true、item为用户存放的数据, waiter为该被阻塞的线程)。当调用take节点时, 若没有数据可供取走, 那么将在阻塞队列中建立请求节点(isData=false、item为null, waiter为该被阻塞的线程)。若阻塞队列未匹配节点为请求节点, 新来的也为请求, 那么将通过尾加的方式存放; 若新来一个数据节点, 那么就可以和阻塞队列中的节点匹配, 数据就不会放到阻塞队列中。注意: 阻塞队列中未匹配节点模式一致, 而不是说阻塞队列所有节点模式一致。 阻塞队列中被匹配的节点Node变化情况如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">阻塞队列节点被匹配前后</th>\n<th style=\"text-align:center\">数据节点</th>\n<th style=\"text-align:center\">阻塞节点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">匹配前</td>\n<td style=\"text-align:center\">isData=true, item=data</td>\n<td style=\"text-align:center\">isData=false, item=null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">匹配后</td>\n<td style=\"text-align:center\">isData=true, item=null</td>\n<td style=\"text-align:center\">isData=false, item=this</td>\n</tr>\n</tbody>\n</table>\n<p>由此, 无论是数据节点还是阻塞节点, 我们可以总结出如下结论:</p>\n<ul>\n<li>匹配前: ((item != null) == isData ) &amp;&amp; (item != this)</li>\n<li>匹配后: ((item == null) == isData ) || (item == this)<br>该结论将在之后的代码中可见。我们也需要了解一个概念, 匹配:阻塞队列中数据节点或者请求节点, 若没有对应的线程来消费它, 那么这个节点就是未匹配的。反之就是匹配的。被匹配过的节点会延迟脱离队列, 为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾。<br>在LinkedTransferQueue从阻塞队列中存放数据的函数:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void put(E e) &#123;</div><div class=\"line\">     xfer(e, true, ASYNC, 0);</div><div class=\"line\">&#125;</div><div class=\"line\">public boolean offer(E e, long timeout, TimeUnit unit) &#123;</div><div class=\"line\">     xfer(e, true, ASYNC, 0);</div><div class=\"line\">     return true;</div><div class=\"line\">&#125;</div><div class=\"line\">public boolean add(E e) &#123;</div><div class=\"line\">     xfer(e, true, ASYNC, 0);</div><div class=\"line\">     return true;</div><div class=\"line\"> &#125;</div><div class=\"line\"> public boolean tryTransfer(E e, long timeout, TimeUnit unit)</div><div class=\"line\">     throws InterruptedException &#123;</div><div class=\"line\">     if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)</div><div class=\"line\">         return true;</div><div class=\"line\">     if (!Thread.interrupted())</div><div class=\"line\">         return false;</div><div class=\"line\">     throw new InterruptedException();</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从阻塞队列中取数据的函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public E poll() &#123;</div><div class=\"line\">    return xfer(null, false, NOW, 0);</div><div class=\"line\">&#125;</div><div class=\"line\">public E take() throws InterruptedException &#123;</div><div class=\"line\">    E e = xfer(null, false, SYNC, 0);</div><div class=\"line\">    if (e != null)</div><div class=\"line\">        return e;</div><div class=\"line\">    Thread.interrupted(); //清空中断， 抛出异常</div><div class=\"line\">    throw new InterruptedException();</div><div class=\"line\">&#125;</div><div class=\"line\">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</div><div class=\"line\">    E e = xfer(null, false, TIMED, unit.toNanos(timeout));</div><div class=\"line\">    if (e != null || !Thread.interrupted())</div><div class=\"line\">        return e;</div><div class=\"line\">    throw new InterruptedException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有两个点需要我们注意下:</p>\n<ol>\n<li>这些函数读取/插入数据实际调用的都是xfer这一个函数, 是不是觉得很神奇, 我们将在之后详细介绍该函数的实现。</li>\n<li>xfer中区别中包含NOW, SYNC, TIMED等参数的不同。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\"> * Possible values for &quot;how&quot; argument in xfer method.</div><div class=\"line\"> */</div><div class=\"line\">// for untimed poll, tryTransfer  NOW就是取数据时, 发现没有数据, 线程立刻返回不追加元素到阻塞队列中等待。</div><div class=\"line\">private static final int NOW   = 0;</div><div class=\"line\"></div><div class=\"line\">// for offer, put, add  ASYNC就是添加数据时, 若消费者来不及消费, 只是将数据放到阻塞队列中, 而线程正常返回。</div><div class=\"line\">//这部分是LinkedTransferQueue作为阻塞队列正常用法</div><div class=\"line\">private static final int ASYNC = 1;</div><div class=\"line\"></div><div class=\"line\">// for transfer, take  SYNC用于消费/生产者存放/拉去数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程也将阻塞</div><div class=\"line\"> //这部分是LinkedTransferQueue的特性所在</div><div class=\"line\">private static final int SYNC  = 2;</div><div class=\"line\"></div><div class=\"line\">// for timed poll, tryTransfer  TIMED用于超时时间内读取或者存放数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程超时阻塞。</div><div class=\"line\">private static final int TIMED = 3;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"xfer函数\"><a href=\"#xfer函数\" class=\"headerlink\" title=\"xfer函数\"></a>xfer函数</h1><p>xfer作为LinkedTransferQueue里面最核心的函数, 在读取数据都依赖它, 接下来将看具体的实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">private E xfer(E e, boolean haveData, int how, long nanos) &#123;</div><div class=\"line\">        //首先检查传递的数据是否符合要求</div><div class=\"line\">        if (haveData &amp;&amp; (e == null))</div><div class=\"line\">            throw new NullPointerException();</div><div class=\"line\">        Node s = null;                        // the node to append, if needed</div><div class=\"line\">        //这里将不断循环重试+goto跳转, 直到明确return</div><div class=\"line\">        retry:</div><div class=\"line\">        for (;;) &#123;// restart on append race</div><div class=\"line\">            // find &amp; match first node, 从头开始查找</div><div class=\"line\">            for (Node h = head, p = h; p != null;) &#123;</div><div class=\"line\">                boolean isData = p.isData;</div><div class=\"line\">                Object item = p.item;</div><div class=\"line\">                // unmatched: 若是生产者说明生产者在等待消费者拿数据; 若是消费者说明在等待生产者生产数据</div><div class=\"line\">                if (item != p &amp;&amp; (item != null) == isData) &#123;</div><div class=\"line\">                     //can&apos;t match 模式一致的话, 那么只能将</div><div class=\"line\">                    if (isData == haveData)</div><div class=\"line\">                        break;  //两个节点是相同类型，不用match了，去下一步</div><div class=\"line\">                    // match 数据类型不同，要么放数据， 要么取数据，不成功，则循环重试</div><div class=\"line\">                    1. 当生产者存放数据时, 发现队列中已经有消费者在等待了, 那么直接将数据交给消费者</div><div class=\"line\">                    2. 当消费者获取数据时, 发现队列中已经有生产者在等待被消费, 那么消费者直接拿走数据。</div><div class=\"line\">                    //cas成功意味着匹配完成。如果本次是请求，则item原本是数据，e就为null反之则e是数据，item原本为null</div><div class=\"line\">                    if (p.casItem(item, e)) &#123;</div><div class=\"line\">                          //head指针可能在p的上游</div><div class=\"line\">                        //循环的目的是：发现当前被使用的节点不是head节点, 那么就会清理head节点, 确保松弛距离&lt;2</div><div class=\"line\">                        for (Node q = p; q != h;) &#123;</div><div class=\"line\">                            Node n = q.next;  // update by 2 unless singleton</div><div class=\"line\">                            //发现head还没有变化, 将head指向当前节点的下一个节点</div><div class=\"line\">                            if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123;</div><div class=\"line\">                                //设置next等于自己，从队列中移除了，等待被GC</div><div class=\"line\">                                h.forgetNext();</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                             // advance and retry， 发现变化了, 则移动head ,尽量保持head与未匹配节点的距离&lt;2</div><div class=\"line\">                            if ((h = head)   == null ||</div><div class=\"line\">                                  //cas 失败后则检查当前head指针距离下一个有效节点是否大于2.大于则再次循环，否则退出。头节点的松弛长度由这段代码决定。从代码上可以看出，松弛距离是2.</div><div class=\"line\">                                (q = h.next) == null || !q.isMatched())</div><div class=\"line\">                                break;        // 除非松弛度小于2(head节点向后到未匹配节点距离小于2才退出)</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        //唤醒那个节点, 若不是线程阻塞, 那么waiter将为null</div><div class=\"line\">                        LockSupport.unpark(p.waiter);</div><div class=\"line\">                        return LinkedTransferQueue.&lt;E&gt;cast(item);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                Node n = p.next; //找下一个节点</div><div class=\"line\">                // Use head if p offlist  如果p已经脱离队列，则从head继续找</div><div class=\"line\">                p = (p != n) ? n : (h = head);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //操作不是立刻返回的</div><div class=\"line\">            if (how != NOW) &#123;                 // No matches available</div><div class=\"line\">                if (s == null)  //第一个进来的</div><div class=\"line\">                    s = new Node(e, haveData);</div><div class=\"line\">                 //ASYNC, SYNC, TIMED类型接口都会将请求追加到队尾，返回队列的上一个节点</div><div class=\"line\">                Node pred = tryAppend(s, haveData);</div><div class=\"line\">                if (pred == null)</div><div class=\"line\">                    continue retry;           // lost race vs opposite mode</div><div class=\"line\">                if (how != ASYNC)</div><div class=\"line\">                    //只有SYNC或者TINED情况, 线程才会被阻塞。只有部分接口才会阻塞线程</div><div class=\"line\">                    return awaitMatch(s, pred, e, (how == TIMED), nanos);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return e; // not waiting   立刻返回的，</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>xfer函数做了如下事情:</p>\n<ul>\n<li>检查传递进来的isData与e是否匹配的。</li>\n<li>从阻塞队列头开始进行查找是否有节点未匹配&amp;&amp;与本次请求匹配, 若与本次请求匹配, 本次请求直接返回, 唤醒睡眠的那个线程(有线程睡眠), 同时清理队列, 保持head与未匹配节点的距离&lt;2(松弛距离)。</li>\n<li>若发现队列第一个未匹配节点与本次请求模式一致的, 本请求将会加入阻塞队列中(tryAppend)。</li>\n<li>若请求类型是异步或者超时等待的, 那么将同时阻塞线程(awaitMatch)。<br>阻塞队列为了减轻并发带来的效率问题, 引入了松弛距离的概念: 向阻塞队列中添加或者读取元素时, 并不会立刻去修改head或者tail指针, 而是只需保证:head向后与未匹配的节点距离不能超过2; tail向后与真正链表末尾节点距离不能超过2, 如下图所示:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue1.png\" height=\"250\" width=\"500\"><br>head的松散距离&lt;2会在节点与线程匹配之后、当发现匹配节点不为head时就会进行检查, 而tail的松散距离检查会在tryAppend中存放数据后进行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">//tryAppend就是尽全力将节点追加到队列最后</div><div class=\"line\">private Node tryAppend(Node s, boolean haveData) &#123;</div><div class=\"line\">    //从tail开始循环, tail不一定是队列真正最后的节点</div><div class=\"line\">    for (Node t = tail, p = t;;) &#123;        // move p to last node and append</div><div class=\"line\">        Node n, u;                        // temps for reads of next &amp; tail</div><div class=\"line\">        //当队列没有任何节点时</div><div class=\"line\">        if (p == null &amp;&amp; (p = head) == null) &#123;</div><div class=\"line\">            if (casHead(null, s))</div><div class=\"line\">                return s;                 // initialize</div><div class=\"line\">        &#125;</div><div class=\"line\">        //检查队列当前节点是否可成为s的前继节点: 模式一致&amp;&amp;当前节点未被匹配, 模式不同的两个节点同时想成为head就会出现这种情况</div><div class=\"line\">        else if (p.cannotPrecede(haveData))</div><div class=\"line\">            return null; // lost race vs opposite mode 否则返回从头开始检查</div><div class=\"line\">        //若发现tail不是最后一个的话, 还可以向后移动</div><div class=\"line\">        else if ((n = p.next) != null)    // not last; keep traversing</div><div class=\"line\">            //tail节点发生变化的话, p直接指向tail; 或者p后移一个继续检查。</div><div class=\"line\">            p = p != t &amp;&amp; t != (u = tail) ? (t = u) : // stale tail</div><div class=\"line\">                (p != n) ? n : null;      // restart if off list</div><div class=\"line\">        //如果CAS失败，那么说明别的节点修改了next指针, 这往后移动一个重来一次。</div><div class=\"line\">        else if (!p.casNext(null, s))</div><div class=\"line\">        //此时说明p一定找到了最后一个节点,</div><div class=\"line\">            p = p.next;                   // re-read on CAS failure</div><div class=\"line\">        else &#123;</div><div class=\"line\">             //开始检查p与tail的松弛距离, 如果tail距离最终节点距离&gt;2, 则tail继续向后移动。</div><div class=\"line\">            if (p != t) &#123;                 // update if slack now &gt;= 2，</div><div class=\"line\">                while ((tail != t || !casTail(t, s)) &amp;&amp;    //t为tail时候</div><div class=\"line\">                       (t = tail)   != null &amp;&amp;    //tail不为null</div><div class=\"line\">                       (s = t.next) != null &amp;&amp; // advance and retry      //tail后面一个也不为null</div><div class=\"line\">                       (s = s.next) != null &amp;&amp; s != t);    //tail的后面的后面也不为null。即有节点的话，就一直往后面找</div><div class=\"line\">            &#125;</div><div class=\"line\">            return p; //返回添加节点的上一个节点</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>若当前请求得不到满足的话, 那么当前线程将以节点形式加入队列而被阻塞:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">//为了减少睡眠后的线程切换消耗, 这里线程不会立马阻塞, 而是会循环一段时间, 发现没有被别的模式相反的节点屁屁额, 没有希望了才会去睡眠</div><div class=\"line\">private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123;</div><div class=\"line\">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</div><div class=\"line\">        Thread w = Thread.currentThread();</div><div class=\"line\">        int spins = -1; // initialized after first item and cancel checks</div><div class=\"line\">        //randomYields为了满足并发场景下的随机数获取, 为了解决在同一时刻多个线程获取随机数时的不一致问题。</div><div class=\"line\">        ThreadLocalRandom randomYields = null; // bound if needed</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            Object item = s.item;</div><div class=\"line\">            if (item != e) &#123;</div><div class=\"line\">                //matched  说明该节点被别的线程唤醒了，被匹配后, 节点item要么被置位null, 要么被放元素。</div><div class=\"line\">                // assert item != s;</div><div class=\"line\">                //item置为为本身, 则节点脱离集群, 更容易被回收; waiter置为null</div><div class=\"line\">                s.forgetContents();           // avoid garbage</div><div class=\"line\">                return LinkedTransferQueue.&lt;E&gt;cast(item);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //若有中断信号, 或者超超时小于0 , 则从队列中清除当前线程</div><div class=\"line\">            if ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= 0)) &amp;&amp;</div><div class=\"line\">                    s.casItem(e, s)) &#123;        // cancel ，让item等于自己，这样类似匹配过了的效果</div><div class=\"line\">                unsplice(pred, s);</div><div class=\"line\">                return e;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //根据不同的模式考虑循环多少次, 若队列模式已经变了, 那么当前节点很快被匹配, 会旋转192次; 若pre被匹配了, 那么本节点也很快被匹配; 或者旋转128次</div><div class=\"line\">            if (spins &lt; 0) &#123;                  // establish spins at/near front</div><div class=\"line\">                if ((spins = spinsFor(pred, s.isData)) &gt; 0)</div><div class=\"line\">                    randomYields = ThreadLocalRandom.current();</div><div class=\"line\">            &#125;</div><div class=\"line\">            else if (spins &gt; 0) &#123;             // spin</div><div class=\"line\">                --spins;</div><div class=\"line\">                if (randomYields.nextInt(CHAINED_SPINS) == 0)   //偶发性释放cpu， 64次可能释放一次</div><div class=\"line\">                    Thread.yield();           // occasionally yield</div><div class=\"line\">            &#125;</div><div class=\"line\">            //spins=0，已经循环了spins词，那么 设置当前线程为s节点上的阻塞线程， 然后下次循环就会调用park</div><div class=\"line\">            else if (s.waiter == null) &#123;</div><div class=\"line\">                s.waiter = w;                 // request unpark then recheck</div><div class=\"line\">            &#125;</div><div class=\"line\">            else if (timed) &#123;</div><div class=\"line\">                nanos = deadline - System.nanoTime();</div><div class=\"line\">                if (nanos &gt; 0L)</div><div class=\"line\">                    LockSupport.parkNanos(this, nanos);</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                LockSupport.park(this);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>由于过程比较繁琐, 为了更好理解, 接下来将顺序展示不同线程执行tansfer(a), transfer(b), tansfer(c), take(), take(), take(), transfer(d)/take()的操作。</p>\n<ol>\n<li>线程thread1、thread2、thread3分别进行tansfer(a)、tansfer(b)、tansfer(c), 过程比较简单, 没啥好说的。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue2.png\" height=\"200\" width=\"300\"><br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue3.png\" height=\"200\" width=\"350\"><br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue4.png\" height=\"200\" width=\"400\"><br>tansfer()主要是将节点尾插法进入队列; 若tail离最后的节点相差大于2, 则移动tail满足需求。</li>\n<li>线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue5.png\" height=\"400\" width=\"650\"><br>线程thread5执行take()时, 找到匹配的节点, 置位null, 并唤醒thread2. 发现当前匹配节点不是head节点, 那么则移动head节点直到松弛距离为2。 thread2还会将item=this, waiter=null。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue6.png\" height=\"400\" width=\"700\"><br>线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue7.png\" height=\"350\" width=\"600\"></li>\n<li>若此时线程thread7进行了tansfer(c), 仅仅将线程thread7以数据节点添加至队列中。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue8.png\" height=\"250\" width=\"800\"><br>若此时线程thread7进行了take(), 此时也添加到了末尾, 注意此时队列模式发生了变化。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue9.png\" height=\"250\" width=\"750\"></li>\n<li>可能有人会好奇, 队列真正的头结点无法遍历, 这样会不会存在内存泄露的问题? 我们大可不必担心, 仍然以例子来说明, 在thread7进行了take()的基础上, thread8线程进行了put(4)操作:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue10.png\" height=\"400\" width=\"900\"><br>可以看到, 队列头两个无用的节点会自动脱离队列, 自然会被回收。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>LinkedTransferQueue与其他阻塞队列相比, 比较大的区别就是也可以阻塞put线程, 此时当有当take()操作时, take线程是不会进入队列的, 而是直接将put()线程唤醒。 结构上采取松弛距离&lt;2来达到在高并发下减少互斥锁的操作而加快了效率。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://segmentfault.com/a/1190000016460411\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000016460411</a><br><a href=\"https://www.zybuluo.com/eric1989/note/698826\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/eric1989/note/698826</a><br><a href=\"http://ifeve.com/buglinkedtransferqueue-bug/\" target=\"_blank\" rel=\"external\">http://ifeve.com/buglinkedtransferqueue-bug/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LinkedTransferQueue作为无边界的阻塞队列, 同时继承了TransferQueue和AbstractQueue。 相较于其他的阻塞队列:  LinkedTransferQueue特殊之处在于TransferQueue接口。 TransferQueue说明如下:</p>\n<blockquote>\n<ul>\n<li>Transfers the element to a waiting consumer immediately, if possible. More precisely, transfers the specified element immediately if there exists a consumer already waiting to receive it (in {@link #take} or timed {@link #poll(long,TimeUnit) poll}), otherwise returning {@code false} without enqueuing the element.</li>\n</ul>\n</blockquote>\n<p>说的是LinkedTransferQueue不仅实现了普通BlockingQueue的功能, 另一个优点就是: 当有消费者等待数据时, 生产者可以直接将数据交给消费者而不是再进入队列。 与LinkedBlockingQueue相比, LinkedBlockingQueue在take和put操作时, 都是通过lock来控制, 当高并发操作take和put操作, 锁的获取和释放都是比较影响性能的。 而LinkedTransferQueue对这种使用进行了改进, 当生产者存放数据时, 发现有消费者等待消费数据, 生产者可以调用transfer直接将数据交给消费者, 而不用通过阻塞队列来传递数据, 减少了锁的释放与获取。</p>\n<h1 id=\"LinkedTransferQueue类简介\"><a href=\"#LinkedTransferQueue类简介\" class=\"headerlink\" title=\"LinkedTransferQueue类简介\"></a>LinkedTransferQueue类简介</h1><p>LinkedTransferQueue的阻塞队列的节点Node设计如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static final class Node &#123;</div><div class=\"line\">        // 若为true, 则说明节点是个数据节点, 否则, 则说明是个请求节点</div><div class=\"line\">        final boolean isData;</div><div class=\"line\">         // initially non-null if isData; CASed to match</div><div class=\"line\">        volatile Object item;</div><div class=\"line\">        volatile Node next;</div><div class=\"line\">         // null until waiting  若不为null，则说明是reservation，有一个线程在等待</div><div class=\"line\">        volatile Thread waiter;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>LinkedTransferQueue中的阻塞队列节点分为两种, 数据节点和请求节点。当生产者调用put时, 若没有消费者需要数据, 直接将数据存放入阻塞队列中, 那么将生成数据节点(isData=true、item为用户存放的数据, waiter为该被阻塞的线程)。当调用take节点时, 若没有数据可供取走, 那么将在阻塞队列中建立请求节点(isData=false、item为null, waiter为该被阻塞的线程)。若阻塞队列未匹配节点为请求节点, 新来的也为请求, 那么将通过尾加的方式存放; 若新来一个数据节点, 那么就可以和阻塞队列中的节点匹配, 数据就不会放到阻塞队列中。注意: 阻塞队列中未匹配节点模式一致, 而不是说阻塞队列所有节点模式一致。 阻塞队列中被匹配的节点Node变化情况如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">阻塞队列节点被匹配前后</th>\n<th style=\"text-align:center\">数据节点</th>\n<th style=\"text-align:center\">阻塞节点</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">匹配前</td>\n<td style=\"text-align:center\">isData=true, item=data</td>\n<td style=\"text-align:center\">isData=false, item=null</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">匹配后</td>\n<td style=\"text-align:center\">isData=true, item=null</td>\n<td style=\"text-align:center\">isData=false, item=this</td>\n</tr>\n</tbody>\n</table>\n<p>由此, 无论是数据节点还是阻塞节点, 我们可以总结出如下结论:</p>\n<ul>\n<li>匹配前: ((item != null) == isData ) &amp;&amp; (item != this)</li>\n<li>匹配后: ((item == null) == isData ) || (item == this)<br>该结论将在之后的代码中可见。我们也需要了解一个概念, 匹配:阻塞队列中数据节点或者请求节点, 若没有对应的线程来消费它, 那么这个节点就是未匹配的。反之就是匹配的。被匹配过的节点会延迟脱离队列, 为了减少head和tail的操作频率, 使用的松弛距离: head和tail不一定时刻指的队列的头和尾。<br>在LinkedTransferQueue从阻塞队列中存放数据的函数:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void put(E e) &#123;</div><div class=\"line\">     xfer(e, true, ASYNC, 0);</div><div class=\"line\">&#125;</div><div class=\"line\">public boolean offer(E e, long timeout, TimeUnit unit) &#123;</div><div class=\"line\">     xfer(e, true, ASYNC, 0);</div><div class=\"line\">     return true;</div><div class=\"line\">&#125;</div><div class=\"line\">public boolean add(E e) &#123;</div><div class=\"line\">     xfer(e, true, ASYNC, 0);</div><div class=\"line\">     return true;</div><div class=\"line\"> &#125;</div><div class=\"line\"> public boolean tryTransfer(E e, long timeout, TimeUnit unit)</div><div class=\"line\">     throws InterruptedException &#123;</div><div class=\"line\">     if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null)</div><div class=\"line\">         return true;</div><div class=\"line\">     if (!Thread.interrupted())</div><div class=\"line\">         return false;</div><div class=\"line\">     throw new InterruptedException();</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>从阻塞队列中取数据的函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public E poll() &#123;</div><div class=\"line\">    return xfer(null, false, NOW, 0);</div><div class=\"line\">&#125;</div><div class=\"line\">public E take() throws InterruptedException &#123;</div><div class=\"line\">    E e = xfer(null, false, SYNC, 0);</div><div class=\"line\">    if (e != null)</div><div class=\"line\">        return e;</div><div class=\"line\">    Thread.interrupted(); //清空中断， 抛出异常</div><div class=\"line\">    throw new InterruptedException();</div><div class=\"line\">&#125;</div><div class=\"line\">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</div><div class=\"line\">    E e = xfer(null, false, TIMED, unit.toNanos(timeout));</div><div class=\"line\">    if (e != null || !Thread.interrupted())</div><div class=\"line\">        return e;</div><div class=\"line\">    throw new InterruptedException();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>有两个点需要我们注意下:</p>\n<ol>\n<li>这些函数读取/插入数据实际调用的都是xfer这一个函数, 是不是觉得很神奇, 我们将在之后详细介绍该函数的实现。</li>\n<li>xfer中区别中包含NOW, SYNC, TIMED等参数的不同。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\"> * Possible values for &quot;how&quot; argument in xfer method.</div><div class=\"line\"> */</div><div class=\"line\">// for untimed poll, tryTransfer  NOW就是取数据时, 发现没有数据, 线程立刻返回不追加元素到阻塞队列中等待。</div><div class=\"line\">private static final int NOW   = 0;</div><div class=\"line\"></div><div class=\"line\">// for offer, put, add  ASYNC就是添加数据时, 若消费者来不及消费, 只是将数据放到阻塞队列中, 而线程正常返回。</div><div class=\"line\">//这部分是LinkedTransferQueue作为阻塞队列正常用法</div><div class=\"line\">private static final int ASYNC = 1;</div><div class=\"line\"></div><div class=\"line\">// for transfer, take  SYNC用于消费/生产者存放/拉去数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程也将阻塞</div><div class=\"line\"> //这部分是LinkedTransferQueue的特性所在</div><div class=\"line\">private static final int SYNC  = 2;</div><div class=\"line\"></div><div class=\"line\">// for timed poll, tryTransfer  TIMED用于超时时间内读取或者存放数据时, 若满足不了的话, 将请求存放在阻塞队列, 同时线程超时阻塞。</div><div class=\"line\">private static final int TIMED = 3;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h1 id=\"xfer函数\"><a href=\"#xfer函数\" class=\"headerlink\" title=\"xfer函数\"></a>xfer函数</h1><p>xfer作为LinkedTransferQueue里面最核心的函数, 在读取数据都依赖它, 接下来将看具体的实现。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div></pre></td><td class=\"code\"><pre><div class=\"line\">private E xfer(E e, boolean haveData, int how, long nanos) &#123;</div><div class=\"line\">        //首先检查传递的数据是否符合要求</div><div class=\"line\">        if (haveData &amp;&amp; (e == null))</div><div class=\"line\">            throw new NullPointerException();</div><div class=\"line\">        Node s = null;                        // the node to append, if needed</div><div class=\"line\">        //这里将不断循环重试+goto跳转, 直到明确return</div><div class=\"line\">        retry:</div><div class=\"line\">        for (;;) &#123;// restart on append race</div><div class=\"line\">            // find &amp; match first node, 从头开始查找</div><div class=\"line\">            for (Node h = head, p = h; p != null;) &#123;</div><div class=\"line\">                boolean isData = p.isData;</div><div class=\"line\">                Object item = p.item;</div><div class=\"line\">                // unmatched: 若是生产者说明生产者在等待消费者拿数据; 若是消费者说明在等待生产者生产数据</div><div class=\"line\">                if (item != p &amp;&amp; (item != null) == isData) &#123;</div><div class=\"line\">                     //can&apos;t match 模式一致的话, 那么只能将</div><div class=\"line\">                    if (isData == haveData)</div><div class=\"line\">                        break;  //两个节点是相同类型，不用match了，去下一步</div><div class=\"line\">                    // match 数据类型不同，要么放数据， 要么取数据，不成功，则循环重试</div><div class=\"line\">                    1. 当生产者存放数据时, 发现队列中已经有消费者在等待了, 那么直接将数据交给消费者</div><div class=\"line\">                    2. 当消费者获取数据时, 发现队列中已经有生产者在等待被消费, 那么消费者直接拿走数据。</div><div class=\"line\">                    //cas成功意味着匹配完成。如果本次是请求，则item原本是数据，e就为null反之则e是数据，item原本为null</div><div class=\"line\">                    if (p.casItem(item, e)) &#123;</div><div class=\"line\">                          //head指针可能在p的上游</div><div class=\"line\">                        //循环的目的是：发现当前被使用的节点不是head节点, 那么就会清理head节点, 确保松弛距离&lt;2</div><div class=\"line\">                        for (Node q = p; q != h;) &#123;</div><div class=\"line\">                            Node n = q.next;  // update by 2 unless singleton</div><div class=\"line\">                            //发现head还没有变化, 将head指向当前节点的下一个节点</div><div class=\"line\">                            if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123;</div><div class=\"line\">                                //设置next等于自己，从队列中移除了，等待被GC</div><div class=\"line\">                                h.forgetNext();</div><div class=\"line\">                                break;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                             // advance and retry， 发现变化了, 则移动head ,尽量保持head与未匹配节点的距离&lt;2</div><div class=\"line\">                            if ((h = head)   == null ||</div><div class=\"line\">                                  //cas 失败后则检查当前head指针距离下一个有效节点是否大于2.大于则再次循环，否则退出。头节点的松弛长度由这段代码决定。从代码上可以看出，松弛距离是2.</div><div class=\"line\">                                (q = h.next) == null || !q.isMatched())</div><div class=\"line\">                                break;        // 除非松弛度小于2(head节点向后到未匹配节点距离小于2才退出)</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        //唤醒那个节点, 若不是线程阻塞, 那么waiter将为null</div><div class=\"line\">                        LockSupport.unpark(p.waiter);</div><div class=\"line\">                        return LinkedTransferQueue.&lt;E&gt;cast(item);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                Node n = p.next; //找下一个节点</div><div class=\"line\">                // Use head if p offlist  如果p已经脱离队列，则从head继续找</div><div class=\"line\">                p = (p != n) ? n : (h = head);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //操作不是立刻返回的</div><div class=\"line\">            if (how != NOW) &#123;                 // No matches available</div><div class=\"line\">                if (s == null)  //第一个进来的</div><div class=\"line\">                    s = new Node(e, haveData);</div><div class=\"line\">                 //ASYNC, SYNC, TIMED类型接口都会将请求追加到队尾，返回队列的上一个节点</div><div class=\"line\">                Node pred = tryAppend(s, haveData);</div><div class=\"line\">                if (pred == null)</div><div class=\"line\">                    continue retry;           // lost race vs opposite mode</div><div class=\"line\">                if (how != ASYNC)</div><div class=\"line\">                    //只有SYNC或者TINED情况, 线程才会被阻塞。只有部分接口才会阻塞线程</div><div class=\"line\">                    return awaitMatch(s, pred, e, (how == TIMED), nanos);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return e; // not waiting   立刻返回的，</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>xfer函数做了如下事情:</p>\n<ul>\n<li>检查传递进来的isData与e是否匹配的。</li>\n<li>从阻塞队列头开始进行查找是否有节点未匹配&amp;&amp;与本次请求匹配, 若与本次请求匹配, 本次请求直接返回, 唤醒睡眠的那个线程(有线程睡眠), 同时清理队列, 保持head与未匹配节点的距离&lt;2(松弛距离)。</li>\n<li>若发现队列第一个未匹配节点与本次请求模式一致的, 本请求将会加入阻塞队列中(tryAppend)。</li>\n<li>若请求类型是异步或者超时等待的, 那么将同时阻塞线程(awaitMatch)。<br>阻塞队列为了减轻并发带来的效率问题, 引入了松弛距离的概念: 向阻塞队列中添加或者读取元素时, 并不会立刻去修改head或者tail指针, 而是只需保证:head向后与未匹配的节点距离不能超过2; tail向后与真正链表末尾节点距离不能超过2, 如下图所示:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue1.png\" height=\"250\" width=\"500\"><br>head的松散距离&lt;2会在节点与线程匹配之后、当发现匹配节点不为head时就会进行检查, 而tail的松散距离检查会在tryAppend中存放数据后进行。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">//tryAppend就是尽全力将节点追加到队列最后</div><div class=\"line\">private Node tryAppend(Node s, boolean haveData) &#123;</div><div class=\"line\">    //从tail开始循环, tail不一定是队列真正最后的节点</div><div class=\"line\">    for (Node t = tail, p = t;;) &#123;        // move p to last node and append</div><div class=\"line\">        Node n, u;                        // temps for reads of next &amp; tail</div><div class=\"line\">        //当队列没有任何节点时</div><div class=\"line\">        if (p == null &amp;&amp; (p = head) == null) &#123;</div><div class=\"line\">            if (casHead(null, s))</div><div class=\"line\">                return s;                 // initialize</div><div class=\"line\">        &#125;</div><div class=\"line\">        //检查队列当前节点是否可成为s的前继节点: 模式一致&amp;&amp;当前节点未被匹配, 模式不同的两个节点同时想成为head就会出现这种情况</div><div class=\"line\">        else if (p.cannotPrecede(haveData))</div><div class=\"line\">            return null; // lost race vs opposite mode 否则返回从头开始检查</div><div class=\"line\">        //若发现tail不是最后一个的话, 还可以向后移动</div><div class=\"line\">        else if ((n = p.next) != null)    // not last; keep traversing</div><div class=\"line\">            //tail节点发生变化的话, p直接指向tail; 或者p后移一个继续检查。</div><div class=\"line\">            p = p != t &amp;&amp; t != (u = tail) ? (t = u) : // stale tail</div><div class=\"line\">                (p != n) ? n : null;      // restart if off list</div><div class=\"line\">        //如果CAS失败，那么说明别的节点修改了next指针, 这往后移动一个重来一次。</div><div class=\"line\">        else if (!p.casNext(null, s))</div><div class=\"line\">        //此时说明p一定找到了最后一个节点,</div><div class=\"line\">            p = p.next;                   // re-read on CAS failure</div><div class=\"line\">        else &#123;</div><div class=\"line\">             //开始检查p与tail的松弛距离, 如果tail距离最终节点距离&gt;2, 则tail继续向后移动。</div><div class=\"line\">            if (p != t) &#123;                 // update if slack now &gt;= 2，</div><div class=\"line\">                while ((tail != t || !casTail(t, s)) &amp;&amp;    //t为tail时候</div><div class=\"line\">                       (t = tail)   != null &amp;&amp;    //tail不为null</div><div class=\"line\">                       (s = t.next) != null &amp;&amp; // advance and retry      //tail后面一个也不为null</div><div class=\"line\">                       (s = s.next) != null &amp;&amp; s != t);    //tail的后面的后面也不为null。即有节点的话，就一直往后面找</div><div class=\"line\">            &#125;</div><div class=\"line\">            return p; //返回添加节点的上一个节点</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>若当前请求得不到满足的话, 那么当前线程将以节点形式加入队列而被阻塞:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">//为了减少睡眠后的线程切换消耗, 这里线程不会立马阻塞, 而是会循环一段时间, 发现没有被别的模式相反的节点屁屁额, 没有希望了才会去睡眠</div><div class=\"line\">private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123;</div><div class=\"line\">        final long deadline = timed ? System.nanoTime() + nanos : 0L;</div><div class=\"line\">        Thread w = Thread.currentThread();</div><div class=\"line\">        int spins = -1; // initialized after first item and cancel checks</div><div class=\"line\">        //randomYields为了满足并发场景下的随机数获取, 为了解决在同一时刻多个线程获取随机数时的不一致问题。</div><div class=\"line\">        ThreadLocalRandom randomYields = null; // bound if needed</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            Object item = s.item;</div><div class=\"line\">            if (item != e) &#123;</div><div class=\"line\">                //matched  说明该节点被别的线程唤醒了，被匹配后, 节点item要么被置位null, 要么被放元素。</div><div class=\"line\">                // assert item != s;</div><div class=\"line\">                //item置为为本身, 则节点脱离集群, 更容易被回收; waiter置为null</div><div class=\"line\">                s.forgetContents();           // avoid garbage</div><div class=\"line\">                return LinkedTransferQueue.&lt;E&gt;cast(item);</div><div class=\"line\">            &#125;</div><div class=\"line\">            //若有中断信号, 或者超超时小于0 , 则从队列中清除当前线程</div><div class=\"line\">            if ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= 0)) &amp;&amp;</div><div class=\"line\">                    s.casItem(e, s)) &#123;        // cancel ，让item等于自己，这样类似匹配过了的效果</div><div class=\"line\">                unsplice(pred, s);</div><div class=\"line\">                return e;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //根据不同的模式考虑循环多少次, 若队列模式已经变了, 那么当前节点很快被匹配, 会旋转192次; 若pre被匹配了, 那么本节点也很快被匹配; 或者旋转128次</div><div class=\"line\">            if (spins &lt; 0) &#123;                  // establish spins at/near front</div><div class=\"line\">                if ((spins = spinsFor(pred, s.isData)) &gt; 0)</div><div class=\"line\">                    randomYields = ThreadLocalRandom.current();</div><div class=\"line\">            &#125;</div><div class=\"line\">            else if (spins &gt; 0) &#123;             // spin</div><div class=\"line\">                --spins;</div><div class=\"line\">                if (randomYields.nextInt(CHAINED_SPINS) == 0)   //偶发性释放cpu， 64次可能释放一次</div><div class=\"line\">                    Thread.yield();           // occasionally yield</div><div class=\"line\">            &#125;</div><div class=\"line\">            //spins=0，已经循环了spins词，那么 设置当前线程为s节点上的阻塞线程， 然后下次循环就会调用park</div><div class=\"line\">            else if (s.waiter == null) &#123;</div><div class=\"line\">                s.waiter = w;                 // request unpark then recheck</div><div class=\"line\">            &#125;</div><div class=\"line\">            else if (timed) &#123;</div><div class=\"line\">                nanos = deadline - System.nanoTime();</div><div class=\"line\">                if (nanos &gt; 0L)</div><div class=\"line\">                    LockSupport.parkNanos(this, nanos);</div><div class=\"line\">            &#125;</div><div class=\"line\">            else &#123;</div><div class=\"line\">                LockSupport.park(this);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h1><p>由于过程比较繁琐, 为了更好理解, 接下来将顺序展示不同线程执行tansfer(a), transfer(b), tansfer(c), take(), take(), take(), transfer(d)/take()的操作。</p>\n<ol>\n<li>线程thread1、thread2、thread3分别进行tansfer(a)、tansfer(b)、tansfer(c), 过程比较简单, 没啥好说的。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue2.png\" height=\"200\" width=\"300\"><br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue3.png\" height=\"200\" width=\"350\"><br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue4.png\" height=\"200\" width=\"400\"><br>tansfer()主要是将节点尾插法进入队列; 若tail离最后的节点相差大于2, 则移动tail满足需求。</li>\n<li>线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue5.png\" height=\"400\" width=\"650\"><br>线程thread5执行take()时, 找到匹配的节点, 置位null, 并唤醒thread2. 发现当前匹配节点不是head节点, 那么则移动head节点直到松弛距离为2。 thread2还会将item=this, waiter=null。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue6.png\" height=\"400\" width=\"700\"><br>线程thread4执行take()时, 找到匹配的节点, 置位null。 并唤醒thread1; thread1还会将item=this, waiter=null<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue7.png\" height=\"350\" width=\"600\"></li>\n<li>若此时线程thread7进行了tansfer(c), 仅仅将线程thread7以数据节点添加至队列中。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue8.png\" height=\"250\" width=\"800\"><br>若此时线程thread7进行了take(), 此时也添加到了末尾, 注意此时队列模式发生了变化。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue9.png\" height=\"250\" width=\"750\"></li>\n<li>可能有人会好奇, 队列真正的头结点无法遍历, 这样会不会存在内存泄露的问题? 我们大可不必担心, 仍然以例子来说明, 在thread7进行了take()的基础上, thread8线程进行了put(4)操作:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LinkedTransferQueue10.png\" height=\"400\" width=\"900\"><br>可以看到, 队列头两个无用的节点会自动脱离队列, 自然会被回收。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>LinkedTransferQueue与其他阻塞队列相比, 比较大的区别就是也可以阻塞put线程, 此时当有当take()操作时, take线程是不会进入队列的, 而是直接将put()线程唤醒。 结构上采取松弛距离&lt;2来达到在高并发下减少互斥锁的操作而加快了效率。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://segmentfault.com/a/1190000016460411\" target=\"_blank\" rel=\"external\">https://segmentfault.com/a/1190000016460411</a><br><a href=\"https://www.zybuluo.com/eric1989/note/698826\" target=\"_blank\" rel=\"external\">https://www.zybuluo.com/eric1989/note/698826</a><br><a href=\"http://ifeve.com/buglinkedtransferqueue-bug/\" target=\"_blank\" rel=\"external\">http://ifeve.com/buglinkedtransferqueue-bug/</a></p>\n"},{"title":"LockSupport原理分析","date":"2018-11-10T09:16:56.000Z","toc":true,"_content":"LockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 本文将从LockSupport基本用法、 类主要函数及相关知识、底层基本原理三方面分别描述。\n# 使用\n基本用法:\n```\nclass Thread1 extends Thread {\n    public void run() {\n        try {\n            ......\n            LockSupport.park();\n            ......\n        } catch (Exception e) {\n        }\n    }\n}\nThread thread1 = new Thread1();\nclass Thread2 extends Thread {\n    public void run() {\n        try {\n            ......\n            LockSupport.unpark(thread1);\n            ......\n        } catch (Exception e) {\n        }\n    }\n}\n```\n当某个线程调用LockSupport.park()时, 该线程将睡眠并同时交出cpu使用。当别的线程调用LockSupport.unpark(thread1)时, 该线程将被唤醒。可见使用及其简单且灵活。park()与unpark()调用没有先后顺序, 这也是与wait()/notify()(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结</a>)相比更灵活的一点。也就是说先调用了unpark(), 再调用park(), thread1也是可以继续执行而不被阻塞。后面将详细介绍该原理。\n\n# LockSupport源码解析\n## Unsafe\n认识LockSupport, 我们就必须要了解Unsafe。 java作为安全的高级程序语言, 屏蔽了直接与内存打交道的途径。同时java也给我们留了一些后门:Unsafe。Unsafe只听名字就知道是个不安全的类, 它可以直接操作内存, 只有受信任的类才可以使用它。我们不能通过这种方式获取到Unsafe:`Unsafe unsafe = sun.misc.Unsafe.getUnsafe();`因为内部会检查该类的加载器是否是启动类加载器，若不是的话，则直接抛出异常；一般都是通过反射实现该类的获取：\n```\n// 应用类中获取Unsafe\nField theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\ntheUnsafe.setAccessible(true);\nUnsafe UNSAFE = (Unsafe) theUnsafe.get(null);\n\n//直接操纵内存修改成员变量值\nTest test = new Test();\nField filed = test.getClass().getDeclaredField(\"a\");\nlong ageOffset = UNSAFE.objectFieldOffset(filed);\n//直接通过修改内存来修改成员变量值\nUNSAFE.putInt(test, ageOffset, 100);\n```\n## parkBlockerOffset和parkBlocker\n在LockSupport中有这么一段static代码块:\n```\nprivate static final sun.misc.Unsafe UNSAFE;\n//获取parkBlocker在内存中的偏移量, 就是说谁把该线程block住了\nprivate static final long parkBlockerOffset;\ntry {\n    // 因为LockSupport是受信任的类, 所以才可以通过这种方式产生Unsafe\n    UNSAFE = sun.misc.Unsafe.getUnsafe();\n    // 线程类类型\n    Class<?> tk = Thread.class;\n    //先是通过反射机制获取Thread类的parkBlocker字段对象\n     parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField(\"parkBlocker\"));\n} catch (Exception ex) { throw new Error(ex); }\n```\n该函数可以获取到该线程类成员变量parkBlocker在内存中的偏移量parkBlockerOffset, 然后就可以通过`public static void park(Object blocker)`显示指示该类被什么阻塞的了。然后在jstack时, 将可以看到如下信息:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LockSupport1.png\" height=\"150\" width=\"600\"/>\n提示你设置的阻塞对象是啥, park()代码如下:\n```\n public static void park(Object blocker) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        UNSAFE.park(false, 0L);\n        setBlocker(t, null);\n}\n```\n这里也可以看出LockSupport实际调用了Unsafe.park/unpark函数。\n\n# Unsafe底层park/unpark原理\nUnsafe类中函数基本都是Native属性, 在虚拟机源代码/hotspot/src/share/vm/prims/unsafe.cpp(L1561)中, 定义了Unsafe类Native与c++语言函数之间对应关系, 如下所示:\n ```\n // These are the methods for 1.8.0\nstatic JNINativeMethod methods_18[] = {\n    {CC\"getObject\",        CC\"(\"OBJ\"J)\"OBJ\"\",   FN_PTR(Unsafe_GetObject)},\n    {CC\"putObject\",        CC\"(\"OBJ\"J\"OBJ\")V\",  FN_PTR(Unsafe_SetObject)},\n    {CC\"getObjectVolatile\",CC\"(\"OBJ\"J)\"OBJ\"\",   FN_PTR(Unsafe_GetObjectVolatile)},\n    {CC\"putObjectVolatile\",CC\"(\"OBJ\"J\"OBJ\")V\",  FN_PTR(Unsafe_SetObjectVolatile)},\n    {CC\"getAddress\",         CC\"(\"ADR\")\"ADR,             FN_PTR(Unsafe_GetNativeAddress)},\n    {CC\"putAddress\",         CC\"(\"ADR\"\"ADR\")V\",          FN_PTR(Unsafe_SetNativeAddress)},\n    {CC\"allocateMemory\",     CC\"(J)\"ADR,                 FN_PTR(Unsafe_AllocateMemory)},\n    {CC\"reallocateMemory\",   CC\"(\"ADR\"J)\"ADR,            FN_PTR(Unsafe_ReallocateMemory)},\n    {CC\"freeMemory\",         CC\"(\"ADR\")V\",               FN_PTR(Unsafe_FreeMemory)},\n    {CC\"objectFieldOffset\",  CC\"(\"FLD\")J\",               FN_PTR(Unsafe_ObjectFieldOffset)},\n    {CC\"staticFieldOffset\",  CC\"(\"FLD\")J\",               FN_PTR(Unsafe_StaticFieldOffset)},\n    {CC\"staticFieldBase\",    CC\"(\"FLD\")\"OBJ,             FN_PTR(Unsafe_StaticFieldBaseFromField)},\n    {CC\"ensureClassInitialized\",CC\"(\"CLS\")V\",            FN_PTR(Unsafe_EnsureClassInitialized)},\n    {CC\"arrayBaseOffset\",    CC\"(\"CLS\")I\",               FN_PTR(Unsafe_ArrayBaseOffset)},\n    {CC\"arrayIndexScale\",    CC\"(\"CLS\")I\",               FN_PTR(Unsafe_ArrayIndexScale)},\n    {CC\"addressSize\",        CC\"()I\",                    FN_PTR(Unsafe_AddressSize)},\n    {CC\"pageSize\",           CC\"()I\",                    FN_PTR(Unsafe_PageSize)},\n    {CC\"defineClass\",        CC\"(\"DC_Args\")\"CLS,         FN_PTR(Unsafe_DefineClass)},\n    {CC\"allocateInstance\",   CC\"(\"CLS\")\"OBJ,             FN_PTR(Unsafe_AllocateInstance)},\n    {CC\"monitorEnter\",       CC\"(\"OBJ\")V\",               FN_PTR(Unsafe_MonitorEnter)},\n    {CC\"monitorExit\",        CC\"(\"OBJ\")V\",               FN_PTR(Unsafe_MonitorExit)},\n    {CC\"tryMonitorEnter\",    CC\"(\"OBJ\")Z\",               FN_PTR(Unsafe_TryMonitorEnter)},\n    {CC\"throwException\",     CC\"(\"THR\")V\",               FN_PTR(Unsafe_ThrowException)},\n    {CC\"compareAndSwapObject\", CC\"(\"OBJ\"J\"OBJ\"\"OBJ\")Z\",  FN_PTR(Unsafe_CompareAndSwapObject)},\n    {CC\"compareAndSwapInt\",  CC\"(\"OBJ\"J\"\"I\"\"I\"\")Z\",      FN_PTR(Unsafe_CompareAndSwapInt)},\n    {CC\"compareAndSwapLong\", CC\"(\"OBJ\"J\"\"J\"\"J\"\")Z\",      FN_PTR(Unsafe_CompareAndSwapLong)},\n    {CC\"putOrderedObject\",   CC\"(\"OBJ\"J\"OBJ\")V\",         FN_PTR(Unsafe_SetOrderedObject)},\n    {CC\"putOrderedInt\",      CC\"(\"OBJ\"JI)V\",             FN_PTR(Unsafe_SetOrderedInt)},\n    {CC\"putOrderedLong\",     CC\"(\"OBJ\"JJ)V\",             FN_PTR(Unsafe_SetOrderedLong)},\n    {CC\"park\",               CC\"(ZJ)V\",                  FN_PTR(Unsafe_Park)},\n    {CC\"unpark\",             CC\"(\"OBJ\")V\",               FN_PTR(Unsafe_Unpark)}\n};\n ```\n可以看出, 我们关注的park和unpark分别对应了Unsafe_Park与Unsafe_Unpark。 下面展示了Unsafe_Park的实现方式:\n```\nUNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))\n  UnsafeWrapper(\"Unsafe_Park\");\n  EventThreadPark event;\n#ifndef USDT2\n  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread->parker(), (int) isAbsolute, time);\n#else /* USDT2 */\n   HOTSPOT_THREAD_PARK_BEGIN(\n                             (uintptr_t) thread->parker(), (int) isAbsolute, time);\n#endif /* USDT2 */\n  JavaThreadParkedState jtps(thread, time != 0);\n  thread->parker()->park(isAbsolute != 0, time);   //进的是这个函数\n#ifndef USDT2\n  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread->parker());\n#else /* USDT2 */\n  HOTSPOT_THREAD_PARK_END(\n                          (uintptr_t) thread->parker());\n#endif /* USDT2 */\n  if (event.should_commit()) {\n    oop obj = thread->current_park_blocker();\n    event.set_klass((obj != NULL) ? obj->klass() : NULL);\n    event.set_timeout(time);\n    event.set_address((obj != NULL) ? (TYPE_ADDRESS) cast_from_oop<uintptr_t>(obj) : 0);\n    event.commit();\n  }\nUNSAFE_END\n```\n我们可以清晰得看到, 真正调用的是thread->parker()->park(isAbsolute != 0, time)方法。\n## thread和Parker\n我们需要了解下vm中thread是如何组成的, JavaThread定义在/hotspot/src/share/vm/prims/runtime/thread.hpp(L1740), 关于Parker成员变量声明如下:\n```\nprivate:\n  Parker*    _parker;\npublic:\n  Parker*     parker() { return _parker; }\n```\n可以看出, 每个thread类中都包含一个Parker。\nParker定义在/hotspot/src/share/vm/runtime/park.hpp(L56), 定义如下:\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  //当_counter只能在0和1之间取值, 当为1时, 代表该类被unpark调用过, 更多的调用, 也不会增加_counter的值, 当该线程调用park()时, 不会阻塞, 同时_counter立刻清零。当为0时, 调用park()会被阻塞。使用volatile来修饰\n  volatile int _counter ;\n  Parker * FreeNext ;\n  JavaThread * AssociatedWith ; // Current association\npublic:\n  Parker() : PlatformParker() {\n    _counter       = 0 ;\n    FreeNext       = NULL ;\n    AssociatedWith = NULL ;\n  }\n```\nPlatformParker继承自Parker, 定义在/hotspot/src/os/linux/vm/os_linux.cpp(L234)\n```\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    enum {\n        REL_INDEX = 0,\n        ABS_INDEX = 1\n    };\n    int _cur_index;  // which cond is in use: -1, 0, 1\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.\n\n  public:       // TODO-FIXME: make dtor private\n    ~PlatformParker() { guarantee (0, \"invariant\") ; }\n\n  public:\n    PlatformParker() {\n      int status;\n      status = pthread_cond_init (&_cond[REL_INDEX], os::Linux::condAttr());\n      assert_status(status == 0, status, \"cond_init rel\");\n      status = pthread_cond_init (&_cond[ABS_INDEX], NULL);\n      assert_status(status == 0, status, \"cond_init abs\");\n      status = pthread_mutex_init (_mutex, NULL);\n      assert_status(status == 0, status, \"mutex_init\");\n      _cur_index = -1; // mark as unused\n    }\n};\n```\n说这么多, 我们主要是为了让你知道_counter, pthread_mutex_t _mutex[1], pthread_cond_t _cond[2]的存在。_mutex[1]和_cond[2]都是为了配合完成c++层面线程的阻塞与互斥等操作。\n\n## Parker.park()\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n   //这里通过原子操作来完成_counter清零操作。 若_counter之前>0, 那么说明之前该线程被unpark()过, 就可以直接返回而不被阻塞。\n  if (Atomic::xchg(0, &_counter) > 0) return;\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");  //判断一定的是java线程\n  JavaThread *jt = (JavaThread *)thread; //类强制转化\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  //进入睡眠等待前先检查是否有中断信号, 若有中断信号也直接返回。\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n  // Next, demultiplex/decode time arguments\n  timespec absTime;\n  //如果是按参数小于0，或者绝对时间，那么可以直接返回\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n   //如果时间大于0，判断阻塞超时时间或阻塞截止日期，同时将时间赋值给absTime\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  //再次检查, 如果有中断信号。直接返回; 或者申请互斥锁失败，则直接返回pthread_mutex_trylock返回0。任何其他返回值都表示错误。\n  //函数pthread_mutex_trylock是POSIX 线程pthread_mutex_lock的非阻塞版本。\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n  //此时已经通过_mutex将该代码进行了互斥操作, 那么直接对_counter都是安全的\n  int status ;\n  如果count>0, 说明之前原子操作赋值为0没有成功。 而_counter> 0, 线程可以直接不阻塞而返回\n  if (_counter > 0)  { // no wait needed\n     //将_counter直接清零\n    _counter = 0;\n    //释放锁并返回， 返回0代表释放锁成功\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ; //这里会去检查一下是否成功了\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence(); //这个函数是HotSpot VM对JMM的内存屏障一个具体的实现函数;\n    return;\n  }\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  assert(_cur_index == -1, \"invariant\");\n     //若没有超时时间，那么本线程将进入睡眠状态并释放cpu、释放对_mutex的锁定，等待其他线程调用pthread_cond_signal唤醒该线程；唤醒后会获取对_mutex的锁定的锁定\n  if (time == 0) {\n    _cur_index = REL_INDEX; // arbitrary choice when not timed\n    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;\n  } else {\n    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;\n     //开始真正的阻塞，超时等待，或者其他线程pthread_cond_signal唤醒该线程\n    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (&_cond[_cur_index]) ;\n      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());\n    }\n  }\n  _cur_index = -1;\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n    //该线程被唤醒了, 同时也对_mutex加锁了, 置位_counter是线程安全的\n  _counter = 0 ;\n  //解锁_mutex\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence(); //内存屏障\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n```\nParker::park主要做了如下事情:\n+ 检查_counter>0(别的线程调用过unpark), 则原子操作清零。线程不用睡眠并返回。\n+ 检查该线程是否有中断信号, 有的话,清掉并返回。\n+ 尝试通过pthread_mutex_trylock对_mutex加锁来达到线程互斥。\n+ 检查_counter是否>0, 若成立,说明第一步原子清零操作失败。检查park是否设置超时时间, 若设置了通过safe_cond_timedwait进行超时等待; 若没有设置,调用pthread_cond_wait进行阻塞等待。 这两个函数都在阻塞等待时都会放弃cpu的使用。 直到别的线程调用pthread_cond_signal唤醒\n+ 直接_counter=0清零。\n+ 通过pthread_mutex_unlock释放mutex的加锁。\n需要了解下: safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再取唤醒锁。\n## Parker.unpark()\n唤醒操作相对简单:\n```\nvoid Parker::unpark() {\n  int s, status ;\n  //首先是互斥获取锁\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  //只要把这个状态置为1就行了，就是说多次调用unpack()没啥意义\n  _counter = 1;\n   //s只能为0，说明没有人调用unpark\n  if (s < 1) {\n    // thread might be parked\n    if (_cur_index != -1) {\n      // thread is definitely parked\n      //线程已经处于parker状态了\n      if (WorkAroundNPTLTimedWaitHang) {\n       //pthread_cond_signal可以唤醒pthread_cond_wait()被&_cond[_cur_index]阻塞的线程\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n        //解锁\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n      } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n      }\n    } else {\n    //仅仅解锁\n      pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\") ;\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\nunpark()主要做了如下事情:\n+ 首先获取锁_mutex。\n+ 对_counter置为1, 而不管之前什么值, 这里说明无论多少函数调用unpark(), 都是无效的, 只会记录一次。\n+ 检查线程是否已经被阻塞了, 若已经阻塞了,调用pthread_cond_signal唤醒唤醒。\n+ 释放对_mutex的锁定。\n\n# 总结\nLockSupport在阻塞线程时, 更多的是依靠操作系统实现来进行的, 在底层实现时, 也是不忘考虑线程中断。 整体来说LockSupport灵活简单而且功能强大。\n参考:\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\nhttp://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","source":"_posts/LockSupport源码解读.md","raw":"---\ntitle: LockSupport原理分析\ndate: 2018-11-10 17:16:56\ntags: LockSupport\ntoc: true\n---\nLockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 本文将从LockSupport基本用法、 类主要函数及相关知识、底层基本原理三方面分别描述。\n# 使用\n基本用法:\n```\nclass Thread1 extends Thread {\n    public void run() {\n        try {\n            ......\n            LockSupport.park();\n            ......\n        } catch (Exception e) {\n        }\n    }\n}\nThread thread1 = new Thread1();\nclass Thread2 extends Thread {\n    public void run() {\n        try {\n            ......\n            LockSupport.unpark(thread1);\n            ......\n        } catch (Exception e) {\n        }\n    }\n}\n```\n当某个线程调用LockSupport.park()时, 该线程将睡眠并同时交出cpu使用。当别的线程调用LockSupport.unpark(thread1)时, 该线程将被唤醒。可见使用及其简单且灵活。park()与unpark()调用没有先后顺序, 这也是与wait()/notify()(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结</a>)相比更灵活的一点。也就是说先调用了unpark(), 再调用park(), thread1也是可以继续执行而不被阻塞。后面将详细介绍该原理。\n\n# LockSupport源码解析\n## Unsafe\n认识LockSupport, 我们就必须要了解Unsafe。 java作为安全的高级程序语言, 屏蔽了直接与内存打交道的途径。同时java也给我们留了一些后门:Unsafe。Unsafe只听名字就知道是个不安全的类, 它可以直接操作内存, 只有受信任的类才可以使用它。我们不能通过这种方式获取到Unsafe:`Unsafe unsafe = sun.misc.Unsafe.getUnsafe();`因为内部会检查该类的加载器是否是启动类加载器，若不是的话，则直接抛出异常；一般都是通过反射实现该类的获取：\n```\n// 应用类中获取Unsafe\nField theUnsafe = Unsafe.class.getDeclaredField(\"theUnsafe\");\ntheUnsafe.setAccessible(true);\nUnsafe UNSAFE = (Unsafe) theUnsafe.get(null);\n\n//直接操纵内存修改成员变量值\nTest test = new Test();\nField filed = test.getClass().getDeclaredField(\"a\");\nlong ageOffset = UNSAFE.objectFieldOffset(filed);\n//直接通过修改内存来修改成员变量值\nUNSAFE.putInt(test, ageOffset, 100);\n```\n## parkBlockerOffset和parkBlocker\n在LockSupport中有这么一段static代码块:\n```\nprivate static final sun.misc.Unsafe UNSAFE;\n//获取parkBlocker在内存中的偏移量, 就是说谁把该线程block住了\nprivate static final long parkBlockerOffset;\ntry {\n    // 因为LockSupport是受信任的类, 所以才可以通过这种方式产生Unsafe\n    UNSAFE = sun.misc.Unsafe.getUnsafe();\n    // 线程类类型\n    Class<?> tk = Thread.class;\n    //先是通过反射机制获取Thread类的parkBlocker字段对象\n     parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField(\"parkBlocker\"));\n} catch (Exception ex) { throw new Error(ex); }\n```\n该函数可以获取到该线程类成员变量parkBlocker在内存中的偏移量parkBlockerOffset, 然后就可以通过`public static void park(Object blocker)`显示指示该类被什么阻塞的了。然后在jstack时, 将可以看到如下信息:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LockSupport1.png\" height=\"150\" width=\"600\"/>\n提示你设置的阻塞对象是啥, park()代码如下:\n```\n public static void park(Object blocker) {\n        Thread t = Thread.currentThread();\n        setBlocker(t, blocker);\n        UNSAFE.park(false, 0L);\n        setBlocker(t, null);\n}\n```\n这里也可以看出LockSupport实际调用了Unsafe.park/unpark函数。\n\n# Unsafe底层park/unpark原理\nUnsafe类中函数基本都是Native属性, 在虚拟机源代码/hotspot/src/share/vm/prims/unsafe.cpp(L1561)中, 定义了Unsafe类Native与c++语言函数之间对应关系, 如下所示:\n ```\n // These are the methods for 1.8.0\nstatic JNINativeMethod methods_18[] = {\n    {CC\"getObject\",        CC\"(\"OBJ\"J)\"OBJ\"\",   FN_PTR(Unsafe_GetObject)},\n    {CC\"putObject\",        CC\"(\"OBJ\"J\"OBJ\")V\",  FN_PTR(Unsafe_SetObject)},\n    {CC\"getObjectVolatile\",CC\"(\"OBJ\"J)\"OBJ\"\",   FN_PTR(Unsafe_GetObjectVolatile)},\n    {CC\"putObjectVolatile\",CC\"(\"OBJ\"J\"OBJ\")V\",  FN_PTR(Unsafe_SetObjectVolatile)},\n    {CC\"getAddress\",         CC\"(\"ADR\")\"ADR,             FN_PTR(Unsafe_GetNativeAddress)},\n    {CC\"putAddress\",         CC\"(\"ADR\"\"ADR\")V\",          FN_PTR(Unsafe_SetNativeAddress)},\n    {CC\"allocateMemory\",     CC\"(J)\"ADR,                 FN_PTR(Unsafe_AllocateMemory)},\n    {CC\"reallocateMemory\",   CC\"(\"ADR\"J)\"ADR,            FN_PTR(Unsafe_ReallocateMemory)},\n    {CC\"freeMemory\",         CC\"(\"ADR\")V\",               FN_PTR(Unsafe_FreeMemory)},\n    {CC\"objectFieldOffset\",  CC\"(\"FLD\")J\",               FN_PTR(Unsafe_ObjectFieldOffset)},\n    {CC\"staticFieldOffset\",  CC\"(\"FLD\")J\",               FN_PTR(Unsafe_StaticFieldOffset)},\n    {CC\"staticFieldBase\",    CC\"(\"FLD\")\"OBJ,             FN_PTR(Unsafe_StaticFieldBaseFromField)},\n    {CC\"ensureClassInitialized\",CC\"(\"CLS\")V\",            FN_PTR(Unsafe_EnsureClassInitialized)},\n    {CC\"arrayBaseOffset\",    CC\"(\"CLS\")I\",               FN_PTR(Unsafe_ArrayBaseOffset)},\n    {CC\"arrayIndexScale\",    CC\"(\"CLS\")I\",               FN_PTR(Unsafe_ArrayIndexScale)},\n    {CC\"addressSize\",        CC\"()I\",                    FN_PTR(Unsafe_AddressSize)},\n    {CC\"pageSize\",           CC\"()I\",                    FN_PTR(Unsafe_PageSize)},\n    {CC\"defineClass\",        CC\"(\"DC_Args\")\"CLS,         FN_PTR(Unsafe_DefineClass)},\n    {CC\"allocateInstance\",   CC\"(\"CLS\")\"OBJ,             FN_PTR(Unsafe_AllocateInstance)},\n    {CC\"monitorEnter\",       CC\"(\"OBJ\")V\",               FN_PTR(Unsafe_MonitorEnter)},\n    {CC\"monitorExit\",        CC\"(\"OBJ\")V\",               FN_PTR(Unsafe_MonitorExit)},\n    {CC\"tryMonitorEnter\",    CC\"(\"OBJ\")Z\",               FN_PTR(Unsafe_TryMonitorEnter)},\n    {CC\"throwException\",     CC\"(\"THR\")V\",               FN_PTR(Unsafe_ThrowException)},\n    {CC\"compareAndSwapObject\", CC\"(\"OBJ\"J\"OBJ\"\"OBJ\")Z\",  FN_PTR(Unsafe_CompareAndSwapObject)},\n    {CC\"compareAndSwapInt\",  CC\"(\"OBJ\"J\"\"I\"\"I\"\")Z\",      FN_PTR(Unsafe_CompareAndSwapInt)},\n    {CC\"compareAndSwapLong\", CC\"(\"OBJ\"J\"\"J\"\"J\"\")Z\",      FN_PTR(Unsafe_CompareAndSwapLong)},\n    {CC\"putOrderedObject\",   CC\"(\"OBJ\"J\"OBJ\")V\",         FN_PTR(Unsafe_SetOrderedObject)},\n    {CC\"putOrderedInt\",      CC\"(\"OBJ\"JI)V\",             FN_PTR(Unsafe_SetOrderedInt)},\n    {CC\"putOrderedLong\",     CC\"(\"OBJ\"JJ)V\",             FN_PTR(Unsafe_SetOrderedLong)},\n    {CC\"park\",               CC\"(ZJ)V\",                  FN_PTR(Unsafe_Park)},\n    {CC\"unpark\",             CC\"(\"OBJ\")V\",               FN_PTR(Unsafe_Unpark)}\n};\n ```\n可以看出, 我们关注的park和unpark分别对应了Unsafe_Park与Unsafe_Unpark。 下面展示了Unsafe_Park的实现方式:\n```\nUNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))\n  UnsafeWrapper(\"Unsafe_Park\");\n  EventThreadPark event;\n#ifndef USDT2\n  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread->parker(), (int) isAbsolute, time);\n#else /* USDT2 */\n   HOTSPOT_THREAD_PARK_BEGIN(\n                             (uintptr_t) thread->parker(), (int) isAbsolute, time);\n#endif /* USDT2 */\n  JavaThreadParkedState jtps(thread, time != 0);\n  thread->parker()->park(isAbsolute != 0, time);   //进的是这个函数\n#ifndef USDT2\n  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread->parker());\n#else /* USDT2 */\n  HOTSPOT_THREAD_PARK_END(\n                          (uintptr_t) thread->parker());\n#endif /* USDT2 */\n  if (event.should_commit()) {\n    oop obj = thread->current_park_blocker();\n    event.set_klass((obj != NULL) ? obj->klass() : NULL);\n    event.set_timeout(time);\n    event.set_address((obj != NULL) ? (TYPE_ADDRESS) cast_from_oop<uintptr_t>(obj) : 0);\n    event.commit();\n  }\nUNSAFE_END\n```\n我们可以清晰得看到, 真正调用的是thread->parker()->park(isAbsolute != 0, time)方法。\n## thread和Parker\n我们需要了解下vm中thread是如何组成的, JavaThread定义在/hotspot/src/share/vm/prims/runtime/thread.hpp(L1740), 关于Parker成员变量声明如下:\n```\nprivate:\n  Parker*    _parker;\npublic:\n  Parker*     parker() { return _parker; }\n```\n可以看出, 每个thread类中都包含一个Parker。\nParker定义在/hotspot/src/share/vm/runtime/park.hpp(L56), 定义如下:\n```\nclass Parker : public os::PlatformParker {\nprivate:\n  //当_counter只能在0和1之间取值, 当为1时, 代表该类被unpark调用过, 更多的调用, 也不会增加_counter的值, 当该线程调用park()时, 不会阻塞, 同时_counter立刻清零。当为0时, 调用park()会被阻塞。使用volatile来修饰\n  volatile int _counter ;\n  Parker * FreeNext ;\n  JavaThread * AssociatedWith ; // Current association\npublic:\n  Parker() : PlatformParker() {\n    _counter       = 0 ;\n    FreeNext       = NULL ;\n    AssociatedWith = NULL ;\n  }\n```\nPlatformParker继承自Parker, 定义在/hotspot/src/os/linux/vm/os_linux.cpp(L234)\n```\nclass PlatformParker : public CHeapObj<mtInternal> {\n  protected:\n    enum {\n        REL_INDEX = 0,\n        ABS_INDEX = 1\n    };\n    int _cur_index;  // which cond is in use: -1, 0, 1\n    pthread_mutex_t _mutex [1] ;\n    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.\n\n  public:       // TODO-FIXME: make dtor private\n    ~PlatformParker() { guarantee (0, \"invariant\") ; }\n\n  public:\n    PlatformParker() {\n      int status;\n      status = pthread_cond_init (&_cond[REL_INDEX], os::Linux::condAttr());\n      assert_status(status == 0, status, \"cond_init rel\");\n      status = pthread_cond_init (&_cond[ABS_INDEX], NULL);\n      assert_status(status == 0, status, \"cond_init abs\");\n      status = pthread_mutex_init (_mutex, NULL);\n      assert_status(status == 0, status, \"mutex_init\");\n      _cur_index = -1; // mark as unused\n    }\n};\n```\n说这么多, 我们主要是为了让你知道_counter, pthread_mutex_t _mutex[1], pthread_cond_t _cond[2]的存在。_mutex[1]和_cond[2]都是为了配合完成c++层面线程的阻塞与互斥等操作。\n\n## Parker.park()\n```\nvoid Parker::park(bool isAbsolute, jlong time) {\n  // Ideally we'd do something useful while spinning, such\n  // as calling unpackTime().\n  // Optional fast-path check:\n  // Return immediately if a permit is available.\n  // We depend on Atomic::xchg() having full barrier semantics\n  // since we are doing a lock-free update to _counter.\n   //这里通过原子操作来完成_counter清零操作。 若_counter之前>0, 那么说明之前该线程被unpark()过, 就可以直接返回而不被阻塞。\n  if (Atomic::xchg(0, &_counter) > 0) return;\n  Thread* thread = Thread::current();\n  assert(thread->is_Java_thread(), \"Must be JavaThread\");  //判断一定的是java线程\n  JavaThread *jt = (JavaThread *)thread; //类强制转化\n  // Optional optimization -- avoid state transitions if there's an interrupt pending.\n  // Check interrupt before trying to wait\n  //进入睡眠等待前先检查是否有中断信号, 若有中断信号也直接返回。\n  if (Thread::is_interrupted(thread, false)) {\n    return;\n  }\n  // Next, demultiplex/decode time arguments\n  timespec absTime;\n  //如果是按参数小于0，或者绝对时间，那么可以直接返回\n  if (time < 0 || (isAbsolute && time == 0) ) { // don't wait at all\n    return;\n  }\n   //如果时间大于0，判断阻塞超时时间或阻塞截止日期，同时将时间赋值给absTime\n  if (time > 0) {\n    unpackTime(&absTime, isAbsolute, time);\n  }\n  // Enter safepoint region\n  // Beware of deadlocks such as 6317397.\n  // The per-thread Parker:: mutex is a classic leaf-lock.\n  // In particular a thread must never block on the Threads_lock while\n  // holding the Parker:: mutex.  If safepoints are pending both the\n  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.\n  ThreadBlockInVM tbivm(jt);\n  // Don't wait if cannot get lock since interference arises from\n  // unblocking.  Also. check interrupt before trying wait\n  //再次检查, 如果有中断信号。直接返回; 或者申请互斥锁失败，则直接返回pthread_mutex_trylock返回0。任何其他返回值都表示错误。\n  //函数pthread_mutex_trylock是POSIX 线程pthread_mutex_lock的非阻塞版本。\n  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) {\n    return;\n  }\n  //此时已经通过_mutex将该代码进行了互斥操作, 那么直接对_counter都是安全的\n  int status ;\n  如果count>0, 说明之前原子操作赋值为0没有成功。 而_counter> 0, 线程可以直接不阻塞而返回\n  if (_counter > 0)  { // no wait needed\n     //将_counter直接清零\n    _counter = 0;\n    //释放锁并返回， 返回0代表释放锁成功\n    status = pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ; //这里会去检查一下是否成功了\n    // Paranoia to ensure our locked and lock-free paths interact\n    // correctly with each other and Java-level accesses.\n    OrderAccess::fence(); //这个函数是HotSpot VM对JMM的内存屏障一个具体的实现函数;\n    return;\n  }\n#ifdef ASSERT\n  // Don't catch signals while blocked; let the running threads have the signals.\n  // (This allows a debugger to break into the running thread.)\n  sigset_t oldsigs;\n  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();\n  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &oldsigs);\n#endif\n  OSThreadWaitState osts(thread->osthread(), false /* not Object.wait() */);\n  jt->set_suspend_equivalent();\n  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()\n\n  assert(_cur_index == -1, \"invariant\");\n     //若没有超时时间，那么本线程将进入睡眠状态并释放cpu、释放对_mutex的锁定，等待其他线程调用pthread_cond_signal唤醒该线程；唤醒后会获取对_mutex的锁定的锁定\n  if (time == 0) {\n    _cur_index = REL_INDEX; // arbitrary choice when not timed\n    status = pthread_cond_wait (&_cond[_cur_index], _mutex) ;\n  } else {\n    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;\n     //开始真正的阻塞，超时等待，或者其他线程pthread_cond_signal唤醒该线程\n    status = os::Linux::safe_cond_timedwait (&_cond[_cur_index], _mutex, &absTime) ;\n    if (status != 0 && WorkAroundNPTLTimedWaitHang) {\n      pthread_cond_destroy (&_cond[_cur_index]) ;\n      pthread_cond_init    (&_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());\n    }\n  }\n  _cur_index = -1;\n  assert_status(status == 0 || status == EINTR ||\n                status == ETIME || status == ETIMEDOUT,\n                status, \"cond_timedwait\");\n\n#ifdef ASSERT\n  pthread_sigmask(SIG_SETMASK, &oldsigs, NULL);\n#endif\n    //该线程被唤醒了, 同时也对_mutex加锁了, 置位_counter是线程安全的\n  _counter = 0 ;\n  //解锁_mutex\n  status = pthread_mutex_unlock(_mutex) ;\n  assert_status(status == 0, status, \"invariant\") ;\n  // Paranoia to ensure our locked and lock-free paths interact\n  // correctly with each other and Java-level accesses.\n  OrderAccess::fence(); //内存屏障\n  // If externally suspended while waiting, re-suspend\n  if (jt->handle_special_suspend_equivalent_condition()) {\n    jt->java_suspend_self();\n  }\n}\n```\nParker::park主要做了如下事情:\n+ 检查_counter>0(别的线程调用过unpark), 则原子操作清零。线程不用睡眠并返回。\n+ 检查该线程是否有中断信号, 有的话,清掉并返回。\n+ 尝试通过pthread_mutex_trylock对_mutex加锁来达到线程互斥。\n+ 检查_counter是否>0, 若成立,说明第一步原子清零操作失败。检查park是否设置超时时间, 若设置了通过safe_cond_timedwait进行超时等待; 若没有设置,调用pthread_cond_wait进行阻塞等待。 这两个函数都在阻塞等待时都会放弃cpu的使用。 直到别的线程调用pthread_cond_signal唤醒\n+ 直接_counter=0清零。\n+ 通过pthread_mutex_unlock释放mutex的加锁。\n需要了解下: safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再取唤醒锁。\n## Parker.unpark()\n唤醒操作相对简单:\n```\nvoid Parker::unpark() {\n  int s, status ;\n  //首先是互斥获取锁\n  status = pthread_mutex_lock(_mutex);\n  assert (status == 0, \"invariant\") ;\n  s = _counter;\n  //只要把这个状态置为1就行了，就是说多次调用unpack()没啥意义\n  _counter = 1;\n   //s只能为0，说明没有人调用unpark\n  if (s < 1) {\n    // thread might be parked\n    if (_cur_index != -1) {\n      // thread is definitely parked\n      //线程已经处于parker状态了\n      if (WorkAroundNPTLTimedWaitHang) {\n       //pthread_cond_signal可以唤醒pthread_cond_wait()被&_cond[_cur_index]阻塞的线程\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n        //解锁\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n      } else {\n        status = pthread_mutex_unlock(_mutex);\n        assert (status == 0, \"invariant\");\n        status = pthread_cond_signal (&_cond[_cur_index]);\n        assert (status == 0, \"invariant\");\n      }\n    } else {\n    //仅仅解锁\n      pthread_mutex_unlock(_mutex);\n      assert (status == 0, \"invariant\") ;\n    }\n  } else {\n    pthread_mutex_unlock(_mutex);\n    assert (status == 0, \"invariant\") ;\n  }\n}\n```\nunpark()主要做了如下事情:\n+ 首先获取锁_mutex。\n+ 对_counter置为1, 而不管之前什么值, 这里说明无论多少函数调用unpark(), 都是无效的, 只会记录一次。\n+ 检查线程是否已经被阻塞了, 若已经阻塞了,调用pthread_cond_signal唤醒唤醒。\n+ 释放对_mutex的锁定。\n\n# 总结\nLockSupport在阻塞线程时, 更多的是依靠操作系统实现来进行的, 在底层实现时, 也是不忘考虑线程中断。 整体来说LockSupport灵活简单而且功能强大。\n参考:\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\nhttps://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\nhttp://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","slug":"LockSupport源码解读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8wx000iphu5ftmbpgqb","content":"<p>LockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 本文将从LockSupport基本用法、 类主要函数及相关知识、底层基本原理三方面分别描述。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>基本用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Thread1 extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ......</div><div class=\"line\">            LockSupport.park();</div><div class=\"line\">            ......</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Thread thread1 = new Thread1();</div><div class=\"line\">class Thread2 extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ......</div><div class=\"line\">            LockSupport.unpark(thread1);</div><div class=\"line\">            ......</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当某个线程调用LockSupport.park()时, 该线程将睡眠并同时交出cpu使用。当别的线程调用LockSupport.unpark(thread1)时, 该线程将被唤醒。可见使用及其简单且灵活。park()与unpark()调用没有先后顺序, 这也是与wait()/notify()(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结</a>)相比更灵活的一点。也就是说先调用了unpark(), 再调用park(), thread1也是可以继续执行而不被阻塞。后面将详细介绍该原理。</p>\n<h1 id=\"LockSupport源码解析\"><a href=\"#LockSupport源码解析\" class=\"headerlink\" title=\"LockSupport源码解析\"></a>LockSupport源码解析</h1><h2 id=\"Unsafe\"><a href=\"#Unsafe\" class=\"headerlink\" title=\"Unsafe\"></a>Unsafe</h2><p>认识LockSupport, 我们就必须要了解Unsafe。 java作为安全的高级程序语言, 屏蔽了直接与内存打交道的途径。同时java也给我们留了一些后门:Unsafe。Unsafe只听名字就知道是个不安全的类, 它可以直接操作内存, 只有受信任的类才可以使用它。我们不能通过这种方式获取到Unsafe:<code>Unsafe unsafe = sun.misc.Unsafe.getUnsafe();</code>因为内部会检查该类的加载器是否是启动类加载器，若不是的话，则直接抛出异常；一般都是通过反射实现该类的获取：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 应用类中获取Unsafe</div><div class=\"line\">Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class=\"line\">theUnsafe.setAccessible(true);</div><div class=\"line\">Unsafe UNSAFE = (Unsafe) theUnsafe.get(null);</div><div class=\"line\"></div><div class=\"line\">//直接操纵内存修改成员变量值</div><div class=\"line\">Test test = new Test();</div><div class=\"line\">Field filed = test.getClass().getDeclaredField(&quot;a&quot;);</div><div class=\"line\">long ageOffset = UNSAFE.objectFieldOffset(filed);</div><div class=\"line\">//直接通过修改内存来修改成员变量值</div><div class=\"line\">UNSAFE.putInt(test, ageOffset, 100);</div></pre></td></tr></table></figure></p>\n<h2 id=\"parkBlockerOffset和parkBlocker\"><a href=\"#parkBlockerOffset和parkBlocker\" class=\"headerlink\" title=\"parkBlockerOffset和parkBlocker\"></a>parkBlockerOffset和parkBlocker</h2><p>在LockSupport中有这么一段static代码块:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final sun.misc.Unsafe UNSAFE;</div><div class=\"line\">//获取parkBlocker在内存中的偏移量, 就是说谁把该线程block住了</div><div class=\"line\">private static final long parkBlockerOffset;</div><div class=\"line\">try &#123;</div><div class=\"line\">    // 因为LockSupport是受信任的类, 所以才可以通过这种方式产生Unsafe</div><div class=\"line\">    UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class=\"line\">    // 线程类类型</div><div class=\"line\">    Class&lt;?&gt; tk = Thread.class;</div><div class=\"line\">    //先是通过反射机制获取Thread类的parkBlocker字段对象</div><div class=\"line\">     parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField(&quot;parkBlocker&quot;));</div><div class=\"line\">&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</div></pre></td></tr></table></figure></p>\n<p>该函数可以获取到该线程类成员变量parkBlocker在内存中的偏移量parkBlockerOffset, 然后就可以通过<code>public static void park(Object blocker)</code>显示指示该类被什么阻塞的了。然后在jstack时, 将可以看到如下信息:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LockSupport1.png\" height=\"150\" width=\"600\"><br>提示你设置的阻塞对象是啥, park()代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public static void park(Object blocker) &#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        setBlocker(t, blocker);</div><div class=\"line\">        UNSAFE.park(false, 0L);</div><div class=\"line\">        setBlocker(t, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里也可以看出LockSupport实际调用了Unsafe.park/unpark函数。</p>\n<h1 id=\"Unsafe底层park-unpark原理\"><a href=\"#Unsafe底层park-unpark原理\" class=\"headerlink\" title=\"Unsafe底层park/unpark原理\"></a>Unsafe底层park/unpark原理</h1><p>Unsafe类中函数基本都是Native属性, 在虚拟机源代码/hotspot/src/share/vm/prims/unsafe.cpp(L1561)中, 定义了Unsafe类Native与c++语言函数之间对应关系, 如下所示:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // These are the methods for 1.8.0</div><div class=\"line\">static JNINativeMethod methods_18[] = &#123;</div><div class=\"line\">    &#123;CC&quot;getObject&quot;,        CC&quot;(&quot;OBJ&quot;J)&quot;OBJ&quot;&quot;,   FN_PTR(Unsafe_GetObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;putObject&quot;,        CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;)V&quot;,  FN_PTR(Unsafe_SetObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;getObjectVolatile&quot;,CC&quot;(&quot;OBJ&quot;J)&quot;OBJ&quot;&quot;,   FN_PTR(Unsafe_GetObjectVolatile)&#125;,</div><div class=\"line\">    &#123;CC&quot;putObjectVolatile&quot;,CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;)V&quot;,  FN_PTR(Unsafe_SetObjectVolatile)&#125;,</div><div class=\"line\">    &#123;CC&quot;getAddress&quot;,         CC&quot;(&quot;ADR&quot;)&quot;ADR,             FN_PTR(Unsafe_GetNativeAddress)&#125;,</div><div class=\"line\">    &#123;CC&quot;putAddress&quot;,         CC&quot;(&quot;ADR&quot;&quot;ADR&quot;)V&quot;,          FN_PTR(Unsafe_SetNativeAddress)&#125;,</div><div class=\"line\">    &#123;CC&quot;allocateMemory&quot;,     CC&quot;(J)&quot;ADR,                 FN_PTR(Unsafe_AllocateMemory)&#125;,</div><div class=\"line\">    &#123;CC&quot;reallocateMemory&quot;,   CC&quot;(&quot;ADR&quot;J)&quot;ADR,            FN_PTR(Unsafe_ReallocateMemory)&#125;,</div><div class=\"line\">    &#123;CC&quot;freeMemory&quot;,         CC&quot;(&quot;ADR&quot;)V&quot;,               FN_PTR(Unsafe_FreeMemory)&#125;,</div><div class=\"line\">    &#123;CC&quot;objectFieldOffset&quot;,  CC&quot;(&quot;FLD&quot;)J&quot;,               FN_PTR(Unsafe_ObjectFieldOffset)&#125;,</div><div class=\"line\">    &#123;CC&quot;staticFieldOffset&quot;,  CC&quot;(&quot;FLD&quot;)J&quot;,               FN_PTR(Unsafe_StaticFieldOffset)&#125;,</div><div class=\"line\">    &#123;CC&quot;staticFieldBase&quot;,    CC&quot;(&quot;FLD&quot;)&quot;OBJ,             FN_PTR(Unsafe_StaticFieldBaseFromField)&#125;,</div><div class=\"line\">    &#123;CC&quot;ensureClassInitialized&quot;,CC&quot;(&quot;CLS&quot;)V&quot;,            FN_PTR(Unsafe_EnsureClassInitialized)&#125;,</div><div class=\"line\">    &#123;CC&quot;arrayBaseOffset&quot;,    CC&quot;(&quot;CLS&quot;)I&quot;,               FN_PTR(Unsafe_ArrayBaseOffset)&#125;,</div><div class=\"line\">    &#123;CC&quot;arrayIndexScale&quot;,    CC&quot;(&quot;CLS&quot;)I&quot;,               FN_PTR(Unsafe_ArrayIndexScale)&#125;,</div><div class=\"line\">    &#123;CC&quot;addressSize&quot;,        CC&quot;()I&quot;,                    FN_PTR(Unsafe_AddressSize)&#125;,</div><div class=\"line\">    &#123;CC&quot;pageSize&quot;,           CC&quot;()I&quot;,                    FN_PTR(Unsafe_PageSize)&#125;,</div><div class=\"line\">    &#123;CC&quot;defineClass&quot;,        CC&quot;(&quot;DC_Args&quot;)&quot;CLS,         FN_PTR(Unsafe_DefineClass)&#125;,</div><div class=\"line\">    &#123;CC&quot;allocateInstance&quot;,   CC&quot;(&quot;CLS&quot;)&quot;OBJ,             FN_PTR(Unsafe_AllocateInstance)&#125;,</div><div class=\"line\">    &#123;CC&quot;monitorEnter&quot;,       CC&quot;(&quot;OBJ&quot;)V&quot;,               FN_PTR(Unsafe_MonitorEnter)&#125;,</div><div class=\"line\">    &#123;CC&quot;monitorExit&quot;,        CC&quot;(&quot;OBJ&quot;)V&quot;,               FN_PTR(Unsafe_MonitorExit)&#125;,</div><div class=\"line\">    &#123;CC&quot;tryMonitorEnter&quot;,    CC&quot;(&quot;OBJ&quot;)Z&quot;,               FN_PTR(Unsafe_TryMonitorEnter)&#125;,</div><div class=\"line\">    &#123;CC&quot;throwException&quot;,     CC&quot;(&quot;THR&quot;)V&quot;,               FN_PTR(Unsafe_ThrowException)&#125;,</div><div class=\"line\">    &#123;CC&quot;compareAndSwapObject&quot;, CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;&quot;OBJ&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSwapObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;compareAndSwapInt&quot;,  CC&quot;(&quot;OBJ&quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</div><div class=\"line\">    &#123;CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</div><div class=\"line\">    &#123;CC&quot;putOrderedObject&quot;,   CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;)V&quot;,         FN_PTR(Unsafe_SetOrderedObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;putOrderedInt&quot;,      CC&quot;(&quot;OBJ&quot;JI)V&quot;,             FN_PTR(Unsafe_SetOrderedInt)&#125;,</div><div class=\"line\">    &#123;CC&quot;putOrderedLong&quot;,     CC&quot;(&quot;OBJ&quot;JJ)V&quot;,             FN_PTR(Unsafe_SetOrderedLong)&#125;,</div><div class=\"line\">    &#123;CC&quot;park&quot;,               CC&quot;(ZJ)V&quot;,                  FN_PTR(Unsafe_Park)&#125;,</div><div class=\"line\">    &#123;CC&quot;unpark&quot;,             CC&quot;(&quot;OBJ&quot;)V&quot;,               FN_PTR(Unsafe_Unpark)&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 我们关注的park和unpark分别对应了Unsafe_Park与Unsafe_Unpark。 下面展示了Unsafe_Park的实现方式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</div><div class=\"line\">  UnsafeWrapper(&quot;Unsafe_Park&quot;);</div><div class=\"line\">  EventThreadPark event;</div><div class=\"line\">#ifndef USDT2</div><div class=\"line\">  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (int) isAbsolute, time);</div><div class=\"line\">#else /* USDT2 */</div><div class=\"line\">   HOTSPOT_THREAD_PARK_BEGIN(</div><div class=\"line\">                             (uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);</div><div class=\"line\">#endif /* USDT2 */</div><div class=\"line\">  JavaThreadParkedState jtps(thread, time != 0);</div><div class=\"line\">  thread-&gt;parker()-&gt;park(isAbsolute != 0, time);   //进的是这个函数</div><div class=\"line\">#ifndef USDT2</div><div class=\"line\">  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());</div><div class=\"line\">#else /* USDT2 */</div><div class=\"line\">  HOTSPOT_THREAD_PARK_END(</div><div class=\"line\">                          (uintptr_t) thread-&gt;parker());</div><div class=\"line\">#endif /* USDT2 */</div><div class=\"line\">  if (event.should_commit()) &#123;</div><div class=\"line\">    oop obj = thread-&gt;current_park_blocker();</div><div class=\"line\">    event.set_klass((obj != NULL) ? obj-&gt;klass() : NULL);</div><div class=\"line\">    event.set_timeout(time);</div><div class=\"line\">    event.set_address((obj != NULL) ? (TYPE_ADDRESS) cast_from_oop&lt;uintptr_t&gt;(obj) : 0);</div><div class=\"line\">    event.commit();</div><div class=\"line\">  &#125;</div><div class=\"line\">UNSAFE_END</div></pre></td></tr></table></figure></p>\n<p>我们可以清晰得看到, 真正调用的是thread-&gt;parker()-&gt;park(isAbsolute != 0, time)方法。</p>\n<h2 id=\"thread和Parker\"><a href=\"#thread和Parker\" class=\"headerlink\" title=\"thread和Parker\"></a>thread和Parker</h2><p>我们需要了解下vm中thread是如何组成的, JavaThread定义在/hotspot/src/share/vm/prims/runtime/thread.hpp(L1740), 关于Parker成员变量声明如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private:</div><div class=\"line\">  Parker*    _parker;</div><div class=\"line\">public:</div><div class=\"line\">  Parker*     parker() &#123; return _parker; &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 每个thread类中都包含一个Parker。<br>Parker定义在/hotspot/src/share/vm/runtime/park.hpp(L56), 定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Parker : public os::PlatformParker &#123;</div><div class=\"line\">private:</div><div class=\"line\">  //当_counter只能在0和1之间取值, 当为1时, 代表该类被unpark调用过, 更多的调用, 也不会增加_counter的值, 当该线程调用park()时, 不会阻塞, 同时_counter立刻清零。当为0时, 调用park()会被阻塞。使用volatile来修饰</div><div class=\"line\">  volatile int _counter ;</div><div class=\"line\">  Parker * FreeNext ;</div><div class=\"line\">  JavaThread * AssociatedWith ; // Current association</div><div class=\"line\">public:</div><div class=\"line\">  Parker() : PlatformParker() &#123;</div><div class=\"line\">    _counter       = 0 ;</div><div class=\"line\">    FreeNext       = NULL ;</div><div class=\"line\">    AssociatedWith = NULL ;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>PlatformParker继承自Parker, 定义在/hotspot/src/os/linux/vm/os_linux.cpp(L234)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;</div><div class=\"line\">  protected:</div><div class=\"line\">    enum &#123;</div><div class=\"line\">        REL_INDEX = 0,</div><div class=\"line\">        ABS_INDEX = 1</div><div class=\"line\">    &#125;;</div><div class=\"line\">    int _cur_index;  // which cond is in use: -1, 0, 1</div><div class=\"line\">    pthread_mutex_t _mutex [1] ;</div><div class=\"line\">    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.</div><div class=\"line\"></div><div class=\"line\">  public:       // TODO-FIXME: make dtor private</div><div class=\"line\">    ~PlatformParker() &#123; guarantee (0, &quot;invariant&quot;) ; &#125;</div><div class=\"line\"></div><div class=\"line\">  public:</div><div class=\"line\">    PlatformParker() &#123;</div><div class=\"line\">      int status;</div><div class=\"line\">      status = pthread_cond_init (&amp;_cond[REL_INDEX], os::Linux::condAttr());</div><div class=\"line\">      assert_status(status == 0, status, &quot;cond_init rel&quot;);</div><div class=\"line\">      status = pthread_cond_init (&amp;_cond[ABS_INDEX], NULL);</div><div class=\"line\">      assert_status(status == 0, status, &quot;cond_init abs&quot;);</div><div class=\"line\">      status = pthread_mutex_init (_mutex, NULL);</div><div class=\"line\">      assert_status(status == 0, status, &quot;mutex_init&quot;);</div><div class=\"line\">      _cur_index = -1; // mark as unused</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>说这么多, 我们主要是为了让你知道_counter, pthread_mutex_t _mutex[1], pthread_cond_t _cond[2]的存在。_mutex[1]和_cond[2]都是为了配合完成c++层面线程的阻塞与互斥等操作。</p>\n<h2 id=\"Parker-park\"><a href=\"#Parker-park\" class=\"headerlink\" title=\"Parker.park()\"></a>Parker.park()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Parker::park(bool isAbsolute, jlong time) &#123;</div><div class=\"line\">  // Ideally we&apos;d do something useful while spinning, such</div><div class=\"line\">  // as calling unpackTime().</div><div class=\"line\">  // Optional fast-path check:</div><div class=\"line\">  // Return immediately if a permit is available.</div><div class=\"line\">  // We depend on Atomic::xchg() having full barrier semantics</div><div class=\"line\">  // since we are doing a lock-free update to _counter.</div><div class=\"line\">   //这里通过原子操作来完成_counter清零操作。 若_counter之前&gt;0, 那么说明之前该线程被unpark()过, 就可以直接返回而不被阻塞。</div><div class=\"line\">  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</div><div class=\"line\">  Thread* thread = Thread::current();</div><div class=\"line\">  assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);  //判断一定的是java线程</div><div class=\"line\">  JavaThread *jt = (JavaThread *)thread; //类强制转化</div><div class=\"line\">  // Optional optimization -- avoid state transitions if there&apos;s an interrupt pending.</div><div class=\"line\">  // Check interrupt before trying to wait</div><div class=\"line\">  //进入睡眠等待前先检查是否有中断信号, 若有中断信号也直接返回。</div><div class=\"line\">  if (Thread::is_interrupted(thread, false)) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // Next, demultiplex/decode time arguments</div><div class=\"line\">  timespec absTime;</div><div class=\"line\">  //如果是按参数小于0，或者绝对时间，那么可以直接返回</div><div class=\"line\">  if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0) ) &#123; // don&apos;t wait at all</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">   //如果时间大于0，判断阻塞超时时间或阻塞截止日期，同时将时间赋值给absTime</div><div class=\"line\">  if (time &gt; 0) &#123;</div><div class=\"line\">    unpackTime(&amp;absTime, isAbsolute, time);</div><div class=\"line\">  &#125;</div><div class=\"line\">  // Enter safepoint region</div><div class=\"line\">  // Beware of deadlocks such as 6317397.</div><div class=\"line\">  // The per-thread Parker:: mutex is a classic leaf-lock.</div><div class=\"line\">  // In particular a thread must never block on the Threads_lock while</div><div class=\"line\">  // holding the Parker:: mutex.  If safepoints are pending both the</div><div class=\"line\">  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.</div><div class=\"line\">  ThreadBlockInVM tbivm(jt);</div><div class=\"line\">  // Don&apos;t wait if cannot get lock since interference arises from</div><div class=\"line\">  // unblocking.  Also. check interrupt before trying wait</div><div class=\"line\">  //再次检查, 如果有中断信号。直接返回; 或者申请互斥锁失败，则直接返回pthread_mutex_trylock返回0。任何其他返回值都表示错误。</div><div class=\"line\">  //函数pthread_mutex_trylock是POSIX 线程pthread_mutex_lock的非阻塞版本。</div><div class=\"line\">  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //此时已经通过_mutex将该代码进行了互斥操作, 那么直接对_counter都是安全的</div><div class=\"line\">  int status ;</div><div class=\"line\">  如果count&gt;0, 说明之前原子操作赋值为0没有成功。 而_counter&gt; 0, 线程可以直接不阻塞而返回</div><div class=\"line\">  if (_counter &gt; 0)  &#123; // no wait needed</div><div class=\"line\">     //将_counter直接清零</div><div class=\"line\">    _counter = 0;</div><div class=\"line\">    //释放锁并返回， 返回0代表释放锁成功</div><div class=\"line\">    status = pthread_mutex_unlock(_mutex);</div><div class=\"line\">    assert (status == 0, &quot;invariant&quot;) ; //这里会去检查一下是否成功了</div><div class=\"line\">    // Paranoia to ensure our locked and lock-free paths interact</div><div class=\"line\">    // correctly with each other and Java-level accesses.</div><div class=\"line\">    OrderAccess::fence(); //这个函数是HotSpot VM对JMM的内存屏障一个具体的实现函数;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">#ifdef ASSERT</div><div class=\"line\">  // Don&apos;t catch signals while blocked; let the running threads have the signals.</div><div class=\"line\">  // (This allows a debugger to break into the running thread.)</div><div class=\"line\">  sigset_t oldsigs;</div><div class=\"line\">  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();</div><div class=\"line\">  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &amp;oldsigs);</div><div class=\"line\">#endif</div><div class=\"line\">  OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);</div><div class=\"line\">  jt-&gt;set_suspend_equivalent();</div><div class=\"line\">  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()</div><div class=\"line\"></div><div class=\"line\">  assert(_cur_index == -1, &quot;invariant&quot;);</div><div class=\"line\">     //若没有超时时间，那么本线程将进入睡眠状态并释放cpu、释放对_mutex的锁定，等待其他线程调用pthread_cond_signal唤醒该线程；唤醒后会获取对_mutex的锁定的锁定</div><div class=\"line\">  if (time == 0) &#123;</div><div class=\"line\">    _cur_index = REL_INDEX; // arbitrary choice when not timed</div><div class=\"line\">    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;</div><div class=\"line\">     //开始真正的阻塞，超时等待，或者其他线程pthread_cond_signal唤醒该线程</div><div class=\"line\">    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</div><div class=\"line\">    if (status != 0 &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</div><div class=\"line\">      pthread_cond_destroy (&amp;_cond[_cur_index]) ;</div><div class=\"line\">      pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  _cur_index = -1;</div><div class=\"line\">  assert_status(status == 0 || status == EINTR ||</div><div class=\"line\">                status == ETIME || status == ETIMEDOUT,</div><div class=\"line\">                status, &quot;cond_timedwait&quot;);</div><div class=\"line\"></div><div class=\"line\">#ifdef ASSERT</div><div class=\"line\">  pthread_sigmask(SIG_SETMASK, &amp;oldsigs, NULL);</div><div class=\"line\">#endif</div><div class=\"line\">    //该线程被唤醒了, 同时也对_mutex加锁了, 置位_counter是线程安全的</div><div class=\"line\">  _counter = 0 ;</div><div class=\"line\">  //解锁_mutex</div><div class=\"line\">  status = pthread_mutex_unlock(_mutex) ;</div><div class=\"line\">  assert_status(status == 0, status, &quot;invariant&quot;) ;</div><div class=\"line\">  // Paranoia to ensure our locked and lock-free paths interact</div><div class=\"line\">  // correctly with each other and Java-level accesses.</div><div class=\"line\">  OrderAccess::fence(); //内存屏障</div><div class=\"line\">  // If externally suspended while waiting, re-suspend</div><div class=\"line\">  if (jt-&gt;handle_special_suspend_equivalent_condition()) &#123;</div><div class=\"line\">    jt-&gt;java_suspend_self();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Parker::park主要做了如下事情:</p>\n<ul>\n<li>检查_counter&gt;0(别的线程调用过unpark), 则原子操作清零。线程不用睡眠并返回。</li>\n<li>检查该线程是否有中断信号, 有的话,清掉并返回。</li>\n<li>尝试通过pthread_mutex_trylock对_mutex加锁来达到线程互斥。</li>\n<li>检查_counter是否&gt;0, 若成立,说明第一步原子清零操作失败。检查park是否设置超时时间, 若设置了通过safe_cond_timedwait进行超时等待; 若没有设置,调用pthread_cond_wait进行阻塞等待。 这两个函数都在阻塞等待时都会放弃cpu的使用。 直到别的线程调用pthread_cond_signal唤醒</li>\n<li>直接_counter=0清零。</li>\n<li>通过pthread_mutex_unlock释放mutex的加锁。<br>需要了解下: safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再取唤醒锁。<h2 id=\"Parker-unpark\"><a href=\"#Parker-unpark\" class=\"headerlink\" title=\"Parker.unpark()\"></a>Parker.unpark()</h2>唤醒操作相对简单:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Parker::unpark() &#123;</div><div class=\"line\">  int s, status ;</div><div class=\"line\">  //首先是互斥获取锁</div><div class=\"line\">  status = pthread_mutex_lock(_mutex);</div><div class=\"line\">  assert (status == 0, &quot;invariant&quot;) ;</div><div class=\"line\">  s = _counter;</div><div class=\"line\">  //只要把这个状态置为1就行了，就是说多次调用unpack()没啥意义</div><div class=\"line\">  _counter = 1;</div><div class=\"line\">   //s只能为0，说明没有人调用unpark</div><div class=\"line\">  if (s &lt; 1) &#123;</div><div class=\"line\">    // thread might be parked</div><div class=\"line\">    if (_cur_index != -1) &#123;</div><div class=\"line\">      // thread is definitely parked</div><div class=\"line\">      //线程已经处于parker状态了</div><div class=\"line\">      if (WorkAroundNPTLTimedWaitHang) &#123;</div><div class=\"line\">       //pthread_cond_signal可以唤醒pthread_cond_wait()被&amp;_cond[_cur_index]阻塞的线程</div><div class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">        //解锁</div><div class=\"line\">        status = pthread_mutex_unlock(_mutex);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        status = pthread_mutex_unlock(_mutex);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    //仅仅解锁</div><div class=\"line\">      pthread_mutex_unlock(_mutex);</div><div class=\"line\">      assert (status == 0, &quot;invariant&quot;) ;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pthread_mutex_unlock(_mutex);</div><div class=\"line\">    assert (status == 0, &quot;invariant&quot;) ;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>unpark()主要做了如下事情:</p>\n<ul>\n<li>首先获取锁_mutex。</li>\n<li>对_counter置为1, 而不管之前什么值, 这里说明无论多少函数调用unpark(), 都是无效的, 只会记录一次。</li>\n<li>检查线程是否已经被阻塞了, 若已经阻塞了,调用pthread_cond_signal唤醒唤醒。</li>\n<li>释放对_mutex的锁定。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>LockSupport在阻塞线程时, 更多的是依靠操作系统实现来进行的, 在底层实现时, 也是不忘考虑线程中断。 整体来说LockSupport灵活简单而且功能强大。<br>参考:<br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html</a><br><a href=\"http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"external\">http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>LockSupport作为并发的基础, 在CountDownLatch、ReentrantLock、Semaphore、ReentrantReadWriteLock中都是作为阻塞/唤醒线程的基本工具, 因此, 很有必要了解LockSupport的用法及原理, 本文将从LockSupport基本用法、 类主要函数及相关知识、底层基本原理三方面分别描述。</p>\n<h1 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h1><p>基本用法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Thread1 extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ......</div><div class=\"line\">            LockSupport.park();</div><div class=\"line\">            ......</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Thread thread1 = new Thread1();</div><div class=\"line\">class Thread2 extends Thread &#123;</div><div class=\"line\">    public void run() &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ......</div><div class=\"line\">            LockSupport.unpark(thread1);</div><div class=\"line\">            ......</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>当某个线程调用LockSupport.park()时, 该线程将睡眠并同时交出cpu使用。当别的线程调用LockSupport.unpark(thread1)时, 该线程将被唤醒。可见使用及其简单且灵活。park()与unpark()调用没有先后顺序, 这也是与wait()/notify()(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2016/10/27/Java%E7%BA%BF%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%B0%8F%E7%BB%93/\">Java 线程知识小结</a>)相比更灵活的一点。也就是说先调用了unpark(), 再调用park(), thread1也是可以继续执行而不被阻塞。后面将详细介绍该原理。</p>\n<h1 id=\"LockSupport源码解析\"><a href=\"#LockSupport源码解析\" class=\"headerlink\" title=\"LockSupport源码解析\"></a>LockSupport源码解析</h1><h2 id=\"Unsafe\"><a href=\"#Unsafe\" class=\"headerlink\" title=\"Unsafe\"></a>Unsafe</h2><p>认识LockSupport, 我们就必须要了解Unsafe。 java作为安全的高级程序语言, 屏蔽了直接与内存打交道的途径。同时java也给我们留了一些后门:Unsafe。Unsafe只听名字就知道是个不安全的类, 它可以直接操作内存, 只有受信任的类才可以使用它。我们不能通过这种方式获取到Unsafe:<code>Unsafe unsafe = sun.misc.Unsafe.getUnsafe();</code>因为内部会检查该类的加载器是否是启动类加载器，若不是的话，则直接抛出异常；一般都是通过反射实现该类的获取：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 应用类中获取Unsafe</div><div class=\"line\">Field theUnsafe = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class=\"line\">theUnsafe.setAccessible(true);</div><div class=\"line\">Unsafe UNSAFE = (Unsafe) theUnsafe.get(null);</div><div class=\"line\"></div><div class=\"line\">//直接操纵内存修改成员变量值</div><div class=\"line\">Test test = new Test();</div><div class=\"line\">Field filed = test.getClass().getDeclaredField(&quot;a&quot;);</div><div class=\"line\">long ageOffset = UNSAFE.objectFieldOffset(filed);</div><div class=\"line\">//直接通过修改内存来修改成员变量值</div><div class=\"line\">UNSAFE.putInt(test, ageOffset, 100);</div></pre></td></tr></table></figure></p>\n<h2 id=\"parkBlockerOffset和parkBlocker\"><a href=\"#parkBlockerOffset和parkBlocker\" class=\"headerlink\" title=\"parkBlockerOffset和parkBlocker\"></a>parkBlockerOffset和parkBlocker</h2><p>在LockSupport中有这么一段static代码块:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final sun.misc.Unsafe UNSAFE;</div><div class=\"line\">//获取parkBlocker在内存中的偏移量, 就是说谁把该线程block住了</div><div class=\"line\">private static final long parkBlockerOffset;</div><div class=\"line\">try &#123;</div><div class=\"line\">    // 因为LockSupport是受信任的类, 所以才可以通过这种方式产生Unsafe</div><div class=\"line\">    UNSAFE = sun.misc.Unsafe.getUnsafe();</div><div class=\"line\">    // 线程类类型</div><div class=\"line\">    Class&lt;?&gt; tk = Thread.class;</div><div class=\"line\">    //先是通过反射机制获取Thread类的parkBlocker字段对象</div><div class=\"line\">     parkBlockerOffset = UNSAFE.objectFieldOffset(tk.getDeclaredField(&quot;parkBlocker&quot;));</div><div class=\"line\">&#125; catch (Exception ex) &#123; throw new Error(ex); &#125;</div></pre></td></tr></table></figure></p>\n<p>该函数可以获取到该线程类成员变量parkBlocker在内存中的偏移量parkBlockerOffset, 然后就可以通过<code>public static void park(Object blocker)</code>显示指示该类被什么阻塞的了。然后在jstack时, 将可以看到如下信息:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/LockSupport1.png\" height=\"150\" width=\"600\"><br>提示你设置的阻塞对象是啥, park()代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public static void park(Object blocker) &#123;</div><div class=\"line\">        Thread t = Thread.currentThread();</div><div class=\"line\">        setBlocker(t, blocker);</div><div class=\"line\">        UNSAFE.park(false, 0L);</div><div class=\"line\">        setBlocker(t, null);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里也可以看出LockSupport实际调用了Unsafe.park/unpark函数。</p>\n<h1 id=\"Unsafe底层park-unpark原理\"><a href=\"#Unsafe底层park-unpark原理\" class=\"headerlink\" title=\"Unsafe底层park/unpark原理\"></a>Unsafe底层park/unpark原理</h1><p>Unsafe类中函数基本都是Native属性, 在虚拟机源代码/hotspot/src/share/vm/prims/unsafe.cpp(L1561)中, 定义了Unsafe类Native与c++语言函数之间对应关系, 如下所示:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // These are the methods for 1.8.0</div><div class=\"line\">static JNINativeMethod methods_18[] = &#123;</div><div class=\"line\">    &#123;CC&quot;getObject&quot;,        CC&quot;(&quot;OBJ&quot;J)&quot;OBJ&quot;&quot;,   FN_PTR(Unsafe_GetObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;putObject&quot;,        CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;)V&quot;,  FN_PTR(Unsafe_SetObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;getObjectVolatile&quot;,CC&quot;(&quot;OBJ&quot;J)&quot;OBJ&quot;&quot;,   FN_PTR(Unsafe_GetObjectVolatile)&#125;,</div><div class=\"line\">    &#123;CC&quot;putObjectVolatile&quot;,CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;)V&quot;,  FN_PTR(Unsafe_SetObjectVolatile)&#125;,</div><div class=\"line\">    &#123;CC&quot;getAddress&quot;,         CC&quot;(&quot;ADR&quot;)&quot;ADR,             FN_PTR(Unsafe_GetNativeAddress)&#125;,</div><div class=\"line\">    &#123;CC&quot;putAddress&quot;,         CC&quot;(&quot;ADR&quot;&quot;ADR&quot;)V&quot;,          FN_PTR(Unsafe_SetNativeAddress)&#125;,</div><div class=\"line\">    &#123;CC&quot;allocateMemory&quot;,     CC&quot;(J)&quot;ADR,                 FN_PTR(Unsafe_AllocateMemory)&#125;,</div><div class=\"line\">    &#123;CC&quot;reallocateMemory&quot;,   CC&quot;(&quot;ADR&quot;J)&quot;ADR,            FN_PTR(Unsafe_ReallocateMemory)&#125;,</div><div class=\"line\">    &#123;CC&quot;freeMemory&quot;,         CC&quot;(&quot;ADR&quot;)V&quot;,               FN_PTR(Unsafe_FreeMemory)&#125;,</div><div class=\"line\">    &#123;CC&quot;objectFieldOffset&quot;,  CC&quot;(&quot;FLD&quot;)J&quot;,               FN_PTR(Unsafe_ObjectFieldOffset)&#125;,</div><div class=\"line\">    &#123;CC&quot;staticFieldOffset&quot;,  CC&quot;(&quot;FLD&quot;)J&quot;,               FN_PTR(Unsafe_StaticFieldOffset)&#125;,</div><div class=\"line\">    &#123;CC&quot;staticFieldBase&quot;,    CC&quot;(&quot;FLD&quot;)&quot;OBJ,             FN_PTR(Unsafe_StaticFieldBaseFromField)&#125;,</div><div class=\"line\">    &#123;CC&quot;ensureClassInitialized&quot;,CC&quot;(&quot;CLS&quot;)V&quot;,            FN_PTR(Unsafe_EnsureClassInitialized)&#125;,</div><div class=\"line\">    &#123;CC&quot;arrayBaseOffset&quot;,    CC&quot;(&quot;CLS&quot;)I&quot;,               FN_PTR(Unsafe_ArrayBaseOffset)&#125;,</div><div class=\"line\">    &#123;CC&quot;arrayIndexScale&quot;,    CC&quot;(&quot;CLS&quot;)I&quot;,               FN_PTR(Unsafe_ArrayIndexScale)&#125;,</div><div class=\"line\">    &#123;CC&quot;addressSize&quot;,        CC&quot;()I&quot;,                    FN_PTR(Unsafe_AddressSize)&#125;,</div><div class=\"line\">    &#123;CC&quot;pageSize&quot;,           CC&quot;()I&quot;,                    FN_PTR(Unsafe_PageSize)&#125;,</div><div class=\"line\">    &#123;CC&quot;defineClass&quot;,        CC&quot;(&quot;DC_Args&quot;)&quot;CLS,         FN_PTR(Unsafe_DefineClass)&#125;,</div><div class=\"line\">    &#123;CC&quot;allocateInstance&quot;,   CC&quot;(&quot;CLS&quot;)&quot;OBJ,             FN_PTR(Unsafe_AllocateInstance)&#125;,</div><div class=\"line\">    &#123;CC&quot;monitorEnter&quot;,       CC&quot;(&quot;OBJ&quot;)V&quot;,               FN_PTR(Unsafe_MonitorEnter)&#125;,</div><div class=\"line\">    &#123;CC&quot;monitorExit&quot;,        CC&quot;(&quot;OBJ&quot;)V&quot;,               FN_PTR(Unsafe_MonitorExit)&#125;,</div><div class=\"line\">    &#123;CC&quot;tryMonitorEnter&quot;,    CC&quot;(&quot;OBJ&quot;)Z&quot;,               FN_PTR(Unsafe_TryMonitorEnter)&#125;,</div><div class=\"line\">    &#123;CC&quot;throwException&quot;,     CC&quot;(&quot;THR&quot;)V&quot;,               FN_PTR(Unsafe_ThrowException)&#125;,</div><div class=\"line\">    &#123;CC&quot;compareAndSwapObject&quot;, CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;&quot;OBJ&quot;)Z&quot;,  FN_PTR(Unsafe_CompareAndSwapObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;compareAndSwapInt&quot;,  CC&quot;(&quot;OBJ&quot;J&quot;&quot;I&quot;&quot;I&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapInt)&#125;,</div><div class=\"line\">    &#123;CC&quot;compareAndSwapLong&quot;, CC&quot;(&quot;OBJ&quot;J&quot;&quot;J&quot;&quot;J&quot;&quot;)Z&quot;,      FN_PTR(Unsafe_CompareAndSwapLong)&#125;,</div><div class=\"line\">    &#123;CC&quot;putOrderedObject&quot;,   CC&quot;(&quot;OBJ&quot;J&quot;OBJ&quot;)V&quot;,         FN_PTR(Unsafe_SetOrderedObject)&#125;,</div><div class=\"line\">    &#123;CC&quot;putOrderedInt&quot;,      CC&quot;(&quot;OBJ&quot;JI)V&quot;,             FN_PTR(Unsafe_SetOrderedInt)&#125;,</div><div class=\"line\">    &#123;CC&quot;putOrderedLong&quot;,     CC&quot;(&quot;OBJ&quot;JJ)V&quot;,             FN_PTR(Unsafe_SetOrderedLong)&#125;,</div><div class=\"line\">    &#123;CC&quot;park&quot;,               CC&quot;(ZJ)V&quot;,                  FN_PTR(Unsafe_Park)&#125;,</div><div class=\"line\">    &#123;CC&quot;unpark&quot;,             CC&quot;(&quot;OBJ&quot;)V&quot;,               FN_PTR(Unsafe_Unpark)&#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 我们关注的park和unpark分别对应了Unsafe_Park与Unsafe_Unpark。 下面展示了Unsafe_Park的实现方式:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">UNSAFE_ENTRY(void, Unsafe_Park(JNIEnv *env, jobject unsafe, jboolean isAbsolute, jlong time))</div><div class=\"line\">  UnsafeWrapper(&quot;Unsafe_Park&quot;);</div><div class=\"line\">  EventThreadPark event;</div><div class=\"line\">#ifndef USDT2</div><div class=\"line\">  HS_DTRACE_PROBE3(hotspot, thread__park__begin, thread-&gt;parker(), (int) isAbsolute, time);</div><div class=\"line\">#else /* USDT2 */</div><div class=\"line\">   HOTSPOT_THREAD_PARK_BEGIN(</div><div class=\"line\">                             (uintptr_t) thread-&gt;parker(), (int) isAbsolute, time);</div><div class=\"line\">#endif /* USDT2 */</div><div class=\"line\">  JavaThreadParkedState jtps(thread, time != 0);</div><div class=\"line\">  thread-&gt;parker()-&gt;park(isAbsolute != 0, time);   //进的是这个函数</div><div class=\"line\">#ifndef USDT2</div><div class=\"line\">  HS_DTRACE_PROBE1(hotspot, thread__park__end, thread-&gt;parker());</div><div class=\"line\">#else /* USDT2 */</div><div class=\"line\">  HOTSPOT_THREAD_PARK_END(</div><div class=\"line\">                          (uintptr_t) thread-&gt;parker());</div><div class=\"line\">#endif /* USDT2 */</div><div class=\"line\">  if (event.should_commit()) &#123;</div><div class=\"line\">    oop obj = thread-&gt;current_park_blocker();</div><div class=\"line\">    event.set_klass((obj != NULL) ? obj-&gt;klass() : NULL);</div><div class=\"line\">    event.set_timeout(time);</div><div class=\"line\">    event.set_address((obj != NULL) ? (TYPE_ADDRESS) cast_from_oop&lt;uintptr_t&gt;(obj) : 0);</div><div class=\"line\">    event.commit();</div><div class=\"line\">  &#125;</div><div class=\"line\">UNSAFE_END</div></pre></td></tr></table></figure></p>\n<p>我们可以清晰得看到, 真正调用的是thread-&gt;parker()-&gt;park(isAbsolute != 0, time)方法。</p>\n<h2 id=\"thread和Parker\"><a href=\"#thread和Parker\" class=\"headerlink\" title=\"thread和Parker\"></a>thread和Parker</h2><p>我们需要了解下vm中thread是如何组成的, JavaThread定义在/hotspot/src/share/vm/prims/runtime/thread.hpp(L1740), 关于Parker成员变量声明如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private:</div><div class=\"line\">  Parker*    _parker;</div><div class=\"line\">public:</div><div class=\"line\">  Parker*     parker() &#123; return _parker; &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 每个thread类中都包含一个Parker。<br>Parker定义在/hotspot/src/share/vm/runtime/park.hpp(L56), 定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">class Parker : public os::PlatformParker &#123;</div><div class=\"line\">private:</div><div class=\"line\">  //当_counter只能在0和1之间取值, 当为1时, 代表该类被unpark调用过, 更多的调用, 也不会增加_counter的值, 当该线程调用park()时, 不会阻塞, 同时_counter立刻清零。当为0时, 调用park()会被阻塞。使用volatile来修饰</div><div class=\"line\">  volatile int _counter ;</div><div class=\"line\">  Parker * FreeNext ;</div><div class=\"line\">  JavaThread * AssociatedWith ; // Current association</div><div class=\"line\">public:</div><div class=\"line\">  Parker() : PlatformParker() &#123;</div><div class=\"line\">    _counter       = 0 ;</div><div class=\"line\">    FreeNext       = NULL ;</div><div class=\"line\">    AssociatedWith = NULL ;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n<p>PlatformParker继承自Parker, 定义在/hotspot/src/os/linux/vm/os_linux.cpp(L234)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">class PlatformParker : public CHeapObj&lt;mtInternal&gt; &#123;</div><div class=\"line\">  protected:</div><div class=\"line\">    enum &#123;</div><div class=\"line\">        REL_INDEX = 0,</div><div class=\"line\">        ABS_INDEX = 1</div><div class=\"line\">    &#125;;</div><div class=\"line\">    int _cur_index;  // which cond is in use: -1, 0, 1</div><div class=\"line\">    pthread_mutex_t _mutex [1] ;</div><div class=\"line\">    pthread_cond_t  _cond  [2] ; // one for relative times and one for abs.</div><div class=\"line\"></div><div class=\"line\">  public:       // TODO-FIXME: make dtor private</div><div class=\"line\">    ~PlatformParker() &#123; guarantee (0, &quot;invariant&quot;) ; &#125;</div><div class=\"line\"></div><div class=\"line\">  public:</div><div class=\"line\">    PlatformParker() &#123;</div><div class=\"line\">      int status;</div><div class=\"line\">      status = pthread_cond_init (&amp;_cond[REL_INDEX], os::Linux::condAttr());</div><div class=\"line\">      assert_status(status == 0, status, &quot;cond_init rel&quot;);</div><div class=\"line\">      status = pthread_cond_init (&amp;_cond[ABS_INDEX], NULL);</div><div class=\"line\">      assert_status(status == 0, status, &quot;cond_init abs&quot;);</div><div class=\"line\">      status = pthread_mutex_init (_mutex, NULL);</div><div class=\"line\">      assert_status(status == 0, status, &quot;mutex_init&quot;);</div><div class=\"line\">      _cur_index = -1; // mark as unused</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>说这么多, 我们主要是为了让你知道_counter, pthread_mutex_t _mutex[1], pthread_cond_t _cond[2]的存在。_mutex[1]和_cond[2]都是为了配合完成c++层面线程的阻塞与互斥等操作。</p>\n<h2 id=\"Parker-park\"><a href=\"#Parker-park\" class=\"headerlink\" title=\"Parker.park()\"></a>Parker.park()</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Parker::park(bool isAbsolute, jlong time) &#123;</div><div class=\"line\">  // Ideally we&apos;d do something useful while spinning, such</div><div class=\"line\">  // as calling unpackTime().</div><div class=\"line\">  // Optional fast-path check:</div><div class=\"line\">  // Return immediately if a permit is available.</div><div class=\"line\">  // We depend on Atomic::xchg() having full barrier semantics</div><div class=\"line\">  // since we are doing a lock-free update to _counter.</div><div class=\"line\">   //这里通过原子操作来完成_counter清零操作。 若_counter之前&gt;0, 那么说明之前该线程被unpark()过, 就可以直接返回而不被阻塞。</div><div class=\"line\">  if (Atomic::xchg(0, &amp;_counter) &gt; 0) return;</div><div class=\"line\">  Thread* thread = Thread::current();</div><div class=\"line\">  assert(thread-&gt;is_Java_thread(), &quot;Must be JavaThread&quot;);  //判断一定的是java线程</div><div class=\"line\">  JavaThread *jt = (JavaThread *)thread; //类强制转化</div><div class=\"line\">  // Optional optimization -- avoid state transitions if there&apos;s an interrupt pending.</div><div class=\"line\">  // Check interrupt before trying to wait</div><div class=\"line\">  //进入睡眠等待前先检查是否有中断信号, 若有中断信号也直接返回。</div><div class=\"line\">  if (Thread::is_interrupted(thread, false)) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  // Next, demultiplex/decode time arguments</div><div class=\"line\">  timespec absTime;</div><div class=\"line\">  //如果是按参数小于0，或者绝对时间，那么可以直接返回</div><div class=\"line\">  if (time &lt; 0 || (isAbsolute &amp;&amp; time == 0) ) &#123; // don&apos;t wait at all</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">   //如果时间大于0，判断阻塞超时时间或阻塞截止日期，同时将时间赋值给absTime</div><div class=\"line\">  if (time &gt; 0) &#123;</div><div class=\"line\">    unpackTime(&amp;absTime, isAbsolute, time);</div><div class=\"line\">  &#125;</div><div class=\"line\">  // Enter safepoint region</div><div class=\"line\">  // Beware of deadlocks such as 6317397.</div><div class=\"line\">  // The per-thread Parker:: mutex is a classic leaf-lock.</div><div class=\"line\">  // In particular a thread must never block on the Threads_lock while</div><div class=\"line\">  // holding the Parker:: mutex.  If safepoints are pending both the</div><div class=\"line\">  // the ThreadBlockInVM() CTOR and DTOR may grab Threads_lock.</div><div class=\"line\">  ThreadBlockInVM tbivm(jt);</div><div class=\"line\">  // Don&apos;t wait if cannot get lock since interference arises from</div><div class=\"line\">  // unblocking.  Also. check interrupt before trying wait</div><div class=\"line\">  //再次检查, 如果有中断信号。直接返回; 或者申请互斥锁失败，则直接返回pthread_mutex_trylock返回0。任何其他返回值都表示错误。</div><div class=\"line\">  //函数pthread_mutex_trylock是POSIX 线程pthread_mutex_lock的非阻塞版本。</div><div class=\"line\">  if (Thread::is_interrupted(thread, false) || pthread_mutex_trylock(_mutex) != 0) &#123;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">  //此时已经通过_mutex将该代码进行了互斥操作, 那么直接对_counter都是安全的</div><div class=\"line\">  int status ;</div><div class=\"line\">  如果count&gt;0, 说明之前原子操作赋值为0没有成功。 而_counter&gt; 0, 线程可以直接不阻塞而返回</div><div class=\"line\">  if (_counter &gt; 0)  &#123; // no wait needed</div><div class=\"line\">     //将_counter直接清零</div><div class=\"line\">    _counter = 0;</div><div class=\"line\">    //释放锁并返回， 返回0代表释放锁成功</div><div class=\"line\">    status = pthread_mutex_unlock(_mutex);</div><div class=\"line\">    assert (status == 0, &quot;invariant&quot;) ; //这里会去检查一下是否成功了</div><div class=\"line\">    // Paranoia to ensure our locked and lock-free paths interact</div><div class=\"line\">    // correctly with each other and Java-level accesses.</div><div class=\"line\">    OrderAccess::fence(); //这个函数是HotSpot VM对JMM的内存屏障一个具体的实现函数;</div><div class=\"line\">    return;</div><div class=\"line\">  &#125;</div><div class=\"line\">#ifdef ASSERT</div><div class=\"line\">  // Don&apos;t catch signals while blocked; let the running threads have the signals.</div><div class=\"line\">  // (This allows a debugger to break into the running thread.)</div><div class=\"line\">  sigset_t oldsigs;</div><div class=\"line\">  sigset_t* allowdebug_blocked = os::Linux::allowdebug_blocked_signals();</div><div class=\"line\">  pthread_sigmask(SIG_BLOCK, allowdebug_blocked, &amp;oldsigs);</div><div class=\"line\">#endif</div><div class=\"line\">  OSThreadWaitState osts(thread-&gt;osthread(), false /* not Object.wait() */);</div><div class=\"line\">  jt-&gt;set_suspend_equivalent();</div><div class=\"line\">  // cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()</div><div class=\"line\"></div><div class=\"line\">  assert(_cur_index == -1, &quot;invariant&quot;);</div><div class=\"line\">     //若没有超时时间，那么本线程将进入睡眠状态并释放cpu、释放对_mutex的锁定，等待其他线程调用pthread_cond_signal唤醒该线程；唤醒后会获取对_mutex的锁定的锁定</div><div class=\"line\">  if (time == 0) &#123;</div><div class=\"line\">    _cur_index = REL_INDEX; // arbitrary choice when not timed</div><div class=\"line\">    status = pthread_cond_wait (&amp;_cond[_cur_index], _mutex) ;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    _cur_index = isAbsolute ? ABS_INDEX : REL_INDEX;</div><div class=\"line\">     //开始真正的阻塞，超时等待，或者其他线程pthread_cond_signal唤醒该线程</div><div class=\"line\">    status = os::Linux::safe_cond_timedwait (&amp;_cond[_cur_index], _mutex, &amp;absTime) ;</div><div class=\"line\">    if (status != 0 &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</div><div class=\"line\">      pthread_cond_destroy (&amp;_cond[_cur_index]) ;</div><div class=\"line\">      pthread_cond_init    (&amp;_cond[_cur_index], isAbsolute ? NULL : os::Linux::condAttr());</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  _cur_index = -1;</div><div class=\"line\">  assert_status(status == 0 || status == EINTR ||</div><div class=\"line\">                status == ETIME || status == ETIMEDOUT,</div><div class=\"line\">                status, &quot;cond_timedwait&quot;);</div><div class=\"line\"></div><div class=\"line\">#ifdef ASSERT</div><div class=\"line\">  pthread_sigmask(SIG_SETMASK, &amp;oldsigs, NULL);</div><div class=\"line\">#endif</div><div class=\"line\">    //该线程被唤醒了, 同时也对_mutex加锁了, 置位_counter是线程安全的</div><div class=\"line\">  _counter = 0 ;</div><div class=\"line\">  //解锁_mutex</div><div class=\"line\">  status = pthread_mutex_unlock(_mutex) ;</div><div class=\"line\">  assert_status(status == 0, status, &quot;invariant&quot;) ;</div><div class=\"line\">  // Paranoia to ensure our locked and lock-free paths interact</div><div class=\"line\">  // correctly with each other and Java-level accesses.</div><div class=\"line\">  OrderAccess::fence(); //内存屏障</div><div class=\"line\">  // If externally suspended while waiting, re-suspend</div><div class=\"line\">  if (jt-&gt;handle_special_suspend_equivalent_condition()) &#123;</div><div class=\"line\">    jt-&gt;java_suspend_self();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>Parker::park主要做了如下事情:</p>\n<ul>\n<li>检查_counter&gt;0(别的线程调用过unpark), 则原子操作清零。线程不用睡眠并返回。</li>\n<li>检查该线程是否有中断信号, 有的话,清掉并返回。</li>\n<li>尝试通过pthread_mutex_trylock对_mutex加锁来达到线程互斥。</li>\n<li>检查_counter是否&gt;0, 若成立,说明第一步原子清零操作失败。检查park是否设置超时时间, 若设置了通过safe_cond_timedwait进行超时等待; 若没有设置,调用pthread_cond_wait进行阻塞等待。 这两个函数都在阻塞等待时都会放弃cpu的使用。 直到别的线程调用pthread_cond_signal唤醒</li>\n<li>直接_counter=0清零。</li>\n<li>通过pthread_mutex_unlock释放mutex的加锁。<br>需要了解下: safe_cond_timedwait/pthread_cond_wait在执行之前肯定已经获取了锁_mutex, 在睡眠前释放了锁, 在被唤醒之前, 首先再取唤醒锁。<h2 id=\"Parker-unpark\"><a href=\"#Parker-unpark\" class=\"headerlink\" title=\"Parker.unpark()\"></a>Parker.unpark()</h2>唤醒操作相对简单:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">void Parker::unpark() &#123;</div><div class=\"line\">  int s, status ;</div><div class=\"line\">  //首先是互斥获取锁</div><div class=\"line\">  status = pthread_mutex_lock(_mutex);</div><div class=\"line\">  assert (status == 0, &quot;invariant&quot;) ;</div><div class=\"line\">  s = _counter;</div><div class=\"line\">  //只要把这个状态置为1就行了，就是说多次调用unpack()没啥意义</div><div class=\"line\">  _counter = 1;</div><div class=\"line\">   //s只能为0，说明没有人调用unpark</div><div class=\"line\">  if (s &lt; 1) &#123;</div><div class=\"line\">    // thread might be parked</div><div class=\"line\">    if (_cur_index != -1) &#123;</div><div class=\"line\">      // thread is definitely parked</div><div class=\"line\">      //线程已经处于parker状态了</div><div class=\"line\">      if (WorkAroundNPTLTimedWaitHang) &#123;</div><div class=\"line\">       //pthread_cond_signal可以唤醒pthread_cond_wait()被&amp;_cond[_cur_index]阻塞的线程</div><div class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">        //解锁</div><div class=\"line\">        status = pthread_mutex_unlock(_mutex);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        status = pthread_mutex_unlock(_mutex);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">        status = pthread_cond_signal (&amp;_cond[_cur_index]);</div><div class=\"line\">        assert (status == 0, &quot;invariant&quot;);</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">    //仅仅解锁</div><div class=\"line\">      pthread_mutex_unlock(_mutex);</div><div class=\"line\">      assert (status == 0, &quot;invariant&quot;) ;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    pthread_mutex_unlock(_mutex);</div><div class=\"line\">    assert (status == 0, &quot;invariant&quot;) ;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>unpark()主要做了如下事情:</p>\n<ul>\n<li>首先获取锁_mutex。</li>\n<li>对_counter置为1, 而不管之前什么值, 这里说明无论多少函数调用unpark(), 都是无效的, 只会记录一次。</li>\n<li>检查线程是否已经被阻塞了, 若已经阻塞了,调用pthread_cond_signal唤醒唤醒。</li>\n<li>释放对_mutex的锁定。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>LockSupport在阻塞线程时, 更多的是依靠操作系统实现来进行的, 在底层实现时, 也是不忘考虑线程中断。 整体来说LockSupport灵活简单而且功能强大。<br>参考:<br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread1/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread2/index.html</a><br><a href=\"https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html\" target=\"_blank\" rel=\"external\">https://www.ibm.com/developerworks/cn/linux/thread/posix_thread3/index.html</a><br><a href=\"http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/\" target=\"_blank\" rel=\"external\">http://www.fanyilun.me/2016/11/19/Thread.interrupt()%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</a></p>\n"},{"title":"Netty Http通信源码二(编码)分析","date":"2018-05-03T16:02:39.000Z","toc":true,"_content":"解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultFullHttpResponse.png\" height=\"250\" width=\"500\"/>\n涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。\n开始向外发送数据时, 如下:\n```\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context\n        final Object m = pipeline.touch(msg, next);\n        EventExecutor executor = next.executor();\n        if (executor.inEventLoop()) {\n            if (flush) {\n                next.invokeWriteAndFlush(m, promise);\n            } else {\n                next.invokeWrite(m, promise);\n            }\n        } else {\n            AbstractWriteTask task;\n            if (flush) {\n                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行\n            }  else {\n                task = WriteTask.newInstance(next, m, promise);\n            }\n            safeExecute(executor, task, promise, m);\n        }\n    }\n```\n当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:\n```\n        @Override\n        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n            super.write(ctx, msg, promise); //一般只是存放在缓存中\n            ctx.invokeFlush(); //真正的调用write,\n        }\n```\n可以看出, 写数据分为两个过程:write()和flush():\n+ write只是将数据放在了缓存ChannelOutboundBuffer中\n+ 通过调用channal.write()向网络发送数据。\n\n# HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\n我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。\n首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:\n```\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        CodecOutputList out = null;\n        try {\n            if (acceptOutboundMessage(msg)) {\n                out = CodecOutputList.newInstance();\n                I cast = (I) msg;\n                try {\n                    encode(ctx, cast, out);\n                } finally {\n                    ReferenceCountUtil.release(cast);\n                }\n                if (out.isEmpty()) {\n                    out.recycle();\n                    out = null;\n                    throw new EncoderException(\n                            StringUtil.simpleClassName(this) + \" must produce at least one message.\");\n                }\n            } else {\n                ctx.write(msg, promise);\n            }\n        }\n        } finally {\n            if (out != null) {\n                final int sizeMinusOne = out.size() - 1;\n                if (sizeMinusOne == 0) {\n                    ctx.write(out.get(0), promise);\n                } else if (sizeMinusOne > 0) {\n                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure\n                    // See https://github.com/netty/netty/issues/2525\n                    ChannelPromise voidPromise = ctx.voidPromise();\n                    boolean isVoidPromise = promise == voidPromise;\n                    for (int i = 0; i < sizeMinusOne; i ++) {//分开向下发送\n                        ChannelPromise p;\n                        if (isVoidPromise) {\n                            p = voidPromise;\n                        } else {\n                            p = ctx.newPromise();\n                        }\n                        ctx.write(out.getUnsafe(i), p);\n                    }\n                    ctx.write(out.getUnsafe(sizeMinusOne), promise);\n                }\n                out.recycle();\n            }\n        }\n    }\n```\n实现也很简单,主要做了如下两件事:\n1. 首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。\n2. 针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。\n\n## HttpContentEncoder的encode()函数\n首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: \"gzip,deflat,br\"为例。\n\nendoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分\n```\n@Override    //msg: DefaultFullHttpResponse\n    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;\n        switch (state) {\n            case AWAIT_HEADERS: {  //初始取值\n                ensureHeaders(msg);\n                assert encoder == null;\n\n                final HttpResponse res = (HttpResponse) msg;\n                 //根据返回结果确定是否需要编码\n                final int code = res.status().code();\n                final CharSequence acceptEncoding;\n                if (code == CONTINUE_CODE) { //continue_code\n                    // We need to not poll the encoding when response with CONTINUE as another response will follow\n                    // for the issued request. See https://github.com/netty/netty/issues/4079\n                    acceptEncoding = null;\n                } else {\n                    // Get the list of encodings accepted by the peer.\n                    acceptEncoding = acceptEncodingQueue.poll(); //\"gzip.default.br\"\n                    if (acceptEncoding == null) {\n                        throw new IllegalStateException(\"cannot send more responses than requests\");\n                    }\n                }\n                /*\n                 * per rfc2616 4.3 Message Body\n                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a\n                 * message-body. All other responses do include a message-body, although it MAY be of zero length.\n                 *\n                 * 9.4 HEAD\n                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body\n                 * in the response.\n                 *\n                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.\n                 *\n                 * See https://github.com/netty/netty/issues/5382\n                 */\n                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) { //是否接下来是没有body的\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n                if (isFull) {\n                    // Pass through the full response with empty content and continue waiting for the the next resp.\n                    if (!((ByteBufHolder) res).content().isReadable()) {\n                        out.add(ReferenceCountUtil.retain(res));\n                        break;\n                    }\n                }\n\n                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity\n                final Result result = beginEncode(res, acceptEncoding.toString());\n\n                // If unable to encode, pass through.\n                if (result == null) {\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n\n                encoder = result.contentEncoder(); //encoder = EmbeddedChannel\n\n                // Encode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip\n\n                // Output the rewritten response.\n                if (isFull) {\n                    // Convert full message into unfull one.\n                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());\n                    newRes.headers().set(res.headers());\n                    out.add(newRes);  //newRes里面还没有放数据\n\n                    ensureContent(res);\n                    encodeFullResponse(newRes, (HttpContent) res, out);\n                    break;\n                } else {\n                    // Make the response chunked to simplify content transformation.\n                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n\n                    out.add(res);\n                    state = State.AWAIT_CONTENT;\n                    if (!(msg instanceof HttpContent)) {\n                        // only break out the switch statement if we have not content to process\n                        // See https://github.com/netty/netty/issues/2006\n                        break;\n                    }\n                    // Fall through to encode the content\n                }\n            }\n            case AWAIT_CONTENT: {\n                ensureContent(msg);\n                if (encodeContent((HttpContent) msg, out)) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n            case PASS_THROUGH: {\n                ensureContent(msg);\n                out.add(ReferenceCountUtil.retain(msg));\n                // Passed through all following contents of the current response.\n                if (msg instanceof LastHttpContent) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n        }\n    }\n```\n该编码器encode主要做的事情:\n1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:\n+ 若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。\n+ 否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br\n2.根据规范`rfc2616 4.3 Message Body`, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。\n3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。\n4.在beginEncode中建立相应压缩管道EmbeddedChannel:\n```\n protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {\n        ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP\n        if (wrapper == null) {\n            return null;\n        }\n        String targetContentEncoding;\n        switch (wrapper) {\n        case GZIP:\n            targetContentEncoding = \"gzip\";\n            break;\n        case ZLIB:\n            targetContentEncoding = \"deflate\";\n            break;\n        default:\n            throw new Error();\n        }\n\n        return new Result(\n                targetContentEncoding,\n                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),\n                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(\n                        wrapper, compressionLevel, windowBits, memLevel)));\n    }\n```\n主要做了如下事情:\n+ 首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip>deflate\n+ 返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/GzipPipline.png\" height=\"250\" width=\"350/>\n对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。\n5.向返回值headler中添加 content-encoding:gzip\n6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.\n7.在encodeFullResponse中调用编码函数encodeContent()\n```\nprivate boolean encodeContent(HttpContent c, List<Object> out) {\n        ByteBuf content = c.content();\n        encode(content, out);\n        if (c instanceof LastHttpContent) {\n            finishEncode(out);\n            LastHttpContent last = (LastHttpContent) c;\n            // Generate an additional chunk if the decoder produced\n            // the last product on closure,\n            HttpHeaders headers = last.trailingHeaders();\n            if (headers.isEmpty()) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                out.add(new ComposedLastHttpContent(headers));\n            }\n            return true;\n        }\n        return false;\n    }\n```\n7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。\n+ 调用JdkZlibEncoder.encode()进行压缩。\n+ 将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。\n+ 在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。\n7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。\n这样整个输出帧的内容存放在out中, 拥有的对象如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpOutPutResponse.png\"  height=\"250\" width=\"500\"/>\n其中:\n+ DefaultHttpResponse: 存放的是Http/1.1 status, Header等\n+ 第一个DefaultHttpContent存放的是压缩的内容。\n+ 第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。\n+ LastHttpContent代表整个帧的结束, content部分为空。\n8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。\n## JdkZlibEncoder压缩\n我们可以了解下JdkZlibEncoder.encode()是怎么压缩的\n```\n    @Override\n    protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {\n        int len = uncompressed.readableBytes(); //总共刻度数据\n        int offset;\n        byte[] inAry;\n        if (uncompressed.hasArray()) {  //若有数组,直接获得数组\n            // if it is backed by an array we not need to to do a copy at all\n            inAry = uncompressed.array();\n            offset = uncompressed.arrayOffset() + uncompressed.readerIndex();\n            // skip all bytes as we will consume all of them\n            uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度\n        } else {\n            inAry = new byte[len];\n            uncompressed.readBytes(inAry);//将数据读取到这个byte数组中\n            offset = 0;\n        }\n        if (writeHeader) { //将数组写进去， 最开始编码，需要写\n            writeHeader = false;\n            if (wrapper == ZlibWrapper.GZIP) {\n                out.writeBytes(gzipHeader);//首先写进去头\n            }\n        }\n        if (wrapper == ZlibWrapper.GZIP) {\n            crc.update(inAry, offset, len);\n        }\n        //向压缩器中传递带压缩的数组\n        deflater.setInput(inAry, offset, len);\n        while (!deflater.needsInput()) {\n            deflate(out); //进行真正的压缩\n        }\n    }\n```\n可以看到:\n+ 首先获得bytebuf的byte数组\n+ 向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];\n其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;\n+ 直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。\n\n\n## DefalueChannalHadlerContext.write()\nDefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。\n接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:\n```\n         ByteBuf buf = null;\n        if (msg instanceof HttpMessage) {  //如果是头部，则先编码头部\n            if (state != ST_INIT) {\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n            }\n            H m = (H) msg;\n            buf = ctx.alloc().buffer();//直接内存分配的地址\n            // Encode the message.\n            encodeInitialLine(buf, m); //先是编码initial部分\n            encodeHeaders(m.headers(), buf);//再编码header部分\n            buf.writeBytes(CRLF);\n            state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK\n                    HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;\n        }\n        if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {\n            out.add(EMPTY_BUFFER);\n            return;\n        }\n        //如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse\n        if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\n            switch (state) {\n                case ST_INIT:\n                    throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n                case ST_CONTENT_NON_CHUNK: //st_content_non_chunk\n                    final long contentLength = contentLength(msg);\n                    if (contentLength > 0) {//可写的空间够，直接放到直接内存buf中\n                        if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {//必须是content类型的\n                            // merge into other buffer for performance reasons\n                            buf.writeBytes(((HttpContent) msg).content());\n                            out.add(buf);\n                        } else {\n                            if (buf != null) {\n                                out.add(buf); //先把直接内存放进去\n                            }\n                            out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去\n                        }\n\n                        if (msg instanceof LastHttpContent) {\n                            state = ST_INIT; //编码完成后，直接复位\n                        }\n                        break;\n                    }\n                    // fall-through!\n                case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里\n\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    } else {\n                        // Need to produce some output otherwise an\n                        // IllegalStateException will be thrown\n                        out.add(EMPTY_BUFFER);\n                    }\n\n                    break;\n                case ST_CONTENT_CHUNK:\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    }\n                    encodeChunkedContent(ctx, msg, contentLength(msg), out);\n                    break;\n                default:\n                    throw new Error();\n            }\n            if (msg instanceof LastHttpContent) { //解码完成，再置位\n                state = ST_INIT;\n            }\n        } else if (buf != null) {\n            out.add(buf);\n        }\n```\nstate初始值为ST_INIT, 该函数主要做了如下操作:\n1. 首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。\n+ 通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)\n```\n         response.protocolVersion().encode(buf); //首先存放version编码\n        buf.writeByte(SP); //存放byte:32水平空格\n        response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=\"200 ok\"\n        buf.writeBytes(CRLF); //  { CR, LF }回车换行\n```\n+ 通过encodeHeaders编码header部分, 每个header属性编码如下:\n```\n         final int nameLen = name.length();\n        final int valueLen = value.length();\n        final int entryLen = nameLen + valueLen + 4;\n        buf.ensureWritable(entryLen);  //检查buf的最小长度\n        int offset = buf.writerIndex();\n        writeAscii(buf, offset, name); // 使用US_ASCII编码\n        offset += nameLen;\n        buf.setByte(offset ++, ':');//:\n        buf.setByte(offset ++, ' ');//空格\n        writeAscii(buf, offset, value);\n        offset += valueLen;\n        buf.setByte(offset ++, '\\r');//\n        buf.setByte(offset ++, '\\n');\n        buf.writerIndex(offset);\n```\n1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格\n2) 通过CharsetUtil.US_ASCII编码key和value\n+ 再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpResponse_Byte.png\"  height=\"250\" width=\"600\"/>\n\n然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。\n2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。\n+ 会直接将整个DefaltHttpContent放入out向外写\n+ 当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。\n\n\n# Netty水位\n\n向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:\n```\n   @Override\n        public final void write(Object msg, ChannelPromise promise) {\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位\n            int size;\n            try {\n                msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap\n                size = pipeline.estimatorHandle().size(msg);\n                if (size < 0) {\n                    size = 0;\n                }\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                ReferenceCountUtil.release(msg);\n                return;\n            }\n            outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer\n        }\n```\n+ 在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。\n+ 通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。\n我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ChannelOutboundBuffer.png\" height=\"250\" width=\"480\"/>\nflushEntry 表示即将刷新的位置\nunflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。\ntailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。\n当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:\n```\n        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息\n        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法\n            setUnwritable(invokeLater);\n        }\n```\n所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?\n在netty启动时, 只需要添加如下参数即可:\n```\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);\n```\n代表:\n+ 当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。\n+ 当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.\n## setUnwritable设置不可写\n\n```\n        for (;;) {\n            final int oldValue = unwritable;\n            final int newValue = oldValue | 1;\n            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态\n                if (oldValue == 0 && newValue != 0) {\n                    fireChannelWritabilityChanged(invokeLater);//\n                }//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。\n                break;\n            }\n        }\n```\n这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写->不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。\n在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。\n\n# Flush\n数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:\n```\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            unsafe.flush();\n        }\n```\n这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():\n```\n        @Override\n        public final void flush() {\n            assertEventLoop();\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null) {\n                return;\n            }\n            outboundBuffer.addFlush();\n            flush0();//写完了\n        }\n```\n主要做了如下事情:\n+ outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;\n+ 调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():\n## 内部flush0\n```\n        @SuppressWarnings(\"deprecation\")\n        protected void flush0() {\n            if (inFlush0) { //有正在写（真正的调用write写）\n                // Avoid re-entrance\n                return;\n            }\n            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n                return;\n            }\n            inFlush0 = true; //标记正在写\n            // Mark all pending write requests as failure if the channel is inactive.\n            if (!isActive()) {\n                try {\n                    if (isOpen()) {\n                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);\n                    } else {\n                        // Do not trigger channelWritabilityChanged because the channel is closed already.\n                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);\n                    }\n                } finally {\n                    inFlush0 = false;\n                }\n                return;\n            }\n            try {\n                doWrite(outboundBuffer);\n            } catch (Throwable t) {\n               ......\n            } finally {\n                inFlush0 = false;\n            }\n        }\n```\n该代码主要做了如下事情:\n1. 检查是否有正在flush,  如是的话, 直接退出。\n2. 标志正在flush\n3.调用NioSocketChannel.doWrite()继续刷:\n```\nprotected void doWrite(ChannelOutboundBuffer in) throws Exception {\n        for (;;) {\n            int size = in.size(); //所有的都写完了\n            if (size == 0) {\n                // All written so clear OP_WRITE\n                clearOpWrite();\n                break;\n            }\n            long writtenBytes = 0;\n            boolean done = false;\n            boolean setOpWrite = false;\n            // Ensure the pending writes are made of ByteBufs only.\n            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个\n            int nioBufferCnt = in.nioBufferCount();\n            long expectedWrittenBytes = in.nioBufferSize();\n            SocketChannel ch = javaChannel();\n            // Always us nioBuffers() to workaround data-corruption.\n            // See https://github.com/netty/netty/issues/2761\n            switch (nioBufferCnt) {\n                case 0:\n                    // We have something else beside ByteBuffers to write so fallback to normal writes.\n                    super.doWrite(in);\n                    return;\n                case 1:\n                    // Only one ByteBuf so use non-gathering write\n                    ByteBuffer nioBuffer = nioBuffers[0];\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {\n                        final int localWrittenBytes = ch.write(nioBuffer);\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {//循环16次, 可能一次写不完\n                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            // Release the fully written buffers, and update the indexes of the partially written buffer.\n            in.removeBytes(writtenBytes); //记录可丢弃的数据\n            if (!done) {//若没有写完\n                // Did not write all buffers completely.\n                incompleteWrite(setOpWrite);\n                break;\n            }\n        }\n    }\n```\n该函数主要做了如下事情:\n1. 通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]\n2. 当content个数>=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。\n\n至此, write到缓存、flush到网络部分全部讲完了。\n","source":"_posts/Netty-Http通信编码源码阅读.md","raw":"---\ntitle: Netty Http通信源码二(编码)分析\ndate: 2018-05-04 00:02:39\ntags:\ntoc: true\n---\n解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultFullHttpResponse.png\" height=\"250\" width=\"500\"/>\n涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。\n开始向外发送数据时, 如下:\n```\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context\n        final Object m = pipeline.touch(msg, next);\n        EventExecutor executor = next.executor();\n        if (executor.inEventLoop()) {\n            if (flush) {\n                next.invokeWriteAndFlush(m, promise);\n            } else {\n                next.invokeWrite(m, promise);\n            }\n        } else {\n            AbstractWriteTask task;\n            if (flush) {\n                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行\n            }  else {\n                task = WriteTask.newInstance(next, m, promise);\n            }\n            safeExecute(executor, task, promise, m);\n        }\n    }\n```\n当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:\n```\n        @Override\n        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n            super.write(ctx, msg, promise); //一般只是存放在缓存中\n            ctx.invokeFlush(); //真正的调用write,\n        }\n```\n可以看出, 写数据分为两个过程:write()和flush():\n+ write只是将数据放在了缓存ChannelOutboundBuffer中\n+ 通过调用channal.write()向网络发送数据。\n\n# HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\n我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。\n首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:\n```\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        CodecOutputList out = null;\n        try {\n            if (acceptOutboundMessage(msg)) {\n                out = CodecOutputList.newInstance();\n                I cast = (I) msg;\n                try {\n                    encode(ctx, cast, out);\n                } finally {\n                    ReferenceCountUtil.release(cast);\n                }\n                if (out.isEmpty()) {\n                    out.recycle();\n                    out = null;\n                    throw new EncoderException(\n                            StringUtil.simpleClassName(this) + \" must produce at least one message.\");\n                }\n            } else {\n                ctx.write(msg, promise);\n            }\n        }\n        } finally {\n            if (out != null) {\n                final int sizeMinusOne = out.size() - 1;\n                if (sizeMinusOne == 0) {\n                    ctx.write(out.get(0), promise);\n                } else if (sizeMinusOne > 0) {\n                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure\n                    // See https://github.com/netty/netty/issues/2525\n                    ChannelPromise voidPromise = ctx.voidPromise();\n                    boolean isVoidPromise = promise == voidPromise;\n                    for (int i = 0; i < sizeMinusOne; i ++) {//分开向下发送\n                        ChannelPromise p;\n                        if (isVoidPromise) {\n                            p = voidPromise;\n                        } else {\n                            p = ctx.newPromise();\n                        }\n                        ctx.write(out.getUnsafe(i), p);\n                    }\n                    ctx.write(out.getUnsafe(sizeMinusOne), promise);\n                }\n                out.recycle();\n            }\n        }\n    }\n```\n实现也很简单,主要做了如下两件事:\n1. 首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。\n2. 针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。\n\n## HttpContentEncoder的encode()函数\n首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: \"gzip,deflat,br\"为例。\n\nendoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分\n```\n@Override    //msg: DefaultFullHttpResponse\n    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;\n        switch (state) {\n            case AWAIT_HEADERS: {  //初始取值\n                ensureHeaders(msg);\n                assert encoder == null;\n\n                final HttpResponse res = (HttpResponse) msg;\n                 //根据返回结果确定是否需要编码\n                final int code = res.status().code();\n                final CharSequence acceptEncoding;\n                if (code == CONTINUE_CODE) { //continue_code\n                    // We need to not poll the encoding when response with CONTINUE as another response will follow\n                    // for the issued request. See https://github.com/netty/netty/issues/4079\n                    acceptEncoding = null;\n                } else {\n                    // Get the list of encodings accepted by the peer.\n                    acceptEncoding = acceptEncodingQueue.poll(); //\"gzip.default.br\"\n                    if (acceptEncoding == null) {\n                        throw new IllegalStateException(\"cannot send more responses than requests\");\n                    }\n                }\n                /*\n                 * per rfc2616 4.3 Message Body\n                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a\n                 * message-body. All other responses do include a message-body, although it MAY be of zero length.\n                 *\n                 * 9.4 HEAD\n                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body\n                 * in the response.\n                 *\n                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.\n                 *\n                 * See https://github.com/netty/netty/issues/5382\n                 */\n                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) { //是否接下来是没有body的\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n                if (isFull) {\n                    // Pass through the full response with empty content and continue waiting for the the next resp.\n                    if (!((ByteBufHolder) res).content().isReadable()) {\n                        out.add(ReferenceCountUtil.retain(res));\n                        break;\n                    }\n                }\n\n                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity\n                final Result result = beginEncode(res, acceptEncoding.toString());\n\n                // If unable to encode, pass through.\n                if (result == null) {\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n\n                encoder = result.contentEncoder(); //encoder = EmbeddedChannel\n\n                // Encode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip\n\n                // Output the rewritten response.\n                if (isFull) {\n                    // Convert full message into unfull one.\n                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());\n                    newRes.headers().set(res.headers());\n                    out.add(newRes);  //newRes里面还没有放数据\n\n                    ensureContent(res);\n                    encodeFullResponse(newRes, (HttpContent) res, out);\n                    break;\n                } else {\n                    // Make the response chunked to simplify content transformation.\n                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n\n                    out.add(res);\n                    state = State.AWAIT_CONTENT;\n                    if (!(msg instanceof HttpContent)) {\n                        // only break out the switch statement if we have not content to process\n                        // See https://github.com/netty/netty/issues/2006\n                        break;\n                    }\n                    // Fall through to encode the content\n                }\n            }\n            case AWAIT_CONTENT: {\n                ensureContent(msg);\n                if (encodeContent((HttpContent) msg, out)) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n            case PASS_THROUGH: {\n                ensureContent(msg);\n                out.add(ReferenceCountUtil.retain(msg));\n                // Passed through all following contents of the current response.\n                if (msg instanceof LastHttpContent) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n        }\n    }\n```\n该编码器encode主要做的事情:\n1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:\n+ 若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。\n+ 否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br\n2.根据规范`rfc2616 4.3 Message Body`, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。\n3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。\n4.在beginEncode中建立相应压缩管道EmbeddedChannel:\n```\n protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {\n        ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP\n        if (wrapper == null) {\n            return null;\n        }\n        String targetContentEncoding;\n        switch (wrapper) {\n        case GZIP:\n            targetContentEncoding = \"gzip\";\n            break;\n        case ZLIB:\n            targetContentEncoding = \"deflate\";\n            break;\n        default:\n            throw new Error();\n        }\n\n        return new Result(\n                targetContentEncoding,\n                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),\n                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(\n                        wrapper, compressionLevel, windowBits, memLevel)));\n    }\n```\n主要做了如下事情:\n+ 首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip>deflate\n+ 返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/GzipPipline.png\" height=\"250\" width=\"350/>\n对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。\n5.向返回值headler中添加 content-encoding:gzip\n6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.\n7.在encodeFullResponse中调用编码函数encodeContent()\n```\nprivate boolean encodeContent(HttpContent c, List<Object> out) {\n        ByteBuf content = c.content();\n        encode(content, out);\n        if (c instanceof LastHttpContent) {\n            finishEncode(out);\n            LastHttpContent last = (LastHttpContent) c;\n            // Generate an additional chunk if the decoder produced\n            // the last product on closure,\n            HttpHeaders headers = last.trailingHeaders();\n            if (headers.isEmpty()) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                out.add(new ComposedLastHttpContent(headers));\n            }\n            return true;\n        }\n        return false;\n    }\n```\n7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。\n+ 调用JdkZlibEncoder.encode()进行压缩。\n+ 将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。\n+ 在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。\n7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。\n这样整个输出帧的内容存放在out中, 拥有的对象如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpOutPutResponse.png\"  height=\"250\" width=\"500\"/>\n其中:\n+ DefaultHttpResponse: 存放的是Http/1.1 status, Header等\n+ 第一个DefaultHttpContent存放的是压缩的内容。\n+ 第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。\n+ LastHttpContent代表整个帧的结束, content部分为空。\n8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。\n## JdkZlibEncoder压缩\n我们可以了解下JdkZlibEncoder.encode()是怎么压缩的\n```\n    @Override\n    protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {\n        int len = uncompressed.readableBytes(); //总共刻度数据\n        int offset;\n        byte[] inAry;\n        if (uncompressed.hasArray()) {  //若有数组,直接获得数组\n            // if it is backed by an array we not need to to do a copy at all\n            inAry = uncompressed.array();\n            offset = uncompressed.arrayOffset() + uncompressed.readerIndex();\n            // skip all bytes as we will consume all of them\n            uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度\n        } else {\n            inAry = new byte[len];\n            uncompressed.readBytes(inAry);//将数据读取到这个byte数组中\n            offset = 0;\n        }\n        if (writeHeader) { //将数组写进去， 最开始编码，需要写\n            writeHeader = false;\n            if (wrapper == ZlibWrapper.GZIP) {\n                out.writeBytes(gzipHeader);//首先写进去头\n            }\n        }\n        if (wrapper == ZlibWrapper.GZIP) {\n            crc.update(inAry, offset, len);\n        }\n        //向压缩器中传递带压缩的数组\n        deflater.setInput(inAry, offset, len);\n        while (!deflater.needsInput()) {\n            deflate(out); //进行真正的压缩\n        }\n    }\n```\n可以看到:\n+ 首先获得bytebuf的byte数组\n+ 向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];\n其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;\n+ 直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。\n\n\n## DefalueChannalHadlerContext.write()\nDefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。\n接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:\n```\n         ByteBuf buf = null;\n        if (msg instanceof HttpMessage) {  //如果是头部，则先编码头部\n            if (state != ST_INIT) {\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n            }\n            H m = (H) msg;\n            buf = ctx.alloc().buffer();//直接内存分配的地址\n            // Encode the message.\n            encodeInitialLine(buf, m); //先是编码initial部分\n            encodeHeaders(m.headers(), buf);//再编码header部分\n            buf.writeBytes(CRLF);\n            state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK\n                    HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;\n        }\n        if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {\n            out.add(EMPTY_BUFFER);\n            return;\n        }\n        //如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse\n        if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\n            switch (state) {\n                case ST_INIT:\n                    throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n                case ST_CONTENT_NON_CHUNK: //st_content_non_chunk\n                    final long contentLength = contentLength(msg);\n                    if (contentLength > 0) {//可写的空间够，直接放到直接内存buf中\n                        if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {//必须是content类型的\n                            // merge into other buffer for performance reasons\n                            buf.writeBytes(((HttpContent) msg).content());\n                            out.add(buf);\n                        } else {\n                            if (buf != null) {\n                                out.add(buf); //先把直接内存放进去\n                            }\n                            out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去\n                        }\n\n                        if (msg instanceof LastHttpContent) {\n                            state = ST_INIT; //编码完成后，直接复位\n                        }\n                        break;\n                    }\n                    // fall-through!\n                case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里\n\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    } else {\n                        // Need to produce some output otherwise an\n                        // IllegalStateException will be thrown\n                        out.add(EMPTY_BUFFER);\n                    }\n\n                    break;\n                case ST_CONTENT_CHUNK:\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    }\n                    encodeChunkedContent(ctx, msg, contentLength(msg), out);\n                    break;\n                default:\n                    throw new Error();\n            }\n            if (msg instanceof LastHttpContent) { //解码完成，再置位\n                state = ST_INIT;\n            }\n        } else if (buf != null) {\n            out.add(buf);\n        }\n```\nstate初始值为ST_INIT, 该函数主要做了如下操作:\n1. 首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。\n+ 通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)\n```\n         response.protocolVersion().encode(buf); //首先存放version编码\n        buf.writeByte(SP); //存放byte:32水平空格\n        response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=\"200 ok\"\n        buf.writeBytes(CRLF); //  { CR, LF }回车换行\n```\n+ 通过encodeHeaders编码header部分, 每个header属性编码如下:\n```\n         final int nameLen = name.length();\n        final int valueLen = value.length();\n        final int entryLen = nameLen + valueLen + 4;\n        buf.ensureWritable(entryLen);  //检查buf的最小长度\n        int offset = buf.writerIndex();\n        writeAscii(buf, offset, name); // 使用US_ASCII编码\n        offset += nameLen;\n        buf.setByte(offset ++, ':');//:\n        buf.setByte(offset ++, ' ');//空格\n        writeAscii(buf, offset, value);\n        offset += valueLen;\n        buf.setByte(offset ++, '\\r');//\n        buf.setByte(offset ++, '\\n');\n        buf.writerIndex(offset);\n```\n1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格\n2) 通过CharsetUtil.US_ASCII编码key和value\n+ 再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpResponse_Byte.png\"  height=\"250\" width=\"600\"/>\n\n然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。\n2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。\n+ 会直接将整个DefaltHttpContent放入out向外写\n+ 当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。\n\n\n# Netty水位\n\n向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:\n```\n   @Override\n        public final void write(Object msg, ChannelPromise promise) {\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位\n            int size;\n            try {\n                msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap\n                size = pipeline.estimatorHandle().size(msg);\n                if (size < 0) {\n                    size = 0;\n                }\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                ReferenceCountUtil.release(msg);\n                return;\n            }\n            outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer\n        }\n```\n+ 在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。\n+ 通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。\n我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ChannelOutboundBuffer.png\" height=\"250\" width=\"480\"/>\nflushEntry 表示即将刷新的位置\nunflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。\ntailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。\n当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:\n```\n        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息\n        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法\n            setUnwritable(invokeLater);\n        }\n```\n所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?\n在netty启动时, 只需要添加如下参数即可:\n```\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);\n```\n代表:\n+ 当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。\n+ 当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.\n## setUnwritable设置不可写\n\n```\n        for (;;) {\n            final int oldValue = unwritable;\n            final int newValue = oldValue | 1;\n            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态\n                if (oldValue == 0 && newValue != 0) {\n                    fireChannelWritabilityChanged(invokeLater);//\n                }//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。\n                break;\n            }\n        }\n```\n这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写->不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。\n在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。\n\n# Flush\n数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:\n```\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            unsafe.flush();\n        }\n```\n这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():\n```\n        @Override\n        public final void flush() {\n            assertEventLoop();\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null) {\n                return;\n            }\n            outboundBuffer.addFlush();\n            flush0();//写完了\n        }\n```\n主要做了如下事情:\n+ outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;\n+ 调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():\n## 内部flush0\n```\n        @SuppressWarnings(\"deprecation\")\n        protected void flush0() {\n            if (inFlush0) { //有正在写（真正的调用write写）\n                // Avoid re-entrance\n                return;\n            }\n            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n                return;\n            }\n            inFlush0 = true; //标记正在写\n            // Mark all pending write requests as failure if the channel is inactive.\n            if (!isActive()) {\n                try {\n                    if (isOpen()) {\n                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);\n                    } else {\n                        // Do not trigger channelWritabilityChanged because the channel is closed already.\n                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);\n                    }\n                } finally {\n                    inFlush0 = false;\n                }\n                return;\n            }\n            try {\n                doWrite(outboundBuffer);\n            } catch (Throwable t) {\n               ......\n            } finally {\n                inFlush0 = false;\n            }\n        }\n```\n该代码主要做了如下事情:\n1. 检查是否有正在flush,  如是的话, 直接退出。\n2. 标志正在flush\n3.调用NioSocketChannel.doWrite()继续刷:\n```\nprotected void doWrite(ChannelOutboundBuffer in) throws Exception {\n        for (;;) {\n            int size = in.size(); //所有的都写完了\n            if (size == 0) {\n                // All written so clear OP_WRITE\n                clearOpWrite();\n                break;\n            }\n            long writtenBytes = 0;\n            boolean done = false;\n            boolean setOpWrite = false;\n            // Ensure the pending writes are made of ByteBufs only.\n            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个\n            int nioBufferCnt = in.nioBufferCount();\n            long expectedWrittenBytes = in.nioBufferSize();\n            SocketChannel ch = javaChannel();\n            // Always us nioBuffers() to workaround data-corruption.\n            // See https://github.com/netty/netty/issues/2761\n            switch (nioBufferCnt) {\n                case 0:\n                    // We have something else beside ByteBuffers to write so fallback to normal writes.\n                    super.doWrite(in);\n                    return;\n                case 1:\n                    // Only one ByteBuf so use non-gathering write\n                    ByteBuffer nioBuffer = nioBuffers[0];\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {\n                        final int localWrittenBytes = ch.write(nioBuffer);\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {//循环16次, 可能一次写不完\n                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            // Release the fully written buffers, and update the indexes of the partially written buffer.\n            in.removeBytes(writtenBytes); //记录可丢弃的数据\n            if (!done) {//若没有写完\n                // Did not write all buffers completely.\n                incompleteWrite(setOpWrite);\n                break;\n            }\n        }\n    }\n```\n该函数主要做了如下事情:\n1. 通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]\n2. 当content个数>=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。\n\n至此, write到缓存、flush到网络部分全部讲完了。\n","slug":"Netty-Http通信编码源码阅读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8wz000jphu5sazaig8j","content":"<p>解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultFullHttpResponse.png\" height=\"250\" width=\"500\"><br>涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。<br>开始向外发送数据时, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</div><div class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context</div><div class=\"line\">        final Object m = pipeline.touch(msg, next);</div><div class=\"line\">        EventExecutor executor = next.executor();</div><div class=\"line\">        if (executor.inEventLoop()) &#123;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                next.invokeWriteAndFlush(m, promise);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                next.invokeWrite(m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            AbstractWriteTask task;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行</div><div class=\"line\">            &#125;  else &#123;</div><div class=\"line\">                task = WriteTask.newInstance(next, m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            safeExecute(executor, task, promise, m);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">    super.write(ctx, msg, promise); //一般只是存放在缓存中</div><div class=\"line\">    ctx.invokeFlush(); //真正的调用write,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 写数据分为两个过程:write()和flush():</p>\n<ul>\n<li>write只是将数据放在了缓存ChannelOutboundBuffer中</li>\n<li>通过调用channal.write()向网络发送数据。</li>\n</ul>\n<h1 id=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"><a href=\"#HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\" class=\"headerlink\" title=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"></a>HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec</h1><p>我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。<br>首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class=\"line\">    CodecOutputList out = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (acceptOutboundMessage(msg)) &#123;</div><div class=\"line\">            out = CodecOutputList.newInstance();</div><div class=\"line\">            I cast = (I) msg;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                encode(ctx, cast, out);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                ReferenceCountUtil.release(cast);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (out.isEmpty()) &#123;</div><div class=\"line\">                out.recycle();</div><div class=\"line\">                out = null;</div><div class=\"line\">                throw new EncoderException(</div><div class=\"line\">                        StringUtil.simpleClassName(this) + &quot; must produce at least one message.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.write(msg, promise);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            final int sizeMinusOne = out.size() - 1;</div><div class=\"line\">            if (sizeMinusOne == 0) &#123;</div><div class=\"line\">                ctx.write(out.get(0), promise);</div><div class=\"line\">            &#125; else if (sizeMinusOne &gt; 0) &#123;</div><div class=\"line\">                // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2525</div><div class=\"line\">                ChannelPromise voidPromise = ctx.voidPromise();</div><div class=\"line\">                boolean isVoidPromise = promise == voidPromise;</div><div class=\"line\">                for (int i = 0; i &lt; sizeMinusOne; i ++) &#123;//分开向下发送</div><div class=\"line\">                    ChannelPromise p;</div><div class=\"line\">                    if (isVoidPromise) &#123;</div><div class=\"line\">                        p = voidPromise;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        p = ctx.newPromise();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    ctx.write(out.getUnsafe(i), p);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ctx.write(out.getUnsafe(sizeMinusOne), promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现也很简单,主要做了如下两件事:</p>\n<ol>\n<li>首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。</li>\n<li>针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。</li>\n</ol>\n<h2 id=\"HttpContentEncoder的encode-函数\"><a href=\"#HttpContentEncoder的encode-函数\" class=\"headerlink\" title=\"HttpContentEncoder的encode()函数\"></a>HttpContentEncoder的encode()函数</h2><p>首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: “gzip,deflat,br”为例。</p>\n<p>endoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override    //msg: DefaultFullHttpResponse</div><div class=\"line\">    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        final boolean isFull = msg instanceof HttpResponse &amp;&amp; msg instanceof LastHttpContent;</div><div class=\"line\">        switch (state) &#123;</div><div class=\"line\">            case AWAIT_HEADERS: &#123;  //初始取值</div><div class=\"line\">                ensureHeaders(msg);</div><div class=\"line\">                assert encoder == null;</div><div class=\"line\"></div><div class=\"line\">                final HttpResponse res = (HttpResponse) msg;</div><div class=\"line\">                 //根据返回结果确定是否需要编码</div><div class=\"line\">                final int code = res.status().code();</div><div class=\"line\">                final CharSequence acceptEncoding;</div><div class=\"line\">                if (code == CONTINUE_CODE) &#123; //continue_code</div><div class=\"line\">                    // We need to not poll the encoding when response with CONTINUE as another response will follow</div><div class=\"line\">                    // for the issued request. See https://github.com/netty/netty/issues/4079</div><div class=\"line\">                    acceptEncoding = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Get the list of encodings accepted by the peer.</div><div class=\"line\">                    acceptEncoding = acceptEncodingQueue.poll(); //&quot;gzip.default.br&quot;</div><div class=\"line\">                    if (acceptEncoding == null) &#123;</div><div class=\"line\">                        throw new IllegalStateException(&quot;cannot send more responses than requests&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                /*</div><div class=\"line\">                 * per rfc2616 4.3 Message Body</div><div class=\"line\">                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a</div><div class=\"line\">                 * message-body. All other responses do include a message-body, although it MAY be of zero length.</div><div class=\"line\">                 *</div><div class=\"line\">                 * 9.4 HEAD</div><div class=\"line\">                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body</div><div class=\"line\">                 * in the response.</div><div class=\"line\">                 *</div><div class=\"line\">                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.</div><div class=\"line\">                 *</div><div class=\"line\">                 * See https://github.com/netty/netty/issues/5382</div><div class=\"line\">                 */</div><div class=\"line\">                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) &#123; //是否接下来是没有body的</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Pass through the full response with empty content and continue waiting for the the next resp.</div><div class=\"line\">                    if (!((ByteBufHolder) res).content().isReadable()) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity</div><div class=\"line\">                final Result result = beginEncode(res, acceptEncoding.toString());</div><div class=\"line\"></div><div class=\"line\">                // If unable to encode, pass through.</div><div class=\"line\">                if (result == null) &#123;</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                encoder = result.contentEncoder(); //encoder = EmbeddedChannel</div><div class=\"line\"></div><div class=\"line\">                // Encode the content and remove or replace the existing headers</div><div class=\"line\">                // so that the message looks like a decoded message.</div><div class=\"line\">                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip</div><div class=\"line\"></div><div class=\"line\">                // Output the rewritten response.</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Convert full message into unfull one.</div><div class=\"line\">                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());</div><div class=\"line\">                    newRes.headers().set(res.headers());</div><div class=\"line\">                    out.add(newRes);  //newRes里面还没有放数据</div><div class=\"line\"></div><div class=\"line\">                    ensureContent(res);</div><div class=\"line\">                    encodeFullResponse(newRes, (HttpContent) res, out);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Make the response chunked to simplify content transformation.</div><div class=\"line\">                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);</div><div class=\"line\">                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);</div><div class=\"line\"></div><div class=\"line\">                    out.add(res);</div><div class=\"line\">                    state = State.AWAIT_CONTENT;</div><div class=\"line\">                    if (!(msg instanceof HttpContent)) &#123;</div><div class=\"line\">                        // only break out the switch statement if we have not content to process</div><div class=\"line\">                        // See https://github.com/netty/netty/issues/2006</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Fall through to encode the content</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case AWAIT_CONTENT: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                if (encodeContent((HttpContent) msg, out)) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case PASS_THROUGH: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                out.add(ReferenceCountUtil.retain(msg));</div><div class=\"line\">                // Passed through all following contents of the current response.</div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>该编码器encode主要做的事情:<br>1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:</p>\n<ul>\n<li>若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。</li>\n<li>否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br<br>2.根据规范<code>rfc2616 4.3 Message Body</code>, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。<br>3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。<br>4.在beginEncode中建立相应压缩管道EmbeddedChannel:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception &#123;</div><div class=\"line\">       ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP</div><div class=\"line\">       if (wrapper == null) &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">       String targetContentEncoding;</div><div class=\"line\">       switch (wrapper) &#123;</div><div class=\"line\">       case GZIP:</div><div class=\"line\">           targetContentEncoding = &quot;gzip&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       case ZLIB:</div><div class=\"line\">           targetContentEncoding = &quot;deflate&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       default:</div><div class=\"line\">           throw new Error();</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return new Result(</div><div class=\"line\">               targetContentEncoding,</div><div class=\"line\">               new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),</div><div class=\"line\">                       ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(</div><div class=\"line\">                       wrapper, compressionLevel, windowBits, memLevel)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip&gt;deflate</li>\n<li>返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:&lt;img src=”<a href=\"https://kkewwei.github.io/elasticsearch_learning/img/GzipPipline.png\">https://kkewwei.github.io/elasticsearch_learning/img/GzipPipline.png</a>“ height=”250” width=”350/&gt;<br>对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。<br>5.向返回值headler中添加 content-encoding:gzip<br>6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.<br>7.在encodeFullResponse中调用编码函数encodeContent()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean encodeContent(HttpContent c, List&lt;Object&gt; out) &#123;</div><div class=\"line\">        ByteBuf content = c.content();</div><div class=\"line\">        encode(content, out);</div><div class=\"line\">        if (c instanceof LastHttpContent) &#123;</div><div class=\"line\">            finishEncode(out);</div><div class=\"line\">            LastHttpContent last = (LastHttpContent) c;</div><div class=\"line\">            // Generate an additional chunk if the decoder produced</div><div class=\"line\">            // the last product on closure,</div><div class=\"line\">            HttpHeaders headers = last.trailingHeaders();</div><div class=\"line\">            if (headers.isEmpty()) &#123;</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new ComposedLastHttpContent(headers));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。</p>\n<ul>\n<li>调用JdkZlibEncoder.encode()进行压缩。</li>\n<li>将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。</li>\n<li>在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。<br>7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。<br>这样整个输出帧的内容存放在out中, 拥有的对象如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpOutPutResponse.png\" height=\"250\" width=\"500\"><br>其中:</li>\n<li>DefaultHttpResponse: 存放的是Http/1.1 status, Header等</li>\n<li>第一个DefaultHttpContent存放的是压缩的内容。</li>\n<li>第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。</li>\n<li>LastHttpContent代表整个帧的结束, content部分为空。<br>8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。<h2 id=\"JdkZlibEncoder压缩\"><a href=\"#JdkZlibEncoder压缩\" class=\"headerlink\" title=\"JdkZlibEncoder压缩\"></a>JdkZlibEncoder压缩</h2>我们可以了解下JdkZlibEncoder.encode()是怎么压缩的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception &#123;</div><div class=\"line\">    int len = uncompressed.readableBytes(); //总共刻度数据</div><div class=\"line\">    int offset;</div><div class=\"line\">    byte[] inAry;</div><div class=\"line\">    if (uncompressed.hasArray()) &#123;  //若有数组,直接获得数组</div><div class=\"line\">        // if it is backed by an array we not need to to do a copy at all</div><div class=\"line\">        inAry = uncompressed.array();</div><div class=\"line\">        offset = uncompressed.arrayOffset() + uncompressed.readerIndex();</div><div class=\"line\">        // skip all bytes as we will consume all of them</div><div class=\"line\">        uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        inAry = new byte[len];</div><div class=\"line\">        uncompressed.readBytes(inAry);//将数据读取到这个byte数组中</div><div class=\"line\">        offset = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (writeHeader) &#123; //将数组写进去， 最开始编码，需要写</div><div class=\"line\">        writeHeader = false;</div><div class=\"line\">        if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">            out.writeBytes(gzipHeader);//首先写进去头</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">        crc.update(inAry, offset, len);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //向压缩器中传递带压缩的数组</div><div class=\"line\">    deflater.setInput(inAry, offset, len);</div><div class=\"line\">    while (!deflater.needsInput()) &#123;</div><div class=\"line\">        deflate(out); //进行真正的压缩</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先获得bytebuf的byte数组</li>\n<li>向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];<br>其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;</li>\n<li>直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。</li>\n</ul>\n<h2 id=\"DefalueChannalHadlerContext-write\"><a href=\"#DefalueChannalHadlerContext-write\" class=\"headerlink\" title=\"DefalueChannalHadlerContext.write()\"></a>DefalueChannalHadlerContext.write()</h2><p>DefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。<br>接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ByteBuf buf = null;</div><div class=\"line\">if (msg instanceof HttpMessage) &#123;  //如果是头部，则先编码头部</div><div class=\"line\">    if (state != ST_INIT) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">    &#125;</div><div class=\"line\">    H m = (H) msg;</div><div class=\"line\">    buf = ctx.alloc().buffer();//直接内存分配的地址</div><div class=\"line\">    // Encode the message.</div><div class=\"line\">    encodeInitialLine(buf, m); //先是编码initial部分</div><div class=\"line\">    encodeHeaders(m.headers(), buf);//再编码header部分</div><div class=\"line\">    buf.writeBytes(CRLF);</div><div class=\"line\">    state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK</div><div class=\"line\">            HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg instanceof ByteBuf &amp;&amp; !((ByteBuf) msg).isReadable()) &#123;</div><div class=\"line\">    out.add(EMPTY_BUFFER);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse</div><div class=\"line\">if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) &#123;</div><div class=\"line\">    switch (state) &#123;</div><div class=\"line\">        case ST_INIT:</div><div class=\"line\">            throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">        case ST_CONTENT_NON_CHUNK: //st_content_non_chunk</div><div class=\"line\">            final long contentLength = contentLength(msg);</div><div class=\"line\">            if (contentLength &gt; 0) &#123;//可写的空间够，直接放到直接内存buf中</div><div class=\"line\">                if (buf != null &amp;&amp; buf.writableBytes() &gt;= contentLength &amp;&amp; msg instanceof HttpContent) &#123;//必须是content类型的</div><div class=\"line\">                    // merge into other buffer for performance reasons</div><div class=\"line\">                    buf.writeBytes(((HttpContent) msg).content());</div><div class=\"line\">                    out.add(buf);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (buf != null) &#123;</div><div class=\"line\">                        out.add(buf); //先把直接内存放进去</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = ST_INIT; //编码完成后，直接复位</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // fall-through!</div><div class=\"line\">        case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里</div><div class=\"line\"></div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Need to produce some output otherwise an</div><div class=\"line\">                // IllegalStateException will be thrown</div><div class=\"line\">                out.add(EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            break;</div><div class=\"line\">        case ST_CONTENT_CHUNK:</div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125;</div><div class=\"line\">            encodeChunkedContent(ctx, msg, contentLength(msg), out);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            throw new Error();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg instanceof LastHttpContent) &#123; //解码完成，再置位</div><div class=\"line\">        state = ST_INIT;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (buf != null) &#123;</div><div class=\"line\">    out.add(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>state初始值为ST_INIT, 该函数主要做了如下操作:</p>\n<ol>\n<li>首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。</li>\n</ol>\n<ul>\n<li><p>通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> response.protocolVersion().encode(buf); //首先存放version编码</div><div class=\"line\">buf.writeByte(SP); //存放byte:32水平空格</div><div class=\"line\">response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=&quot;200 ok&quot;</div><div class=\"line\">buf.writeBytes(CRLF); //  &#123; CR, LF &#125;回车换行</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过encodeHeaders编码header部分, 每个header属性编码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> final int nameLen = name.length();</div><div class=\"line\">final int valueLen = value.length();</div><div class=\"line\">final int entryLen = nameLen + valueLen + 4;</div><div class=\"line\">buf.ensureWritable(entryLen);  //检查buf的最小长度</div><div class=\"line\">int offset = buf.writerIndex();</div><div class=\"line\">writeAscii(buf, offset, name); // 使用US_ASCII编码</div><div class=\"line\">offset += nameLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;:&apos;);//:</div><div class=\"line\">buf.setByte(offset ++, &apos; &apos;);//空格</div><div class=\"line\">writeAscii(buf, offset, value);</div><div class=\"line\">offset += valueLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;\\r&apos;);//</div><div class=\"line\">buf.setByte(offset ++, &apos;\\n&apos;);</div><div class=\"line\">buf.writerIndex(offset);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格<br>2) 通过CharsetUtil.US_ASCII编码key和value</p>\n<ul>\n<li>再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpResponse_Byte.png\" height=\"250\" width=\"600\"></li>\n</ul>\n<p>然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。<br>2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。</p>\n<ul>\n<li>会直接将整个DefaltHttpContent放入out向外写</li>\n<li>当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。</li>\n</ul>\n<h1 id=\"Netty水位\"><a href=\"#Netty水位\" class=\"headerlink\" title=\"Netty水位\"></a>Netty水位</h1><p>向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">     public final void write(Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位</div><div class=\"line\">         int size;</div><div class=\"line\">         try &#123;</div><div class=\"line\">             msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap</div><div class=\"line\">             size = pipeline.estimatorHandle().size(msg);</div><div class=\"line\">             if (size &lt; 0) &#123;</div><div class=\"line\">                 size = 0;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; catch (Throwable t) &#123;</div><div class=\"line\">             safeSetFailure(promise, t);</div><div class=\"line\">             ReferenceCountUtil.release(msg);</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。</li>\n<li>通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。<br>我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ChannelOutboundBuffer.png\" height=\"250\" width=\"480\"><br>flushEntry 表示即将刷新的位置<br>unflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。<br>tailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。<br>当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息</div><div class=\"line\">if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法</div><div class=\"line\">    setUnwritable(invokeLater);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?<br>在netty启动时, 只需要添加如下参数即可:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);</div></pre></td></tr></table></figure></p>\n<p>代表:</p>\n<ul>\n<li>当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。</li>\n<li>当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.<h2 id=\"setUnwritable设置不可写\"><a href=\"#setUnwritable设置不可写\" class=\"headerlink\" title=\"setUnwritable设置不可写\"></a>setUnwritable设置不可写</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    final int oldValue = unwritable;</div><div class=\"line\">    final int newValue = oldValue | 1;</div><div class=\"line\">    if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) &#123;//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态</div><div class=\"line\">        if (oldValue == 0 &amp;&amp; newValue != 0) &#123;</div><div class=\"line\">            fireChannelWritabilityChanged(invokeLater);//</div><div class=\"line\">        &#125;//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写-&gt;不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。<br>在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。</p>\n<h1 id=\"Flush\"><a href=\"#Flush\" class=\"headerlink\" title=\"Flush\"></a>Flush</h1><p>数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">    unsafe.flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public final void flush() &#123;</div><div class=\"line\">    assertEventLoop();</div><div class=\"line\">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    outboundBuffer.addFlush();</div><div class=\"line\">    flush0();//写完了</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;</li>\n<li>调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():<h2 id=\"内部flush0\"><a href=\"#内部flush0\" class=\"headerlink\" title=\"内部flush0\"></a>内部flush0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">protected void flush0() &#123;</div><div class=\"line\">    if (inFlush0) &#123; //有正在写（真正的调用write写）</div><div class=\"line\">        // Avoid re-entrance</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    inFlush0 = true; //标记正在写</div><div class=\"line\">    // Mark all pending write requests as failure if the channel is inactive.</div><div class=\"line\">    if (!isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (isOpen()) &#123;</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Do not trigger channelWritabilityChanged because the channel is closed already.</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            inFlush0 = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        doWrite(outboundBuffer);</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">       ......</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        inFlush0 = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该代码主要做了如下事情:</p>\n<ol>\n<li>检查是否有正在flush,  如是的话, 直接退出。</li>\n<li>标志正在flush<br>3.调用NioSocketChannel.doWrite()继续刷:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            int size = in.size(); //所有的都写完了</div><div class=\"line\">            if (size == 0) &#123;</div><div class=\"line\">                // All written so clear OP_WRITE</div><div class=\"line\">                clearOpWrite();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            long writtenBytes = 0;</div><div class=\"line\">            boolean done = false;</div><div class=\"line\">            boolean setOpWrite = false;</div><div class=\"line\">            // Ensure the pending writes are made of ByteBufs only.</div><div class=\"line\">            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个</div><div class=\"line\">            int nioBufferCnt = in.nioBufferCount();</div><div class=\"line\">            long expectedWrittenBytes = in.nioBufferSize();</div><div class=\"line\">            SocketChannel ch = javaChannel();</div><div class=\"line\">            // Always us nioBuffers() to workaround data-corruption.</div><div class=\"line\">            // See https://github.com/netty/netty/issues/2761</div><div class=\"line\">            switch (nioBufferCnt) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                    // We have something else beside ByteBuffers to write so fallback to normal writes.</div><div class=\"line\">                    super.doWrite(in);</div><div class=\"line\">                    return;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    // Only one ByteBuf so use non-gathering write</div><div class=\"line\">                    ByteBuffer nioBuffer = nioBuffers[0];</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;</div><div class=\"line\">                        final int localWrittenBytes = ch.write(nioBuffer);</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;//循环16次, 可能一次写不完</div><div class=\"line\">                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">            in.removeBytes(writtenBytes); //记录可丢弃的数据</div><div class=\"line\">            if (!done) &#123;//若没有写完</div><div class=\"line\">                // Did not write all buffers completely.</div><div class=\"line\">                incompleteWrite(setOpWrite);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]</li>\n<li>当content个数&gt;=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。</li>\n</ol>\n<p>至此, write到缓存、flush到网络部分全部讲完了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultFullHttpResponse.png\" height=\"250\" width=\"500\"><br>涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。<br>开始向外发送数据时, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</div><div class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context</div><div class=\"line\">        final Object m = pipeline.touch(msg, next);</div><div class=\"line\">        EventExecutor executor = next.executor();</div><div class=\"line\">        if (executor.inEventLoop()) &#123;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                next.invokeWriteAndFlush(m, promise);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                next.invokeWrite(m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            AbstractWriteTask task;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行</div><div class=\"line\">            &#125;  else &#123;</div><div class=\"line\">                task = WriteTask.newInstance(next, m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            safeExecute(executor, task, promise, m);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">    super.write(ctx, msg, promise); //一般只是存放在缓存中</div><div class=\"line\">    ctx.invokeFlush(); //真正的调用write,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 写数据分为两个过程:write()和flush():</p>\n<ul>\n<li>write只是将数据放在了缓存ChannelOutboundBuffer中</li>\n<li>通过调用channal.write()向网络发送数据。</li>\n</ul>\n<h1 id=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"><a href=\"#HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\" class=\"headerlink\" title=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"></a>HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec</h1><p>我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。<br>首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class=\"line\">    CodecOutputList out = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (acceptOutboundMessage(msg)) &#123;</div><div class=\"line\">            out = CodecOutputList.newInstance();</div><div class=\"line\">            I cast = (I) msg;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                encode(ctx, cast, out);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                ReferenceCountUtil.release(cast);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (out.isEmpty()) &#123;</div><div class=\"line\">                out.recycle();</div><div class=\"line\">                out = null;</div><div class=\"line\">                throw new EncoderException(</div><div class=\"line\">                        StringUtil.simpleClassName(this) + &quot; must produce at least one message.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.write(msg, promise);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            final int sizeMinusOne = out.size() - 1;</div><div class=\"line\">            if (sizeMinusOne == 0) &#123;</div><div class=\"line\">                ctx.write(out.get(0), promise);</div><div class=\"line\">            &#125; else if (sizeMinusOne &gt; 0) &#123;</div><div class=\"line\">                // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2525</div><div class=\"line\">                ChannelPromise voidPromise = ctx.voidPromise();</div><div class=\"line\">                boolean isVoidPromise = promise == voidPromise;</div><div class=\"line\">                for (int i = 0; i &lt; sizeMinusOne; i ++) &#123;//分开向下发送</div><div class=\"line\">                    ChannelPromise p;</div><div class=\"line\">                    if (isVoidPromise) &#123;</div><div class=\"line\">                        p = voidPromise;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        p = ctx.newPromise();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    ctx.write(out.getUnsafe(i), p);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ctx.write(out.getUnsafe(sizeMinusOne), promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现也很简单,主要做了如下两件事:</p>\n<ol>\n<li>首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。</li>\n<li>针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。</li>\n</ol>\n<h2 id=\"HttpContentEncoder的encode-函数\"><a href=\"#HttpContentEncoder的encode-函数\" class=\"headerlink\" title=\"HttpContentEncoder的encode()函数\"></a>HttpContentEncoder的encode()函数</h2><p>首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: “gzip,deflat,br”为例。</p>\n<p>endoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override    //msg: DefaultFullHttpResponse</div><div class=\"line\">    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        final boolean isFull = msg instanceof HttpResponse &amp;&amp; msg instanceof LastHttpContent;</div><div class=\"line\">        switch (state) &#123;</div><div class=\"line\">            case AWAIT_HEADERS: &#123;  //初始取值</div><div class=\"line\">                ensureHeaders(msg);</div><div class=\"line\">                assert encoder == null;</div><div class=\"line\"></div><div class=\"line\">                final HttpResponse res = (HttpResponse) msg;</div><div class=\"line\">                 //根据返回结果确定是否需要编码</div><div class=\"line\">                final int code = res.status().code();</div><div class=\"line\">                final CharSequence acceptEncoding;</div><div class=\"line\">                if (code == CONTINUE_CODE) &#123; //continue_code</div><div class=\"line\">                    // We need to not poll the encoding when response with CONTINUE as another response will follow</div><div class=\"line\">                    // for the issued request. See https://github.com/netty/netty/issues/4079</div><div class=\"line\">                    acceptEncoding = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Get the list of encodings accepted by the peer.</div><div class=\"line\">                    acceptEncoding = acceptEncodingQueue.poll(); //&quot;gzip.default.br&quot;</div><div class=\"line\">                    if (acceptEncoding == null) &#123;</div><div class=\"line\">                        throw new IllegalStateException(&quot;cannot send more responses than requests&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                /*</div><div class=\"line\">                 * per rfc2616 4.3 Message Body</div><div class=\"line\">                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a</div><div class=\"line\">                 * message-body. All other responses do include a message-body, although it MAY be of zero length.</div><div class=\"line\">                 *</div><div class=\"line\">                 * 9.4 HEAD</div><div class=\"line\">                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body</div><div class=\"line\">                 * in the response.</div><div class=\"line\">                 *</div><div class=\"line\">                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.</div><div class=\"line\">                 *</div><div class=\"line\">                 * See https://github.com/netty/netty/issues/5382</div><div class=\"line\">                 */</div><div class=\"line\">                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) &#123; //是否接下来是没有body的</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Pass through the full response with empty content and continue waiting for the the next resp.</div><div class=\"line\">                    if (!((ByteBufHolder) res).content().isReadable()) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity</div><div class=\"line\">                final Result result = beginEncode(res, acceptEncoding.toString());</div><div class=\"line\"></div><div class=\"line\">                // If unable to encode, pass through.</div><div class=\"line\">                if (result == null) &#123;</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                encoder = result.contentEncoder(); //encoder = EmbeddedChannel</div><div class=\"line\"></div><div class=\"line\">                // Encode the content and remove or replace the existing headers</div><div class=\"line\">                // so that the message looks like a decoded message.</div><div class=\"line\">                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip</div><div class=\"line\"></div><div class=\"line\">                // Output the rewritten response.</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Convert full message into unfull one.</div><div class=\"line\">                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());</div><div class=\"line\">                    newRes.headers().set(res.headers());</div><div class=\"line\">                    out.add(newRes);  //newRes里面还没有放数据</div><div class=\"line\"></div><div class=\"line\">                    ensureContent(res);</div><div class=\"line\">                    encodeFullResponse(newRes, (HttpContent) res, out);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Make the response chunked to simplify content transformation.</div><div class=\"line\">                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);</div><div class=\"line\">                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);</div><div class=\"line\"></div><div class=\"line\">                    out.add(res);</div><div class=\"line\">                    state = State.AWAIT_CONTENT;</div><div class=\"line\">                    if (!(msg instanceof HttpContent)) &#123;</div><div class=\"line\">                        // only break out the switch statement if we have not content to process</div><div class=\"line\">                        // See https://github.com/netty/netty/issues/2006</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Fall through to encode the content</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case AWAIT_CONTENT: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                if (encodeContent((HttpContent) msg, out)) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case PASS_THROUGH: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                out.add(ReferenceCountUtil.retain(msg));</div><div class=\"line\">                // Passed through all following contents of the current response.</div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>该编码器encode主要做的事情:<br>1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:</p>\n<ul>\n<li>若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。</li>\n<li>否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br<br>2.根据规范<code>rfc2616 4.3 Message Body</code>, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。<br>3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。<br>4.在beginEncode中建立相应压缩管道EmbeddedChannel:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception &#123;</div><div class=\"line\">       ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP</div><div class=\"line\">       if (wrapper == null) &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">       String targetContentEncoding;</div><div class=\"line\">       switch (wrapper) &#123;</div><div class=\"line\">       case GZIP:</div><div class=\"line\">           targetContentEncoding = &quot;gzip&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       case ZLIB:</div><div class=\"line\">           targetContentEncoding = &quot;deflate&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       default:</div><div class=\"line\">           throw new Error();</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return new Result(</div><div class=\"line\">               targetContentEncoding,</div><div class=\"line\">               new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),</div><div class=\"line\">                       ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(</div><div class=\"line\">                       wrapper, compressionLevel, windowBits, memLevel)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip&gt;deflate</li>\n<li>返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:&lt;img src=”<a href=\"https://kkewwei.github.io/elasticsearch_learning/img/GzipPipline.png\">https://kkewwei.github.io/elasticsearch_learning/img/GzipPipline.png</a>“ height=”250” width=”350/&gt;<br>对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。<br>5.向返回值headler中添加 content-encoding:gzip<br>6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.<br>7.在encodeFullResponse中调用编码函数encodeContent()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean encodeContent(HttpContent c, List&lt;Object&gt; out) &#123;</div><div class=\"line\">        ByteBuf content = c.content();</div><div class=\"line\">        encode(content, out);</div><div class=\"line\">        if (c instanceof LastHttpContent) &#123;</div><div class=\"line\">            finishEncode(out);</div><div class=\"line\">            LastHttpContent last = (LastHttpContent) c;</div><div class=\"line\">            // Generate an additional chunk if the decoder produced</div><div class=\"line\">            // the last product on closure,</div><div class=\"line\">            HttpHeaders headers = last.trailingHeaders();</div><div class=\"line\">            if (headers.isEmpty()) &#123;</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new ComposedLastHttpContent(headers));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。</p>\n<ul>\n<li>调用JdkZlibEncoder.encode()进行压缩。</li>\n<li>将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。</li>\n<li>在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。<br>7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。<br>这样整个输出帧的内容存放在out中, 拥有的对象如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpOutPutResponse.png\" height=\"250\" width=\"500\"><br>其中:</li>\n<li>DefaultHttpResponse: 存放的是Http/1.1 status, Header等</li>\n<li>第一个DefaultHttpContent存放的是压缩的内容。</li>\n<li>第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。</li>\n<li>LastHttpContent代表整个帧的结束, content部分为空。<br>8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。<h2 id=\"JdkZlibEncoder压缩\"><a href=\"#JdkZlibEncoder压缩\" class=\"headerlink\" title=\"JdkZlibEncoder压缩\"></a>JdkZlibEncoder压缩</h2>我们可以了解下JdkZlibEncoder.encode()是怎么压缩的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception &#123;</div><div class=\"line\">    int len = uncompressed.readableBytes(); //总共刻度数据</div><div class=\"line\">    int offset;</div><div class=\"line\">    byte[] inAry;</div><div class=\"line\">    if (uncompressed.hasArray()) &#123;  //若有数组,直接获得数组</div><div class=\"line\">        // if it is backed by an array we not need to to do a copy at all</div><div class=\"line\">        inAry = uncompressed.array();</div><div class=\"line\">        offset = uncompressed.arrayOffset() + uncompressed.readerIndex();</div><div class=\"line\">        // skip all bytes as we will consume all of them</div><div class=\"line\">        uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        inAry = new byte[len];</div><div class=\"line\">        uncompressed.readBytes(inAry);//将数据读取到这个byte数组中</div><div class=\"line\">        offset = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (writeHeader) &#123; //将数组写进去， 最开始编码，需要写</div><div class=\"line\">        writeHeader = false;</div><div class=\"line\">        if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">            out.writeBytes(gzipHeader);//首先写进去头</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">        crc.update(inAry, offset, len);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //向压缩器中传递带压缩的数组</div><div class=\"line\">    deflater.setInput(inAry, offset, len);</div><div class=\"line\">    while (!deflater.needsInput()) &#123;</div><div class=\"line\">        deflate(out); //进行真正的压缩</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先获得bytebuf的byte数组</li>\n<li>向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];<br>其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;</li>\n<li>直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。</li>\n</ul>\n<h2 id=\"DefalueChannalHadlerContext-write\"><a href=\"#DefalueChannalHadlerContext-write\" class=\"headerlink\" title=\"DefalueChannalHadlerContext.write()\"></a>DefalueChannalHadlerContext.write()</h2><p>DefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。<br>接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ByteBuf buf = null;</div><div class=\"line\">if (msg instanceof HttpMessage) &#123;  //如果是头部，则先编码头部</div><div class=\"line\">    if (state != ST_INIT) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">    &#125;</div><div class=\"line\">    H m = (H) msg;</div><div class=\"line\">    buf = ctx.alloc().buffer();//直接内存分配的地址</div><div class=\"line\">    // Encode the message.</div><div class=\"line\">    encodeInitialLine(buf, m); //先是编码initial部分</div><div class=\"line\">    encodeHeaders(m.headers(), buf);//再编码header部分</div><div class=\"line\">    buf.writeBytes(CRLF);</div><div class=\"line\">    state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK</div><div class=\"line\">            HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg instanceof ByteBuf &amp;&amp; !((ByteBuf) msg).isReadable()) &#123;</div><div class=\"line\">    out.add(EMPTY_BUFFER);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse</div><div class=\"line\">if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) &#123;</div><div class=\"line\">    switch (state) &#123;</div><div class=\"line\">        case ST_INIT:</div><div class=\"line\">            throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">        case ST_CONTENT_NON_CHUNK: //st_content_non_chunk</div><div class=\"line\">            final long contentLength = contentLength(msg);</div><div class=\"line\">            if (contentLength &gt; 0) &#123;//可写的空间够，直接放到直接内存buf中</div><div class=\"line\">                if (buf != null &amp;&amp; buf.writableBytes() &gt;= contentLength &amp;&amp; msg instanceof HttpContent) &#123;//必须是content类型的</div><div class=\"line\">                    // merge into other buffer for performance reasons</div><div class=\"line\">                    buf.writeBytes(((HttpContent) msg).content());</div><div class=\"line\">                    out.add(buf);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (buf != null) &#123;</div><div class=\"line\">                        out.add(buf); //先把直接内存放进去</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = ST_INIT; //编码完成后，直接复位</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // fall-through!</div><div class=\"line\">        case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里</div><div class=\"line\"></div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Need to produce some output otherwise an</div><div class=\"line\">                // IllegalStateException will be thrown</div><div class=\"line\">                out.add(EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            break;</div><div class=\"line\">        case ST_CONTENT_CHUNK:</div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125;</div><div class=\"line\">            encodeChunkedContent(ctx, msg, contentLength(msg), out);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            throw new Error();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg instanceof LastHttpContent) &#123; //解码完成，再置位</div><div class=\"line\">        state = ST_INIT;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (buf != null) &#123;</div><div class=\"line\">    out.add(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>state初始值为ST_INIT, 该函数主要做了如下操作:</p>\n<ol>\n<li>首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。</li>\n</ol>\n<ul>\n<li><p>通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> response.protocolVersion().encode(buf); //首先存放version编码</div><div class=\"line\">buf.writeByte(SP); //存放byte:32水平空格</div><div class=\"line\">response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=&quot;200 ok&quot;</div><div class=\"line\">buf.writeBytes(CRLF); //  &#123; CR, LF &#125;回车换行</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过encodeHeaders编码header部分, 每个header属性编码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> final int nameLen = name.length();</div><div class=\"line\">final int valueLen = value.length();</div><div class=\"line\">final int entryLen = nameLen + valueLen + 4;</div><div class=\"line\">buf.ensureWritable(entryLen);  //检查buf的最小长度</div><div class=\"line\">int offset = buf.writerIndex();</div><div class=\"line\">writeAscii(buf, offset, name); // 使用US_ASCII编码</div><div class=\"line\">offset += nameLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;:&apos;);//:</div><div class=\"line\">buf.setByte(offset ++, &apos; &apos;);//空格</div><div class=\"line\">writeAscii(buf, offset, value);</div><div class=\"line\">offset += valueLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;\\r&apos;);//</div><div class=\"line\">buf.setByte(offset ++, &apos;\\n&apos;);</div><div class=\"line\">buf.writerIndex(offset);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格<br>2) 通过CharsetUtil.US_ASCII编码key和value</p>\n<ul>\n<li>再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/HttpResponse_Byte.png\" height=\"250\" width=\"600\"></li>\n</ul>\n<p>然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。<br>2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。</p>\n<ul>\n<li>会直接将整个DefaltHttpContent放入out向外写</li>\n<li>当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。</li>\n</ul>\n<h1 id=\"Netty水位\"><a href=\"#Netty水位\" class=\"headerlink\" title=\"Netty水位\"></a>Netty水位</h1><p>向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">     public final void write(Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位</div><div class=\"line\">         int size;</div><div class=\"line\">         try &#123;</div><div class=\"line\">             msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap</div><div class=\"line\">             size = pipeline.estimatorHandle().size(msg);</div><div class=\"line\">             if (size &lt; 0) &#123;</div><div class=\"line\">                 size = 0;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; catch (Throwable t) &#123;</div><div class=\"line\">             safeSetFailure(promise, t);</div><div class=\"line\">             ReferenceCountUtil.release(msg);</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。</li>\n<li>通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。<br>我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ChannelOutboundBuffer.png\" height=\"250\" width=\"480\"><br>flushEntry 表示即将刷新的位置<br>unflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。<br>tailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。<br>当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息</div><div class=\"line\">if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法</div><div class=\"line\">    setUnwritable(invokeLater);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?<br>在netty启动时, 只需要添加如下参数即可:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);</div></pre></td></tr></table></figure></p>\n<p>代表:</p>\n<ul>\n<li>当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。</li>\n<li>当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.<h2 id=\"setUnwritable设置不可写\"><a href=\"#setUnwritable设置不可写\" class=\"headerlink\" title=\"setUnwritable设置不可写\"></a>setUnwritable设置不可写</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    final int oldValue = unwritable;</div><div class=\"line\">    final int newValue = oldValue | 1;</div><div class=\"line\">    if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) &#123;//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态</div><div class=\"line\">        if (oldValue == 0 &amp;&amp; newValue != 0) &#123;</div><div class=\"line\">            fireChannelWritabilityChanged(invokeLater);//</div><div class=\"line\">        &#125;//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写-&gt;不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。<br>在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。</p>\n<h1 id=\"Flush\"><a href=\"#Flush\" class=\"headerlink\" title=\"Flush\"></a>Flush</h1><p>数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">    unsafe.flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public final void flush() &#123;</div><div class=\"line\">    assertEventLoop();</div><div class=\"line\">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    outboundBuffer.addFlush();</div><div class=\"line\">    flush0();//写完了</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;</li>\n<li>调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():<h2 id=\"内部flush0\"><a href=\"#内部flush0\" class=\"headerlink\" title=\"内部flush0\"></a>内部flush0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">protected void flush0() &#123;</div><div class=\"line\">    if (inFlush0) &#123; //有正在写（真正的调用write写）</div><div class=\"line\">        // Avoid re-entrance</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    inFlush0 = true; //标记正在写</div><div class=\"line\">    // Mark all pending write requests as failure if the channel is inactive.</div><div class=\"line\">    if (!isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (isOpen()) &#123;</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Do not trigger channelWritabilityChanged because the channel is closed already.</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            inFlush0 = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        doWrite(outboundBuffer);</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">       ......</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        inFlush0 = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该代码主要做了如下事情:</p>\n<ol>\n<li>检查是否有正在flush,  如是的话, 直接退出。</li>\n<li>标志正在flush<br>3.调用NioSocketChannel.doWrite()继续刷:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            int size = in.size(); //所有的都写完了</div><div class=\"line\">            if (size == 0) &#123;</div><div class=\"line\">                // All written so clear OP_WRITE</div><div class=\"line\">                clearOpWrite();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            long writtenBytes = 0;</div><div class=\"line\">            boolean done = false;</div><div class=\"line\">            boolean setOpWrite = false;</div><div class=\"line\">            // Ensure the pending writes are made of ByteBufs only.</div><div class=\"line\">            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个</div><div class=\"line\">            int nioBufferCnt = in.nioBufferCount();</div><div class=\"line\">            long expectedWrittenBytes = in.nioBufferSize();</div><div class=\"line\">            SocketChannel ch = javaChannel();</div><div class=\"line\">            // Always us nioBuffers() to workaround data-corruption.</div><div class=\"line\">            // See https://github.com/netty/netty/issues/2761</div><div class=\"line\">            switch (nioBufferCnt) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                    // We have something else beside ByteBuffers to write so fallback to normal writes.</div><div class=\"line\">                    super.doWrite(in);</div><div class=\"line\">                    return;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    // Only one ByteBuf so use non-gathering write</div><div class=\"line\">                    ByteBuffer nioBuffer = nioBuffers[0];</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;</div><div class=\"line\">                        final int localWrittenBytes = ch.write(nioBuffer);</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;//循环16次, 可能一次写不完</div><div class=\"line\">                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">            in.removeBytes(writtenBytes); //记录可丢弃的数据</div><div class=\"line\">            if (!done) &#123;//若没有写完</div><div class=\"line\">                // Did not write all buffers completely.</div><div class=\"line\">                incompleteWrite(setOpWrite);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]</li>\n<li>当content个数&gt;=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。</li>\n</ol>\n<p>至此, write到缓存、flush到网络部分全部讲完了。</p>\n"},{"title":"Netty Http通信源码一(解码)分析","date":"2018-04-15T16:06:17.000Z","_content":"首先给出一个http server pipiLine里面的处理器的组成结构的示例:\n```\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);\n            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个\n            ch.pipeline().addLast(\"decoder\", decoder);\n            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n            final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));\n            ch.pipeline().addLast(\"aggregator\", aggregator);  //包的聚合\n            ch.pipeline().addLast(\"encoder_compress\", new HttpContentCompressor(transport.compressionLevel));\n            ch.pipeline().addLast(\"pipelining\", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));\n            ch.pipeline().addLast(\"handler\", requestHandler);\n        }\n```\n其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。\nhttp处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。\n这里有一个问题:\n`为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?`\n服务器端数据真正接收到客户端网络的数据是在NioSocketChannel里面的NioByteUnsafe(NioSocketChannelUnsafe父类)里面的read()里面。\n# HttpObjectDecoder和HttpRequestDecoder\n首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:\n+ HttpRequest: 主要存放inital, head等。\n+ HttpContent: 传输的数据部分\nHttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成`HttpRequest`,实际就是将`ChannelBuffer`转变为多个`HttpChunk`对象。\nHttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。\nHttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。\ndecode函数实现如下:\n```\nprotected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) { //没有break\n        case SKIP_CONTROL_CHARS: { //skip_control_chars\n            if (!skipControlCharacters(buffer)) {\n                return;\n            }\n            currentState = State.READ_INITIAL;   //read_initail\n        }\n        case READ_INITIAL: try {  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1\n            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line); //{Method, URL, HTTPVersion\n            if (initialLine.length < 3) { //无效的请求， 忽略。\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars\n                return;\n            }\n            message = createMessage(initialLine);  //DefaultHttpRequest\n            currentState = State.READ_HEADER;  //read_header\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {    //read_header\n            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:   //skip_control_char\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE: //read_chunk_size\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:  //或者读取变量类型长度或者定长\n                long contentLength = contentLength();//没有长度相关变量就是-1\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content\n                    resetNow();\n                    return;\n                }\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content\n                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {  //read_fixed_lengt_content\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength; // 注意这两个直接赋值一样\n                }\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {  //read_variable_length_content\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {  //read_fixed_length_content\n            int readLimit = buffer.readableBytes();\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create a HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面\n            chunkSize -= toRead; //content = PooledSlicedByteBuf\n            if (chunkSize == 0) {  //要是定长的话，就直接content就是DefaultLastHttpContent，\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow(); //解析完了就该返回了\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {//read_chunk_size\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: { //read_chunked_content\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n            out.add(chunk);\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {//read_chunked_delimiter\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {//read_chunked_foooter\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {  //bad_message\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {//upgraded\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n```\n注意这里的case并没有break, decode主要做了如下逻辑:\n1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。\n```\nprivate static boolean skipControlCharacters(ByteBuf buffer) {\n        boolean skiped = false;\n        final int wIdx = buffer.writerIndex();\n        int rIdx = buffer.readerIndex();\n        while (wIdx > rIdx) {\n            int c = buffer.getUnsignedByte(rIdx++);\n            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等\n                rIdx--;\n                skiped = true;\n                break;\n            }\n        }\n        buffer.readerIndex(rIdx);\n        return skiped;\n    }\n```\n首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。\n2) 读取INITIAL部分\n从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:`GET /_cat/indices HTTP/1.1`, 创建对象:DefaultHttpRequest, 其中\n```\nhttpVersion: HTTP/1.1\nmethod: GET\nuri: /_cat/indices\n```\n这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。\n3) 读取Headers部分\n```\nprivate State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;  //DefaultHttpRequest\n        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders\n        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while{}为循环\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do { //这是个while循环，以换行符来进行分割\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n                line = headerParser.parse(buffer);   //\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {   //解析出最后一个header\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {  //header是否为空\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始\n        } else if (HttpUtil.isTransferEncodingChunked(message)) { // 是否包含 transfer-encoding: chunked\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {   //Content-Length: 80\n            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值\n        } else { //没有Content-Length和chunked相关的，就是读取变量类型长度\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n        }\n```\n主要做的事:\n+ 读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:\n```\n\"Accept\" -> \"*/*\"\n\"User-Agent\" -> \"curl/7/43/0\"\n\"Host\" -> \"127.0.0.1:9200\"\n\"Content-Length\" -> \"66735\"\n\"Content-Encoding\" -> \"gzip\"\n\"Content-Type\" -> \"application/x-www-form-urlencoded\"\n\"Expect\" -> \"100-continue\"\n\"null\" -> \"null\"\n```\n我们需要了解一个参数:Expect: 100-continue\n\n> <a href=\"https://blog.csdn.net/MitKey/article/details/52042537\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。<p>客户端策略:\n如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}\n如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。\n并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。\n有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。<p>服务端策略:\n正确情况下，收到请求后，返回 100 或错误码。\n如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。\n\n这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度>=1025时, 客户端发送的header里面才会有这个参数。\n+ 如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。\n这里会设置状态为READ_FIXED_LENGTH_CONTENT\n4)  读取内容\n因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<Math.min(readableLength, maxChunkSize), 每读取maxChunkSize长度的值就向后传递, 同时修改chunkSize的值。读取第二个chunked的动作在MessageToMessageDecoder中发出(该content的readableBytes>0)。\n这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。\n# HttpObjectAggregator和 MessageAggregator\nHttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。\nMessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:\n```\n    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {\n        if (isStartMessage(msg)) {//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行\n            handlingOversizedMessage = false;\n            if (currentMessage != null) {\n                currentMessage.release();\n                currentMessage = null;\n                throw new MessageAggregationException();\n            }\n            @SuppressWarnings(\"unchecked\")\n            S m = (S) msg; //DefaultHttpRequest\n            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)\n            // Check before content length. Failing an expectation may result in a different response being sent.\n            Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse\n            if (continueResponse != null) { //向客户端返回100-continue, 告诉客户端可以发送content了\n                // Cache the write listener for reuse.\n                ChannelFutureListener listener = continueResponseWriteListener;\n                if (listener == null) {\n                    continueResponseWriteListener = listener = new ChannelFutureListener() {\n                        @Override\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                ctx.fireExceptionCaught(future.cause());\n                            }\n                        }\n                    };\n                }\n                // Make sure to call this before writing, otherwise reference counts may be invalid.\n                boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);\n                handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);\n\n                final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);\n\n                if (closeAfterWrite) {\n                    future.addListener(ChannelFutureListener.CLOSE);\n                    return;\n                }\n                if (handlingOversizedMessage) {\n                    return;\n                }\n            } else if (isContentLengthInvalid(m, maxContentLength)) { //检查length是否有效，\n                // if content length is set, preemptively close if it's too large\n                invokeHandleOversizedMessage(ctx, m);\n                return;\n            }\n\n            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {\n                O aggregated;\n                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {\n                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());\n                } else {\n                    aggregated = beginAggregation(m, EMPTY_BUFFER);\n                }\n                finishAggregation(aggregated);\n                out.add(aggregated);\n                return;\n            }\n             //同时生成好Compent\n            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.\n            CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可\n            if (m instanceof ByteBufHolder) {\n                appendPartialContent(content, ((ByteBufHolder) m).content());\n            }\n            currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest\n        } else if (isContentMessage(msg)) { //解析内容部分\n            if (currentMessage == null) {\n                // it is possible that a TooLongFrameException was already thrown but we can still discard data\n                // until the begging of the next request/response.\n                return;\n            }\n\n            // Merge the received chunk into the content of the current message.\n            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();\n\n            @SuppressWarnings(\"unchecked\")\n            final C m = (C) msg; //可能是DefaultLastHttpContent\n            // Handle oversized message.\n            if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {\n                // By convention, full message type extends first message type.\n                @SuppressWarnings(\"unchecked\")\n                S s = (S) currentMessage;\n                invokeHandleOversizedMessage(ctx, s);\n                return;\n            }\n            // Append the content of the chunk.\n            appendPartialContent(content, m.content()); //把产生的数据添加到末尾\n            //\n            // Give the subtypes a chance to merge additional information such as trailing headers.\n            aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest\n\n            final boolean last;\n            if (m instanceof DecoderResultProvider) {\n                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();\n                if (!decoderResult.isSuccess()) {\n                    if (currentMessage instanceof DecoderResultProvider) {\n                        ((DecoderResultProvider) currentMessage).setDecoderResult(\n                                DecoderResult.failure(decoderResult.cause()));\n                    }\n                    last = true;\n                } else {\n                    last = isLastContentMessage(m);\n                }\n            } else {\n                last = isLastContentMessage(m);\n            }\n\n            if (last) {  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，\n                finishAggregation(currentMessage);\n\n                // All done\n                out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。\n                currentMessage = null;\n            }\n        } else {\n            throw new MessageAggregationException();\n        }\n    }\n```\ndecode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。\n1) 若请求是HttpRequest\n说明该部分是request最开始的那一部分。\n+ 首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。\n+ 生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。\n需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性`List<Component> components`构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。\n\n2) 若请求是HttpContent部分\n+ 将content添加进CompositeByteBuf中\n通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:\n```\n     private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {\n            .....\n            if (cIndex == components.size()) {\n                wasAdded = components.add(c);\n                if (cIndex == 0) {\n                    c.endOffset = readableBytes;\n                } else {\n                    Component prev = components.get(cIndex - 1);\n                    c.offset = prev.endOffset;\n                    c.endOffset = c.offset + readableBytes;\n                }\n            }\n            .....\n            if (increaseWriterIndex) {\n                writerIndex(writerIndex() + buffer.readableBytes());\n            }\n            return cIndex;\n        }\n    }\n```\n每个Component结构如下:\n```\n        ByteBuf buf;  //该Component实际存储\n        final int length;\n        int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。\n        int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。\n```\n在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。\n\n+ 等待所有的content发送过来\n1. 轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。\n2. 直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。\n\n至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultLastHttpContent.png\" />\n# 附\n如何将Composite转换为一个连续的堆内buf呢?\n通过Unpooled.copiedBuffer(request.content())方法即可。\n","source":"_posts/Netty-Http通信解码源码阅读.md","raw":"---\ntitle: Netty Http通信源码一(解码)分析\ndate: 2018-04-16 00:06:17\ntags:\n---\n首先给出一个http server pipiLine里面的处理器的组成结构的示例:\n```\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);\n            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个\n            ch.pipeline().addLast(\"decoder\", decoder);\n            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n            final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));\n            ch.pipeline().addLast(\"aggregator\", aggregator);  //包的聚合\n            ch.pipeline().addLast(\"encoder_compress\", new HttpContentCompressor(transport.compressionLevel));\n            ch.pipeline().addLast(\"pipelining\", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));\n            ch.pipeline().addLast(\"handler\", requestHandler);\n        }\n```\n其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。\nhttp处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。\n这里有一个问题:\n`为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?`\n服务器端数据真正接收到客户端网络的数据是在NioSocketChannel里面的NioByteUnsafe(NioSocketChannelUnsafe父类)里面的read()里面。\n# HttpObjectDecoder和HttpRequestDecoder\n首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:\n+ HttpRequest: 主要存放inital, head等。\n+ HttpContent: 传输的数据部分\nHttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成`HttpRequest`,实际就是将`ChannelBuffer`转变为多个`HttpChunk`对象。\nHttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。\nHttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。\ndecode函数实现如下:\n```\nprotected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) { //没有break\n        case SKIP_CONTROL_CHARS: { //skip_control_chars\n            if (!skipControlCharacters(buffer)) {\n                return;\n            }\n            currentState = State.READ_INITIAL;   //read_initail\n        }\n        case READ_INITIAL: try {  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1\n            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line); //{Method, URL, HTTPVersion\n            if (initialLine.length < 3) { //无效的请求， 忽略。\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars\n                return;\n            }\n            message = createMessage(initialLine);  //DefaultHttpRequest\n            currentState = State.READ_HEADER;  //read_header\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {    //read_header\n            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:   //skip_control_char\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE: //read_chunk_size\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:  //或者读取变量类型长度或者定长\n                long contentLength = contentLength();//没有长度相关变量就是-1\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content\n                    resetNow();\n                    return;\n                }\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content\n                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {  //read_fixed_lengt_content\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength; // 注意这两个直接赋值一样\n                }\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {  //read_variable_length_content\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {  //read_fixed_length_content\n            int readLimit = buffer.readableBytes();\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create a HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面\n            chunkSize -= toRead; //content = PooledSlicedByteBuf\n            if (chunkSize == 0) {  //要是定长的话，就直接content就是DefaultLastHttpContent，\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow(); //解析完了就该返回了\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {//read_chunk_size\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: { //read_chunked_content\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n            out.add(chunk);\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {//read_chunked_delimiter\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {//read_chunked_foooter\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {  //bad_message\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {//upgraded\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n```\n注意这里的case并没有break, decode主要做了如下逻辑:\n1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。\n```\nprivate static boolean skipControlCharacters(ByteBuf buffer) {\n        boolean skiped = false;\n        final int wIdx = buffer.writerIndex();\n        int rIdx = buffer.readerIndex();\n        while (wIdx > rIdx) {\n            int c = buffer.getUnsignedByte(rIdx++);\n            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等\n                rIdx--;\n                skiped = true;\n                break;\n            }\n        }\n        buffer.readerIndex(rIdx);\n        return skiped;\n    }\n```\n首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。\n2) 读取INITIAL部分\n从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:`GET /_cat/indices HTTP/1.1`, 创建对象:DefaultHttpRequest, 其中\n```\nhttpVersion: HTTP/1.1\nmethod: GET\nuri: /_cat/indices\n```\n这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。\n3) 读取Headers部分\n```\nprivate State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;  //DefaultHttpRequest\n        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders\n        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while{}为循环\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do { //这是个while循环，以换行符来进行分割\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n                line = headerParser.parse(buffer);   //\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {   //解析出最后一个header\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {  //header是否为空\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始\n        } else if (HttpUtil.isTransferEncodingChunked(message)) { // 是否包含 transfer-encoding: chunked\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {   //Content-Length: 80\n            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值\n        } else { //没有Content-Length和chunked相关的，就是读取变量类型长度\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n        }\n```\n主要做的事:\n+ 读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:\n```\n\"Accept\" -> \"*/*\"\n\"User-Agent\" -> \"curl/7/43/0\"\n\"Host\" -> \"127.0.0.1:9200\"\n\"Content-Length\" -> \"66735\"\n\"Content-Encoding\" -> \"gzip\"\n\"Content-Type\" -> \"application/x-www-form-urlencoded\"\n\"Expect\" -> \"100-continue\"\n\"null\" -> \"null\"\n```\n我们需要了解一个参数:Expect: 100-continue\n\n> <a href=\"https://blog.csdn.net/MitKey/article/details/52042537\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。<p>客户端策略:\n如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}\n如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。\n并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。\n有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。<p>服务端策略:\n正确情况下，收到请求后，返回 100 或错误码。\n如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。\n\n这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度>=1025时, 客户端发送的header里面才会有这个参数。\n+ 如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。\n这里会设置状态为READ_FIXED_LENGTH_CONTENT\n4)  读取内容\n因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<Math.min(readableLength, maxChunkSize), 每读取maxChunkSize长度的值就向后传递, 同时修改chunkSize的值。读取第二个chunked的动作在MessageToMessageDecoder中发出(该content的readableBytes>0)。\n这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。\n# HttpObjectAggregator和 MessageAggregator\nHttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。\nMessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:\n```\n    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {\n        if (isStartMessage(msg)) {//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行\n            handlingOversizedMessage = false;\n            if (currentMessage != null) {\n                currentMessage.release();\n                currentMessage = null;\n                throw new MessageAggregationException();\n            }\n            @SuppressWarnings(\"unchecked\")\n            S m = (S) msg; //DefaultHttpRequest\n            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)\n            // Check before content length. Failing an expectation may result in a different response being sent.\n            Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse\n            if (continueResponse != null) { //向客户端返回100-continue, 告诉客户端可以发送content了\n                // Cache the write listener for reuse.\n                ChannelFutureListener listener = continueResponseWriteListener;\n                if (listener == null) {\n                    continueResponseWriteListener = listener = new ChannelFutureListener() {\n                        @Override\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                ctx.fireExceptionCaught(future.cause());\n                            }\n                        }\n                    };\n                }\n                // Make sure to call this before writing, otherwise reference counts may be invalid.\n                boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);\n                handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);\n\n                final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);\n\n                if (closeAfterWrite) {\n                    future.addListener(ChannelFutureListener.CLOSE);\n                    return;\n                }\n                if (handlingOversizedMessage) {\n                    return;\n                }\n            } else if (isContentLengthInvalid(m, maxContentLength)) { //检查length是否有效，\n                // if content length is set, preemptively close if it's too large\n                invokeHandleOversizedMessage(ctx, m);\n                return;\n            }\n\n            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {\n                O aggregated;\n                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {\n                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());\n                } else {\n                    aggregated = beginAggregation(m, EMPTY_BUFFER);\n                }\n                finishAggregation(aggregated);\n                out.add(aggregated);\n                return;\n            }\n             //同时生成好Compent\n            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.\n            CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可\n            if (m instanceof ByteBufHolder) {\n                appendPartialContent(content, ((ByteBufHolder) m).content());\n            }\n            currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest\n        } else if (isContentMessage(msg)) { //解析内容部分\n            if (currentMessage == null) {\n                // it is possible that a TooLongFrameException was already thrown but we can still discard data\n                // until the begging of the next request/response.\n                return;\n            }\n\n            // Merge the received chunk into the content of the current message.\n            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();\n\n            @SuppressWarnings(\"unchecked\")\n            final C m = (C) msg; //可能是DefaultLastHttpContent\n            // Handle oversized message.\n            if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {\n                // By convention, full message type extends first message type.\n                @SuppressWarnings(\"unchecked\")\n                S s = (S) currentMessage;\n                invokeHandleOversizedMessage(ctx, s);\n                return;\n            }\n            // Append the content of the chunk.\n            appendPartialContent(content, m.content()); //把产生的数据添加到末尾\n            //\n            // Give the subtypes a chance to merge additional information such as trailing headers.\n            aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest\n\n            final boolean last;\n            if (m instanceof DecoderResultProvider) {\n                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();\n                if (!decoderResult.isSuccess()) {\n                    if (currentMessage instanceof DecoderResultProvider) {\n                        ((DecoderResultProvider) currentMessage).setDecoderResult(\n                                DecoderResult.failure(decoderResult.cause()));\n                    }\n                    last = true;\n                } else {\n                    last = isLastContentMessage(m);\n                }\n            } else {\n                last = isLastContentMessage(m);\n            }\n\n            if (last) {  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，\n                finishAggregation(currentMessage);\n\n                // All done\n                out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。\n                currentMessage = null;\n            }\n        } else {\n            throw new MessageAggregationException();\n        }\n    }\n```\ndecode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。\n1) 若请求是HttpRequest\n说明该部分是request最开始的那一部分。\n+ 首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。\n+ 生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。\n需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性`List<Component> components`构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。\n\n2) 若请求是HttpContent部分\n+ 将content添加进CompositeByteBuf中\n通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:\n```\n     private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {\n            .....\n            if (cIndex == components.size()) {\n                wasAdded = components.add(c);\n                if (cIndex == 0) {\n                    c.endOffset = readableBytes;\n                } else {\n                    Component prev = components.get(cIndex - 1);\n                    c.offset = prev.endOffset;\n                    c.endOffset = c.offset + readableBytes;\n                }\n            }\n            .....\n            if (increaseWriterIndex) {\n                writerIndex(writerIndex() + buffer.readableBytes());\n            }\n            return cIndex;\n        }\n    }\n```\n每个Component结构如下:\n```\n        ByteBuf buf;  //该Component实际存储\n        final int length;\n        int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。\n        int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。\n```\n在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。\n\n+ 等待所有的content发送过来\n1. 轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。\n2. 直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。\n\n至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultLastHttpContent.png\" />\n# 附\n如何将Composite转换为一个连续的堆内buf呢?\n通过Unpooled.copiedBuffer(request.content())方法即可。\n","slug":"Netty-Http通信解码源码阅读","published":1,"updated":"2019-06-05T11:00:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8x0000kphu5kvsgf898","content":"<p>首先给出一个http server pipiLine里面的处理器的组成结构的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void initChannel(Channel ch) throws Exception &#123;</div><div class=\"line\">    final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);</div><div class=\"line\">    decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个</div><div class=\"line\">    ch.pipeline().addLast(&quot;decoder&quot;, decoder);</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder&quot;, new HttpResponseEncoder());</div><div class=\"line\">    final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));</div><div class=\"line\">    ch.pipeline().addLast(&quot;aggregator&quot;, aggregator);  //包的聚合</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder_compress&quot;, new HttpContentCompressor(transport.compressionLevel));</div><div class=\"line\">    ch.pipeline().addLast(&quot;pipelining&quot;, new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));</div><div class=\"line\">    ch.pipeline().addLast(&quot;handler&quot;, requestHandler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。<br>http处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。<br>这里有一个问题:<br><code>为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?</code><br>服务器端数据真正接收到客户端网络的数据是在NioSocketChannel里面的NioByteUnsafe(NioSocketChannelUnsafe父类)里面的read()里面。</p>\n<h1 id=\"HttpObjectDecoder和HttpRequestDecoder\"><a href=\"#HttpObjectDecoder和HttpRequestDecoder\" class=\"headerlink\" title=\"HttpObjectDecoder和HttpRequestDecoder\"></a>HttpObjectDecoder和HttpRequestDecoder</h1><p>首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:</p>\n<ul>\n<li>HttpRequest: 主要存放inital, head等。</li>\n<li>HttpContent: 传输的数据部分<br>HttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成<code>HttpRequest</code>,实际就是将<code>ChannelBuffer</code>转变为多个<code>HttpChunk</code>对象。<br>HttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。<br>HttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。<br>decode函数实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        if (resetRequested) &#123;</div><div class=\"line\">            resetNow();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        switch (currentState) &#123; //没有break</div><div class=\"line\">        case SKIP_CONTROL_CHARS: &#123; //skip_control_chars</div><div class=\"line\">            if (!skipControlCharacters(buffer)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_INITIAL;   //read_initail</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_INITIAL: try &#123;  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String[] initialLine = splitInitialLine(line); //&#123;Method, URL, HTTPVersion</div><div class=\"line\">            if (initialLine.length &lt; 3) &#123; //无效的请求， 忽略。</div><div class=\"line\">                // Invalid initial line - ignore.</div><div class=\"line\">                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            message = createMessage(initialLine);  //DefaultHttpRequest</div><div class=\"line\">            currentState = State.READ_HEADER;  //read_header</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_HEADER: try &#123;    //read_header</div><div class=\"line\">            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式</div><div class=\"line\">            if (nextState == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = nextState;</div><div class=\"line\">            switch (nextState) &#123;</div><div class=\"line\">            case SKIP_CONTROL_CHARS:   //skip_control_char</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content</div><div class=\"line\">                resetNow();</div><div class=\"line\">                return;</div><div class=\"line\">            case READ_CHUNK_SIZE: //read_chunk_size</div><div class=\"line\">                if (!chunkedSupported) &#123;</div><div class=\"line\">                    throw new IllegalArgumentException(&quot;Chunked messages not supported&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                return;</div><div class=\"line\">            default:  //或者读取变量类型长度或者定长</div><div class=\"line\">                long contentLength = contentLength();//没有长度相关变量就是-1</div><div class=\"line\">                if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) &#123;</div><div class=\"line\">                    out.add(message);</div><div class=\"line\">                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content</div><div class=\"line\">                    resetNow();</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content</div><div class=\"line\">                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content</div><div class=\"line\">                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分</div><div class=\"line\">                if (nextState == State.READ_FIXED_LENGTH_CONTENT) &#123;  //read_fixed_lengt_content</div><div class=\"line\">                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.</div><div class=\"line\">                    chunkSize = contentLength; // 注意这两个直接赋值一样</div><div class=\"line\">                &#125;</div><div class=\"line\">                // We return here, this forces decode to be called again where we will decode the content</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_VARIABLE_LENGTH_CONTENT: &#123;  //read_variable_length_content</div><div class=\"line\">            // Keep reading data as a chunk until the end of connection is reached.</div><div class=\"line\">            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);</div><div class=\"line\">            if (toRead &gt; 0) &#123;</div><div class=\"line\">                ByteBuf content = buffer.readRetainedSlice(toRead);</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_FIXED_LENGTH_CONTENT: &#123;  //read_fixed_length_content</div><div class=\"line\">            int readLimit = buffer.readableBytes();</div><div class=\"line\">            // Check if the buffer is readable first as we use the readable byte count</div><div class=\"line\">            // to create the HttpChunk. This is needed as otherwise we may end up with</div><div class=\"line\">            // create a HttpChunk instance that contains an empty buffer and so is</div><div class=\"line\">            // handled like it is the last HttpChunk.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/433</div><div class=\"line\">            if (readLimit == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int toRead = Math.min(readLimit, maxChunkSize);</div><div class=\"line\">            if (toRead &gt; chunkSize) &#123;</div><div class=\"line\">                toRead = (int) chunkSize;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面</div><div class=\"line\">            chunkSize -= toRead; //content = PooledSlicedByteBuf</div><div class=\"line\">            if (chunkSize == 0) &#123;  //要是定长的话，就直接content就是DefaultLastHttpContent，</div><div class=\"line\">                // Read all content.</div><div class=\"line\">                out.add(new DefaultLastHttpContent(content, validateHeaders));</div><div class=\"line\">                resetNow(); //解析完了就该返回了</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        /**</div><div class=\"line\">         * everything else after this point takes care of reading chunked content. basically, read chunk size,</div><div class=\"line\">         * read chunk, read and ignore the CRLF and repeat until 0</div><div class=\"line\">         */</div><div class=\"line\">        case READ_CHUNK_SIZE: try &#123;//read_chunk_size</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer);</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int chunkSize = getChunkSize(line.toString());</div><div class=\"line\">            this.chunkSize = chunkSize;</div><div class=\"line\">            if (chunkSize == 0) &#123;</div><div class=\"line\">                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNKED_CONTENT: &#123; //read_chunked_content</div><div class=\"line\">            assert chunkSize &lt;= Integer.MAX_VALUE;</div><div class=\"line\">            int toRead = Math.min((int) chunkSize, maxChunkSize);</div><div class=\"line\">            toRead = Math.min(toRead, buffer.readableBytes());</div><div class=\"line\">            if (toRead == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));</div><div class=\"line\">            chunkSize -= toRead;</div><div class=\"line\">            out.add(chunk);</div><div class=\"line\">            if (chunkSize != 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_DELIMITER: &#123;//read_chunked_delimiter</div><div class=\"line\">            final int wIdx = buffer.writerIndex();</div><div class=\"line\">            int rIdx = buffer.readerIndex();</div><div class=\"line\">            while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">                byte next = buffer.getByte(rIdx++);</div><div class=\"line\">                if (next == HttpConstants.LF) &#123;</div><div class=\"line\">                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            buffer.readerIndex(rIdx);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_FOOTER: try &#123;//read_chunked_foooter</div><div class=\"line\">            LastHttpContent trailer = readTrailingHeaders(buffer);</div><div class=\"line\">            if (trailer == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.add(trailer);</div><div class=\"line\">            resetNow();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case BAD_MESSAGE: &#123;  //bad_message</div><div class=\"line\">            // Keep discarding until disconnection.</div><div class=\"line\">            buffer.skipBytes(buffer.readableBytes());</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case UPGRADED: &#123;//upgraded</div><div class=\"line\">            int readableBytes = buffer.readableBytes();</div><div class=\"line\">            if (readableBytes &gt; 0) &#123;</div><div class=\"line\">                // Keep on consuming as otherwise we may trigger an DecoderException,</div><div class=\"line\">                // other handler will replace this codec with the upgraded protocol codec to</div><div class=\"line\">                // take the traffic over at some point then.</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2173</div><div class=\"line\">                out.add(buffer.readBytes(readableBytes));</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意这里的case并没有break, decode主要做了如下逻辑:<br>1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean skipControlCharacters(ByteBuf buffer) &#123;</div><div class=\"line\">        boolean skiped = false;</div><div class=\"line\">        final int wIdx = buffer.writerIndex();</div><div class=\"line\">        int rIdx = buffer.readerIndex();</div><div class=\"line\">        while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">            int c = buffer.getUnsignedByte(rIdx++);</div><div class=\"line\">            if (!Character.isISOControl(c) &amp;&amp; !Character.isWhitespace(c)) &#123;//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等</div><div class=\"line\">                rIdx--;</div><div class=\"line\">                skiped = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        buffer.readerIndex(rIdx);</div><div class=\"line\">        return skiped;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。<br>2) 读取INITIAL部分<br>从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:<code>GET /_cat/indices HTTP/1.1</code>, 创建对象:DefaultHttpRequest, 其中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpVersion: HTTP/1.1</div><div class=\"line\">method: GET</div><div class=\"line\">uri: /_cat/indices</div></pre></td></tr></table></figure></p>\n<p>这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。<br>3) 读取Headers部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">private State readHeaders(ByteBuf buffer) &#123;</div><div class=\"line\">        final HttpMessage message = this.message;  //DefaultHttpRequest</div><div class=\"line\">        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders</div><div class=\"line\">        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while&#123;&#125;为循环</div><div class=\"line\">        if (line == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (line.length() &gt; 0) &#123;</div><div class=\"line\">            do &#123; //这是个while循环，以换行符来进行分割</div><div class=\"line\">                char firstChar = line.charAt(0);</div><div class=\"line\">                if (name != null &amp;&amp; (firstChar == &apos; &apos; || firstChar == &apos;\\t&apos;)) &#123;</div><div class=\"line\">                    String trimmedLine = line.toString().trim();</div><div class=\"line\">                    String valueStr = String.valueOf(value);</div><div class=\"line\">                    value = valueStr + &apos; &apos; + trimmedLine;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (name != null) &#123;</div><div class=\"line\">                        headers.add(name, value);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    splitHeader(line);</div><div class=\"line\">                &#125;</div><div class=\"line\">                line = headerParser.parse(buffer);   //</div><div class=\"line\">                if (line == null) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; while (line.length() &gt; 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Add the last header.</div><div class=\"line\">        if (name != null) &#123;   //解析出最后一个header</div><div class=\"line\">            headers.add(name, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        // reset name and value fields</div><div class=\"line\">        name = null;</div><div class=\"line\">        value = null;</div><div class=\"line\"></div><div class=\"line\">        State nextState;</div><div class=\"line\"></div><div class=\"line\">        if (isContentAlwaysEmpty(message)) &#123;  //header是否为空</div><div class=\"line\">            HttpUtil.setTransferEncodingChunked(message, false);</div><div class=\"line\">            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始</div><div class=\"line\">        &#125; else if (HttpUtil.isTransferEncodingChunked(message)) &#123; // 是否包含 transfer-encoding: chunked</div><div class=\"line\">            nextState = State.READ_CHUNK_SIZE;</div><div class=\"line\">        &#125; else if (contentLength() &gt;= 0) &#123;   //Content-Length: 80</div><div class=\"line\">            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值</div><div class=\"line\">        &#125; else &#123; //没有Content-Length和chunked相关的，就是读取变量类型长度</div><div class=\"line\">            nextState = State.READ_VARIABLE_LENGTH_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return nextState;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;Accept&quot; -&gt; &quot;*/*&quot;</div><div class=\"line\">&quot;User-Agent&quot; -&gt; &quot;curl/7/43/0&quot;</div><div class=\"line\">&quot;Host&quot; -&gt; &quot;127.0.0.1:9200&quot;</div><div class=\"line\">&quot;Content-Length&quot; -&gt; &quot;66735&quot;</div><div class=\"line\">&quot;Content-Encoding&quot; -&gt; &quot;gzip&quot;</div><div class=\"line\">&quot;Content-Type&quot; -&gt; &quot;application/x-www-form-urlencoded&quot;</div><div class=\"line\">&quot;Expect&quot; -&gt; &quot;100-continue&quot;</div><div class=\"line\">&quot;null&quot; -&gt; &quot;null&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们需要了解一个参数:Expect: 100-continue</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/MitKey/article/details/52042537\" target=\"_blank\" rel=\"external\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。</p><p>客户端策略:<br>如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}<br>如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。<br>并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。<br>有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。</p><p>服务端策略:<br>正确情况下，收到请求后，返回 100 或错误码。<br>如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。</p>\n</blockquote>\n<p>这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度&gt;=1025时, 客户端发送的header里面才会有这个参数。</p>\n<ul>\n<li>如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。<br>这里会设置状态为READ_FIXED_LENGTH_CONTENT<br>4)  读取内容<br>因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<math.min(readablelength, maxchunksize),=\"\" 每读取maxchunksize长度的值就向后传递,=\"\" 同时修改chunksize的值。读取第二个chunked的动作在messagetomessagedecoder中发出(该content的readablebytes=\"\">0)。<br>这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。<h1 id=\"HttpObjectAggregator和-MessageAggregator\"><a href=\"#HttpObjectAggregator和-MessageAggregator\" class=\"headerlink\" title=\"HttpObjectAggregator和 MessageAggregator\"></a>HttpObjectAggregator和 MessageAggregator</h1>HttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。<br>MessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">    if (isStartMessage(msg)) &#123;//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行</div><div class=\"line\">        handlingOversizedMessage = false;</div><div class=\"line\">        if (currentMessage != null) &#123;</div><div class=\"line\">            currentMessage.release();</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">            throw new MessageAggregationException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        S m = (S) msg; //DefaultHttpRequest</div><div class=\"line\">        // Send the continue response if necessary (e.g. &apos;Expect: 100-continue&apos; header)</div><div class=\"line\">        // Check before content length. Failing an expectation may result in a different response being sent.</div><div class=\"line\">        Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse</div><div class=\"line\">        if (continueResponse != null) &#123; //向客户端返回100-continue, 告诉客户端可以发送content了</div><div class=\"line\">            // Cache the write listener for reuse.</div><div class=\"line\">            ChannelFutureListener listener = continueResponseWriteListener;</div><div class=\"line\">            if (listener == null) &#123;</div><div class=\"line\">                continueResponseWriteListener = listener = new ChannelFutureListener() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                        if (!future.isSuccess()) &#123;</div><div class=\"line\">                            ctx.fireExceptionCaught(future.cause());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Make sure to call this before writing, otherwise reference counts may be invalid.</div><div class=\"line\">            boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);</div><div class=\"line\">            handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);</div><div class=\"line\"></div><div class=\"line\">            final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);</div><div class=\"line\"></div><div class=\"line\">            if (closeAfterWrite) &#123;</div><div class=\"line\">                future.addListener(ChannelFutureListener.CLOSE);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (handlingOversizedMessage) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; //检查length是否有效，</div><div class=\"line\">            // if content length is set, preemptively close if it&apos;s too large</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, m);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123;</div><div class=\"line\">            O aggregated;</div><div class=\"line\">            if (m instanceof ByteBufHolder &amp;&amp; ((ByteBufHolder) m).content().isReadable()) &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\">            finishAggregation(aggregated);</div><div class=\"line\">            out.add(aggregated);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //同时生成好Compent</div><div class=\"line\">        // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.</div><div class=\"line\">        CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可</div><div class=\"line\">        if (m instanceof ByteBufHolder) &#123;</div><div class=\"line\">            appendPartialContent(content, ((ByteBufHolder) m).content());</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest</div><div class=\"line\">    &#125; else if (isContentMessage(msg)) &#123; //解析内容部分</div><div class=\"line\">        if (currentMessage == null) &#123;</div><div class=\"line\">            // it is possible that a TooLongFrameException was already thrown but we can still discard data</div><div class=\"line\">            // until the begging of the next request/response.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Merge the received chunk into the content of the current message.</div><div class=\"line\">        CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();</div><div class=\"line\"></div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        final C m = (C) msg; //可能是DefaultLastHttpContent</div><div class=\"line\">        // Handle oversized message.</div><div class=\"line\">        if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123;</div><div class=\"line\">            // By convention, full message type extends first message type.</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            S s = (S) currentMessage;</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, s);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // Append the content of the chunk.</div><div class=\"line\">        appendPartialContent(content, m.content()); //把产生的数据添加到末尾</div><div class=\"line\">        //</div><div class=\"line\">        // Give the subtypes a chance to merge additional information such as trailing headers.</div><div class=\"line\">        aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest</div><div class=\"line\"></div><div class=\"line\">        final boolean last;</div><div class=\"line\">        if (m instanceof DecoderResultProvider) &#123;</div><div class=\"line\">            DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();</div><div class=\"line\">            if (!decoderResult.isSuccess()) &#123;</div><div class=\"line\">                if (currentMessage instanceof DecoderResultProvider) &#123;</div><div class=\"line\">                    ((DecoderResultProvider) currentMessage).setDecoderResult(</div><div class=\"line\">                            DecoderResult.failure(decoderResult.cause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">                last = true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                last = isLastContentMessage(m);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            last = isLastContentMessage(m);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (last) &#123;  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，</div><div class=\"line\">            finishAggregation(currentMessage);</div><div class=\"line\"></div><div class=\"line\">            // All done</div><div class=\"line\">            out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new MessageAggregationException();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</math.min(readablelength,></li>\n</ul>\n<p>decode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。<br>1) 若请求是HttpRequest<br>说明该部分是request最开始的那一部分。</p>\n<ul>\n<li>首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。</li>\n<li>生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。<br>需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性<code>List&lt;Component&gt; components</code>构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。</li>\n</ul>\n<p>2) 若请求是HttpContent部分</p>\n<ul>\n<li>将content添加进CompositeByteBuf中<br>通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) &#123;</div><div class=\"line\">        .....</div><div class=\"line\">        if (cIndex == components.size()) &#123;</div><div class=\"line\">            wasAdded = components.add(c);</div><div class=\"line\">            if (cIndex == 0) &#123;</div><div class=\"line\">                c.endOffset = readableBytes;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Component prev = components.get(cIndex - 1);</div><div class=\"line\">                c.offset = prev.endOffset;</div><div class=\"line\">                c.endOffset = c.offset + readableBytes;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .....</div><div class=\"line\">        if (increaseWriterIndex) &#123;</div><div class=\"line\">            writerIndex(writerIndex() + buffer.readableBytes());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个Component结构如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf buf;  //该Component实际存储</div><div class=\"line\">final int length;</div><div class=\"line\">int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。</div><div class=\"line\">int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。</div></pre></td></tr></table></figure></p>\n<p>在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。</p>\n<ul>\n<li>等待所有的content发送过来</li>\n</ul>\n<ol>\n<li>轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。</li>\n<li>直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。</li>\n</ol>\n<p>至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultLastHttpContent.png\"></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>如何将Composite转换为一个连续的堆内buf呢?<br>通过Unpooled.copiedBuffer(request.content())方法即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先给出一个http server pipiLine里面的处理器的组成结构的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void initChannel(Channel ch) throws Exception &#123;</div><div class=\"line\">    final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);</div><div class=\"line\">    decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个</div><div class=\"line\">    ch.pipeline().addLast(&quot;decoder&quot;, decoder);</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder&quot;, new HttpResponseEncoder());</div><div class=\"line\">    final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));</div><div class=\"line\">    ch.pipeline().addLast(&quot;aggregator&quot;, aggregator);  //包的聚合</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder_compress&quot;, new HttpContentCompressor(transport.compressionLevel));</div><div class=\"line\">    ch.pipeline().addLast(&quot;pipelining&quot;, new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));</div><div class=\"line\">    ch.pipeline().addLast(&quot;handler&quot;, requestHandler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。<br>http处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。<br>这里有一个问题:<br><code>为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?</code><br>服务器端数据真正接收到客户端网络的数据是在NioSocketChannel里面的NioByteUnsafe(NioSocketChannelUnsafe父类)里面的read()里面。</p>\n<h1 id=\"HttpObjectDecoder和HttpRequestDecoder\"><a href=\"#HttpObjectDecoder和HttpRequestDecoder\" class=\"headerlink\" title=\"HttpObjectDecoder和HttpRequestDecoder\"></a>HttpObjectDecoder和HttpRequestDecoder</h1><p>首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:</p>\n<ul>\n<li>HttpRequest: 主要存放inital, head等。</li>\n<li>HttpContent: 传输的数据部分<br>HttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成<code>HttpRequest</code>,实际就是将<code>ChannelBuffer</code>转变为多个<code>HttpChunk</code>对象。<br>HttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。<br>HttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。<br>decode函数实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        if (resetRequested) &#123;</div><div class=\"line\">            resetNow();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        switch (currentState) &#123; //没有break</div><div class=\"line\">        case SKIP_CONTROL_CHARS: &#123; //skip_control_chars</div><div class=\"line\">            if (!skipControlCharacters(buffer)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_INITIAL;   //read_initail</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_INITIAL: try &#123;  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String[] initialLine = splitInitialLine(line); //&#123;Method, URL, HTTPVersion</div><div class=\"line\">            if (initialLine.length &lt; 3) &#123; //无效的请求， 忽略。</div><div class=\"line\">                // Invalid initial line - ignore.</div><div class=\"line\">                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            message = createMessage(initialLine);  //DefaultHttpRequest</div><div class=\"line\">            currentState = State.READ_HEADER;  //read_header</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_HEADER: try &#123;    //read_header</div><div class=\"line\">            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式</div><div class=\"line\">            if (nextState == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = nextState;</div><div class=\"line\">            switch (nextState) &#123;</div><div class=\"line\">            case SKIP_CONTROL_CHARS:   //skip_control_char</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content</div><div class=\"line\">                resetNow();</div><div class=\"line\">                return;</div><div class=\"line\">            case READ_CHUNK_SIZE: //read_chunk_size</div><div class=\"line\">                if (!chunkedSupported) &#123;</div><div class=\"line\">                    throw new IllegalArgumentException(&quot;Chunked messages not supported&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                return;</div><div class=\"line\">            default:  //或者读取变量类型长度或者定长</div><div class=\"line\">                long contentLength = contentLength();//没有长度相关变量就是-1</div><div class=\"line\">                if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) &#123;</div><div class=\"line\">                    out.add(message);</div><div class=\"line\">                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content</div><div class=\"line\">                    resetNow();</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content</div><div class=\"line\">                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content</div><div class=\"line\">                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分</div><div class=\"line\">                if (nextState == State.READ_FIXED_LENGTH_CONTENT) &#123;  //read_fixed_lengt_content</div><div class=\"line\">                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.</div><div class=\"line\">                    chunkSize = contentLength; // 注意这两个直接赋值一样</div><div class=\"line\">                &#125;</div><div class=\"line\">                // We return here, this forces decode to be called again where we will decode the content</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_VARIABLE_LENGTH_CONTENT: &#123;  //read_variable_length_content</div><div class=\"line\">            // Keep reading data as a chunk until the end of connection is reached.</div><div class=\"line\">            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);</div><div class=\"line\">            if (toRead &gt; 0) &#123;</div><div class=\"line\">                ByteBuf content = buffer.readRetainedSlice(toRead);</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_FIXED_LENGTH_CONTENT: &#123;  //read_fixed_length_content</div><div class=\"line\">            int readLimit = buffer.readableBytes();</div><div class=\"line\">            // Check if the buffer is readable first as we use the readable byte count</div><div class=\"line\">            // to create the HttpChunk. This is needed as otherwise we may end up with</div><div class=\"line\">            // create a HttpChunk instance that contains an empty buffer and so is</div><div class=\"line\">            // handled like it is the last HttpChunk.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/433</div><div class=\"line\">            if (readLimit == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int toRead = Math.min(readLimit, maxChunkSize);</div><div class=\"line\">            if (toRead &gt; chunkSize) &#123;</div><div class=\"line\">                toRead = (int) chunkSize;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面</div><div class=\"line\">            chunkSize -= toRead; //content = PooledSlicedByteBuf</div><div class=\"line\">            if (chunkSize == 0) &#123;  //要是定长的话，就直接content就是DefaultLastHttpContent，</div><div class=\"line\">                // Read all content.</div><div class=\"line\">                out.add(new DefaultLastHttpContent(content, validateHeaders));</div><div class=\"line\">                resetNow(); //解析完了就该返回了</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        /**</div><div class=\"line\">         * everything else after this point takes care of reading chunked content. basically, read chunk size,</div><div class=\"line\">         * read chunk, read and ignore the CRLF and repeat until 0</div><div class=\"line\">         */</div><div class=\"line\">        case READ_CHUNK_SIZE: try &#123;//read_chunk_size</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer);</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int chunkSize = getChunkSize(line.toString());</div><div class=\"line\">            this.chunkSize = chunkSize;</div><div class=\"line\">            if (chunkSize == 0) &#123;</div><div class=\"line\">                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNKED_CONTENT: &#123; //read_chunked_content</div><div class=\"line\">            assert chunkSize &lt;= Integer.MAX_VALUE;</div><div class=\"line\">            int toRead = Math.min((int) chunkSize, maxChunkSize);</div><div class=\"line\">            toRead = Math.min(toRead, buffer.readableBytes());</div><div class=\"line\">            if (toRead == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));</div><div class=\"line\">            chunkSize -= toRead;</div><div class=\"line\">            out.add(chunk);</div><div class=\"line\">            if (chunkSize != 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_DELIMITER: &#123;//read_chunked_delimiter</div><div class=\"line\">            final int wIdx = buffer.writerIndex();</div><div class=\"line\">            int rIdx = buffer.readerIndex();</div><div class=\"line\">            while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">                byte next = buffer.getByte(rIdx++);</div><div class=\"line\">                if (next == HttpConstants.LF) &#123;</div><div class=\"line\">                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            buffer.readerIndex(rIdx);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_FOOTER: try &#123;//read_chunked_foooter</div><div class=\"line\">            LastHttpContent trailer = readTrailingHeaders(buffer);</div><div class=\"line\">            if (trailer == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.add(trailer);</div><div class=\"line\">            resetNow();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case BAD_MESSAGE: &#123;  //bad_message</div><div class=\"line\">            // Keep discarding until disconnection.</div><div class=\"line\">            buffer.skipBytes(buffer.readableBytes());</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case UPGRADED: &#123;//upgraded</div><div class=\"line\">            int readableBytes = buffer.readableBytes();</div><div class=\"line\">            if (readableBytes &gt; 0) &#123;</div><div class=\"line\">                // Keep on consuming as otherwise we may trigger an DecoderException,</div><div class=\"line\">                // other handler will replace this codec with the upgraded protocol codec to</div><div class=\"line\">                // take the traffic over at some point then.</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2173</div><div class=\"line\">                out.add(buffer.readBytes(readableBytes));</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意这里的case并没有break, decode主要做了如下逻辑:<br>1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean skipControlCharacters(ByteBuf buffer) &#123;</div><div class=\"line\">        boolean skiped = false;</div><div class=\"line\">        final int wIdx = buffer.writerIndex();</div><div class=\"line\">        int rIdx = buffer.readerIndex();</div><div class=\"line\">        while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">            int c = buffer.getUnsignedByte(rIdx++);</div><div class=\"line\">            if (!Character.isISOControl(c) &amp;&amp; !Character.isWhitespace(c)) &#123;//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等</div><div class=\"line\">                rIdx--;</div><div class=\"line\">                skiped = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        buffer.readerIndex(rIdx);</div><div class=\"line\">        return skiped;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。<br>2) 读取INITIAL部分<br>从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:<code>GET /_cat/indices HTTP/1.1</code>, 创建对象:DefaultHttpRequest, 其中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpVersion: HTTP/1.1</div><div class=\"line\">method: GET</div><div class=\"line\">uri: /_cat/indices</div></pre></td></tr></table></figure></p>\n<p>这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。<br>3) 读取Headers部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">private State readHeaders(ByteBuf buffer) &#123;</div><div class=\"line\">        final HttpMessage message = this.message;  //DefaultHttpRequest</div><div class=\"line\">        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders</div><div class=\"line\">        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while&#123;&#125;为循环</div><div class=\"line\">        if (line == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (line.length() &gt; 0) &#123;</div><div class=\"line\">            do &#123; //这是个while循环，以换行符来进行分割</div><div class=\"line\">                char firstChar = line.charAt(0);</div><div class=\"line\">                if (name != null &amp;&amp; (firstChar == &apos; &apos; || firstChar == &apos;\\t&apos;)) &#123;</div><div class=\"line\">                    String trimmedLine = line.toString().trim();</div><div class=\"line\">                    String valueStr = String.valueOf(value);</div><div class=\"line\">                    value = valueStr + &apos; &apos; + trimmedLine;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (name != null) &#123;</div><div class=\"line\">                        headers.add(name, value);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    splitHeader(line);</div><div class=\"line\">                &#125;</div><div class=\"line\">                line = headerParser.parse(buffer);   //</div><div class=\"line\">                if (line == null) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; while (line.length() &gt; 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Add the last header.</div><div class=\"line\">        if (name != null) &#123;   //解析出最后一个header</div><div class=\"line\">            headers.add(name, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        // reset name and value fields</div><div class=\"line\">        name = null;</div><div class=\"line\">        value = null;</div><div class=\"line\"></div><div class=\"line\">        State nextState;</div><div class=\"line\"></div><div class=\"line\">        if (isContentAlwaysEmpty(message)) &#123;  //header是否为空</div><div class=\"line\">            HttpUtil.setTransferEncodingChunked(message, false);</div><div class=\"line\">            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始</div><div class=\"line\">        &#125; else if (HttpUtil.isTransferEncodingChunked(message)) &#123; // 是否包含 transfer-encoding: chunked</div><div class=\"line\">            nextState = State.READ_CHUNK_SIZE;</div><div class=\"line\">        &#125; else if (contentLength() &gt;= 0) &#123;   //Content-Length: 80</div><div class=\"line\">            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值</div><div class=\"line\">        &#125; else &#123; //没有Content-Length和chunked相关的，就是读取变量类型长度</div><div class=\"line\">            nextState = State.READ_VARIABLE_LENGTH_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return nextState;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;Accept&quot; -&gt; &quot;*/*&quot;</div><div class=\"line\">&quot;User-Agent&quot; -&gt; &quot;curl/7/43/0&quot;</div><div class=\"line\">&quot;Host&quot; -&gt; &quot;127.0.0.1:9200&quot;</div><div class=\"line\">&quot;Content-Length&quot; -&gt; &quot;66735&quot;</div><div class=\"line\">&quot;Content-Encoding&quot; -&gt; &quot;gzip&quot;</div><div class=\"line\">&quot;Content-Type&quot; -&gt; &quot;application/x-www-form-urlencoded&quot;</div><div class=\"line\">&quot;Expect&quot; -&gt; &quot;100-continue&quot;</div><div class=\"line\">&quot;null&quot; -&gt; &quot;null&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们需要了解一个参数:Expect: 100-continue</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/MitKey/article/details/52042537\" target=\"_blank\" rel=\"external\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。</p><p>客户端策略:<br>如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}<br>如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。<br>并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。<br>有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。</p><p>服务端策略:<br>正确情况下，收到请求后，返回 100 或错误码。<br>如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。</p>\n</blockquote>\n<p>这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度&gt;=1025时, 客户端发送的header里面才会有这个参数。</p>\n<ul>\n<li>如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。<br>这里会设置状态为READ_FIXED_LENGTH_CONTENT<br>4)  读取内容<br>因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<math.min(readablelength, maxchunksize),=\"\" 每读取maxchunksize长度的值就向后传递,=\"\" 同时修改chunksize的值。读取第二个chunked的动作在messagetomessagedecoder中发出(该content的readablebytes=\"\">0)。<br>这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。<h1 id=\"HttpObjectAggregator和-MessageAggregator\"><a href=\"#HttpObjectAggregator和-MessageAggregator\" class=\"headerlink\" title=\"HttpObjectAggregator和 MessageAggregator\"></a>HttpObjectAggregator和 MessageAggregator</h1>HttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。<br>MessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">    if (isStartMessage(msg)) &#123;//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行</div><div class=\"line\">        handlingOversizedMessage = false;</div><div class=\"line\">        if (currentMessage != null) &#123;</div><div class=\"line\">            currentMessage.release();</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">            throw new MessageAggregationException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        S m = (S) msg; //DefaultHttpRequest</div><div class=\"line\">        // Send the continue response if necessary (e.g. &apos;Expect: 100-continue&apos; header)</div><div class=\"line\">        // Check before content length. Failing an expectation may result in a different response being sent.</div><div class=\"line\">        Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse</div><div class=\"line\">        if (continueResponse != null) &#123; //向客户端返回100-continue, 告诉客户端可以发送content了</div><div class=\"line\">            // Cache the write listener for reuse.</div><div class=\"line\">            ChannelFutureListener listener = continueResponseWriteListener;</div><div class=\"line\">            if (listener == null) &#123;</div><div class=\"line\">                continueResponseWriteListener = listener = new ChannelFutureListener() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                        if (!future.isSuccess()) &#123;</div><div class=\"line\">                            ctx.fireExceptionCaught(future.cause());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Make sure to call this before writing, otherwise reference counts may be invalid.</div><div class=\"line\">            boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);</div><div class=\"line\">            handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);</div><div class=\"line\"></div><div class=\"line\">            final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);</div><div class=\"line\"></div><div class=\"line\">            if (closeAfterWrite) &#123;</div><div class=\"line\">                future.addListener(ChannelFutureListener.CLOSE);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (handlingOversizedMessage) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; //检查length是否有效，</div><div class=\"line\">            // if content length is set, preemptively close if it&apos;s too large</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, m);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123;</div><div class=\"line\">            O aggregated;</div><div class=\"line\">            if (m instanceof ByteBufHolder &amp;&amp; ((ByteBufHolder) m).content().isReadable()) &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\">            finishAggregation(aggregated);</div><div class=\"line\">            out.add(aggregated);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //同时生成好Compent</div><div class=\"line\">        // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.</div><div class=\"line\">        CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可</div><div class=\"line\">        if (m instanceof ByteBufHolder) &#123;</div><div class=\"line\">            appendPartialContent(content, ((ByteBufHolder) m).content());</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest</div><div class=\"line\">    &#125; else if (isContentMessage(msg)) &#123; //解析内容部分</div><div class=\"line\">        if (currentMessage == null) &#123;</div><div class=\"line\">            // it is possible that a TooLongFrameException was already thrown but we can still discard data</div><div class=\"line\">            // until the begging of the next request/response.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Merge the received chunk into the content of the current message.</div><div class=\"line\">        CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();</div><div class=\"line\"></div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        final C m = (C) msg; //可能是DefaultLastHttpContent</div><div class=\"line\">        // Handle oversized message.</div><div class=\"line\">        if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123;</div><div class=\"line\">            // By convention, full message type extends first message type.</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            S s = (S) currentMessage;</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, s);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // Append the content of the chunk.</div><div class=\"line\">        appendPartialContent(content, m.content()); //把产生的数据添加到末尾</div><div class=\"line\">        //</div><div class=\"line\">        // Give the subtypes a chance to merge additional information such as trailing headers.</div><div class=\"line\">        aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest</div><div class=\"line\"></div><div class=\"line\">        final boolean last;</div><div class=\"line\">        if (m instanceof DecoderResultProvider) &#123;</div><div class=\"line\">            DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();</div><div class=\"line\">            if (!decoderResult.isSuccess()) &#123;</div><div class=\"line\">                if (currentMessage instanceof DecoderResultProvider) &#123;</div><div class=\"line\">                    ((DecoderResultProvider) currentMessage).setDecoderResult(</div><div class=\"line\">                            DecoderResult.failure(decoderResult.cause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">                last = true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                last = isLastContentMessage(m);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            last = isLastContentMessage(m);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (last) &#123;  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，</div><div class=\"line\">            finishAggregation(currentMessage);</div><div class=\"line\"></div><div class=\"line\">            // All done</div><div class=\"line\">            out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new MessageAggregationException();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</math.min(readablelength,></li>\n</ul>\n<p>decode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。<br>1) 若请求是HttpRequest<br>说明该部分是request最开始的那一部分。</p>\n<ul>\n<li>首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。</li>\n<li>生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。<br>需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性<code>List&lt;Component&gt; components</code>构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。</li>\n</ul>\n<p>2) 若请求是HttpContent部分</p>\n<ul>\n<li>将content添加进CompositeByteBuf中<br>通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) &#123;</div><div class=\"line\">        .....</div><div class=\"line\">        if (cIndex == components.size()) &#123;</div><div class=\"line\">            wasAdded = components.add(c);</div><div class=\"line\">            if (cIndex == 0) &#123;</div><div class=\"line\">                c.endOffset = readableBytes;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Component prev = components.get(cIndex - 1);</div><div class=\"line\">                c.offset = prev.endOffset;</div><div class=\"line\">                c.endOffset = c.offset + readableBytes;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .....</div><div class=\"line\">        if (increaseWriterIndex) &#123;</div><div class=\"line\">            writerIndex(writerIndex() + buffer.readableBytes());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个Component结构如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf buf;  //该Component实际存储</div><div class=\"line\">final int length;</div><div class=\"line\">int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。</div><div class=\"line\">int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。</div></pre></td></tr></table></figure></p>\n<p>在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。</p>\n<ul>\n<li>等待所有的content发送过来</li>\n</ul>\n<ol>\n<li>轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。</li>\n<li>直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。</li>\n</ol>\n<p>至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/DefaultLastHttpContent.png\"></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>如何将Composite转换为一个连续的堆内buf呢?<br>通过Unpooled.copiedBuffer(request.content())方法即可。</p>\n"},{"title":"Netty PoolChunk原理探究","date":"2018-07-20T10:48:20.000Z","toc":true,"_content":"Netty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk1.png\" height=\"400\" width=\"450\"/>\n该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。\n+ 如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。\n+ 若申请32K的内存, 那么在该二叉树第8层申请。\n+ 若申请8K的内存, 那么将直接在第11层申请。\n*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>\n接下来介绍PoolChunk的成员属性:\n```\n    //该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配\n    final PoolArena<T> arena;。\n    //对外内存: DirectByteBuffer, 堆内内存 byte[]。\n    final T memory;\n    // 是内存池还是非内存池方式\n    final boolean unpooled;\n    private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明\n    private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。\n    //与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了\n    private final PoolSubpage<T>[] subpages;\n    /** Used to determine if the requested capacity is equal to or greater than pageSize. */\n    //用来判断申请的内存是否超过pageSize大小\n    private final int subpageOverflowMask;\n    //每个PoolSubpage的大小，默认为8192个字节（8K)\n    private final int pageSize;\n    //pageSize 2的 pageShifts幂\n    private final int pageShifts;\n    // 平衡二叉树的深度，\n    private final int maxOrder;\n    //PoolChunk的总内存大小,chunkSize =   (1<<maxOrder) * pageSize。\n    private final int chunkSize;\n    // PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。\n    private final int maxSubpageAllocs;\n    /** Used to mark memory as unusable */\n    //标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配\n    private final byte unusable;\n\n    //当前PoolChunk剩余可分配内存, 初始为16M。\n    private int freeBytes;\n\n    //一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)\n    PoolChunkList<T> parent;\n```\n当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk2.png\" height=\"200\" width=\"250\"/>\nNetty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。\n当第11层下标为2048的节点被分配出去:\n1. 则该节点的层号被修改为12, 表示该节点不可再分配。\n2. 同时id为1024的父节点层号改为11, id为512的节点层号改为10, ..., id为1的节点层号改为2.\n\n当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。\n构造函数中该成员斌量初始过程如下:\n```\n        memoryMap = new byte[maxSubpageAllocs << 1];\n        depthMap = new byte[memoryMap.length];\n        int memoryMapIndex = 1;\n        for (int d = 0; d <= maxOrder; ++ d) { // move down the tree one level at a time\n            int depth = 1 << d;\n            for (int p = 0; p < depth; ++ p) {\n                // in each level traverse left to right and set value to the depth of subtree\n                memoryMap[memoryMapIndex] = (byte) d;\n                depthMap[memoryMapIndex] = (byte) d;\n                memoryMapIndex ++;\n            }\n        }\n```\n实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。\n\n# PoolChunk分配内存\n在PoolArea.allocateNormal()中调用newChunk产生PoolChunk\n```\n        protected PoolChunk<ByteBuffer> newChunk(int pageSize, int maxOrder,\n                int pageShifts, int chunkSize) {\n            //\n            if (directMemoryCacheAlignment == 0) {\n                return new PoolChunk<ByteBuffer>(this,\n                         //allocateDirect(chunkSize)会直接创建直接内存， 用直接内存地址构建的DirectByteBuffer\n                        allocateDirect(chunkSize), pageSize, maxOrder,\n                        pageShifts, chunkSize, 0);  //pageShifts= log8k = 13\n            }\n            final ByteBuffer memory = allocateDirect(chunkSize\n                    + directMemoryCacheAlignment);\n            return new PoolChunk<ByteBuffer>(this, memory, pageSize,\n                    maxOrder, pageShifts, chunkSize,\n                    offsetCacheLine(memory));\n```\n我们需要关注下如何通过allocateDirect()产生堆外内存的:\n```\n         private static ByteBuffer allocateDirect(int capacity) {\n            //如果不是调用cleaner来回收对象，那么将使用DirectByteBuff来回收对象\n            return PlatformDependent.useDirectBufferNoCleaner() ?\n                    PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);\n        }\n        static ByteBuffer allocateDirectNoCleaner(int capacity) {\n        return newDirectBuffer(UNSAFE.allocateMemory(capacity), capacity);\n```\n最终是通过直接内存地址的address来产生DirectByteBuffer的, 此时该对象没有cleaner成员变量, 将不能通过cleaner来回收直接内存。\n接下来看看如何是从PoolChunk中分配内存的:\n```\n    long allocate(int normCapacity) {\n        if ((normCapacity & subpageOverflowMask) != 0) {\n            return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id\n        } else {  //分配小于8k\n            return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位\n        }\n    }\n```\n+ 返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。\n+ 若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。\n\n## 分配大于page的内存\n我们首先看allocateRun是如何操作的\n```\n     private long allocateRun(int normCapacity) {//64k\n         //算出当前大小的内存需要在那一层完成分配\n        int d = maxOrder - (log2(normCapacity) - pageShifts);\n        int id = allocateNode(d);\n        if (id < 0) {\n            return id;\n        }\n        freeBytes -= runLength(id);\n        return id;\n    }\n```\n1. 首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。\n2. 开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:\n```\n    private int allocateNode(int d) {\n        int id = 1;\n        int initial = - (1 << d); // has last d bits = 0 and rest all = 1\n        byte val = value(id);\n        //若第一层的深度不够，那么该chunkend不够分配\n        if (val > d) { // unusable\n            return -1;\n        }\n        // id & initial == 1 << d for all ids at depth d, for < d it is 0\n        while (val < d || (id & initial) == 0) {\n            id <<= 1;\n            val = value(id);\n            if (val > d) {\n                id ^= 1;\n                val = value(id);\n            }\n        }\n        byte value = value(id);\n        assert value == d && (id & initial) == 1 << d :\n        String.format(\"val = %d, id & initial = %d, d = %d\", value, id & initial, d);\n        setValue(id, unusable); // mark as unusable\n        updateParentsAlloc(id);\n        return id; //返回的是查找到的那个节点的下标\n    }\n```\n主要做了如下工作:\n1. 从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(`若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点`, 并且在该节点的下标一定>=2^d)\n2. 若当前节点层数<d, 或者当前节点的下标 < 2^d, 那么继续下一层左孩子节点查找, 直到找到某一个节点的层数==目前层数d, 则完成查找。若发现该节点剩余大小不够分配, 则在兄弟节点继续查找。\n如下图, 当查找层号为11的节点, 找到符合下标id>=x 2^11的节点 && 层号 == 11的节点 , 只能在下标为2049的那个节点。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"/>\n其中 (id & initial) == 0) 等价于id <2^d, 作用: 若当前节点的下标< 2^s, 则会继续在当前节点的孩子节点查找。\n3. 将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。\n4. 更新该节点的所有祖父父节点层号:\n```\n   private void updateParentsAlloc(int id) {\n        while (id > 1) {  //开始更新父类节点的值\n            int parentId = id >>> 1;\n            byte val1 = value(id);\n            byte val2 = value(id ^ 1);  //获取相邻节点的值\n            byte val = val1 < val2 ? val1 : val2;\n            setValue(parentId, val);\n            id = parentId;\n        }\n    }\n```\n父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。\n\n## 分配小于page的内存\n我们来看是如何分配小于8k的内存。\n```\n    private long allocateSubpage(int normCapacity) {\n        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n        // This is need as we may add it back and so alter the linked-list structure.\n        PoolSubpage<T> head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点\n        synchronized (head) {\n            int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起\n            int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点\n            if (id < 0) {\n                return id;\n            }\n\n            final PoolSubpage<T>[] subpages = this.subpages;\n            final int pageSize = this.pageSize;\n\n            freeBytes -= pageSize;//（就是一个16M的空间）\n\n            int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）\n            PoolSubpage<T> subpage = subpages[subpageIdx];\n            if (subpage == null) {  //说明这个PoolSubpagte还没有分配出去\n                subpage = new PoolSubpage<T>(head, this, id, runOffset(id), pageSize, normCapacity);\n                subpages[subpageIdx] = subpage;\n            } else {\n                subpage.init(head, normCapacity);\n            }\n            return subpage.allocate();\n        }\n    }\n```\n主要做了如下事情:\n+ 我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。\n+ 查看该节点是第几个叶子节点: subpageIdx。\n+ 获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。\n\n## 释放内存\n上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。\n```\n    void free(long handle) {\n        int memoryMapIdx = memoryMapIdx(handle);\n        int bitmapIdx = bitmapIdx(handle);\n\n        if (bitmapIdx != 0) { // free a subpage\n            PoolSubpage<T> subpage = subpages[subpageIdx(memoryMapIdx)];\n            assert subpage != null && subpage.doNotDestroy;\n\n            // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n            // This is need as we may add it back and so alter the linked-list structure.\n            PoolSubpage<T> head = arena.findSubpagePoolHead(subpage.elemSize);\n            synchronized (head) {\n                if (subpage.free(head, bitmapIdx & 0x3FFFFFFF)) {\n                    return;\n                }\n            }\n        }\n        freeBytes += runLength(memoryMapIdx);\n        setValue(memoryMapIdx, depth(memoryMapIdx));\n        updateParentsFree(memoryMapIdx);\n    }\n```\n做了如下事情:\n+ 首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。\n```\n    private static int memoryMapIdx(long handle) { //低32位\n        return (int) handle;\n    }\n    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n    private static int bitmapIdx(long handle) { //高32位\n        return (int) (handle >>> Integer.SIZE);\n    }\n```\nhandlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。\n+ 判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数\n+ 若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。\n\n# 总结\n\nNetty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。","source":"_posts/Netty-PoolChunk原理探究.md","raw":"---\ntitle: Netty PoolChunk原理探究\ndate: 2018-07-20 18:48:20\ntags:\ntoc: true\n---\nNetty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk1.png\" height=\"400\" width=\"450\"/>\n该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。\n+ 如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。\n+ 若申请32K的内存, 那么在该二叉树第8层申请。\n+ 若申请8K的内存, 那么将直接在第11层申请。\n*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>\n接下来介绍PoolChunk的成员属性:\n```\n    //该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配\n    final PoolArena<T> arena;。\n    //对外内存: DirectByteBuffer, 堆内内存 byte[]。\n    final T memory;\n    // 是内存池还是非内存池方式\n    final boolean unpooled;\n    private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明\n    private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。\n    //与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了\n    private final PoolSubpage<T>[] subpages;\n    /** Used to determine if the requested capacity is equal to or greater than pageSize. */\n    //用来判断申请的内存是否超过pageSize大小\n    private final int subpageOverflowMask;\n    //每个PoolSubpage的大小，默认为8192个字节（8K)\n    private final int pageSize;\n    //pageSize 2的 pageShifts幂\n    private final int pageShifts;\n    // 平衡二叉树的深度，\n    private final int maxOrder;\n    //PoolChunk的总内存大小,chunkSize =   (1<<maxOrder) * pageSize。\n    private final int chunkSize;\n    // PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。\n    private final int maxSubpageAllocs;\n    /** Used to mark memory as unusable */\n    //标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配\n    private final byte unusable;\n\n    //当前PoolChunk剩余可分配内存, 初始为16M。\n    private int freeBytes;\n\n    //一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)\n    PoolChunkList<T> parent;\n```\n当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk2.png\" height=\"200\" width=\"250\"/>\nNetty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。\n当第11层下标为2048的节点被分配出去:\n1. 则该节点的层号被修改为12, 表示该节点不可再分配。\n2. 同时id为1024的父节点层号改为11, id为512的节点层号改为10, ..., id为1的节点层号改为2.\n\n当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。\n构造函数中该成员斌量初始过程如下:\n```\n        memoryMap = new byte[maxSubpageAllocs << 1];\n        depthMap = new byte[memoryMap.length];\n        int memoryMapIndex = 1;\n        for (int d = 0; d <= maxOrder; ++ d) { // move down the tree one level at a time\n            int depth = 1 << d;\n            for (int p = 0; p < depth; ++ p) {\n                // in each level traverse left to right and set value to the depth of subtree\n                memoryMap[memoryMapIndex] = (byte) d;\n                depthMap[memoryMapIndex] = (byte) d;\n                memoryMapIndex ++;\n            }\n        }\n```\n实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。\n\n# PoolChunk分配内存\n在PoolArea.allocateNormal()中调用newChunk产生PoolChunk\n```\n        protected PoolChunk<ByteBuffer> newChunk(int pageSize, int maxOrder,\n                int pageShifts, int chunkSize) {\n            //\n            if (directMemoryCacheAlignment == 0) {\n                return new PoolChunk<ByteBuffer>(this,\n                         //allocateDirect(chunkSize)会直接创建直接内存， 用直接内存地址构建的DirectByteBuffer\n                        allocateDirect(chunkSize), pageSize, maxOrder,\n                        pageShifts, chunkSize, 0);  //pageShifts= log8k = 13\n            }\n            final ByteBuffer memory = allocateDirect(chunkSize\n                    + directMemoryCacheAlignment);\n            return new PoolChunk<ByteBuffer>(this, memory, pageSize,\n                    maxOrder, pageShifts, chunkSize,\n                    offsetCacheLine(memory));\n```\n我们需要关注下如何通过allocateDirect()产生堆外内存的:\n```\n         private static ByteBuffer allocateDirect(int capacity) {\n            //如果不是调用cleaner来回收对象，那么将使用DirectByteBuff来回收对象\n            return PlatformDependent.useDirectBufferNoCleaner() ?\n                    PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);\n        }\n        static ByteBuffer allocateDirectNoCleaner(int capacity) {\n        return newDirectBuffer(UNSAFE.allocateMemory(capacity), capacity);\n```\n最终是通过直接内存地址的address来产生DirectByteBuffer的, 此时该对象没有cleaner成员变量, 将不能通过cleaner来回收直接内存。\n接下来看看如何是从PoolChunk中分配内存的:\n```\n    long allocate(int normCapacity) {\n        if ((normCapacity & subpageOverflowMask) != 0) {\n            return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id\n        } else {  //分配小于8k\n            return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位\n        }\n    }\n```\n+ 返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。\n+ 若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。\n\n## 分配大于page的内存\n我们首先看allocateRun是如何操作的\n```\n     private long allocateRun(int normCapacity) {//64k\n         //算出当前大小的内存需要在那一层完成分配\n        int d = maxOrder - (log2(normCapacity) - pageShifts);\n        int id = allocateNode(d);\n        if (id < 0) {\n            return id;\n        }\n        freeBytes -= runLength(id);\n        return id;\n    }\n```\n1. 首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。\n2. 开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:\n```\n    private int allocateNode(int d) {\n        int id = 1;\n        int initial = - (1 << d); // has last d bits = 0 and rest all = 1\n        byte val = value(id);\n        //若第一层的深度不够，那么该chunkend不够分配\n        if (val > d) { // unusable\n            return -1;\n        }\n        // id & initial == 1 << d for all ids at depth d, for < d it is 0\n        while (val < d || (id & initial) == 0) {\n            id <<= 1;\n            val = value(id);\n            if (val > d) {\n                id ^= 1;\n                val = value(id);\n            }\n        }\n        byte value = value(id);\n        assert value == d && (id & initial) == 1 << d :\n        String.format(\"val = %d, id & initial = %d, d = %d\", value, id & initial, d);\n        setValue(id, unusable); // mark as unusable\n        updateParentsAlloc(id);\n        return id; //返回的是查找到的那个节点的下标\n    }\n```\n主要做了如下工作:\n1. 从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(`若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点`, 并且在该节点的下标一定>=2^d)\n2. 若当前节点层数<d, 或者当前节点的下标 < 2^d, 那么继续下一层左孩子节点查找, 直到找到某一个节点的层数==目前层数d, 则完成查找。若发现该节点剩余大小不够分配, 则在兄弟节点继续查找。\n如下图, 当查找层号为11的节点, 找到符合下标id>=x 2^11的节点 && 层号 == 11的节点 , 只能在下标为2049的那个节点。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"/>\n其中 (id & initial) == 0) 等价于id <2^d, 作用: 若当前节点的下标< 2^s, 则会继续在当前节点的孩子节点查找。\n3. 将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。\n4. 更新该节点的所有祖父父节点层号:\n```\n   private void updateParentsAlloc(int id) {\n        while (id > 1) {  //开始更新父类节点的值\n            int parentId = id >>> 1;\n            byte val1 = value(id);\n            byte val2 = value(id ^ 1);  //获取相邻节点的值\n            byte val = val1 < val2 ? val1 : val2;\n            setValue(parentId, val);\n            id = parentId;\n        }\n    }\n```\n父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。\n\n## 分配小于page的内存\n我们来看是如何分配小于8k的内存。\n```\n    private long allocateSubpage(int normCapacity) {\n        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n        // This is need as we may add it back and so alter the linked-list structure.\n        PoolSubpage<T> head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点\n        synchronized (head) {\n            int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起\n            int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点\n            if (id < 0) {\n                return id;\n            }\n\n            final PoolSubpage<T>[] subpages = this.subpages;\n            final int pageSize = this.pageSize;\n\n            freeBytes -= pageSize;//（就是一个16M的空间）\n\n            int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）\n            PoolSubpage<T> subpage = subpages[subpageIdx];\n            if (subpage == null) {  //说明这个PoolSubpagte还没有分配出去\n                subpage = new PoolSubpage<T>(head, this, id, runOffset(id), pageSize, normCapacity);\n                subpages[subpageIdx] = subpage;\n            } else {\n                subpage.init(head, normCapacity);\n            }\n            return subpage.allocate();\n        }\n    }\n```\n主要做了如下事情:\n+ 我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。\n+ 查看该节点是第几个叶子节点: subpageIdx。\n+ 获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。\n\n## 释放内存\n上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。\n```\n    void free(long handle) {\n        int memoryMapIdx = memoryMapIdx(handle);\n        int bitmapIdx = bitmapIdx(handle);\n\n        if (bitmapIdx != 0) { // free a subpage\n            PoolSubpage<T> subpage = subpages[subpageIdx(memoryMapIdx)];\n            assert subpage != null && subpage.doNotDestroy;\n\n            // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.\n            // This is need as we may add it back and so alter the linked-list structure.\n            PoolSubpage<T> head = arena.findSubpagePoolHead(subpage.elemSize);\n            synchronized (head) {\n                if (subpage.free(head, bitmapIdx & 0x3FFFFFFF)) {\n                    return;\n                }\n            }\n        }\n        freeBytes += runLength(memoryMapIdx);\n        setValue(memoryMapIdx, depth(memoryMapIdx));\n        updateParentsFree(memoryMapIdx);\n    }\n```\n做了如下事情:\n+ 首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。\n```\n    private static int memoryMapIdx(long handle) { //低32位\n        return (int) handle;\n    }\n    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n    private static int bitmapIdx(long handle) { //高32位\n        return (int) (handle >>> Integer.SIZE);\n    }\n```\nhandlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。\n+ 判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数\n+ 若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。\n\n# 总结\n\nNetty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。","slug":"Netty-PoolChunk原理探究","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8x2000nphu51jsb8afk","content":"<p>Netty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk1.png\" height=\"400\" width=\"450\"><br>该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。</p>\n<ul>\n<li>如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。</li>\n<li>若申请32K的内存, 那么在该二叉树第8层申请。</li>\n<li>若申请8K的内存, 那么将直接在第11层申请。<br>*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a><br>接下来介绍PoolChunk的成员属性:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">//该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配</div><div class=\"line\">final PoolArena&lt;T&gt; arena;。</div><div class=\"line\">//对外内存: DirectByteBuffer, 堆内内存 byte[]。</div><div class=\"line\">final T memory;</div><div class=\"line\">// 是内存池还是非内存池方式</div><div class=\"line\">final boolean unpooled;</div><div class=\"line\">private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明</div><div class=\"line\">private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。</div><div class=\"line\">//与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] subpages;</div><div class=\"line\">/** Used to determine if the requested capacity is equal to or greater than pageSize. */</div><div class=\"line\">//用来判断申请的内存是否超过pageSize大小</div><div class=\"line\">private final int subpageOverflowMask;</div><div class=\"line\">//每个PoolSubpage的大小，默认为8192个字节（8K)</div><div class=\"line\">private final int pageSize;</div><div class=\"line\">//pageSize 2的 pageShifts幂</div><div class=\"line\">private final int pageShifts;</div><div class=\"line\">// 平衡二叉树的深度，</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//PoolChunk的总内存大小,chunkSize =   (1&lt;&lt;maxOrder) * pageSize。</div><div class=\"line\">private final int chunkSize;</div><div class=\"line\">// PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。</div><div class=\"line\">private final int maxSubpageAllocs;</div><div class=\"line\">/** Used to mark memory as unusable */</div><div class=\"line\">//标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配</div><div class=\"line\">private final byte unusable;</div><div class=\"line\"></div><div class=\"line\">//当前PoolChunk剩余可分配内存, 初始为16M。</div><div class=\"line\">private int freeBytes;</div><div class=\"line\"></div><div class=\"line\">//一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)</div><div class=\"line\">PoolChunkList&lt;T&gt; parent;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk2.png\" height=\"200\" width=\"250\"><br>Netty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。<br>当第11层下标为2048的节点被分配出去:</p>\n<ol>\n<li>则该节点的层号被修改为12, 表示该节点不可再分配。</li>\n<li>同时id为1024的父节点层号改为11, id为512的节点层号改为10, …, id为1的节点层号改为2.</li>\n</ol>\n<p>当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。<br>构造函数中该成员斌量初始过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1];</div><div class=\"line\">depthMap = new byte[memoryMap.length];</div><div class=\"line\">int memoryMapIndex = 1;</div><div class=\"line\">for (int d = 0; d &lt;= maxOrder; ++ d) &#123; // move down the tree one level at a time</div><div class=\"line\">    int depth = 1 &lt;&lt; d;</div><div class=\"line\">    for (int p = 0; p &lt; depth; ++ p) &#123;</div><div class=\"line\">        // in each level traverse left to right and set value to the depth of subtree</div><div class=\"line\">        memoryMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        depthMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        memoryMapIndex ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。</p>\n<h1 id=\"PoolChunk分配内存\"><a href=\"#PoolChunk分配内存\" class=\"headerlink\" title=\"PoolChunk分配内存\"></a>PoolChunk分配内存</h1><p>在PoolArea.allocateNormal()中调用newChunk产生PoolChunk<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected PoolChunk&lt;ByteBuffer&gt; newChunk(int pageSize, int maxOrder,</div><div class=\"line\">        int pageShifts, int chunkSize) &#123;</div><div class=\"line\">    //</div><div class=\"line\">    if (directMemoryCacheAlignment == 0) &#123;</div><div class=\"line\">        return new PoolChunk&lt;ByteBuffer&gt;(this,</div><div class=\"line\">                 //allocateDirect(chunkSize)会直接创建直接内存， 用直接内存地址构建的DirectByteBuffer</div><div class=\"line\">                allocateDirect(chunkSize), pageSize, maxOrder,</div><div class=\"line\">                pageShifts, chunkSize, 0);  //pageShifts= log8k = 13</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ByteBuffer memory = allocateDirect(chunkSize</div><div class=\"line\">            + directMemoryCacheAlignment);</div><div class=\"line\">    return new PoolChunk&lt;ByteBuffer&gt;(this, memory, pageSize,</div><div class=\"line\">            maxOrder, pageShifts, chunkSize,</div><div class=\"line\">            offsetCacheLine(memory));</div></pre></td></tr></table></figure></p>\n<p>我们需要关注下如何通过allocateDirect()产生堆外内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ByteBuffer allocateDirect(int capacity) &#123;</div><div class=\"line\">    //如果不是调用cleaner来回收对象，那么将使用DirectByteBuff来回收对象</div><div class=\"line\">    return PlatformDependent.useDirectBufferNoCleaner() ?</div><div class=\"line\">            PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);</div><div class=\"line\">&#125;</div><div class=\"line\">static ByteBuffer allocateDirectNoCleaner(int capacity) &#123;</div><div class=\"line\">return newDirectBuffer(UNSAFE.allocateMemory(capacity), capacity);</div></pre></td></tr></table></figure></p>\n<p>最终是通过直接内存地址的address来产生DirectByteBuffer的, 此时该对象没有cleaner成员变量, 将不能通过cleaner来回收直接内存。<br>接下来看看如何是从PoolChunk中分配内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate(int normCapacity) &#123;</div><div class=\"line\">    if ((normCapacity &amp; subpageOverflowMask) != 0) &#123;</div><div class=\"line\">        return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id</div><div class=\"line\">    &#125; else &#123;  //分配小于8k</div><div class=\"line\">        return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。</li>\n<li>若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。</li>\n</ul>\n<h2 id=\"分配大于page的内存\"><a href=\"#分配大于page的内存\" class=\"headerlink\" title=\"分配大于page的内存\"></a>分配大于page的内存</h2><p>我们首先看allocateRun是如何操作的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private long allocateRun(int normCapacity) &#123;//64k</div><div class=\"line\">     //算出当前大小的内存需要在那一层完成分配</div><div class=\"line\">    int d = maxOrder - (log2(normCapacity) - pageShifts);</div><div class=\"line\">    int id = allocateNode(d);</div><div class=\"line\">    if (id &lt; 0) &#123;</div><div class=\"line\">        return id;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes -= runLength(id);</div><div class=\"line\">    return id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。</li>\n<li>开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int allocateNode(int d) &#123;</div><div class=\"line\">    int id = 1;</div><div class=\"line\">    int initial = - (1 &lt;&lt; d); // has last d bits = 0 and rest all = 1</div><div class=\"line\">    byte val = value(id);</div><div class=\"line\">    //若第一层的深度不够，那么该chunkend不够分配</div><div class=\"line\">    if (val &gt; d) &#123; // unusable</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</div><div class=\"line\">    while (val &lt; d || (id &amp; initial) == 0) &#123;</div><div class=\"line\">        id &lt;&lt;= 1;</div><div class=\"line\">        val = value(id);</div><div class=\"line\">        if (val &gt; d) &#123;</div><div class=\"line\">            id ^= 1;</div><div class=\"line\">            val = value(id);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    byte value = value(id);</div><div class=\"line\">    assert value == d &amp;&amp; (id &amp; initial) == 1 &lt;&lt; d :</div><div class=\"line\">    String.format(&quot;val = %d, id &amp; initial = %d, d = %d&quot;, value, id &amp; initial, d);</div><div class=\"line\">    setValue(id, unusable); // mark as unusable</div><div class=\"line\">    updateParentsAlloc(id);</div><div class=\"line\">    return id; //返回的是查找到的那个节点的下标</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要做了如下工作:</p>\n<ol>\n<li>从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(<code>若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点</code>, 并且在该节点的下标一定&gt;=2^d)</li>\n<li>若当前节点层数<d, 或者当前节点的下标=\"\" <=\"\" 2^d,=\"\" 那么继续下一层左孩子节点查找,=\"\" 直到找到某一个节点的层数=\"=目前层数d,\" 则完成查找。若发现该节点剩余大小不够分配,=\"\" 则在兄弟节点继续查找。=\"\" 如下图,=\"\" 当查找层号为11的节点,=\"\" 找到符合下标id=\"\">=x 2^11的节点 &amp;&amp; 层号 == 11的节点 , 只能在下标为2049的那个节点。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"><br>其中 (id &amp; initial) == 0) 等价于id &lt;2^d, 作用: 若当前节点的下标&lt; 2^s, 则会继续在当前节点的孩子节点查找。</d,></li>\n<li>将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。</li>\n<li>更新该节点的所有祖父父节点层号:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void updateParentsAlloc(int id) &#123;</div><div class=\"line\">     while (id &gt; 1) &#123;  //开始更新父类节点的值</div><div class=\"line\">         int parentId = id &gt;&gt;&gt; 1;</div><div class=\"line\">         byte val1 = value(id);</div><div class=\"line\">         byte val2 = value(id ^ 1);  //获取相邻节点的值</div><div class=\"line\">         byte val = val1 &lt; val2 ? val1 : val2;</div><div class=\"line\">         setValue(parentId, val);</div><div class=\"line\">         id = parentId;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。</p>\n<h2 id=\"分配小于page的内存\"><a href=\"#分配小于page的内存\" class=\"headerlink\" title=\"分配小于page的内存\"></a>分配小于page的内存</h2><p>我们来看是如何分配小于8k的内存。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long allocateSubpage(int normCapacity) &#123;</div><div class=\"line\">    // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">    // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点</div><div class=\"line\">    synchronized (head) &#123;</div><div class=\"line\">        int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起</div><div class=\"line\">        int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点</div><div class=\"line\">        if (id &lt; 0) &#123;</div><div class=\"line\">            return id;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final PoolSubpage&lt;T&gt;[] subpages = this.subpages;</div><div class=\"line\">        final int pageSize = this.pageSize;</div><div class=\"line\"></div><div class=\"line\">        freeBytes -= pageSize;//（就是一个16M的空间）</div><div class=\"line\"></div><div class=\"line\">        int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</div><div class=\"line\">        if (subpage == null) &#123;  //说明这个PoolSubpagte还没有分配出去</div><div class=\"line\">            subpage = new PoolSubpage&lt;T&gt;(head, this, id, runOffset(id), pageSize, normCapacity);</div><div class=\"line\">            subpages[subpageIdx] = subpage;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            subpage.init(head, normCapacity);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return subpage.allocate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。</li>\n<li>查看该节点是第几个叶子节点: subpageIdx。</li>\n<li>获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。</li>\n</ul>\n<h2 id=\"释放内存\"><a href=\"#释放内存\" class=\"headerlink\" title=\"释放内存\"></a>释放内存</h2><p>上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">void free(long handle) &#123;</div><div class=\"line\">    int memoryMapIdx = memoryMapIdx(handle);</div><div class=\"line\">    int bitmapIdx = bitmapIdx(handle);</div><div class=\"line\"></div><div class=\"line\">    if (bitmapIdx != 0) &#123; // free a subpage</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</div><div class=\"line\">        assert subpage != null &amp;&amp; subpage.doNotDestroy;</div><div class=\"line\"></div><div class=\"line\">        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">        // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</div><div class=\"line\">        synchronized (head) &#123;</div><div class=\"line\">            if (subpage.free(head, bitmapIdx &amp; 0x3FFFFFFF)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes += runLength(memoryMapIdx);</div><div class=\"line\">    setValue(memoryMapIdx, depth(memoryMapIdx));</div><div class=\"line\">    updateParentsFree(memoryMapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int memoryMapIdx(long handle) &#123; //低32位</div><div class=\"line\">    return (int) handle;</div><div class=\"line\">&#125;</div><div class=\"line\">////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">private static int bitmapIdx(long handle) &#123; //高32位</div><div class=\"line\">    return (int) (handle &gt;&gt;&gt; Integer.SIZE);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>handlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。</p>\n<ul>\n<li>判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数</li>\n<li>若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Netty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Netty分配内存(0~16M)与回收主要是在PoolChunk上完成的, 在内存分配时希望是有序的。当没有内存可分配时, 一次申请到16M PoolChunk内存, 用户实际使用时可能一次性不能使用16M, 所以逻辑上将PoolChunk划分成不同的块, 使用平衡二叉树进行管理内存的分配, 构建的二叉树结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk1.png\" height=\"400\" width=\"450\"><br>该二叉树将PoolChunk分11层, 第一层为1个16M, 第二层为2个8MB,第三层为4个4MB的内存块, 直到第11层为2048个8KB的内存块,  8kb的内存块称之为page。</p>\n<ul>\n<li>如果我们申请16M的内存, 那么将直接在该二叉树第一层申请。</li>\n<li>若申请32K的内存, 那么在该二叉树第8层申请。</li>\n<li>若申请8K的内存, 那么将直接在第11层申请。<br>*实际申请内存大小时, size一定限定为2^x, 参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a><br>接下来介绍PoolChunk的成员属性:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">//该PoolChunk所属的PoolArena, 上层PoolArena控制着在哪块PoolArena上分配</div><div class=\"line\">final PoolArena&lt;T&gt; arena;。</div><div class=\"line\">//对外内存: DirectByteBuffer, 堆内内存 byte[]。</div><div class=\"line\">final T memory;</div><div class=\"line\">// 是内存池还是非内存池方式</div><div class=\"line\">final boolean unpooled;</div><div class=\"line\">private final byte[] memoryMap;  //PoolChunk的物理视图是连续的PoolSubpage,用PoolSubpage保持，而memoryMap是所有PoolSubpage的逻辑映射，映射为一颗平衡二叉数，用来标记每一个PoolSubpage是否被分配。下文会更进一步说明</div><div class=\"line\">private final byte[] depthMap;    //而depthMap中保存的值表示各个id对应的深度，是个固定值，初始化后不再变更。</div><div class=\"line\">//与叶子节点个数相同, 一个叶子节点可以映射PoolSupage中一个元素, 若叶子节点与该元素完成了映射, 说明该叶子节点已经被分配出去了</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] subpages;</div><div class=\"line\">/** Used to determine if the requested capacity is equal to or greater than pageSize. */</div><div class=\"line\">//用来判断申请的内存是否超过pageSize大小</div><div class=\"line\">private final int subpageOverflowMask;</div><div class=\"line\">//每个PoolSubpage的大小，默认为8192个字节（8K)</div><div class=\"line\">private final int pageSize;</div><div class=\"line\">//pageSize 2的 pageShifts幂</div><div class=\"line\">private final int pageShifts;</div><div class=\"line\">// 平衡二叉树的深度，</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//PoolChunk的总内存大小,chunkSize =   (1&lt;&lt;maxOrder) * pageSize。</div><div class=\"line\">private final int chunkSize;</div><div class=\"line\">// PoolChunk由maxSubpageAllocs个PoolSubpage组成, 默认2048个。</div><div class=\"line\">private final int maxSubpageAllocs;</div><div class=\"line\">/** Used to mark memory as unusable */</div><div class=\"line\">//标记为已被分配的值，该值为 maxOrder + 1=12, 当memoryMap[id] = unusable时，则表示id节点已被分配</div><div class=\"line\">private final byte unusable;</div><div class=\"line\"></div><div class=\"line\">//当前PoolChunk剩余可分配内存, 初始为16M。</div><div class=\"line\">private int freeBytes;</div><div class=\"line\"></div><div class=\"line\">//一个PoolChunk分配后，会根据其使用率挂在一个PoolChunkList中(q050, q025...)</div><div class=\"line\">PoolChunkList&lt;T&gt; parent;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>当我们需要分配内存时, 会在二叉树上查找满足大小的节点, 我们需要考虑的一个问题: 若申请了第11层下标为2048节点的8k内存, 下标为1024的父节点怎么才能避免被不被16k的申请所申请到呢?<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunk2.png\" height=\"200\" width=\"250\"><br>Netty为每一层分配的一个层号, 根据层号可以直接获取该节点剩余最大可分配的内存空间。<br>当第11层下标为2048的节点被分配出去:</p>\n<ol>\n<li>则该节点的层号被修改为12, 表示该节点不可再分配。</li>\n<li>同时id为1024的父节点层号改为11, id为512的节点层号改为10, …, id为1的节点层号改为2.</li>\n</ol>\n<p>当申请16k的内存时, 分配的节点的层号必须等于(11-log(16k/8k)) = 10, id为1024的节点自然被淘汰了。动态记录每个节点层数的成员属性为memoryMap, 记录每个节点深度的成员属性为depthMap, 其中memoryMap值是可以动态改变的, 而depthMap是静态不变的。<br>构造函数中该成员斌量初始过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoryMap = new byte[maxSubpageAllocs &lt;&lt; 1];</div><div class=\"line\">depthMap = new byte[memoryMap.length];</div><div class=\"line\">int memoryMapIndex = 1;</div><div class=\"line\">for (int d = 0; d &lt;= maxOrder; ++ d) &#123; // move down the tree one level at a time</div><div class=\"line\">    int depth = 1 &lt;&lt; d;</div><div class=\"line\">    for (int p = 0; p &lt; depth; ++ p) &#123;</div><div class=\"line\">        // in each level traverse left to right and set value to the depth of subtree</div><div class=\"line\">        memoryMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        depthMap[memoryMapIndex] = (byte) d;</div><div class=\"line\">        memoryMapIndex ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实际操作中, 针对数据构造二叉树, 实际从memoryMap下标为1的节点开始使用, 数组元素个数为4096。</p>\n<h1 id=\"PoolChunk分配内存\"><a href=\"#PoolChunk分配内存\" class=\"headerlink\" title=\"PoolChunk分配内存\"></a>PoolChunk分配内存</h1><p>在PoolArea.allocateNormal()中调用newChunk产生PoolChunk<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected PoolChunk&lt;ByteBuffer&gt; newChunk(int pageSize, int maxOrder,</div><div class=\"line\">        int pageShifts, int chunkSize) &#123;</div><div class=\"line\">    //</div><div class=\"line\">    if (directMemoryCacheAlignment == 0) &#123;</div><div class=\"line\">        return new PoolChunk&lt;ByteBuffer&gt;(this,</div><div class=\"line\">                 //allocateDirect(chunkSize)会直接创建直接内存， 用直接内存地址构建的DirectByteBuffer</div><div class=\"line\">                allocateDirect(chunkSize), pageSize, maxOrder,</div><div class=\"line\">                pageShifts, chunkSize, 0);  //pageShifts= log8k = 13</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ByteBuffer memory = allocateDirect(chunkSize</div><div class=\"line\">            + directMemoryCacheAlignment);</div><div class=\"line\">    return new PoolChunk&lt;ByteBuffer&gt;(this, memory, pageSize,</div><div class=\"line\">            maxOrder, pageShifts, chunkSize,</div><div class=\"line\">            offsetCacheLine(memory));</div></pre></td></tr></table></figure></p>\n<p>我们需要关注下如何通过allocateDirect()产生堆外内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private static ByteBuffer allocateDirect(int capacity) &#123;</div><div class=\"line\">    //如果不是调用cleaner来回收对象，那么将使用DirectByteBuff来回收对象</div><div class=\"line\">    return PlatformDependent.useDirectBufferNoCleaner() ?</div><div class=\"line\">            PlatformDependent.allocateDirectNoCleaner(capacity) : ByteBuffer.allocateDirect(capacity);</div><div class=\"line\">&#125;</div><div class=\"line\">static ByteBuffer allocateDirectNoCleaner(int capacity) &#123;</div><div class=\"line\">return newDirectBuffer(UNSAFE.allocateMemory(capacity), capacity);</div></pre></td></tr></table></figure></p>\n<p>最终是通过直接内存地址的address来产生DirectByteBuffer的, 此时该对象没有cleaner成员变量, 将不能通过cleaner来回收直接内存。<br>接下来看看如何是从PoolChunk中分配内存的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate(int normCapacity) &#123;</div><div class=\"line\">    if ((normCapacity &amp; subpageOverflowMask) != 0) &#123;</div><div class=\"line\">        return allocateRun(normCapacity);  //// 大于等于pageSize时返回的是可分配normCapacity的节点的id</div><div class=\"line\">    &#125; else &#123;  //分配小于8k</div><div class=\"line\">        return allocateSubpage(normCapacity); //（small）返回是第几个long,long第几位</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>返回值handle可以定位出该内存块的处在该PoolChunk中具体的位置信息。</li>\n<li>若申请的内存大于等于page(8k), 进入allocateRun进行申请, 返回值handler就是找到的节点在二叉树中的下标(int长度); 若申请的内存小于8K, 进入allocateSubpage进行申请, 返回长度是个long。</li>\n</ul>\n<h2 id=\"分配大于page的内存\"><a href=\"#分配大于page的内存\" class=\"headerlink\" title=\"分配大于page的内存\"></a>分配大于page的内存</h2><p>我们首先看allocateRun是如何操作的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private long allocateRun(int normCapacity) &#123;//64k</div><div class=\"line\">     //算出当前大小的内存需要在那一层完成分配</div><div class=\"line\">    int d = maxOrder - (log2(normCapacity) - pageShifts);</div><div class=\"line\">    int id = allocateNode(d);</div><div class=\"line\">    if (id &lt; 0) &#123;</div><div class=\"line\">        return id;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes -= runLength(id);</div><div class=\"line\">    return id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>首先计算出在二叉树哪层分配内存, 比如申请32k的内存, 那么d = maxOrder - (log2(normCapacity) - pageShifts) = 11 - (log2(32k) - 13) = 9, 说明只能在该二叉树第9层找到合适的节点。 为啥减13, 因为默认pag为8k, log2(8k)=13。</li>\n<li>开始进入二叉树对应的d层中通过allocateNode查找哪个节点还没有分配出去:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int allocateNode(int d) &#123;</div><div class=\"line\">    int id = 1;</div><div class=\"line\">    int initial = - (1 &lt;&lt; d); // has last d bits = 0 and rest all = 1</div><div class=\"line\">    byte val = value(id);</div><div class=\"line\">    //若第一层的深度不够，那么该chunkend不够分配</div><div class=\"line\">    if (val &gt; d) &#123; // unusable</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // id &amp; initial == 1 &lt;&lt; d for all ids at depth d, for &lt; d it is 0</div><div class=\"line\">    while (val &lt; d || (id &amp; initial) == 0) &#123;</div><div class=\"line\">        id &lt;&lt;= 1;</div><div class=\"line\">        val = value(id);</div><div class=\"line\">        if (val &gt; d) &#123;</div><div class=\"line\">            id ^= 1;</div><div class=\"line\">            val = value(id);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    byte value = value(id);</div><div class=\"line\">    assert value == d &amp;&amp; (id &amp; initial) == 1 &lt;&lt; d :</div><div class=\"line\">    String.format(&quot;val = %d, id &amp; initial = %d, d = %d&quot;, value, id &amp; initial, d);</div><div class=\"line\">    setValue(id, unusable); // mark as unusable</div><div class=\"line\">    updateParentsAlloc(id);</div><div class=\"line\">    return id; //返回的是查找到的那个节点的下标</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>主要做了如下工作:</p>\n<ol>\n<li>从根节点开始遍历, 首先检查第1层的层号, 若大于申请的层号, 那么该节点不够申请的大小, 直接退出。(<code>若不退出的话, 那就意味该二叉树一定可以找到大小为d层号的节点</code>, 并且在该节点的下标一定&gt;=2^d)</li>\n<li>若当前节点层数<d, 或者当前节点的下标=\"\" <=\"\" 2^d,=\"\" 那么继续下一层左孩子节点查找,=\"\" 直到找到某一个节点的层数=\"=目前层数d,\" 则完成查找。若发现该节点剩余大小不够分配,=\"\" 则在兄弟节点继续查找。=\"\" 如下图,=\"\" 当查找层号为11的节点,=\"\" 找到符合下标id=\"\">=x 2^11的节点 &amp;&amp; 层号 == 11的节点 , 只能在下标为2049的那个节点。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolChunke_allocation_select.png\" height=\"300\" width=\"350\"><br>其中 (id &amp; initial) == 0) 等价于id &lt;2^d, 作用: 若当前节点的下标&lt; 2^s, 则会继续在当前节点的孩子节点查找。</d,></li>\n<li>将成功找到的那个节点层号标为不可分配unusable, 意味着已经分配出去了。</li>\n<li>更新该节点的所有祖父父节点层号:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void updateParentsAlloc(int id) &#123;</div><div class=\"line\">     while (id &gt; 1) &#123;  //开始更新父类节点的值</div><div class=\"line\">         int parentId = id &gt;&gt;&gt; 1;</div><div class=\"line\">         byte val1 = value(id);</div><div class=\"line\">         byte val2 = value(id ^ 1);  //获取相邻节点的值</div><div class=\"line\">         byte val = val1 &lt; val2 ? val1 : val2;</div><div class=\"line\">         setValue(parentId, val);</div><div class=\"line\">         id = parentId;</div><div class=\"line\">     &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>父节点的层号选取两个子节点层号最小的那个层号, 表示该父节点能分配的最大内存。</p>\n<h2 id=\"分配小于page的内存\"><a href=\"#分配小于page的内存\" class=\"headerlink\" title=\"分配小于page的内存\"></a>分配小于page的内存</h2><p>我们来看是如何分配小于8k的内存。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long allocateSubpage(int normCapacity) &#123;</div><div class=\"line\">    // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">    // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">    PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(normCapacity);  //// 找到arena中对应阶级的subpage头节点，不存数据的头结点</div><div class=\"line\">    synchronized (head) &#123;</div><div class=\"line\">        int d = maxOrder; // subpages are only be allocated from pages i.e., leaves   subpage只能从叶子节点开始找起</div><div class=\"line\">        int id = allocateNode(d); //只在叶子节点找到一个为8k的节点，肯定可以找到一个节点</div><div class=\"line\">        if (id &lt; 0) &#123;</div><div class=\"line\">            return id;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        final PoolSubpage&lt;T&gt;[] subpages = this.subpages;</div><div class=\"line\">        final int pageSize = this.pageSize;</div><div class=\"line\"></div><div class=\"line\">        freeBytes -= pageSize;//（就是一个16M的空间）</div><div class=\"line\"></div><div class=\"line\">        int subpageIdx = subpageIdx(id);  //第几个PoolSubpage（叶子节点）</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx];</div><div class=\"line\">        if (subpage == null) &#123;  //说明这个PoolSubpagte还没有分配出去</div><div class=\"line\">            subpage = new PoolSubpage&lt;T&gt;(head, this, id, runOffset(id), pageSize, normCapacity);</div><div class=\"line\">            subpages[subpageIdx] = subpage;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            subpage.init(head, normCapacity);</div><div class=\"line\">        &#125;</div><div class=\"line\">        return subpage.allocate();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>我们需要知道, 小于8k的内存分配都是在叶子节点里面分配的, 首先先从二叉树中查找层号为11(叶子节点)的可用节点。</li>\n<li>查看该节点是第几个叶子节点: subpageIdx。</li>\n<li>获取该叶子节点对应的PoolSubpage, subpage为null的可能为: PoolSubpage释放时, 并没有从subpages中取出, 该PoolSubpage还存放在subpages的数组里, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a> free()函数, 至于从PoolSubpage中分配内存的过程放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>中详细描述。</li>\n</ul>\n<h2 id=\"释放内存\"><a href=\"#释放内存\" class=\"headerlink\" title=\"释放内存\"></a>释放内存</h2><p>上面讲的在allocate中申请内存时, 返回的是一个handle , 该释放内存时的参数也是该handle。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">void free(long handle) &#123;</div><div class=\"line\">    int memoryMapIdx = memoryMapIdx(handle);</div><div class=\"line\">    int bitmapIdx = bitmapIdx(handle);</div><div class=\"line\"></div><div class=\"line\">    if (bitmapIdx != 0) &#123; // free a subpage</div><div class=\"line\">        PoolSubpage&lt;T&gt; subpage = subpages[subpageIdx(memoryMapIdx)];</div><div class=\"line\">        assert subpage != null &amp;&amp; subpage.doNotDestroy;</div><div class=\"line\"></div><div class=\"line\">        // Obtain the head of the PoolSubPage pool that is owned by the PoolArena and synchronize on it.</div><div class=\"line\">        // This is need as we may add it back and so alter the linked-list structure.</div><div class=\"line\">        PoolSubpage&lt;T&gt; head = arena.findSubpagePoolHead(subpage.elemSize);</div><div class=\"line\">        synchronized (head) &#123;</div><div class=\"line\">            if (subpage.free(head, bitmapIdx &amp; 0x3FFFFFFF)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    freeBytes += runLength(memoryMapIdx);</div><div class=\"line\">    setValue(memoryMapIdx, depth(memoryMapIdx));</div><div class=\"line\">    updateParentsFree(memoryMapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>首先通过handle获取属于哪个page: memoryMapIdx、属于PoolSubpage里面哪个子内存块:bitmapIdx。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static int memoryMapIdx(long handle) &#123; //低32位</div><div class=\"line\">    return (int) handle;</div><div class=\"line\">&#125;</div><div class=\"line\">////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">private static int bitmapIdx(long handle) &#123; //高32位</div><div class=\"line\">    return (int) (handle &gt;&gt;&gt; Integer.SIZE);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>handlee低32位字段即为memoryMapIdx, 高32为字段即为bitmapIdx。</p>\n<ul>\n<li>判是PoolSubpage的子块bitmapIdx不为0, 那么一定是小于8K的内存释放, 请参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>toHandle函数</li>\n<li>若是PoolSubpage的子块bitmapIdx为0 , 那么一定是大于8K的内存释放, 释放时修改该节点祖辈的层号, 修改该chunk的大小。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Netty PoolChunk讲完了, 主要理解二叉树的构建, 当分配大于8K的内存时, 怎么从二叉树中查找合适的节点, 怎么释放该二叉树上的节点块就可以了。 若分配小于8K的内存块, 主要是在子节点内部分配, 将放在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>详细探究。</p>\n"},{"title":"Netty-PoolSubpage原理探究","date":"2018-07-21T17:02:45.000Z","toc":true,"_content":"Netty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolSubpage.png\" height=\"400\" width=\"450\"/>\n每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。\n下面是PoolSubpage的构造函数:\n```\n   PoolSubpage(PoolSubpage<T> head, PoolChunk<T> chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) {\n        this.chunk = chunk;\n        //与PoolChunkPage中哪个节点映射一起来\n        this.memoryMapIdx = memoryMapIdx;\n        this.runOffset = runOffset;\n        //该叶子节点的大小\n        this.pageSize = pageSize;\n        //bitmap的每一位都描述的是一个element的使用情况\n        bitmap = new long[pageSize >>> 10];\n        init(head, elemSize);\n    }\n    //init根据当前需要分配的内存大小，确定需要多少个bitmap元素\n    void init(PoolSubpage<T> head, int elemSize) {   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个\n        doNotDestroy = true;\n        this.elemSize = elemSize;\n        if (elemSize != 0) {\n            maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存\n            nextAvail = 0;\n            bitmapLength = maxNumElems >>> 6;  //6代表着long长度 = 2\n            if ((maxNumElems & 63) != 0) {//低6位\n                bitmapLength ++;\n            }\n\n            for (int i = 0; i < bitmapLength; i ++) {\n                bitmap[i] = 0;\n            }\n        }\n        addToPool(head);\n    }\n```\n有人会有疑问: 为啥bitmap = new long[pageSize >>> 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16\\*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。\n然后再调用init来对PoolSubpage结构进行初始化:\n1. 总共可以分成`pageSize/elemSize`个element。 bitmap所有元素也不一定需要全部用上, 实际会用`maxNumElems >>> 6`个long就可以了。\n2. 然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。\n\n# PoolSubpage的内存分配\n```\n    long allocate() { //找到一位\n        if (elemSize == 0) {\n            return toHandle(0);\n        }\n        if (numAvail == 0 || !doNotDestroy) {\n            return -1;\n        }\n        final int bitmapIdx = getNextAvail(); //64进制\n        int q = bitmapIdx >>> 6;//第几位long\n        int r = bitmapIdx & 63; //这个long第几位\n        assert (bitmap[q] >>> r & 1) == 0;\n        bitmap[q] |= 1L << r;  //将相关位置置为1\n        if (-- numAvail == 0) { //这个page没有再能够提供的bit位\n            removeFromPool(); //从可分配链中去掉\n        }\n        return toHandle(bitmapIdx);\n    }\n\n```\n若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:\n```\n    private int findNextAvail0(int i, long bits) {\n        final int maxNumElems = this.maxNumElems; //包含的段个数\n        final int baseVal = i << 6; //64进制，第2位，最大数也只是8*64 + 64\n\n        for (int j = 0; j < 64; j ++) {\n            if ((bits & 1) == 0) { //bits哪位为0，局说明哪位可用\n                int val = baseVal | j; //第4个long+9  i<<6 + j\n                if (val < maxNumElems) { //不能大于总段数\n                    return val;\n                } else {\n                    break;\n                }\n            }\n            bits >>>= 1;  //一位位找，直到找到某位为0\n        }\n        return -1;\n    }\n```\n主要做了如下事情:\n1. 遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。\n2. 检查该元素每一个bit是否为0, 找到后, 返回值为`i << 6 | j`, 包含第几个元素 + 元素内第几个bit位。\n再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:\n```\n    private long toHandle(int bitmapIdx) {\n        ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n        return 0x4000000000000000L | (long) bitmapIdx << 32 | memoryMapIdx;\n    }\n```\n可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。\n\n# PoolSubpage的内存释放\n```\n    boolean free(PoolSubpage<T> head, int bitmapIdx) {\n        if (elemSize == 0) {\n            return true;\n        }\n        int q = bitmapIdx >>> 6;\n        int r = bitmapIdx & 63;\n        assert (bitmap[q] >>> r & 1) != 0;\n        bitmap[q] ^= 1L << r;\n\n        setNextAvail(bitmapIdx);\n\n        if (numAvail ++ == 0) {\n            addToPool(head);\n            return true;\n        }\n\n        if (numAvail != maxNumElems) {\n            return true;\n        } else {\n            // Subpage not in use (numAvail == maxNumElems)\n            if (prev == next) {\n                // Do not remove if this subpage is the only one left in the pool.\n                return true;\n            }\n\n            // Remove this subpage from the pool if there are other subpages left in the pool.\n            doNotDestroy = false;\n            removeFromPool();\n            return false;\n        }\n    }\n```\n释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:\n1. 若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。\n2. 若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。\n3. 反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。\n\n# 总结\n\nPoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。","source":"_posts/Netty-PoolSubpage原理探究.md","raw":"---\ntitle: Netty-PoolSubpage原理探究\ndate: 2018-07-22 01:02:45\ntags:\ntoc: true\n---\nNetty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolSubpage.png\" height=\"400\" width=\"450\"/>\n每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。\n下面是PoolSubpage的构造函数:\n```\n   PoolSubpage(PoolSubpage<T> head, PoolChunk<T> chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) {\n        this.chunk = chunk;\n        //与PoolChunkPage中哪个节点映射一起来\n        this.memoryMapIdx = memoryMapIdx;\n        this.runOffset = runOffset;\n        //该叶子节点的大小\n        this.pageSize = pageSize;\n        //bitmap的每一位都描述的是一个element的使用情况\n        bitmap = new long[pageSize >>> 10];\n        init(head, elemSize);\n    }\n    //init根据当前需要分配的内存大小，确定需要多少个bitmap元素\n    void init(PoolSubpage<T> head, int elemSize) {   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个\n        doNotDestroy = true;\n        this.elemSize = elemSize;\n        if (elemSize != 0) {\n            maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存\n            nextAvail = 0;\n            bitmapLength = maxNumElems >>> 6;  //6代表着long长度 = 2\n            if ((maxNumElems & 63) != 0) {//低6位\n                bitmapLength ++;\n            }\n\n            for (int i = 0; i < bitmapLength; i ++) {\n                bitmap[i] = 0;\n            }\n        }\n        addToPool(head);\n    }\n```\n有人会有疑问: 为啥bitmap = new long[pageSize >>> 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16\\*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。\n然后再调用init来对PoolSubpage结构进行初始化:\n1. 总共可以分成`pageSize/elemSize`个element。 bitmap所有元素也不一定需要全部用上, 实际会用`maxNumElems >>> 6`个long就可以了。\n2. 然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。\n\n# PoolSubpage的内存分配\n```\n    long allocate() { //找到一位\n        if (elemSize == 0) {\n            return toHandle(0);\n        }\n        if (numAvail == 0 || !doNotDestroy) {\n            return -1;\n        }\n        final int bitmapIdx = getNextAvail(); //64进制\n        int q = bitmapIdx >>> 6;//第几位long\n        int r = bitmapIdx & 63; //这个long第几位\n        assert (bitmap[q] >>> r & 1) == 0;\n        bitmap[q] |= 1L << r;  //将相关位置置为1\n        if (-- numAvail == 0) { //这个page没有再能够提供的bit位\n            removeFromPool(); //从可分配链中去掉\n        }\n        return toHandle(bitmapIdx);\n    }\n\n```\n若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:\n```\n    private int findNextAvail0(int i, long bits) {\n        final int maxNumElems = this.maxNumElems; //包含的段个数\n        final int baseVal = i << 6; //64进制，第2位，最大数也只是8*64 + 64\n\n        for (int j = 0; j < 64; j ++) {\n            if ((bits & 1) == 0) { //bits哪位为0，局说明哪位可用\n                int val = baseVal | j; //第4个long+9  i<<6 + j\n                if (val < maxNumElems) { //不能大于总段数\n                    return val;\n                } else {\n                    break;\n                }\n            }\n            bits >>>= 1;  //一位位找，直到找到某位为0\n        }\n        return -1;\n    }\n```\n主要做了如下事情:\n1. 遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。\n2. 检查该元素每一个bit是否为0, 找到后, 返回值为`i << 6 | j`, 包含第几个元素 + 元素内第几个bit位。\n再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:\n```\n    private long toHandle(int bitmapIdx) {\n        ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n        return 0x4000000000000000L | (long) bitmapIdx << 32 | memoryMapIdx;\n    }\n```\n可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。\n\n# PoolSubpage的内存释放\n```\n    boolean free(PoolSubpage<T> head, int bitmapIdx) {\n        if (elemSize == 0) {\n            return true;\n        }\n        int q = bitmapIdx >>> 6;\n        int r = bitmapIdx & 63;\n        assert (bitmap[q] >>> r & 1) != 0;\n        bitmap[q] ^= 1L << r;\n\n        setNextAvail(bitmapIdx);\n\n        if (numAvail ++ == 0) {\n            addToPool(head);\n            return true;\n        }\n\n        if (numAvail != maxNumElems) {\n            return true;\n        } else {\n            // Subpage not in use (numAvail == maxNumElems)\n            if (prev == next) {\n                // Do not remove if this subpage is the only one left in the pool.\n                return true;\n            }\n\n            // Remove this subpage from the pool if there are other subpages left in the pool.\n            doNotDestroy = false;\n            removeFromPool();\n            return false;\n        }\n    }\n```\n释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:\n1. 若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。\n2. 若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。\n3. 反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。\n\n# 总结\n\nPoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。","slug":"Netty-PoolSubpage原理探究","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8x3000ophu5soksko72","content":"<p>Netty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolSubpage.png\" height=\"400\" width=\"450\"><br>每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。<br>下面是PoolSubpage的构造函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) &#123;</div><div class=\"line\">     this.chunk = chunk;</div><div class=\"line\">     //与PoolChunkPage中哪个节点映射一起来</div><div class=\"line\">     this.memoryMapIdx = memoryMapIdx;</div><div class=\"line\">     this.runOffset = runOffset;</div><div class=\"line\">     //该叶子节点的大小</div><div class=\"line\">     this.pageSize = pageSize;</div><div class=\"line\">     //bitmap的每一位都描述的是一个element的使用情况</div><div class=\"line\">     bitmap = new long[pageSize &gt;&gt;&gt; 10];</div><div class=\"line\">     init(head, elemSize);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //init根据当前需要分配的内存大小，确定需要多少个bitmap元素</div><div class=\"line\"> void init(PoolSubpage&lt;T&gt; head, int elemSize) &#123;   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个</div><div class=\"line\">     doNotDestroy = true;</div><div class=\"line\">     this.elemSize = elemSize;</div><div class=\"line\">     if (elemSize != 0) &#123;</div><div class=\"line\">         maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存</div><div class=\"line\">         nextAvail = 0;</div><div class=\"line\">         bitmapLength = maxNumElems &gt;&gt;&gt; 6;  //6代表着long长度 = 2</div><div class=\"line\">         if ((maxNumElems &amp; 63) != 0) &#123;//低6位</div><div class=\"line\">             bitmapLength ++;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         for (int i = 0; i &lt; bitmapLength; i ++) &#123;</div><div class=\"line\">             bitmap[i] = 0;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     addToPool(head);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>有人会有疑问: 为啥bitmap = new long[pageSize &gt;&gt;&gt; 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。<br>然后再调用init来对PoolSubpage结构进行初始化:</p>\n<ol>\n<li>总共可以分成<code>pageSize/elemSize</code>个element。 bitmap所有元素也不一定需要全部用上, 实际会用<code>maxNumElems &gt;&gt;&gt; 6</code>个long就可以了。</li>\n<li>然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。</li>\n</ol>\n<h1 id=\"PoolSubpage的内存分配\"><a href=\"#PoolSubpage的内存分配\" class=\"headerlink\" title=\"PoolSubpage的内存分配\"></a>PoolSubpage的内存分配</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate() &#123; //找到一位</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return toHandle(0);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (numAvail == 0 || !doNotDestroy) &#123;</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final int bitmapIdx = getNextAvail(); //64进制</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;//第几位long</div><div class=\"line\">    int r = bitmapIdx &amp; 63; //这个long第几位</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) == 0;</div><div class=\"line\">    bitmap[q] |= 1L &lt;&lt; r;  //将相关位置置为1</div><div class=\"line\">    if (-- numAvail == 0) &#123; //这个page没有再能够提供的bit位</div><div class=\"line\">        removeFromPool(); //从可分配链中去掉</div><div class=\"line\">    &#125;</div><div class=\"line\">    return toHandle(bitmapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int findNextAvail0(int i, long bits) &#123;</div><div class=\"line\">    final int maxNumElems = this.maxNumElems; //包含的段个数</div><div class=\"line\">    final int baseVal = i &lt;&lt; 6; //64进制，第2位，最大数也只是8*64 + 64</div><div class=\"line\"></div><div class=\"line\">    for (int j = 0; j &lt; 64; j ++) &#123;</div><div class=\"line\">        if ((bits &amp; 1) == 0) &#123; //bits哪位为0，局说明哪位可用</div><div class=\"line\">            int val = baseVal | j; //第4个long+9  i&lt;&lt;6 + j</div><div class=\"line\">            if (val &lt; maxNumElems) &#123; //不能大于总段数</div><div class=\"line\">                return val;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        bits &gt;&gt;&gt;= 1;  //一位位找，直到找到某位为0</div><div class=\"line\">    &#125;</div><div class=\"line\">    return -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ol>\n<li>遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。</li>\n<li>检查该元素每一个bit是否为0, 找到后, 返回值为<code>i &lt;&lt; 6 | j</code>, 包含第几个元素 + 元素内第几个bit位。<br>再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long toHandle(int bitmapIdx) &#123;</div><div class=\"line\">    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">    return 0x4000000000000000L | (long) bitmapIdx &lt;&lt; 32 | memoryMapIdx;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。</p>\n<h1 id=\"PoolSubpage的内存释放\"><a href=\"#PoolSubpage的内存释放\" class=\"headerlink\" title=\"PoolSubpage的内存释放\"></a>PoolSubpage的内存释放</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean free(PoolSubpage&lt;T&gt; head, int bitmapIdx) &#123;</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;</div><div class=\"line\">    int r = bitmapIdx &amp; 63;</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) != 0;</div><div class=\"line\">    bitmap[q] ^= 1L &lt;&lt; r;</div><div class=\"line\"></div><div class=\"line\">    setNextAvail(bitmapIdx);</div><div class=\"line\"></div><div class=\"line\">    if (numAvail ++ == 0) &#123;</div><div class=\"line\">        addToPool(head);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (numAvail != maxNumElems) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Subpage not in use (numAvail == maxNumElems)</div><div class=\"line\">        if (prev == next) &#123;</div><div class=\"line\">            // Do not remove if this subpage is the only one left in the pool.</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remove this subpage from the pool if there are other subpages left in the pool.</div><div class=\"line\">        doNotDestroy = false;</div><div class=\"line\">        removeFromPool();</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:</p>\n<ol>\n<li>若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。</li>\n<li>若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。</li>\n<li>反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>PoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Netty中大于8K的内存是通过PoolChunk来分配的, 小于8k的内存是通过PoolSubpage分配的, 本章将详细描述如何通过PoolSubpage分配小于8K的内存。当申请小于8K的内存时, 会从分配一个8k的叶子节点, 若用不完的话, 存在很大的浪费, 所以通过PoolSubpage来管理8K的内存, 如下图<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolSubpage.png\" height=\"400\" width=\"450\"><br>每一个PoolSubpage都会与PoolChunk里面的一个叶子节点映射起来, 然后将PoolSubpage根据用户申请的ElementSize化成几等分, 之后只要再次申请ElementSize大小的内存, 将直接从这个PoolSubpage中分配。<br>下面是PoolSubpage的构造函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">PoolSubpage(PoolSubpage&lt;T&gt; head, PoolChunk&lt;T&gt; chunk, int memoryMapIdx, int runOffset, int pageSize, int elemSize) &#123;</div><div class=\"line\">     this.chunk = chunk;</div><div class=\"line\">     //与PoolChunkPage中哪个节点映射一起来</div><div class=\"line\">     this.memoryMapIdx = memoryMapIdx;</div><div class=\"line\">     this.runOffset = runOffset;</div><div class=\"line\">     //该叶子节点的大小</div><div class=\"line\">     this.pageSize = pageSize;</div><div class=\"line\">     //bitmap的每一位都描述的是一个element的使用情况</div><div class=\"line\">     bitmap = new long[pageSize &gt;&gt;&gt; 10];</div><div class=\"line\">     init(head, elemSize);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //init根据当前需要分配的内存大小，确定需要多少个bitmap元素</div><div class=\"line\"> void init(PoolSubpage&lt;T&gt; head, int elemSize) &#123;   ///elemSize代表此次申请的大小，比如申请64byte，那么这个page被分成了8k/64=2^7=128个</div><div class=\"line\">     doNotDestroy = true;</div><div class=\"line\">     this.elemSize = elemSize;</div><div class=\"line\">     if (elemSize != 0) &#123;</div><div class=\"line\">         maxNumElems = numAvail = pageSize / elemSize; //被分成了128份64大小的内存</div><div class=\"line\">         nextAvail = 0;</div><div class=\"line\">         bitmapLength = maxNumElems &gt;&gt;&gt; 6;  //6代表着long长度 = 2</div><div class=\"line\">         if ((maxNumElems &amp; 63) != 0) &#123;//低6位</div><div class=\"line\">             bitmapLength ++;</div><div class=\"line\">         &#125;</div><div class=\"line\"></div><div class=\"line\">         for (int i = 0; i &lt; bitmapLength; i ++) &#123;</div><div class=\"line\">             bitmap[i] = 0;</div><div class=\"line\">         &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">     addToPool(head);</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>有人会有疑问: 为啥bitmap = new long[pageSize &gt;&gt;&gt; 10], 因为小于8K的内存, 最小是以16b为单位来分配的, 一个long类型为64位, 最多需要pageSize/(16*64)个long就可以将一个PoolSubpage中所有element是否分配描述清楚了, log2(16*64)=10。<br>然后再调用init来对PoolSubpage结构进行初始化:</p>\n<ol>\n<li>总共可以分成<code>pageSize/elemSize</code>个element。 bitmap所有元素也不一定需要全部用上, 实际会用<code>maxNumElems &gt;&gt;&gt; 6</code>个long就可以了。</li>\n<li>然后根据头插法将该PoolSubpage插入tinySubpagePools或者smallSubpagePools(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)对应级别的链中。</li>\n</ol>\n<h1 id=\"PoolSubpage的内存分配\"><a href=\"#PoolSubpage的内存分配\" class=\"headerlink\" title=\"PoolSubpage的内存分配\"></a>PoolSubpage的内存分配</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">long allocate() &#123; //找到一位</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return toHandle(0);</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (numAvail == 0 || !doNotDestroy) &#123;</div><div class=\"line\">        return -1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final int bitmapIdx = getNextAvail(); //64进制</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;//第几位long</div><div class=\"line\">    int r = bitmapIdx &amp; 63; //这个long第几位</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) == 0;</div><div class=\"line\">    bitmap[q] |= 1L &lt;&lt; r;  //将相关位置置为1</div><div class=\"line\">    if (-- numAvail == 0) &#123; //这个page没有再能够提供的bit位</div><div class=\"line\">        removeFromPool(); //从可分配链中去掉</div><div class=\"line\">    &#125;</div><div class=\"line\">    return toHandle(bitmapIdx);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>若可分配的element个数为0, 则将相应可分配链中去掉(该链结构可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)。 PoolSubpage在初始化时候已经规定了可分配内存块的大小, 所以调用的函数中不需要告诉需要分配的内存大小, 在PoolSubpage中查找可用的element通过findNextAvail0实现的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private int findNextAvail0(int i, long bits) &#123;</div><div class=\"line\">    final int maxNumElems = this.maxNumElems; //包含的段个数</div><div class=\"line\">    final int baseVal = i &lt;&lt; 6; //64进制，第2位，最大数也只是8*64 + 64</div><div class=\"line\"></div><div class=\"line\">    for (int j = 0; j &lt; 64; j ++) &#123;</div><div class=\"line\">        if ((bits &amp; 1) == 0) &#123; //bits哪位为0，局说明哪位可用</div><div class=\"line\">            int val = baseVal | j; //第4个long+9  i&lt;&lt;6 + j</div><div class=\"line\">            if (val &lt; maxNumElems) &#123; //不能大于总段数</div><div class=\"line\">                return val;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        bits &gt;&gt;&gt;= 1;  //一位位找，直到找到某位为0</div><div class=\"line\">    &#125;</div><div class=\"line\">    return -1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ol>\n<li>遍历bitmap中所有元素, 找到一个bit为0的元素, 说明还有element没有分配出去。</li>\n<li>检查该元素每一个bit是否为0, 找到后, 返回值为<code>i &lt;&lt; 6 | j</code>, 包含第几个元素 + 元素内第几个bit位。<br>再返回到allocate函数中, 将该元素对应的bit置为1, 并构造handle:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">private long toHandle(int bitmapIdx) &#123;</div><div class=\"line\">    ////高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">    return 0x4000000000000000L | (long) bitmapIdx &lt;&lt; 32 | memoryMapIdx;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>可以得知针对小于8K的分配, 返回的handle一定是大于int类型的数据, 若handle高位不为0, 则该handle映射的内存块一定是小于8K的内存块。该handle将page、element的位置信息全部编码进去了, 这些信息也很容易解码出来。</p>\n<h1 id=\"PoolSubpage的内存释放\"><a href=\"#PoolSubpage的内存释放\" class=\"headerlink\" title=\"PoolSubpage的内存释放\"></a>PoolSubpage的内存释放</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean free(PoolSubpage&lt;T&gt; head, int bitmapIdx) &#123;</div><div class=\"line\">    if (elemSize == 0) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    int q = bitmapIdx &gt;&gt;&gt; 6;</div><div class=\"line\">    int r = bitmapIdx &amp; 63;</div><div class=\"line\">    assert (bitmap[q] &gt;&gt;&gt; r &amp; 1) != 0;</div><div class=\"line\">    bitmap[q] ^= 1L &lt;&lt; r;</div><div class=\"line\"></div><div class=\"line\">    setNextAvail(bitmapIdx);</div><div class=\"line\"></div><div class=\"line\">    if (numAvail ++ == 0) &#123;</div><div class=\"line\">        addToPool(head);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (numAvail != maxNumElems) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Subpage not in use (numAvail == maxNumElems)</div><div class=\"line\">        if (prev == next) &#123;</div><div class=\"line\">            // Do not remove if this subpage is the only one left in the pool.</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Remove this subpage from the pool if there are other subpages left in the pool.</div><div class=\"line\">        doNotDestroy = false;</div><div class=\"line\">        removeFromPool();</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>释放的时候并不会将该PoolSubpage从subpages(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>)中取出, 释放逻辑也比较简单, 除了将bitmap中相应long置为0, 别的工作就是检查该PoolSubpage是否需要加入对应的链或者从对应的链中取出:</p>\n<ol>\n<li>若当前可用的element为0, 则说明已经从相应可分配链中去掉了, 此时再通过头插法加入对应的可分配链中, 说明还在使用。</li>\n<li>若目前剩余可用element小于最大剩余可用的, 同样说明还在使用。</li>\n<li>反之说明该PoolSubpage没有element被分配出去。 若该级别的链大于1个PoolSubpage还在使用, 则返回该链可以释放了; 只剩余这个PoolSubpage还没有释放, 那暂时先不释放等待之后的内存分配。</li>\n</ol>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>PoolSubpage主要管理小于8K的内存分配, 内存返回的handle可以唯一确定PoolChunk、poolSubpage中具体哪个element。 当PoolSubpage没有使用的内存时, 可能从对应的链中取出。同时一定没有从subpages中去掉。</p>\n"},{"title":"Netty PoolThreadCache原理探究","date":"2018-07-14T11:04:06.000Z","toc":true,"_content":"NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。\n# PoolThreadCache\nNetty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolThreadCache2.png\" height=\"400\" width=\"450\"/>\n图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32>>4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。\n下面大致介绍下PoolThreadCache里面的属性作用:\n```\n    final PoolArena<byte[]> heapArena;\n    final PoolArena<ByteBuffer> directArena;\n\n    // Hold the caches for the different size classes, which are tiny, small and normal.\n    //tiny内存缓存的个数。默认为512\n    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;\n    //small内存缓存的个数,默认为256个\n    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;\n    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;\n    //normalCacheSize缓存的个数，默认为64\n    private final MemoryRegionCache<byte[]>[] normalHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;\n\n    private final int freeSweepAllocationThreshold;\n\n    private final Thread deathWatchThread;\n    //线程消亡后，释放资源\n    private final Runnable freeTask;\n    //freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。\n    private int allocations;\n\n```\n`heapArena`与`directArena`作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。`smallSubPageHeapCaches`数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, ... , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。`normalHeapCaches`数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a>\n 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:\n ```\n private static <T> MemoryRegionCache<T>[] createNormalCaches(\n            int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {\n        if (cacheSize > 0) {\n            int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k\n            //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的\n            int arraySize = Math.max(1, log2(max / area.pageSize) + 1);\n            //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住\n            @SuppressWarnings(\"unchecked\")\n            MemoryRegionCache<T>[] cache = new MemoryRegionCache[arraySize];\n            for (int i = 0; i < cache.length; i++) {\n                cache[i] = new NormalMemoryRegionCache<T>(cacheSize);\n            }\n            return cache;\n        } else {\n            return null;\n        }\n    }\n ```\n 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。\n\n以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:\n```\n     boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {\n        return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);\n    }\n```\n在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:\n```\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private boolean allocate(MemoryRegionCache<?> cache, PooledByteBuf buf, int reqCapacity) {\n        if (cache == null) {\n            // no cache found so just return false here\n            return false;\n        }\n        boolean allocated = cache.allocate(buf, reqCapacity);\n        if (++ allocations >= freeSweepAllocationThreshold) {\n            allocations = 0;\n            trim();\n        }\n        return allocated;\n    }\n```\n做了如下事情:\n+ 若没有该级别的缓存块, 则直接退出。\n+ 若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。\n\ntrim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:\n```\n        public final void trim() {\n            int free = size - allocations;\n            allocations = 0;\n\n            // We not even allocated all the number that are\n             //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次\n            if (free > 0) {\n                free(free);//才不会释放该缓存\n            }\n        }\n```\n`size`表示该16K级别的queue单位十年内必须分配多少次, 才不会释放(默认64个)\n`allocations`表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。\nfree大于0表示成功分配freeSweepAllocationThreshold次缓存中时间内,从当前缓存中分配的次数allocations小于阈值size, 该缓存队列需要释放。 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。\n\n## PoolThreadLocalCache\n文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。\nPoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadCache。 PoolThreadLocalCache继承了FastThreadLocal, PoolThreadLocalCache.get()实际调用了FastThreadLocal.get()方法:\n```\n    public final V get() {\n        return get(InternalThreadLocalMap.get());\n    }\n\n    public final V get(InternalThreadLocalMap threadLocalMap) {\n         //想得到该层级缓存，发现没有，那么只能去初始话一个\n        Object v = threadLocalMap.indexedVariable(index);\n        if (v != InternalThreadLocalMap.UNSET) {\n            return (V) v;\n        }\n\n        return initialize(threadLocalMap);\n    }\n```\n在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。\n```\nstatic final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();\n```\n若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:\n```\n        protected synchronized PoolThreadCache initialValue() {\n            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea\n            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n\n            if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) {\n                return new PoolThreadCache( //为每一级别增加缓存\n                        heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,\n                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);\n            }\n            // No caching for non FastThreadLocalThreads.\n            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);\n        }\n```\n这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。\n至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。\n\n","source":"_posts/Netty-PoolThreadCache源码探究.md","raw":"---\ntitle: Netty PoolThreadCache原理探究\ndate: 2018-07-14 19:04:06\ntags:\ntoc: true\n---\nNioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。\n# PoolThreadCache\nNetty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolThreadCache2.png\" height=\"400\" width=\"450\"/>\n图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32>>4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。\n下面大致介绍下PoolThreadCache里面的属性作用:\n```\n    final PoolArena<byte[]> heapArena;\n    final PoolArena<ByteBuffer> directArena;\n\n    // Hold the caches for the different size classes, which are tiny, small and normal.\n    //tiny内存缓存的个数。默认为512\n    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;\n    //small内存缓存的个数,默认为256个\n    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;\n    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;\n    //normalCacheSize缓存的个数，默认为64\n    private final MemoryRegionCache<byte[]>[] normalHeapCaches;\n    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;\n\n    private final int freeSweepAllocationThreshold;\n\n    private final Thread deathWatchThread;\n    //线程消亡后，释放资源\n    private final Runnable freeTask;\n    //freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。\n    private int allocations;\n\n```\n`heapArena`与`directArena`作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。`smallSubPageHeapCaches`数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, ... , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。`normalHeapCaches`数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a>\n 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:\n ```\n private static <T> MemoryRegionCache<T>[] createNormalCaches(\n            int cacheSize, int maxCachedBufferCapacity, PoolArena<T> area) {\n        if (cacheSize > 0) {\n            int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k\n            //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的\n            int arraySize = Math.max(1, log2(max / area.pageSize) + 1);\n            //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住\n            @SuppressWarnings(\"unchecked\")\n            MemoryRegionCache<T>[] cache = new MemoryRegionCache[arraySize];\n            for (int i = 0; i < cache.length; i++) {\n                cache[i] = new NormalMemoryRegionCache<T>(cacheSize);\n            }\n            return cache;\n        } else {\n            return null;\n        }\n    }\n ```\n 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。\n\n以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:\n```\n     boolean allocateNormal(PoolArena<?> area, PooledByteBuf<?> buf, int reqCapacity, int normCapacity) {\n        return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);\n    }\n```\n在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:\n```\n    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n    private boolean allocate(MemoryRegionCache<?> cache, PooledByteBuf buf, int reqCapacity) {\n        if (cache == null) {\n            // no cache found so just return false here\n            return false;\n        }\n        boolean allocated = cache.allocate(buf, reqCapacity);\n        if (++ allocations >= freeSweepAllocationThreshold) {\n            allocations = 0;\n            trim();\n        }\n        return allocated;\n    }\n```\n做了如下事情:\n+ 若没有该级别的缓存块, 则直接退出。\n+ 若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。\n\ntrim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:\n```\n        public final void trim() {\n            int free = size - allocations;\n            allocations = 0;\n\n            // We not even allocated all the number that are\n             //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次\n            if (free > 0) {\n                free(free);//才不会释放该缓存\n            }\n        }\n```\n`size`表示该16K级别的queue单位十年内必须分配多少次, 才不会释放(默认64个)\n`allocations`表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。\nfree大于0表示成功分配freeSweepAllocationThreshold次缓存中时间内,从当前缓存中分配的次数allocations小于阈值size, 该缓存队列需要释放。 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。\n\n## PoolThreadLocalCache\n文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。\nPoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadCache。 PoolThreadLocalCache继承了FastThreadLocal, PoolThreadLocalCache.get()实际调用了FastThreadLocal.get()方法:\n```\n    public final V get() {\n        return get(InternalThreadLocalMap.get());\n    }\n\n    public final V get(InternalThreadLocalMap threadLocalMap) {\n         //想得到该层级缓存，发现没有，那么只能去初始话一个\n        Object v = threadLocalMap.indexedVariable(index);\n        if (v != InternalThreadLocalMap.UNSET) {\n            return (V) v;\n        }\n\n        return initialize(threadLocalMap);\n    }\n```\n在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。\n```\nstatic final ThreadLocal<InternalThreadLocalMap> slowThreadLocalMap = new ThreadLocal<InternalThreadLocalMap>();\n```\n若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:\n```\n        protected synchronized PoolThreadCache initialValue() {\n            final PoolArena<byte[]> heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea\n            final PoolArena<ByteBuffer> directArena = leastUsedArena(directArenas);\n\n            if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) {\n                return new PoolThreadCache( //为每一级别增加缓存\n                        heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,\n                        DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);\n            }\n            // No caching for non FastThreadLocalThreads.\n            return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);\n        }\n```\n这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。\n至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。\n\n","slug":"Netty-PoolThreadCache源码探究","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8x4000pphu5dwbmpnh6","content":"<p>NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。</p>\n<h1 id=\"PoolThreadCache\"><a href=\"#PoolThreadCache\" class=\"headerlink\" title=\"PoolThreadCache\"></a>PoolThreadCache</h1><p>Netty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolThreadCache2.png\" height=\"400\" width=\"450\"><br>图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32&gt;&gt;4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。<br>下面大致介绍下PoolThreadCache里面的属性作用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">final PoolArena&lt;byte[]&gt; heapArena;</div><div class=\"line\">final PoolArena&lt;ByteBuffer&gt; directArena;</div><div class=\"line\"></div><div class=\"line\">// Hold the caches for the different size classes, which are tiny, small and normal.</div><div class=\"line\">//tiny内存缓存的个数。默认为512</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] tinySubPageHeapCaches;</div><div class=\"line\">//small内存缓存的个数,默认为256个</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] smallSubPageHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</div><div class=\"line\">//normalCacheSize缓存的个数，默认为64</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] normalHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</div><div class=\"line\"></div><div class=\"line\">private final int freeSweepAllocationThreshold;</div><div class=\"line\"></div><div class=\"line\">private final Thread deathWatchThread;</div><div class=\"line\">//线程消亡后，释放资源</div><div class=\"line\">private final Runnable freeTask;</div><div class=\"line\">//freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。</div><div class=\"line\">private int allocations;</div></pre></td></tr></table></figure></p>\n<p><code>heapArena</code>与<code>directArena</code>作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&amp;heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。<code>smallSubPageHeapCaches</code>数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, … , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。<code>normalHeapCaches</code>数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a><br> 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createNormalCaches(</div><div class=\"line\">           int cacheSize, int maxCachedBufferCapacity, PoolArena&lt;T&gt; area) &#123;</div><div class=\"line\">       if (cacheSize &gt; 0) &#123;</div><div class=\"line\">           int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k</div><div class=\"line\">           //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的</div><div class=\"line\">           int arraySize = Math.max(1, log2(max / area.pageSize) + 1);</div><div class=\"line\">           //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住</div><div class=\"line\">           @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">           MemoryRegionCache&lt;T&gt;[] cache = new MemoryRegionCache[arraySize];</div><div class=\"line\">           for (int i = 0; i &lt; cache.length; i++) &#123;</div><div class=\"line\">               cache[i] = new NormalMemoryRegionCache&lt;T&gt;(cacheSize);</div><div class=\"line\">           &#125;</div><div class=\"line\">           return cache;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p> 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。</p>\n<p>以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean allocateNormal(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</div><div class=\"line\">private boolean allocate(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, int reqCapacity) &#123;</div><div class=\"line\">    if (cache == null) &#123;</div><div class=\"line\">        // no cache found so just return false here</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean allocated = cache.allocate(buf, reqCapacity);</div><div class=\"line\">    if (++ allocations &gt;= freeSweepAllocationThreshold) &#123;</div><div class=\"line\">        allocations = 0;</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return allocated;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>若没有该级别的缓存块, 则直接退出。</li>\n<li>若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。</li>\n</ul>\n<p>trim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void trim() &#123;</div><div class=\"line\">    int free = size - allocations;</div><div class=\"line\">    allocations = 0;</div><div class=\"line\"></div><div class=\"line\">    // We not even allocated all the number that are</div><div class=\"line\">     //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次</div><div class=\"line\">    if (free &gt; 0) &#123;</div><div class=\"line\">        free(free);//才不会释放该缓存</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>size</code>表示该16K级别的queue单位十年内必须分配多少次, 才不会释放(默认64个)<br><code>allocations</code>表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。<br>free大于0表示成功分配freeSweepAllocationThreshold次缓存中时间内,从当前缓存中分配的次数allocations小于阈值size, 该缓存队列需要释放。 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。</p>\n<h2 id=\"PoolThreadLocalCache\"><a href=\"#PoolThreadLocalCache\" class=\"headerlink\" title=\"PoolThreadLocalCache\"></a>PoolThreadLocalCache</h2><p>文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。<br>PoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadCache。 PoolThreadLocalCache继承了FastThreadLocal, PoolThreadLocalCache.get()实际调用了FastThreadLocal.get()方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get() &#123;</div><div class=\"line\">    return get(InternalThreadLocalMap.get());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public final V get(InternalThreadLocalMap threadLocalMap) &#123;</div><div class=\"line\">     //想得到该层级缓存，发现没有，那么只能去初始话一个</div><div class=\"line\">    Object v = threadLocalMap.indexedVariable(index);</div><div class=\"line\">    if (v != InternalThreadLocalMap.UNSET) &#123;</div><div class=\"line\">        return (V) v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return initialize(threadLocalMap);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">static final ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = new ThreadLocal&lt;InternalThreadLocalMap&gt;();</div></pre></td></tr></table></figure></p>\n<p>若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected synchronized PoolThreadCache initialValue() &#123;</div><div class=\"line\">    final PoolArena&lt;byte[]&gt; heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea</div><div class=\"line\">    final PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</div><div class=\"line\"></div><div class=\"line\">    if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) &#123;</div><div class=\"line\">        return new PoolThreadCache( //为每一级别增加缓存</div><div class=\"line\">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</div><div class=\"line\">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // No caching for non FastThreadLocalThreads.</div><div class=\"line\">    return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。<br>至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。</p>\n<h1 id=\"PoolThreadCache\"><a href=\"#PoolThreadCache\" class=\"headerlink\" title=\"PoolThreadCache\"></a>PoolThreadCache</h1><p>Netty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的区间。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolThreadCache2.png\" height=\"400\" width=\"450\"><br>图中只展示了small类型数组的大小(为4), 而tiny、normal数组的大小分别分32、 3。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32&gt;&gt;4))的queue中。 本文章大量用到某一级别的缓存块, 举个例子:normal级别的缓存块有[8k, 16k, 32k]。<br>下面大致介绍下PoolThreadCache里面的属性作用:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">final PoolArena&lt;byte[]&gt; heapArena;</div><div class=\"line\">final PoolArena&lt;ByteBuffer&gt; directArena;</div><div class=\"line\"></div><div class=\"line\">// Hold the caches for the different size classes, which are tiny, small and normal.</div><div class=\"line\">//tiny内存缓存的个数。默认为512</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] tinySubPageHeapCaches;</div><div class=\"line\">//small内存缓存的个数,默认为256个</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] smallSubPageHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</div><div class=\"line\">//normalCacheSize缓存的个数，默认为64</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] normalHeapCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;</div><div class=\"line\"></div><div class=\"line\">private final int freeSweepAllocationThreshold;</div><div class=\"line\"></div><div class=\"line\">private final Thread deathWatchThread;</div><div class=\"line\">//线程消亡后，释放资源</div><div class=\"line\">private final Runnable freeTask;</div><div class=\"line\">//freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。</div><div class=\"line\">private int allocations;</div></pre></td></tr></table></figure></p>\n<p><code>heapArena</code>与<code>directArena</code>作用一样, 根据用户使用direct内存还是heap内存来确定使用哪个块。由构造函数可以看出directArena与PoolThreadCache绑定了, 同时PoolThreadCache也与某个NioEventLoop对应的线程绑定的, 所以该NioEventLoop线程都与唯一的directArena(&amp;heapArena)绑定着, 这样相对减轻了线程间申请内存导致互斥的发生。<code>smallSubPageHeapCaches</code>数组长度为4(如上图所示), 依次缓存[512K, 1024k, 2048k, 4096k]大小的缓存, 每个的元素对应的缓存queue个数不能超过256个; 而tinySubPageHeapCaches数组缓存的是[16B, 32B, … , 496B]大小的内存块, 每个元素对应的缓存queue个数不能超过512个。<code>normalHeapCaches</code>数组结构相同, 但是只缓存[8k, 16k, 32k]大小的内存块, 每个元素对应的缓存queue个数不超过64个。 normal最大内存块为16m, 而缓存仅仅缓存最大32k内存的原因是这是一种巨大的开销: 试想仅仅16m对应的级别存储, 就可缓存16M*64大小的内存块放在内存, 而这些内存块等着被新分配出去而没有主动释放, 存在巨大的浪费。 至于tiny、small、normal缓存每一等级划分规则, 可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\"> Netty PoolArea内存原理探究</a><br> 由于normalHeapCaches的特殊性, 如下展示该部分的代码实现:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static &lt;T&gt; MemoryRegionCache&lt;T&gt;[] createNormalCaches(</div><div class=\"line\">           int cacheSize, int maxCachedBufferCapacity, PoolArena&lt;T&gt; area) &#123;</div><div class=\"line\">       if (cacheSize &gt; 0) &#123;</div><div class=\"line\">           int max = Math.min(area.chunkSize, maxCachedBufferCapacity); //默认32k</div><div class=\"line\">           //normalHeapCaches 数组中的元素的大小，是以2的幂倍pageSize递增的</div><div class=\"line\">           int arraySize = Math.max(1, log2(max / area.pageSize) + 1);</div><div class=\"line\">           //只缓存8k，16k，32k的缓存，太大的话，内存扛不住，若最大缓存32m的话，缓存64*32M个，太大了，扛不住</div><div class=\"line\">           @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">           MemoryRegionCache&lt;T&gt;[] cache = new MemoryRegionCache[arraySize];</div><div class=\"line\">           for (int i = 0; i &lt; cache.length; i++) &#123;</div><div class=\"line\">               cache[i] = new NormalMemoryRegionCache&lt;T&gt;(cacheSize);</div><div class=\"line\">           &#125;</div><div class=\"line\">           return cache;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p> 最大缓存的大小由io.netty.allocator.maxCachedBufferCapacity来指定, 默认缓存最大32k。</p>\n<p>以下展示缓存中分配内存的过程, 以从normal级别缓存分配内存为例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean allocateNormal(PoolArena&lt;?&gt; area, PooledByteBuf&lt;?&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    return allocate(cacheForNormal(area, normCapacity), buf, reqCapacity);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在cacheForNormal中根据normCapacity确定从normalSubPageDirectCaches对应级别获取缓存内存块, 接着开始分配内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</div><div class=\"line\">private boolean allocate(MemoryRegionCache&lt;?&gt; cache, PooledByteBuf buf, int reqCapacity) &#123;</div><div class=\"line\">    if (cache == null) &#123;</div><div class=\"line\">        // no cache found so just return false here</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean allocated = cache.allocate(buf, reqCapacity);</div><div class=\"line\">    if (++ allocations &gt;= freeSweepAllocationThreshold) &#123;</div><div class=\"line\">        allocations = 0;</div><div class=\"line\">        trim();</div><div class=\"line\">    &#125;</div><div class=\"line\">    return allocated;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>做了如下事情:</p>\n<ul>\n<li>若没有该级别的缓存块, 则直接退出。</li>\n<li>若缓存有该级别的缓存块, 则将该缓存块分配出去, 同时判断从PoolThreadCache缓存中成功分配内存的次数是否达到阈值freeSweepAllocationThreshold(8192次), 若达到阈值, 则在trim()中尝试释放分配率很低的缓存块, 以免内存泄漏。</li>\n</ul>\n<p>trim()是如何确定哪些缓存块需要释放呢? 它会分别检查tiny、small、normal类型缓存块, 并轮训其中每一级别缓存块, 调用MemoryRegionCache.trim()检查是否需要释放, 以下以检查normal类型16k级别缓存块为例来说明:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void trim() &#123;</div><div class=\"line\">    int free = size - allocations;</div><div class=\"line\">    allocations = 0;</div><div class=\"line\"></div><div class=\"line\">    // We not even allocated all the number that are</div><div class=\"line\">     //只有从该级别分配大于预定值，tiny：512，small:256 , normal:64次</div><div class=\"line\">    if (free &gt; 0) &#123;</div><div class=\"line\">        free(free);//才不会释放该缓存</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>size</code>表示该16K级别的queue单位十年内必须分配多少次, 才不会释放(默认64个)<br><code>allocations</code>表示在达到MemoryRegionCache成功分配freeSweepAllocationThreshold次缓存中、从16K级别的缓存块中分配的缓存次数。<br>free大于0表示成功分配freeSweepAllocationThreshold次缓存中时间内,从当前缓存中分配的次数allocations小于阈值size, 该缓存队列需要释放。 如果从16KB级缓存队列中成功分配的缓存次数超过size(64次), 则不会释放级别缓存queue。若没有从该级别缓存队列中成功分配一次, 那么该级别的缓存queue存放的缓存块将全部释放。</p>\n<h2 id=\"PoolThreadLocalCache\"><a href=\"#PoolThreadLocalCache\" class=\"headerlink\" title=\"PoolThreadLocalCache\"></a>PoolThreadLocalCache</h2><p>文章开头讲了, 线程首先从本地缓存分配内存。PoolThreadCache主要解决了了如何从本地缓存分配内存, 而本地缓存如何与该线程联系在一起的呢? 这就是PoolThreadLocalCache起的作用。<br>PoolThreadLocalCache是全局唯一的, 任何线程分配内存, 都会调用同一个PoolThreadLocalCache.get()获取PoolThreadCache。 PoolThreadLocalCache继承了FastThreadLocal, PoolThreadLocalCache.get()实际调用了FastThreadLocal.get()方法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final V get() &#123;</div><div class=\"line\">    return get(InternalThreadLocalMap.get());</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public final V get(InternalThreadLocalMap threadLocalMap) &#123;</div><div class=\"line\">     //想得到该层级缓存，发现没有，那么只能去初始话一个</div><div class=\"line\">    Object v = threadLocalMap.indexedVariable(index);</div><div class=\"line\">    if (v != InternalThreadLocalMap.UNSET) &#123;</div><div class=\"line\">        return (V) v;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return initialize(threadLocalMap);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在InternalThreadLocalMap中定义了slowThreadLocalMap属性, 该类型是我们熟悉的ThreadLocal。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">static final ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = new ThreadLocal&lt;InternalThreadLocalMap&gt;();</div></pre></td></tr></table></figure></p>\n<p>若从本地缓冲中获取不到PoolThreadCache, 则会调用PoolThreadLocalCache.initialize()初始一个:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected synchronized PoolThreadCache initialValue() &#123;</div><div class=\"line\">    final PoolArena&lt;byte[]&gt; heapArena = leastUsedArena(heapArenas); //找出被别的NioEventLoop使用最少次数多PoolArea</div><div class=\"line\">    final PoolArena&lt;ByteBuffer&gt; directArena = leastUsedArena(directArenas);</div><div class=\"line\"></div><div class=\"line\">    if (useCacheForAllThreads || Thread.currentThread() instanceof FastThreadLocalThread) &#123;</div><div class=\"line\">        return new PoolThreadCache( //为每一级别增加缓存</div><div class=\"line\">                heapArena, directArena, tinyCacheSize, smallCacheSize, normalCacheSize,</div><div class=\"line\">                DEFAULT_MAX_CACHED_BUFFER_CAPACITY, DEFAULT_CACHE_TRIM_INTERVAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // No caching for non FastThreadLocalThreads.</div><div class=\"line\">    return new PoolThreadCache(heapArena, directArena, 0, 0, 0, 0, 0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里我们需要注意leastUsedArena()函数。 Netty默认会产生NioEventLoop |work|个PoolArea块, 至于该线程绑定哪个PoolArea呢, 是根据该PoolArea被多少线程绑定次数来依据的。 被越少的线程绑定到一起, 分配内存发生冲突的概率越小。 这里选择被绑定次数最低的那个PoolArea来构建PoolThreadCache。<br>至此, 线程与PoolThreadCache实现了一一绑定。 之后该线程分配内存, 都会利用PoolThreadLocalCache.get()获取PoolThreadCache, 然后利用里面的PoolArea来完成的。</p>\n"},{"title":"Netty堆外内存回收原理详解","date":"2019-01-12T07:22:41.000Z","toc":true,"_content":"Netty堆外内存通过DirectByteBuffer实现管理, 它会首先申请16M的直接内存块大小, 放入DirectByteBuffer, 由PoolChunk映射这16MB的内存块, 通过PoolChunk的分配来完成该直接内存块使用与释放。 每当用户申请小块内存时, 都从这16M的内存中分配, 当该部分内存使用完后, 会释放到PoolChunk内存池中, 而不是彻底释放。 可以看出, netty每次释放直接内存并没有使用DirectByteBuffer自带Cleaner来释放(具体可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/27/DirectByteBuffer%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\">DirectByteBuffer堆外内存详解</a>), 使用PoolChunk管理直接内存的使用情况的好处也是很清晰的: 直接申请与释放堆外内存是个很大的开销, 若通过PoolChunk管理直接内存使用后, 可以循环使用该部分直接内存, 这样才能满足netty的高性能特性。 本文将讲述netty释放直接内存的原理及细节。\n而DirectByteBuffer封装在PooledUnsafeDirectByteBuf, netty层面也主要操作后者, 两者的关系图如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收1.png\" height=\"250\" width=\"350\"/>\n了解这两者对应关系, 对理解该文有一定的帮助。\n\n# PlatformDependent及PlatformDependent0简介\nPlatformDependent及PlatformDependent0主要是用来确定重要参数配置的, 比如netty是否需要使用Unsfa, 当前使用的java版本等, 了解这些参数变量, 有助于更方面了解直接内存的使用。\n### PlatformDependent\n```\n    //是否有Unsafe, 拥有了Unsafe, 我们可以方便的操控直接内存,可以通过-Dio.netty.noUnsafe及-Dio.netty.tryUnsafe参数来决定, 默认是可以\n    private static final boolean HAS_UNSAFE = hasUnsafe0();\n    //用户优先使用堆外内存还是堆内内存, 通过-Dio.netty.noPreferDirect参数控制\n    private static final boolean DIRECT_BUFFER_PREFERRED =HAS_UNSAFE && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n    //当前netty能够使用的最大堆外内存, 默认与堆内内存相等\n    private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();\n     //与unsafe结合可以直接获取任何堆内array对象的直接地址\n    private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();\n    //与unsafe结合可以获取任何对象的直接内存地址\n    private static final int ADDRESS_SIZE = addressSize0();\n     //默认为true，则代表着netty将自己通过PoolCHunk来实现直接内存的回收与分配, 而不是使用DirectByteBuffer自带的功能来回收直接内存\n    private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;\n    //直接内存地址的使用量, 每次新申请和释放16M堆外内存, 都会统计到该变量中, 实际项目中, 我们可以通过反射拿到该变量值以观察堆外内存是否出现泄漏\n    private static final AtomicLong DIRECT_MEMORY_COUNTER;\n    //最大堆外内存\n    private static final long DIRECT_MEMORY_LIMIT;\n    private static final ThreadLocalRandomProvider RANDOM_PROVIDER;\n    //自己弄一个cleaner, 当16M内存被完全释放时, 会调用该变量完成。\n    private static final Cleaner CLEANER;\n    static {\n         ......\n        long maxDirectMemory = SystemPropertyUtil.getLong(\"io.netty.maxDirectMemory\", -1);\n        //PlatformDependent0.hasDirectBufferNoCleanerConstructor()会检查可以通过反射+直接内存地址来构建DirectByteBuffer对象\n        if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            USE_DIRECT_BUFFER_NO_CLEANER = false;\n            DIRECT_MEMORY_COUNTER = null;\n        } else {\n            //代表释放DirectByteBuffer里面的直接内存, 不使用自带的cleaner机制, 通过UNSAFE.freeMemory(address)释放的。具体见PoolArea.destroyChunk()方法选择。\n            USE_DIRECT_BUFFER_NO_CLEANER = true;\n            if (maxDirectMemory < 0) {\n                maxDirectMemory = maxDirectMemory0();\n                if (maxDirectMemory <= 0) {\n                    DIRECT_MEMORY_COUNTER = null;\n                } else {\n                    DIRECT_MEMORY_COUNTER = new AtomicLong();\n                }\n            } else {\n                DIRECT_MEMORY_COUNTER = new AtomicLong();\n            }\n        }\n        DIRECT_MEMORY_LIMIT = maxDirectMemory;\n        if (!isAndroid() && hasUnsafe()) {\n            if (javaVersion() >= 9) {\n                CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;\n            } else {\n                CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;\n            }\n        } else {\n            CLEANER = NOOP;\n        }\n    }\n```\n我们可以看下CleanerJava6如何进行直接内存释放的:\n```\nfinal class CleanerJava6 implements Cleaner {\n    //随便产生了一个DircetByteBuff，里面的cleaner的直接内存地址\n    private static final long CLEANER_FIELD_OFFSET;\n    //DircetByteBuff中cleaner的直接内存地址\n    private static final Method CLEAN_METHOD;\n    static {\n        long fieldOffset = -1;\n        Method clean = null;\n        Throwable error = null;\n        if (PlatformDependent0.hasUnsafe()) {\n            //先产生一个DirectByteBuffer\n            ByteBuffer direct = ByteBuffer.allocateDirect(1);\n            try {\n            //根据反射, 获取到该对象的cleaner域\n                Field cleanerField = direct.getClass().getDeclaredField(\"cleaner\");\n                fieldOffset = PlatformDependent0.objectFieldOffset(cleanerField);\n                Object cleaner = PlatformDependent0.getObject(direct, fieldOffset);\n                clean = cleaner.getClass().getDeclaredMethod(\"clean\");\n                //调用clean，测试回收DirectByteBuffer里面的直接内存\n                clean.invoke(cleaner);\n            } catch (Throwable t) {\n                // We don't have ByteBuffer.cleaner().\n                fieldOffset = -1;\n                clean = null;\n                error = t;\n            }\n        } else {\n            error = new UnsupportedOperationException(\"sun.misc.Unsafe unavailable\");\n        }\n        if (error == null) {\n            logger.debug(\"java.nio.ByteBuffer.cleaner(): available\");\n        } else {\n            logger.debug(\"java.nio.ByteBuffer.cleaner(): unavailable\", error);\n        }\n        CLEANER_FIELD_OFFSET = fieldOffset; //DircetByteBuff中cleaner的直接内存地址\n        CLEAN_METHOD = clean;   ////DircetByteBuff中cleaner的直接内存地址\n    }\n    @Override\n    public void freeDirectBuffer(ByteBuffer buffer) {\n        if (!buffer.isDirect()) {\n            return;\n        }\n        try {\n            //获取该buffer里面的cleanerd对象\n            Object cleaner = PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);\n            if (cleaner != null) {\n                //主动调用clean()函数以回收该内存\n                CLEAN_METHOD.invoke(cleaner);\n            }\n        } catch (Throwable cause) {\n            PlatformDependent0.throwException(cause);\n        }\n    }\n}\n```\n使用CleanerJava6释放直接内存的一个前提就是存在cleaner成员变量, 当使用DirectByteBuffer(int cap)产生的DirectByteBuffer, 其cleaner才会存在。 而使用private DirectByteBuffer(long addr, int cap)则不会产生cleaner对象, 而netty默认使用后者产生DirectByteBuffer对象(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">allocateNormal.allocateDirect()</a>)。\n### PlatformDependent0\n```\n    //与Unsafe配合, 可以获取任何对象任何成员变量的值\n    private static final long ADDRESS_FIELD_OFFSET;\n    //可以通过该地址直接获取数组在内存中的初始地址， 参考https://www.jianshu.com/p/9819eb48716a\n    private static final long BYTE_ARRAY_BASE_OFFSET;\n    //DirectByteBuff对象构造器，参数包括直接内存address\n    private static final Constructor<?> DIRECT_BUFFER_CONSTRUCTOR;\n    //是否明确不让使用Unsafe\n    private static final boolean IS_EXPLICIT_NO_UNSAFE = explicitNoUnsafe0();\n    //通过Unsafe来控制直接内存\n    private static final Object INTERNAL_UNSAFE;\n    static final Unsafe UNSAFE;\n    private static final boolean UNALIGNED;\n    static {\n        final ByteBuffer direct;\n        Field addressField = null;\n        Method allocateArrayMethod = null;\n        Unsafe unsafe;\n        Object internalUnsafe = null;\n        if (isExplicitNoUnsafe()) {\n            direct = null;\n            addressField = null;\n            unsafe = null;\n            internalUnsafe = null;\n        } else {\n            //这里只是尝试分配一个内存\n            direct = ByteBuffer.allocateDirect(1);\n            // 尝试通过反射获取Unsafe对象\n            final Object maybeUnsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                @Override\n                public Object run() {\n                    try {\n                        //反射， 强制获取该类属性\n                        final Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n                        Throwable cause = ReflectionUtil.trySetAccessible(unsafeField);\n                        if (cause != null) {\n                            return cause;\n                        }\n                        // the unsafe instance\n                        return unsafeField.get(null);\n                    } catch (NoSuchFieldException e) {\n                        ......\n                        return e;\n                    }\n                }\n            });\n            if (maybeUnsafe instanceof Exception) {\n                unsafe = null;\n            } else {\n                unsafe = (Unsafe) maybeUnsafe;\n            }\n            //检车copyMemory可用\n            if (unsafe != null) {\n                final Unsafe finalUnsafe = unsafe;\n                final Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        try {\n                            finalUnsafe.getClass().getDeclaredMethod(\n                                    \"copyMemory\", Object.class, long.class, Object.class, long.class, long.class);\n                            return null;\n                        } catch (NoSuchMethodException e) {\n                            ......\n                        }\n                    }\n                });\n                if (maybeException == null) {\n                    logger.debug(\"sun.misc.Unsafe.copyMemory: available\");\n                } else {\n                    // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.\n                    unsafe = null;\n                }\n            }\n            if (unsafe != null) {\n                //测试通过Unsafe获取DirectByteBuffer.address()可用\n                final Unsafe finalUnsafe = unsafe;\n                final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        try {\n                            final Field field = Buffer.class.getDeclaredField(\"address\");\n                            final long offset = finalUnsafe.objectFieldOffset(field);\n                            final long address = finalUnsafe.getLong(direct, offset);\n                            if (address == 0) {\n                                return null;\n                            }\n                            return field;\n                        } catch (NoSuchFieldException e) {\n                           ......\n                        }\n                    }\n                });\n                if (maybeAddressField instanceof Field) {\n                    addressField = (Field) maybeAddressField;\n                } else {\n                    unsafe = null;\n                }\n            }\n            if (unsafe != null) {\n                long byteArrayIndexScale = unsafe.arrayIndexScale(byte[].class);\n                if (byteArrayIndexScale != 1) {\n                    unsafe = null;\n                }\n            }\n        }\n        UNSAFE = unsafe;\n        if (unsafe == null) {\n            ADDRESS_FIELD_OFFSET = -1;\n            BYTE_ARRAY_BASE_OFFSET = -1;\n            UNALIGNED = false;\n            DIRECT_BUFFER_CONSTRUCTOR = null;\n            ALLOCATE_ARRAY_METHOD = null;\n        } else {\n            //构建通过private DirectByteBuffer(long addr, int cap)获取DirectByteBuffer对象的构造体\n            Constructor<?> directBufferConstructor;\n            long address = -1;\n            try {\n                //返回的是DirectByteBuff的构造器\n                final Object maybeDirectBufferConstructor =\n                        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                            @Override\n                            public Object run() {\n                                try {\n                                    final Constructor<?> constructor =  //对应DirectByteBuffer(long addr, int cap)\n                                            direct.getClass().getDeclaredConstructor(long.class, int.class);\n                                    Throwable cause = ReflectionUtil.trySetAccessible(constructor);\n                                    if (cause != null) {\n                                        return cause;\n                                    }\n                                    return constructor;\n                                } catch (NoSuchMethodException e) {\n                                    return e;\n                                } catch (SecurityException e) {\n                                    return e;\n                                }\n                            }\n                        });\n                if (maybeDirectBufferConstructor instanceof Constructor<?>) {\n                    address = UNSAFE.allocateMemory(1);\n                    try {\n                         //这里是尝试产生一个直接内存测试一用\n                        ((Constructor<?>) maybeDirectBufferConstructor).newInstance(address, 1);\n                        directBufferConstructor = (Constructor<?>) maybeDirectBufferConstructor;\n                    } catch (InstantiationException e) {\n                        directBufferConstructor = null;\n                        ......\n                    }\n                } else {\n                    directBufferConstructor = null;\n                }\n            } finally {\n                if (address != -1) {\n                   //测试完成后再释放这个节点\n                    UNSAFE.freeMemory(address);\n                }\n            }\n            DIRECT_BUFFER_CONSTRUCTOR = directBufferConstructor;\n            ADDRESS_FIELD_OFFSET = objectFieldOffset(addressField);\n            BYTE_ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);\n        }\n    }\n```\n# 直接内存的释放\n当数据通过channel发送出去后(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码二(编码)分析</a>), 然后就开始准备着释放直接内存\n```\n      // Release the fully written buffers, and update the indexes of the partially written buffer.\n     in.removeBytes(writtenBytes); //释放内存资源\n```\n最后调用的remove():\n```\n     public boolean remove() {\n        Entry e = flushedEntry;\n        if (e == null) {\n            clearNioBuffers();\n            return false;\n        }\n        Object msg = e.msg; //PooledUnsafeDirectByteBuf\n        ChannelPromise promise = e.promise;\n        int size = e.pendingSize;\n        removeEntry(e);\n        if (!e.cancelled) {\n            // only release message, notify and decrement if it was not canceled before.\n            ReferenceCountUtil.safeRelease(msg); //释放了直接内存地址，\n            safeSuccess(promise);\n            decrementPendingOutboundBytes(size, false, true);\n        }\n        // recycle the entry\n        e.recycle(); //释放Entry\n        return true;\n    }\n```\nremove主要做了三件事:\n+ 调用removeEntry(e)清理ChannelOutboundBuffer里面的缓存链表。\n+ 调用ReferenceCountUtil.safeRelease(msg)释放该对象的引用次数, 当引用次数为0时, 那么将直接调用PooledByteBuf.deallocate()释放该ByteBuffer。\n+ 调用e.recycle()来回收Entry(原理见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%9dsdsdsdsd8%85%E8%AF%BB/\">Ndsdsdsd源码二(编码)分析</a>)\n```\n    protected final void deallocate() {\n        if (handle >= 0) {\n            final long handle = this.handle;\n            this.handle = -1;\n            memory = null;\n            tmpNioBuf = null;\n            chunk.arena.free(chunk, handle, maxLength, cache);\n            chunk = null;\n            recycle(); //释放\n        }\n    }\n```\n主要做了两件事:\n+ 释放直接内存DirectByteBuffer占用的内存。\n+ 释放PooledUnsafeDirectByteBuf对象, 使其回收进入对象池以便下次继续使用该对象。\n我们接着看area.free()是怎么操作的\n```\n    void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cache) {\n        if (chunk.unpooled) {\n            int size = chunk.chunkSize();\n            destroyChunk(chunk);\n            activeBytesHuge.add(-size);\n            deallocationsHuge.increment();\n        } else {\n            SizeClass sizeClass = sizeClass(normCapacity);\n            if (cache != null && cache.add(this, chunk, handle, normCapacity, sizeClass)) {  //放入该cache的缓存队列\n                // cached so not free it.\n                return;\n            }\n\n            freeChunk(chunk, handle, sizeClass);\n        }\n    }\n```\n这里做判断, 针对该对象是否池化做了不同判断:\n+ 针对非池化内存, 直接将该内存块给释放了\n+ 针对池化内存:\n1. 检查内存属性为tiny、small、normal中的一种\n2. 查找是否有该属性的缓存, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>我们知道, 缓存的范围只在[16B, 32kB]之间, 若内存块在这范围之内, 则将内存块放入对应的缓存中\n3. 若内存块>32KB, 那么将调用freeChunk()该内存块释放到公共内存池中。\n```\nvoid freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass) {\n        final boolean destroyChunk;\n        synchronized (this) {\n            destroyChunk = !chunk.parent.free(chunk, handle);\n        }\n        if (destroyChunk) {\n            // destroyChunk not need to be called while holding the synchronized lock.\n            destroyChunk(chunk);\n        }\n    }\n```\nfreeChunk做了如下检查:\n调用free来释放PoolChunkList中对应的节点\n```\n    boolean free(PoolChunk<T> chunk, long handle) {\n        chunk.free(handle);\n        if (chunk.usage() < minUsage) {\n            //若当前PoolChunk使用率不满足当前链节点最低使用率要求, 从当前PoolchunkList中删掉chunk\n            remove(chunk);\n            // 根据目前PoolChunk使用率, 逐次检查q100->qinit的节点, 直到找到一个满足条件的节点\n            return move0(chunk);\n        }\n        return true;\n    }\n     private boolean move0(PoolChunk<T> chunk) {\n         //若找到当前链节点是qinit链， 那么说明该节点使用为0, PoolChunk对应的16MB内存完全空闲, 将会释放该直接内存块\n        if (prevList == null) {\n            // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and\n            // all memory associated with the PoolChunk will be released.\n            assert chunk.usage() == 0;\n            return false;\n        }\n        return prevList.move(chunk); //移动到前面的链中\n    }\n```\n释放PoolChunk对应的16M的内存块的过程如下:\n```\n        protected void destroyChunk(PoolChunk<ByteBuffer> chunk) {\n            if (PlatformDependent.useDirectBufferNoCleaner()) {\n                //将直接通过显示调用UNSAFE.freeMemory(address)方式释放内存, 并修改DIRECT_MEMORY_COUNTER值\n                PlatformDependent.freeDirectNoCleaner(chunk.memory);\n            } else {\n                //如果用cleaner回收内存, 将调用CleanerJava6.freeDirectBuffer()释放内存\n                PlatformDependent.freeDirectBuffer(chunk.memory);\n            }\n        }\n```\n# 总结\n整个netty池化内存回收过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收.png\" height=\"400\" width=\"990\"/>\nnetty默认释放管理直接内存方式与DirectByteBuffer默认释放内存的方式不一致, 释放时会依次检查缓存、公共内存池, 若Poolchunk使用率为0, 那么16M直接内存将直接释放。","source":"_posts/Netty内存回收原理解读.md","raw":"---\ntitle: Netty堆外内存回收原理详解\ndate: 2019-01-12 15:22:41\ntags:\ntoc: true\n---\nNetty堆外内存通过DirectByteBuffer实现管理, 它会首先申请16M的直接内存块大小, 放入DirectByteBuffer, 由PoolChunk映射这16MB的内存块, 通过PoolChunk的分配来完成该直接内存块使用与释放。 每当用户申请小块内存时, 都从这16M的内存中分配, 当该部分内存使用完后, 会释放到PoolChunk内存池中, 而不是彻底释放。 可以看出, netty每次释放直接内存并没有使用DirectByteBuffer自带Cleaner来释放(具体可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/27/DirectByteBuffer%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\">DirectByteBuffer堆外内存详解</a>), 使用PoolChunk管理直接内存的使用情况的好处也是很清晰的: 直接申请与释放堆外内存是个很大的开销, 若通过PoolChunk管理直接内存使用后, 可以循环使用该部分直接内存, 这样才能满足netty的高性能特性。 本文将讲述netty释放直接内存的原理及细节。\n而DirectByteBuffer封装在PooledUnsafeDirectByteBuf, netty层面也主要操作后者, 两者的关系图如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收1.png\" height=\"250\" width=\"350\"/>\n了解这两者对应关系, 对理解该文有一定的帮助。\n\n# PlatformDependent及PlatformDependent0简介\nPlatformDependent及PlatformDependent0主要是用来确定重要参数配置的, 比如netty是否需要使用Unsfa, 当前使用的java版本等, 了解这些参数变量, 有助于更方面了解直接内存的使用。\n### PlatformDependent\n```\n    //是否有Unsafe, 拥有了Unsafe, 我们可以方便的操控直接内存,可以通过-Dio.netty.noUnsafe及-Dio.netty.tryUnsafe参数来决定, 默认是可以\n    private static final boolean HAS_UNSAFE = hasUnsafe0();\n    //用户优先使用堆外内存还是堆内内存, 通过-Dio.netty.noPreferDirect参数控制\n    private static final boolean DIRECT_BUFFER_PREFERRED =HAS_UNSAFE && !SystemPropertyUtil.getBoolean(\"io.netty.noPreferDirect\", false);\n    //当前netty能够使用的最大堆外内存, 默认与堆内内存相等\n    private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();\n     //与unsafe结合可以直接获取任何堆内array对象的直接地址\n    private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();\n    //与unsafe结合可以获取任何对象的直接内存地址\n    private static final int ADDRESS_SIZE = addressSize0();\n     //默认为true，则代表着netty将自己通过PoolCHunk来实现直接内存的回收与分配, 而不是使用DirectByteBuffer自带的功能来回收直接内存\n    private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;\n    //直接内存地址的使用量, 每次新申请和释放16M堆外内存, 都会统计到该变量中, 实际项目中, 我们可以通过反射拿到该变量值以观察堆外内存是否出现泄漏\n    private static final AtomicLong DIRECT_MEMORY_COUNTER;\n    //最大堆外内存\n    private static final long DIRECT_MEMORY_LIMIT;\n    private static final ThreadLocalRandomProvider RANDOM_PROVIDER;\n    //自己弄一个cleaner, 当16M内存被完全释放时, 会调用该变量完成。\n    private static final Cleaner CLEANER;\n    static {\n         ......\n        long maxDirectMemory = SystemPropertyUtil.getLong(\"io.netty.maxDirectMemory\", -1);\n        //PlatformDependent0.hasDirectBufferNoCleanerConstructor()会检查可以通过反射+直接内存地址来构建DirectByteBuffer对象\n        if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) {\n            USE_DIRECT_BUFFER_NO_CLEANER = false;\n            DIRECT_MEMORY_COUNTER = null;\n        } else {\n            //代表释放DirectByteBuffer里面的直接内存, 不使用自带的cleaner机制, 通过UNSAFE.freeMemory(address)释放的。具体见PoolArea.destroyChunk()方法选择。\n            USE_DIRECT_BUFFER_NO_CLEANER = true;\n            if (maxDirectMemory < 0) {\n                maxDirectMemory = maxDirectMemory0();\n                if (maxDirectMemory <= 0) {\n                    DIRECT_MEMORY_COUNTER = null;\n                } else {\n                    DIRECT_MEMORY_COUNTER = new AtomicLong();\n                }\n            } else {\n                DIRECT_MEMORY_COUNTER = new AtomicLong();\n            }\n        }\n        DIRECT_MEMORY_LIMIT = maxDirectMemory;\n        if (!isAndroid() && hasUnsafe()) {\n            if (javaVersion() >= 9) {\n                CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;\n            } else {\n                CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;\n            }\n        } else {\n            CLEANER = NOOP;\n        }\n    }\n```\n我们可以看下CleanerJava6如何进行直接内存释放的:\n```\nfinal class CleanerJava6 implements Cleaner {\n    //随便产生了一个DircetByteBuff，里面的cleaner的直接内存地址\n    private static final long CLEANER_FIELD_OFFSET;\n    //DircetByteBuff中cleaner的直接内存地址\n    private static final Method CLEAN_METHOD;\n    static {\n        long fieldOffset = -1;\n        Method clean = null;\n        Throwable error = null;\n        if (PlatformDependent0.hasUnsafe()) {\n            //先产生一个DirectByteBuffer\n            ByteBuffer direct = ByteBuffer.allocateDirect(1);\n            try {\n            //根据反射, 获取到该对象的cleaner域\n                Field cleanerField = direct.getClass().getDeclaredField(\"cleaner\");\n                fieldOffset = PlatformDependent0.objectFieldOffset(cleanerField);\n                Object cleaner = PlatformDependent0.getObject(direct, fieldOffset);\n                clean = cleaner.getClass().getDeclaredMethod(\"clean\");\n                //调用clean，测试回收DirectByteBuffer里面的直接内存\n                clean.invoke(cleaner);\n            } catch (Throwable t) {\n                // We don't have ByteBuffer.cleaner().\n                fieldOffset = -1;\n                clean = null;\n                error = t;\n            }\n        } else {\n            error = new UnsupportedOperationException(\"sun.misc.Unsafe unavailable\");\n        }\n        if (error == null) {\n            logger.debug(\"java.nio.ByteBuffer.cleaner(): available\");\n        } else {\n            logger.debug(\"java.nio.ByteBuffer.cleaner(): unavailable\", error);\n        }\n        CLEANER_FIELD_OFFSET = fieldOffset; //DircetByteBuff中cleaner的直接内存地址\n        CLEAN_METHOD = clean;   ////DircetByteBuff中cleaner的直接内存地址\n    }\n    @Override\n    public void freeDirectBuffer(ByteBuffer buffer) {\n        if (!buffer.isDirect()) {\n            return;\n        }\n        try {\n            //获取该buffer里面的cleanerd对象\n            Object cleaner = PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);\n            if (cleaner != null) {\n                //主动调用clean()函数以回收该内存\n                CLEAN_METHOD.invoke(cleaner);\n            }\n        } catch (Throwable cause) {\n            PlatformDependent0.throwException(cause);\n        }\n    }\n}\n```\n使用CleanerJava6释放直接内存的一个前提就是存在cleaner成员变量, 当使用DirectByteBuffer(int cap)产生的DirectByteBuffer, 其cleaner才会存在。 而使用private DirectByteBuffer(long addr, int cap)则不会产生cleaner对象, 而netty默认使用后者产生DirectByteBuffer对象(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">allocateNormal.allocateDirect()</a>)。\n### PlatformDependent0\n```\n    //与Unsafe配合, 可以获取任何对象任何成员变量的值\n    private static final long ADDRESS_FIELD_OFFSET;\n    //可以通过该地址直接获取数组在内存中的初始地址， 参考https://www.jianshu.com/p/9819eb48716a\n    private static final long BYTE_ARRAY_BASE_OFFSET;\n    //DirectByteBuff对象构造器，参数包括直接内存address\n    private static final Constructor<?> DIRECT_BUFFER_CONSTRUCTOR;\n    //是否明确不让使用Unsafe\n    private static final boolean IS_EXPLICIT_NO_UNSAFE = explicitNoUnsafe0();\n    //通过Unsafe来控制直接内存\n    private static final Object INTERNAL_UNSAFE;\n    static final Unsafe UNSAFE;\n    private static final boolean UNALIGNED;\n    static {\n        final ByteBuffer direct;\n        Field addressField = null;\n        Method allocateArrayMethod = null;\n        Unsafe unsafe;\n        Object internalUnsafe = null;\n        if (isExplicitNoUnsafe()) {\n            direct = null;\n            addressField = null;\n            unsafe = null;\n            internalUnsafe = null;\n        } else {\n            //这里只是尝试分配一个内存\n            direct = ByteBuffer.allocateDirect(1);\n            // 尝试通过反射获取Unsafe对象\n            final Object maybeUnsafe = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                @Override\n                public Object run() {\n                    try {\n                        //反射， 强制获取该类属性\n                        final Field unsafeField = Unsafe.class.getDeclaredField(\"theUnsafe\");\n                        Throwable cause = ReflectionUtil.trySetAccessible(unsafeField);\n                        if (cause != null) {\n                            return cause;\n                        }\n                        // the unsafe instance\n                        return unsafeField.get(null);\n                    } catch (NoSuchFieldException e) {\n                        ......\n                        return e;\n                    }\n                }\n            });\n            if (maybeUnsafe instanceof Exception) {\n                unsafe = null;\n            } else {\n                unsafe = (Unsafe) maybeUnsafe;\n            }\n            //检车copyMemory可用\n            if (unsafe != null) {\n                final Unsafe finalUnsafe = unsafe;\n                final Object maybeException = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        try {\n                            finalUnsafe.getClass().getDeclaredMethod(\n                                    \"copyMemory\", Object.class, long.class, Object.class, long.class, long.class);\n                            return null;\n                        } catch (NoSuchMethodException e) {\n                            ......\n                        }\n                    }\n                });\n                if (maybeException == null) {\n                    logger.debug(\"sun.misc.Unsafe.copyMemory: available\");\n                } else {\n                    // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.\n                    unsafe = null;\n                }\n            }\n            if (unsafe != null) {\n                //测试通过Unsafe获取DirectByteBuffer.address()可用\n                final Unsafe finalUnsafe = unsafe;\n                final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                    @Override\n                    public Object run() {\n                        try {\n                            final Field field = Buffer.class.getDeclaredField(\"address\");\n                            final long offset = finalUnsafe.objectFieldOffset(field);\n                            final long address = finalUnsafe.getLong(direct, offset);\n                            if (address == 0) {\n                                return null;\n                            }\n                            return field;\n                        } catch (NoSuchFieldException e) {\n                           ......\n                        }\n                    }\n                });\n                if (maybeAddressField instanceof Field) {\n                    addressField = (Field) maybeAddressField;\n                } else {\n                    unsafe = null;\n                }\n            }\n            if (unsafe != null) {\n                long byteArrayIndexScale = unsafe.arrayIndexScale(byte[].class);\n                if (byteArrayIndexScale != 1) {\n                    unsafe = null;\n                }\n            }\n        }\n        UNSAFE = unsafe;\n        if (unsafe == null) {\n            ADDRESS_FIELD_OFFSET = -1;\n            BYTE_ARRAY_BASE_OFFSET = -1;\n            UNALIGNED = false;\n            DIRECT_BUFFER_CONSTRUCTOR = null;\n            ALLOCATE_ARRAY_METHOD = null;\n        } else {\n            //构建通过private DirectByteBuffer(long addr, int cap)获取DirectByteBuffer对象的构造体\n            Constructor<?> directBufferConstructor;\n            long address = -1;\n            try {\n                //返回的是DirectByteBuff的构造器\n                final Object maybeDirectBufferConstructor =\n                        AccessController.doPrivileged(new PrivilegedAction<Object>() {\n                            @Override\n                            public Object run() {\n                                try {\n                                    final Constructor<?> constructor =  //对应DirectByteBuffer(long addr, int cap)\n                                            direct.getClass().getDeclaredConstructor(long.class, int.class);\n                                    Throwable cause = ReflectionUtil.trySetAccessible(constructor);\n                                    if (cause != null) {\n                                        return cause;\n                                    }\n                                    return constructor;\n                                } catch (NoSuchMethodException e) {\n                                    return e;\n                                } catch (SecurityException e) {\n                                    return e;\n                                }\n                            }\n                        });\n                if (maybeDirectBufferConstructor instanceof Constructor<?>) {\n                    address = UNSAFE.allocateMemory(1);\n                    try {\n                         //这里是尝试产生一个直接内存测试一用\n                        ((Constructor<?>) maybeDirectBufferConstructor).newInstance(address, 1);\n                        directBufferConstructor = (Constructor<?>) maybeDirectBufferConstructor;\n                    } catch (InstantiationException e) {\n                        directBufferConstructor = null;\n                        ......\n                    }\n                } else {\n                    directBufferConstructor = null;\n                }\n            } finally {\n                if (address != -1) {\n                   //测试完成后再释放这个节点\n                    UNSAFE.freeMemory(address);\n                }\n            }\n            DIRECT_BUFFER_CONSTRUCTOR = directBufferConstructor;\n            ADDRESS_FIELD_OFFSET = objectFieldOffset(addressField);\n            BYTE_ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);\n        }\n    }\n```\n# 直接内存的释放\n当数据通过channel发送出去后(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码二(编码)分析</a>), 然后就开始准备着释放直接内存\n```\n      // Release the fully written buffers, and update the indexes of the partially written buffer.\n     in.removeBytes(writtenBytes); //释放内存资源\n```\n最后调用的remove():\n```\n     public boolean remove() {\n        Entry e = flushedEntry;\n        if (e == null) {\n            clearNioBuffers();\n            return false;\n        }\n        Object msg = e.msg; //PooledUnsafeDirectByteBuf\n        ChannelPromise promise = e.promise;\n        int size = e.pendingSize;\n        removeEntry(e);\n        if (!e.cancelled) {\n            // only release message, notify and decrement if it was not canceled before.\n            ReferenceCountUtil.safeRelease(msg); //释放了直接内存地址，\n            safeSuccess(promise);\n            decrementPendingOutboundBytes(size, false, true);\n        }\n        // recycle the entry\n        e.recycle(); //释放Entry\n        return true;\n    }\n```\nremove主要做了三件事:\n+ 调用removeEntry(e)清理ChannelOutboundBuffer里面的缓存链表。\n+ 调用ReferenceCountUtil.safeRelease(msg)释放该对象的引用次数, 当引用次数为0时, 那么将直接调用PooledByteBuf.deallocate()释放该ByteBuffer。\n+ 调用e.recycle()来回收Entry(原理见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%9dsdsdsdsd8%85%E8%AF%BB/\">Ndsdsdsd源码二(编码)分析</a>)\n```\n    protected final void deallocate() {\n        if (handle >= 0) {\n            final long handle = this.handle;\n            this.handle = -1;\n            memory = null;\n            tmpNioBuf = null;\n            chunk.arena.free(chunk, handle, maxLength, cache);\n            chunk = null;\n            recycle(); //释放\n        }\n    }\n```\n主要做了两件事:\n+ 释放直接内存DirectByteBuffer占用的内存。\n+ 释放PooledUnsafeDirectByteBuf对象, 使其回收进入对象池以便下次继续使用该对象。\n我们接着看area.free()是怎么操作的\n```\n    void free(PoolChunk<T> chunk, long handle, int normCapacity, PoolThreadCache cache) {\n        if (chunk.unpooled) {\n            int size = chunk.chunkSize();\n            destroyChunk(chunk);\n            activeBytesHuge.add(-size);\n            deallocationsHuge.increment();\n        } else {\n            SizeClass sizeClass = sizeClass(normCapacity);\n            if (cache != null && cache.add(this, chunk, handle, normCapacity, sizeClass)) {  //放入该cache的缓存队列\n                // cached so not free it.\n                return;\n            }\n\n            freeChunk(chunk, handle, sizeClass);\n        }\n    }\n```\n这里做判断, 针对该对象是否池化做了不同判断:\n+ 针对非池化内存, 直接将该内存块给释放了\n+ 针对池化内存:\n1. 检查内存属性为tiny、small、normal中的一种\n2. 查找是否有该属性的缓存, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>我们知道, 缓存的范围只在[16B, 32kB]之间, 若内存块在这范围之内, 则将内存块放入对应的缓存中\n3. 若内存块>32KB, 那么将调用freeChunk()该内存块释放到公共内存池中。\n```\nvoid freeChunk(PoolChunk<T> chunk, long handle, SizeClass sizeClass) {\n        final boolean destroyChunk;\n        synchronized (this) {\n            destroyChunk = !chunk.parent.free(chunk, handle);\n        }\n        if (destroyChunk) {\n            // destroyChunk not need to be called while holding the synchronized lock.\n            destroyChunk(chunk);\n        }\n    }\n```\nfreeChunk做了如下检查:\n调用free来释放PoolChunkList中对应的节点\n```\n    boolean free(PoolChunk<T> chunk, long handle) {\n        chunk.free(handle);\n        if (chunk.usage() < minUsage) {\n            //若当前PoolChunk使用率不满足当前链节点最低使用率要求, 从当前PoolchunkList中删掉chunk\n            remove(chunk);\n            // 根据目前PoolChunk使用率, 逐次检查q100->qinit的节点, 直到找到一个满足条件的节点\n            return move0(chunk);\n        }\n        return true;\n    }\n     private boolean move0(PoolChunk<T> chunk) {\n         //若找到当前链节点是qinit链， 那么说明该节点使用为0, PoolChunk对应的16MB内存完全空闲, 将会释放该直接内存块\n        if (prevList == null) {\n            // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and\n            // all memory associated with the PoolChunk will be released.\n            assert chunk.usage() == 0;\n            return false;\n        }\n        return prevList.move(chunk); //移动到前面的链中\n    }\n```\n释放PoolChunk对应的16M的内存块的过程如下:\n```\n        protected void destroyChunk(PoolChunk<ByteBuffer> chunk) {\n            if (PlatformDependent.useDirectBufferNoCleaner()) {\n                //将直接通过显示调用UNSAFE.freeMemory(address)方式释放内存, 并修改DIRECT_MEMORY_COUNTER值\n                PlatformDependent.freeDirectNoCleaner(chunk.memory);\n            } else {\n                //如果用cleaner回收内存, 将调用CleanerJava6.freeDirectBuffer()释放内存\n                PlatformDependent.freeDirectBuffer(chunk.memory);\n            }\n        }\n```\n# 总结\n整个netty池化内存回收过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收.png\" height=\"400\" width=\"990\"/>\nnetty默认释放管理直接内存方式与DirectByteBuffer默认释放内存的方式不一致, 释放时会依次检查缓存、公共内存池, 若Poolchunk使用率为0, 那么16M直接内存将直接释放。","slug":"Netty内存回收原理解读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8x6000rphu5kobaor3t","content":"<p>Netty堆外内存通过DirectByteBuffer实现管理, 它会首先申请16M的直接内存块大小, 放入DirectByteBuffer, 由PoolChunk映射这16MB的内存块, 通过PoolChunk的分配来完成该直接内存块使用与释放。 每当用户申请小块内存时, 都从这16M的内存中分配, 当该部分内存使用完后, 会释放到PoolChunk内存池中, 而不是彻底释放。 可以看出, netty每次释放直接内存并没有使用DirectByteBuffer自带Cleaner来释放(具体可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/27/DirectByteBuffer%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\">DirectByteBuffer堆外内存详解</a>), 使用PoolChunk管理直接内存的使用情况的好处也是很清晰的: 直接申请与释放堆外内存是个很大的开销, 若通过PoolChunk管理直接内存使用后, 可以循环使用该部分直接内存, 这样才能满足netty的高性能特性。 本文将讲述netty释放直接内存的原理及细节。<br>而DirectByteBuffer封装在PooledUnsafeDirectByteBuf, netty层面也主要操作后者, 两者的关系图如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收1.png\" height=\"250\" width=\"350\"><br>了解这两者对应关系, 对理解该文有一定的帮助。</p>\n<h1 id=\"PlatformDependent及PlatformDependent0简介\"><a href=\"#PlatformDependent及PlatformDependent0简介\" class=\"headerlink\" title=\"PlatformDependent及PlatformDependent0简介\"></a>PlatformDependent及PlatformDependent0简介</h1><p>PlatformDependent及PlatformDependent0主要是用来确定重要参数配置的, 比如netty是否需要使用Unsfa, 当前使用的java版本等, 了解这些参数变量, 有助于更方面了解直接内存的使用。</p>\n<h3 id=\"PlatformDependent\"><a href=\"#PlatformDependent\" class=\"headerlink\" title=\"PlatformDependent\"></a>PlatformDependent</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否有Unsafe, 拥有了Unsafe, 我们可以方便的操控直接内存,可以通过-Dio.netty.noUnsafe及-Dio.netty.tryUnsafe参数来决定, 默认是可以</div><div class=\"line\">private static final boolean HAS_UNSAFE = hasUnsafe0();</div><div class=\"line\">//用户优先使用堆外内存还是堆内内存, 通过-Dio.netty.noPreferDirect参数控制</div><div class=\"line\">private static final boolean DIRECT_BUFFER_PREFERRED =HAS_UNSAFE &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);</div><div class=\"line\">//当前netty能够使用的最大堆外内存, 默认与堆内内存相等</div><div class=\"line\">private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();</div><div class=\"line\"> //与unsafe结合可以直接获取任何堆内array对象的直接地址</div><div class=\"line\">private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();</div><div class=\"line\">//与unsafe结合可以获取任何对象的直接内存地址</div><div class=\"line\">private static final int ADDRESS_SIZE = addressSize0();</div><div class=\"line\"> //默认为true，则代表着netty将自己通过PoolCHunk来实现直接内存的回收与分配, 而不是使用DirectByteBuffer自带的功能来回收直接内存</div><div class=\"line\">private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;</div><div class=\"line\">//直接内存地址的使用量, 每次新申请和释放16M堆外内存, 都会统计到该变量中, 实际项目中, 我们可以通过反射拿到该变量值以观察堆外内存是否出现泄漏</div><div class=\"line\">private static final AtomicLong DIRECT_MEMORY_COUNTER;</div><div class=\"line\">//最大堆外内存</div><div class=\"line\">private static final long DIRECT_MEMORY_LIMIT;</div><div class=\"line\">private static final ThreadLocalRandomProvider RANDOM_PROVIDER;</div><div class=\"line\">//自己弄一个cleaner, 当16M内存被完全释放时, 会调用该变量完成。</div><div class=\"line\">private static final Cleaner CLEANER;</div><div class=\"line\">static &#123;</div><div class=\"line\">     ......</div><div class=\"line\">    long maxDirectMemory = SystemPropertyUtil.getLong(&quot;io.netty.maxDirectMemory&quot;, -1);</div><div class=\"line\">    //PlatformDependent0.hasDirectBufferNoCleanerConstructor()会检查可以通过反射+直接内存地址来构建DirectByteBuffer对象</div><div class=\"line\">    if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) &#123;</div><div class=\"line\">        USE_DIRECT_BUFFER_NO_CLEANER = false;</div><div class=\"line\">        DIRECT_MEMORY_COUNTER = null;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //代表释放DirectByteBuffer里面的直接内存, 不使用自带的cleaner机制, 通过UNSAFE.freeMemory(address)释放的。具体见PoolArea.destroyChunk()方法选择。</div><div class=\"line\">        USE_DIRECT_BUFFER_NO_CLEANER = true;</div><div class=\"line\">        if (maxDirectMemory &lt; 0) &#123;</div><div class=\"line\">            maxDirectMemory = maxDirectMemory0();</div><div class=\"line\">            if (maxDirectMemory &lt;= 0) &#123;</div><div class=\"line\">                DIRECT_MEMORY_COUNTER = null;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                DIRECT_MEMORY_COUNTER = new AtomicLong();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            DIRECT_MEMORY_COUNTER = new AtomicLong();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    DIRECT_MEMORY_LIMIT = maxDirectMemory;</div><div class=\"line\">    if (!isAndroid() &amp;&amp; hasUnsafe()) &#123;</div><div class=\"line\">        if (javaVersion() &gt;= 9) &#123;</div><div class=\"line\">            CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        CLEANER = NOOP;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看下CleanerJava6如何进行直接内存释放的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">final class CleanerJava6 implements Cleaner &#123;</div><div class=\"line\">    //随便产生了一个DircetByteBuff，里面的cleaner的直接内存地址</div><div class=\"line\">    private static final long CLEANER_FIELD_OFFSET;</div><div class=\"line\">    //DircetByteBuff中cleaner的直接内存地址</div><div class=\"line\">    private static final Method CLEAN_METHOD;</div><div class=\"line\">    static &#123;</div><div class=\"line\">        long fieldOffset = -1;</div><div class=\"line\">        Method clean = null;</div><div class=\"line\">        Throwable error = null;</div><div class=\"line\">        if (PlatformDependent0.hasUnsafe()) &#123;</div><div class=\"line\">            //先产生一个DirectByteBuffer</div><div class=\"line\">            ByteBuffer direct = ByteBuffer.allocateDirect(1);</div><div class=\"line\">            try &#123;</div><div class=\"line\">            //根据反射, 获取到该对象的cleaner域</div><div class=\"line\">                Field cleanerField = direct.getClass().getDeclaredField(&quot;cleaner&quot;);</div><div class=\"line\">                fieldOffset = PlatformDependent0.objectFieldOffset(cleanerField);</div><div class=\"line\">                Object cleaner = PlatformDependent0.getObject(direct, fieldOffset);</div><div class=\"line\">                clean = cleaner.getClass().getDeclaredMethod(&quot;clean&quot;);</div><div class=\"line\">                //调用clean，测试回收DirectByteBuffer里面的直接内存</div><div class=\"line\">                clean.invoke(cleaner);</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                // We don&apos;t have ByteBuffer.cleaner().</div><div class=\"line\">                fieldOffset = -1;</div><div class=\"line\">                clean = null;</div><div class=\"line\">                error = t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            error = new UnsupportedOperationException(&quot;sun.misc.Unsafe unavailable&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (error == null) &#123;</div><div class=\"line\">            logger.debug(&quot;java.nio.ByteBuffer.cleaner(): available&quot;);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            logger.debug(&quot;java.nio.ByteBuffer.cleaner(): unavailable&quot;, error);</div><div class=\"line\">        &#125;</div><div class=\"line\">        CLEANER_FIELD_OFFSET = fieldOffset; //DircetByteBuff中cleaner的直接内存地址</div><div class=\"line\">        CLEAN_METHOD = clean;   ////DircetByteBuff中cleaner的直接内存地址</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void freeDirectBuffer(ByteBuffer buffer) &#123;</div><div class=\"line\">        if (!buffer.isDirect()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            //获取该buffer里面的cleanerd对象</div><div class=\"line\">            Object cleaner = PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);</div><div class=\"line\">            if (cleaner != null) &#123;</div><div class=\"line\">                //主动调用clean()函数以回收该内存</div><div class=\"line\">                CLEAN_METHOD.invoke(cleaner);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable cause) &#123;</div><div class=\"line\">            PlatformDependent0.throwException(cause);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用CleanerJava6释放直接内存的一个前提就是存在cleaner成员变量, 当使用DirectByteBuffer(int cap)产生的DirectByteBuffer, 其cleaner才会存在。 而使用private DirectByteBuffer(long addr, int cap)则不会产生cleaner对象, 而netty默认使用后者产生DirectByteBuffer对象(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">allocateNormal.allocateDirect()</a>)。</p>\n<h3 id=\"PlatformDependent0\"><a href=\"#PlatformDependent0\" class=\"headerlink\" title=\"PlatformDependent0\"></a>PlatformDependent0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div></pre></td><td class=\"code\"><pre><div class=\"line\">//与Unsafe配合, 可以获取任何对象任何成员变量的值</div><div class=\"line\">private static final long ADDRESS_FIELD_OFFSET;</div><div class=\"line\">//可以通过该地址直接获取数组在内存中的初始地址， 参考https://www.jianshu.com/p/9819eb48716a</div><div class=\"line\">private static final long BYTE_ARRAY_BASE_OFFSET;</div><div class=\"line\">//DirectByteBuff对象构造器，参数包括直接内存address</div><div class=\"line\">private static final Constructor&lt;?&gt; DIRECT_BUFFER_CONSTRUCTOR;</div><div class=\"line\">//是否明确不让使用Unsafe</div><div class=\"line\">private static final boolean IS_EXPLICIT_NO_UNSAFE = explicitNoUnsafe0();</div><div class=\"line\">//通过Unsafe来控制直接内存</div><div class=\"line\">private static final Object INTERNAL_UNSAFE;</div><div class=\"line\">static final Unsafe UNSAFE;</div><div class=\"line\">private static final boolean UNALIGNED;</div><div class=\"line\">static &#123;</div><div class=\"line\">    final ByteBuffer direct;</div><div class=\"line\">    Field addressField = null;</div><div class=\"line\">    Method allocateArrayMethod = null;</div><div class=\"line\">    Unsafe unsafe;</div><div class=\"line\">    Object internalUnsafe = null;</div><div class=\"line\">    if (isExplicitNoUnsafe()) &#123;</div><div class=\"line\">        direct = null;</div><div class=\"line\">        addressField = null;</div><div class=\"line\">        unsafe = null;</div><div class=\"line\">        internalUnsafe = null;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //这里只是尝试分配一个内存</div><div class=\"line\">        direct = ByteBuffer.allocateDirect(1);</div><div class=\"line\">        // 尝试通过反射获取Unsafe对象</div><div class=\"line\">        final Object maybeUnsafe = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public Object run() &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    //反射， 强制获取该类属性</div><div class=\"line\">                    final Field unsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class=\"line\">                    Throwable cause = ReflectionUtil.trySetAccessible(unsafeField);</div><div class=\"line\">                    if (cause != null) &#123;</div><div class=\"line\">                        return cause;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // the unsafe instance</div><div class=\"line\">                    return unsafeField.get(null);</div><div class=\"line\">                &#125; catch (NoSuchFieldException e) &#123;</div><div class=\"line\">                    ......</div><div class=\"line\">                    return e;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        if (maybeUnsafe instanceof Exception) &#123;</div><div class=\"line\">            unsafe = null;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            unsafe = (Unsafe) maybeUnsafe;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //检车copyMemory可用</div><div class=\"line\">        if (unsafe != null) &#123;</div><div class=\"line\">            final Unsafe finalUnsafe = unsafe;</div><div class=\"line\">            final Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public Object run() &#123;</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        finalUnsafe.getClass().getDeclaredMethod(</div><div class=\"line\">                                &quot;copyMemory&quot;, Object.class, long.class, Object.class, long.class, long.class);</div><div class=\"line\">                        return null;</div><div class=\"line\">                    &#125; catch (NoSuchMethodException e) &#123;</div><div class=\"line\">                        ......</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            if (maybeException == null) &#123;</div><div class=\"line\">                logger.debug(&quot;sun.misc.Unsafe.copyMemory: available&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.</div><div class=\"line\">                unsafe = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (unsafe != null) &#123;</div><div class=\"line\">            //测试通过Unsafe获取DirectByteBuffer.address()可用</div><div class=\"line\">            final Unsafe finalUnsafe = unsafe;</div><div class=\"line\">            final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public Object run() &#123;</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        final Field field = Buffer.class.getDeclaredField(&quot;address&quot;);</div><div class=\"line\">                        final long offset = finalUnsafe.objectFieldOffset(field);</div><div class=\"line\">                        final long address = finalUnsafe.getLong(direct, offset);</div><div class=\"line\">                        if (address == 0) &#123;</div><div class=\"line\">                            return null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        return field;</div><div class=\"line\">                    &#125; catch (NoSuchFieldException e) &#123;</div><div class=\"line\">                       ......</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            if (maybeAddressField instanceof Field) &#123;</div><div class=\"line\">                addressField = (Field) maybeAddressField;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                unsafe = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (unsafe != null) &#123;</div><div class=\"line\">            long byteArrayIndexScale = unsafe.arrayIndexScale(byte[].class);</div><div class=\"line\">            if (byteArrayIndexScale != 1) &#123;</div><div class=\"line\">                unsafe = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    UNSAFE = unsafe;</div><div class=\"line\">    if (unsafe == null) &#123;</div><div class=\"line\">        ADDRESS_FIELD_OFFSET = -1;</div><div class=\"line\">        BYTE_ARRAY_BASE_OFFSET = -1;</div><div class=\"line\">        UNALIGNED = false;</div><div class=\"line\">        DIRECT_BUFFER_CONSTRUCTOR = null;</div><div class=\"line\">        ALLOCATE_ARRAY_METHOD = null;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //构建通过private DirectByteBuffer(long addr, int cap)获取DirectByteBuffer对象的构造体</div><div class=\"line\">        Constructor&lt;?&gt; directBufferConstructor;</div><div class=\"line\">        long address = -1;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            //返回的是DirectByteBuff的构造器</div><div class=\"line\">            final Object maybeDirectBufferConstructor =</div><div class=\"line\">                    AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public Object run() &#123;</div><div class=\"line\">                            try &#123;</div><div class=\"line\">                                final Constructor&lt;?&gt; constructor =  //对应DirectByteBuffer(long addr, int cap)</div><div class=\"line\">                                        direct.getClass().getDeclaredConstructor(long.class, int.class);</div><div class=\"line\">                                Throwable cause = ReflectionUtil.trySetAccessible(constructor);</div><div class=\"line\">                                if (cause != null) &#123;</div><div class=\"line\">                                    return cause;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                return constructor;</div><div class=\"line\">                            &#125; catch (NoSuchMethodException e) &#123;</div><div class=\"line\">                                return e;</div><div class=\"line\">                            &#125; catch (SecurityException e) &#123;</div><div class=\"line\">                                return e;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">            if (maybeDirectBufferConstructor instanceof Constructor&lt;?&gt;) &#123;</div><div class=\"line\">                address = UNSAFE.allocateMemory(1);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                     //这里是尝试产生一个直接内存测试一用</div><div class=\"line\">                    ((Constructor&lt;?&gt;) maybeDirectBufferConstructor).newInstance(address, 1);</div><div class=\"line\">                    directBufferConstructor = (Constructor&lt;?&gt;) maybeDirectBufferConstructor;</div><div class=\"line\">                &#125; catch (InstantiationException e) &#123;</div><div class=\"line\">                    directBufferConstructor = null;</div><div class=\"line\">                    ......</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                directBufferConstructor = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            if (address != -1) &#123;</div><div class=\"line\">               //测试完成后再释放这个节点</div><div class=\"line\">                UNSAFE.freeMemory(address);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        DIRECT_BUFFER_CONSTRUCTOR = directBufferConstructor;</div><div class=\"line\">        ADDRESS_FIELD_OFFSET = objectFieldOffset(addressField);</div><div class=\"line\">        BYTE_ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"直接内存的释放\"><a href=\"#直接内存的释放\" class=\"headerlink\" title=\"直接内存的释放\"></a>直接内存的释放</h1><p>当数据通过channel发送出去后(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码二(编码)分析</a>), 然后就开始准备着释放直接内存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">in.removeBytes(writtenBytes); //释放内存资源</div></pre></td></tr></table></figure></p>\n<p>最后调用的remove():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public boolean remove() &#123;</div><div class=\"line\">    Entry e = flushedEntry;</div><div class=\"line\">    if (e == null) &#123;</div><div class=\"line\">        clearNioBuffers();</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Object msg = e.msg; //PooledUnsafeDirectByteBuf</div><div class=\"line\">    ChannelPromise promise = e.promise;</div><div class=\"line\">    int size = e.pendingSize;</div><div class=\"line\">    removeEntry(e);</div><div class=\"line\">    if (!e.cancelled) &#123;</div><div class=\"line\">        // only release message, notify and decrement if it was not canceled before.</div><div class=\"line\">        ReferenceCountUtil.safeRelease(msg); //释放了直接内存地址，</div><div class=\"line\">        safeSuccess(promise);</div><div class=\"line\">        decrementPendingOutboundBytes(size, false, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // recycle the entry</div><div class=\"line\">    e.recycle(); //释放Entry</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>remove主要做了三件事:</p>\n<ul>\n<li>调用removeEntry(e)清理ChannelOutboundBuffer里面的缓存链表。</li>\n<li>调用ReferenceCountUtil.safeRelease(msg)释放该对象的引用次数, 当引用次数为0时, 那么将直接调用PooledByteBuf.deallocate()释放该ByteBuffer。</li>\n<li>调用e.recycle()来回收Entry(原理见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%9dsdsdsdsd8%85%E8%AF%BB/\">Ndsdsdsd源码二(编码)分析</a>)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void deallocate() &#123;</div><div class=\"line\">    if (handle &gt;= 0) &#123;</div><div class=\"line\">        final long handle = this.handle;</div><div class=\"line\">        this.handle = -1;</div><div class=\"line\">        memory = null;</div><div class=\"line\">        tmpNioBuf = null;</div><div class=\"line\">        chunk.arena.free(chunk, handle, maxLength, cache);</div><div class=\"line\">        chunk = null;</div><div class=\"line\">        recycle(); //释放</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了两件事:</p>\n<ul>\n<li>释放直接内存DirectByteBuffer占用的内存。</li>\n<li>释放PooledUnsafeDirectByteBuf对象, 使其回收进入对象池以便下次继续使用该对象。<br>我们接着看area.free()是怎么操作的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">void free(PoolChunk&lt;T&gt; chunk, long handle, int normCapacity, PoolThreadCache cache) &#123;</div><div class=\"line\">    if (chunk.unpooled) &#123;</div><div class=\"line\">        int size = chunk.chunkSize();</div><div class=\"line\">        destroyChunk(chunk);</div><div class=\"line\">        activeBytesHuge.add(-size);</div><div class=\"line\">        deallocationsHuge.increment();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        SizeClass sizeClass = sizeClass(normCapacity);</div><div class=\"line\">        if (cache != null &amp;&amp; cache.add(this, chunk, handle, normCapacity, sizeClass)) &#123;  //放入该cache的缓存队列</div><div class=\"line\">            // cached so not free it.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        freeChunk(chunk, handle, sizeClass);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里做判断, 针对该对象是否池化做了不同判断:</p>\n<ul>\n<li>针对非池化内存, 直接将该内存块给释放了</li>\n<li>针对池化内存:</li>\n</ul>\n<ol>\n<li>检查内存属性为tiny、small、normal中的一种</li>\n<li>查找是否有该属性的缓存, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>我们知道, 缓存的范围只在[16B, 32kB]之间, 若内存块在这范围之内, 则将内存块放入对应的缓存中</li>\n<li>若内存块&gt;32KB, 那么将调用freeChunk()该内存块释放到公共内存池中。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">void freeChunk(PoolChunk&lt;T&gt; chunk, long handle, SizeClass sizeClass) &#123;</div><div class=\"line\">        final boolean destroyChunk;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            destroyChunk = !chunk.parent.free(chunk, handle);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (destroyChunk) &#123;</div><div class=\"line\">            // destroyChunk not need to be called while holding the synchronized lock.</div><div class=\"line\">            destroyChunk(chunk);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>freeChunk做了如下检查:<br>调用free来释放PoolChunkList中对应的节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean free(PoolChunk&lt;T&gt; chunk, long handle) &#123;</div><div class=\"line\">    chunk.free(handle);</div><div class=\"line\">    if (chunk.usage() &lt; minUsage) &#123;</div><div class=\"line\">        //若当前PoolChunk使用率不满足当前链节点最低使用率要求, 从当前PoolchunkList中删掉chunk</div><div class=\"line\">        remove(chunk);</div><div class=\"line\">        // 根据目前PoolChunk使用率, 逐次检查q100-&gt;qinit的节点, 直到找到一个满足条件的节点</div><div class=\"line\">        return move0(chunk);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\"> private boolean move0(PoolChunk&lt;T&gt; chunk) &#123;</div><div class=\"line\">     //若找到当前链节点是qinit链， 那么说明该节点使用为0, PoolChunk对应的16MB内存完全空闲, 将会释放该直接内存块</div><div class=\"line\">    if (prevList == null) &#123;</div><div class=\"line\">        // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and</div><div class=\"line\">        // all memory associated with the PoolChunk will be released.</div><div class=\"line\">        assert chunk.usage() == 0;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return prevList.move(chunk); //移动到前面的链中</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>释放PoolChunk对应的16M的内存块的过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void destroyChunk(PoolChunk&lt;ByteBuffer&gt; chunk) &#123;</div><div class=\"line\">    if (PlatformDependent.useDirectBufferNoCleaner()) &#123;</div><div class=\"line\">        //将直接通过显示调用UNSAFE.freeMemory(address)方式释放内存, 并修改DIRECT_MEMORY_COUNTER值</div><div class=\"line\">        PlatformDependent.freeDirectNoCleaner(chunk.memory);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //如果用cleaner回收内存, 将调用CleanerJava6.freeDirectBuffer()释放内存</div><div class=\"line\">        PlatformDependent.freeDirectBuffer(chunk.memory);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>整个netty池化内存回收过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收.png\" height=\"400\" width=\"990\"><br>netty默认释放管理直接内存方式与DirectByteBuffer默认释放内存的方式不一致, 释放时会依次检查缓存、公共内存池, 若Poolchunk使用率为0, 那么16M直接内存将直接释放。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Netty堆外内存通过DirectByteBuffer实现管理, 它会首先申请16M的直接内存块大小, 放入DirectByteBuffer, 由PoolChunk映射这16MB的内存块, 通过PoolChunk的分配来完成该直接内存块使用与释放。 每当用户申请小块内存时, 都从这16M的内存中分配, 当该部分内存使用完后, 会释放到PoolChunk内存池中, 而不是彻底释放。 可以看出, netty每次释放直接内存并没有使用DirectByteBuffer自带Cleaner来释放(具体可以参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/27/DirectByteBuffer%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98%E8%AF%A6%E8%A7%A3/\">DirectByteBuffer堆外内存详解</a>), 使用PoolChunk管理直接内存的使用情况的好处也是很清晰的: 直接申请与释放堆外内存是个很大的开销, 若通过PoolChunk管理直接内存使用后, 可以循环使用该部分直接内存, 这样才能满足netty的高性能特性。 本文将讲述netty释放直接内存的原理及细节。<br>而DirectByteBuffer封装在PooledUnsafeDirectByteBuf, netty层面也主要操作后者, 两者的关系图如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收1.png\" height=\"250\" width=\"350\"><br>了解这两者对应关系, 对理解该文有一定的帮助。</p>\n<h1 id=\"PlatformDependent及PlatformDependent0简介\"><a href=\"#PlatformDependent及PlatformDependent0简介\" class=\"headerlink\" title=\"PlatformDependent及PlatformDependent0简介\"></a>PlatformDependent及PlatformDependent0简介</h1><p>PlatformDependent及PlatformDependent0主要是用来确定重要参数配置的, 比如netty是否需要使用Unsfa, 当前使用的java版本等, 了解这些参数变量, 有助于更方面了解直接内存的使用。</p>\n<h3 id=\"PlatformDependent\"><a href=\"#PlatformDependent\" class=\"headerlink\" title=\"PlatformDependent\"></a>PlatformDependent</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">//是否有Unsafe, 拥有了Unsafe, 我们可以方便的操控直接内存,可以通过-Dio.netty.noUnsafe及-Dio.netty.tryUnsafe参数来决定, 默认是可以</div><div class=\"line\">private static final boolean HAS_UNSAFE = hasUnsafe0();</div><div class=\"line\">//用户优先使用堆外内存还是堆内内存, 通过-Dio.netty.noPreferDirect参数控制</div><div class=\"line\">private static final boolean DIRECT_BUFFER_PREFERRED =HAS_UNSAFE &amp;&amp; !SystemPropertyUtil.getBoolean(&quot;io.netty.noPreferDirect&quot;, false);</div><div class=\"line\">//当前netty能够使用的最大堆外内存, 默认与堆内内存相等</div><div class=\"line\">private static final long MAX_DIRECT_MEMORY = maxDirectMemory0();</div><div class=\"line\"> //与unsafe结合可以直接获取任何堆内array对象的直接地址</div><div class=\"line\">private static final long BYTE_ARRAY_BASE_OFFSET = byteArrayBaseOffset0();</div><div class=\"line\">//与unsafe结合可以获取任何对象的直接内存地址</div><div class=\"line\">private static final int ADDRESS_SIZE = addressSize0();</div><div class=\"line\"> //默认为true，则代表着netty将自己通过PoolCHunk来实现直接内存的回收与分配, 而不是使用DirectByteBuffer自带的功能来回收直接内存</div><div class=\"line\">private static final boolean USE_DIRECT_BUFFER_NO_CLEANER;</div><div class=\"line\">//直接内存地址的使用量, 每次新申请和释放16M堆外内存, 都会统计到该变量中, 实际项目中, 我们可以通过反射拿到该变量值以观察堆外内存是否出现泄漏</div><div class=\"line\">private static final AtomicLong DIRECT_MEMORY_COUNTER;</div><div class=\"line\">//最大堆外内存</div><div class=\"line\">private static final long DIRECT_MEMORY_LIMIT;</div><div class=\"line\">private static final ThreadLocalRandomProvider RANDOM_PROVIDER;</div><div class=\"line\">//自己弄一个cleaner, 当16M内存被完全释放时, 会调用该变量完成。</div><div class=\"line\">private static final Cleaner CLEANER;</div><div class=\"line\">static &#123;</div><div class=\"line\">     ......</div><div class=\"line\">    long maxDirectMemory = SystemPropertyUtil.getLong(&quot;io.netty.maxDirectMemory&quot;, -1);</div><div class=\"line\">    //PlatformDependent0.hasDirectBufferNoCleanerConstructor()会检查可以通过反射+直接内存地址来构建DirectByteBuffer对象</div><div class=\"line\">    if (maxDirectMemory == 0 || !hasUnsafe() || !PlatformDependent0.hasDirectBufferNoCleanerConstructor()) &#123;</div><div class=\"line\">        USE_DIRECT_BUFFER_NO_CLEANER = false;</div><div class=\"line\">        DIRECT_MEMORY_COUNTER = null;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //代表释放DirectByteBuffer里面的直接内存, 不使用自带的cleaner机制, 通过UNSAFE.freeMemory(address)释放的。具体见PoolArea.destroyChunk()方法选择。</div><div class=\"line\">        USE_DIRECT_BUFFER_NO_CLEANER = true;</div><div class=\"line\">        if (maxDirectMemory &lt; 0) &#123;</div><div class=\"line\">            maxDirectMemory = maxDirectMemory0();</div><div class=\"line\">            if (maxDirectMemory &lt;= 0) &#123;</div><div class=\"line\">                DIRECT_MEMORY_COUNTER = null;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                DIRECT_MEMORY_COUNTER = new AtomicLong();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            DIRECT_MEMORY_COUNTER = new AtomicLong();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    DIRECT_MEMORY_LIMIT = maxDirectMemory;</div><div class=\"line\">    if (!isAndroid() &amp;&amp; hasUnsafe()) &#123;</div><div class=\"line\">        if (javaVersion() &gt;= 9) &#123;</div><div class=\"line\">            CLEANER = CleanerJava9.isSupported() ? new CleanerJava9() : NOOP;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            CLEANER = CleanerJava6.isSupported() ? new CleanerJava6() : NOOP;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        CLEANER = NOOP;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们可以看下CleanerJava6如何进行直接内存释放的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">final class CleanerJava6 implements Cleaner &#123;</div><div class=\"line\">    //随便产生了一个DircetByteBuff，里面的cleaner的直接内存地址</div><div class=\"line\">    private static final long CLEANER_FIELD_OFFSET;</div><div class=\"line\">    //DircetByteBuff中cleaner的直接内存地址</div><div class=\"line\">    private static final Method CLEAN_METHOD;</div><div class=\"line\">    static &#123;</div><div class=\"line\">        long fieldOffset = -1;</div><div class=\"line\">        Method clean = null;</div><div class=\"line\">        Throwable error = null;</div><div class=\"line\">        if (PlatformDependent0.hasUnsafe()) &#123;</div><div class=\"line\">            //先产生一个DirectByteBuffer</div><div class=\"line\">            ByteBuffer direct = ByteBuffer.allocateDirect(1);</div><div class=\"line\">            try &#123;</div><div class=\"line\">            //根据反射, 获取到该对象的cleaner域</div><div class=\"line\">                Field cleanerField = direct.getClass().getDeclaredField(&quot;cleaner&quot;);</div><div class=\"line\">                fieldOffset = PlatformDependent0.objectFieldOffset(cleanerField);</div><div class=\"line\">                Object cleaner = PlatformDependent0.getObject(direct, fieldOffset);</div><div class=\"line\">                clean = cleaner.getClass().getDeclaredMethod(&quot;clean&quot;);</div><div class=\"line\">                //调用clean，测试回收DirectByteBuffer里面的直接内存</div><div class=\"line\">                clean.invoke(cleaner);</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                // We don&apos;t have ByteBuffer.cleaner().</div><div class=\"line\">                fieldOffset = -1;</div><div class=\"line\">                clean = null;</div><div class=\"line\">                error = t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            error = new UnsupportedOperationException(&quot;sun.misc.Unsafe unavailable&quot;);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (error == null) &#123;</div><div class=\"line\">            logger.debug(&quot;java.nio.ByteBuffer.cleaner(): available&quot;);</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            logger.debug(&quot;java.nio.ByteBuffer.cleaner(): unavailable&quot;, error);</div><div class=\"line\">        &#125;</div><div class=\"line\">        CLEANER_FIELD_OFFSET = fieldOffset; //DircetByteBuff中cleaner的直接内存地址</div><div class=\"line\">        CLEAN_METHOD = clean;   ////DircetByteBuff中cleaner的直接内存地址</div><div class=\"line\">    &#125;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void freeDirectBuffer(ByteBuffer buffer) &#123;</div><div class=\"line\">        if (!buffer.isDirect()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            //获取该buffer里面的cleanerd对象</div><div class=\"line\">            Object cleaner = PlatformDependent0.getObject(buffer, CLEANER_FIELD_OFFSET);</div><div class=\"line\">            if (cleaner != null) &#123;</div><div class=\"line\">                //主动调用clean()函数以回收该内存</div><div class=\"line\">                CLEAN_METHOD.invoke(cleaner);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable cause) &#123;</div><div class=\"line\">            PlatformDependent0.throwException(cause);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用CleanerJava6释放直接内存的一个前提就是存在cleaner成员变量, 当使用DirectByteBuffer(int cap)产生的DirectByteBuffer, 其cleaner才会存在。 而使用private DirectByteBuffer(long addr, int cap)则不会产生cleaner对象, 而netty默认使用后者产生DirectByteBuffer对象(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">allocateNormal.allocateDirect()</a>)。</p>\n<h3 id=\"PlatformDependent0\"><a href=\"#PlatformDependent0\" class=\"headerlink\" title=\"PlatformDependent0\"></a>PlatformDependent0</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div></pre></td><td class=\"code\"><pre><div class=\"line\">//与Unsafe配合, 可以获取任何对象任何成员变量的值</div><div class=\"line\">private static final long ADDRESS_FIELD_OFFSET;</div><div class=\"line\">//可以通过该地址直接获取数组在内存中的初始地址， 参考https://www.jianshu.com/p/9819eb48716a</div><div class=\"line\">private static final long BYTE_ARRAY_BASE_OFFSET;</div><div class=\"line\">//DirectByteBuff对象构造器，参数包括直接内存address</div><div class=\"line\">private static final Constructor&lt;?&gt; DIRECT_BUFFER_CONSTRUCTOR;</div><div class=\"line\">//是否明确不让使用Unsafe</div><div class=\"line\">private static final boolean IS_EXPLICIT_NO_UNSAFE = explicitNoUnsafe0();</div><div class=\"line\">//通过Unsafe来控制直接内存</div><div class=\"line\">private static final Object INTERNAL_UNSAFE;</div><div class=\"line\">static final Unsafe UNSAFE;</div><div class=\"line\">private static final boolean UNALIGNED;</div><div class=\"line\">static &#123;</div><div class=\"line\">    final ByteBuffer direct;</div><div class=\"line\">    Field addressField = null;</div><div class=\"line\">    Method allocateArrayMethod = null;</div><div class=\"line\">    Unsafe unsafe;</div><div class=\"line\">    Object internalUnsafe = null;</div><div class=\"line\">    if (isExplicitNoUnsafe()) &#123;</div><div class=\"line\">        direct = null;</div><div class=\"line\">        addressField = null;</div><div class=\"line\">        unsafe = null;</div><div class=\"line\">        internalUnsafe = null;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //这里只是尝试分配一个内存</div><div class=\"line\">        direct = ByteBuffer.allocateDirect(1);</div><div class=\"line\">        // 尝试通过反射获取Unsafe对象</div><div class=\"line\">        final Object maybeUnsafe = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public Object run() &#123;</div><div class=\"line\">                try &#123;</div><div class=\"line\">                    //反射， 强制获取该类属性</div><div class=\"line\">                    final Field unsafeField = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;);</div><div class=\"line\">                    Throwable cause = ReflectionUtil.trySetAccessible(unsafeField);</div><div class=\"line\">                    if (cause != null) &#123;</div><div class=\"line\">                        return cause;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // the unsafe instance</div><div class=\"line\">                    return unsafeField.get(null);</div><div class=\"line\">                &#125; catch (NoSuchFieldException e) &#123;</div><div class=\"line\">                    ......</div><div class=\"line\">                    return e;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        if (maybeUnsafe instanceof Exception) &#123;</div><div class=\"line\">            unsafe = null;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            unsafe = (Unsafe) maybeUnsafe;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //检车copyMemory可用</div><div class=\"line\">        if (unsafe != null) &#123;</div><div class=\"line\">            final Unsafe finalUnsafe = unsafe;</div><div class=\"line\">            final Object maybeException = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public Object run() &#123;</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        finalUnsafe.getClass().getDeclaredMethod(</div><div class=\"line\">                                &quot;copyMemory&quot;, Object.class, long.class, Object.class, long.class, long.class);</div><div class=\"line\">                        return null;</div><div class=\"line\">                    &#125; catch (NoSuchMethodException e) &#123;</div><div class=\"line\">                        ......</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            if (maybeException == null) &#123;</div><div class=\"line\">                logger.debug(&quot;sun.misc.Unsafe.copyMemory: available&quot;);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Unsafe.copyMemory(Object, long, Object, long, long) unavailable.</div><div class=\"line\">                unsafe = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (unsafe != null) &#123;</div><div class=\"line\">            //测试通过Unsafe获取DirectByteBuffer.address()可用</div><div class=\"line\">            final Unsafe finalUnsafe = unsafe;</div><div class=\"line\">            final Object maybeAddressField = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public Object run() &#123;</div><div class=\"line\">                    try &#123;</div><div class=\"line\">                        final Field field = Buffer.class.getDeclaredField(&quot;address&quot;);</div><div class=\"line\">                        final long offset = finalUnsafe.objectFieldOffset(field);</div><div class=\"line\">                        final long address = finalUnsafe.getLong(direct, offset);</div><div class=\"line\">                        if (address == 0) &#123;</div><div class=\"line\">                            return null;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        return field;</div><div class=\"line\">                    &#125; catch (NoSuchFieldException e) &#123;</div><div class=\"line\">                       ......</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">            if (maybeAddressField instanceof Field) &#123;</div><div class=\"line\">                addressField = (Field) maybeAddressField;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                unsafe = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (unsafe != null) &#123;</div><div class=\"line\">            long byteArrayIndexScale = unsafe.arrayIndexScale(byte[].class);</div><div class=\"line\">            if (byteArrayIndexScale != 1) &#123;</div><div class=\"line\">                unsafe = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    UNSAFE = unsafe;</div><div class=\"line\">    if (unsafe == null) &#123;</div><div class=\"line\">        ADDRESS_FIELD_OFFSET = -1;</div><div class=\"line\">        BYTE_ARRAY_BASE_OFFSET = -1;</div><div class=\"line\">        UNALIGNED = false;</div><div class=\"line\">        DIRECT_BUFFER_CONSTRUCTOR = null;</div><div class=\"line\">        ALLOCATE_ARRAY_METHOD = null;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //构建通过private DirectByteBuffer(long addr, int cap)获取DirectByteBuffer对象的构造体</div><div class=\"line\">        Constructor&lt;?&gt; directBufferConstructor;</div><div class=\"line\">        long address = -1;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            //返回的是DirectByteBuff的构造器</div><div class=\"line\">            final Object maybeDirectBufferConstructor =</div><div class=\"line\">                    AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class=\"line\">                        @Override</div><div class=\"line\">                        public Object run() &#123;</div><div class=\"line\">                            try &#123;</div><div class=\"line\">                                final Constructor&lt;?&gt; constructor =  //对应DirectByteBuffer(long addr, int cap)</div><div class=\"line\">                                        direct.getClass().getDeclaredConstructor(long.class, int.class);</div><div class=\"line\">                                Throwable cause = ReflectionUtil.trySetAccessible(constructor);</div><div class=\"line\">                                if (cause != null) &#123;</div><div class=\"line\">                                    return cause;</div><div class=\"line\">                                &#125;</div><div class=\"line\">                                return constructor;</div><div class=\"line\">                            &#125; catch (NoSuchMethodException e) &#123;</div><div class=\"line\">                                return e;</div><div class=\"line\">                            &#125; catch (SecurityException e) &#123;</div><div class=\"line\">                                return e;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">            if (maybeDirectBufferConstructor instanceof Constructor&lt;?&gt;) &#123;</div><div class=\"line\">                address = UNSAFE.allocateMemory(1);</div><div class=\"line\">                try &#123;</div><div class=\"line\">                     //这里是尝试产生一个直接内存测试一用</div><div class=\"line\">                    ((Constructor&lt;?&gt;) maybeDirectBufferConstructor).newInstance(address, 1);</div><div class=\"line\">                    directBufferConstructor = (Constructor&lt;?&gt;) maybeDirectBufferConstructor;</div><div class=\"line\">                &#125; catch (InstantiationException e) &#123;</div><div class=\"line\">                    directBufferConstructor = null;</div><div class=\"line\">                    ......</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                directBufferConstructor = null;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            if (address != -1) &#123;</div><div class=\"line\">               //测试完成后再释放这个节点</div><div class=\"line\">                UNSAFE.freeMemory(address);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        DIRECT_BUFFER_CONSTRUCTOR = directBufferConstructor;</div><div class=\"line\">        ADDRESS_FIELD_OFFSET = objectFieldOffset(addressField);</div><div class=\"line\">        BYTE_ARRAY_BASE_OFFSET = UNSAFE.arrayBaseOffset(byte[].class);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"直接内存的释放\"><a href=\"#直接内存的释放\" class=\"headerlink\" title=\"直接内存的释放\"></a>直接内存的释放</h1><p>当数据通过channel发送出去后(见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码二(编码)分析</a>), 然后就开始准备着释放直接内存<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"> // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">in.removeBytes(writtenBytes); //释放内存资源</div></pre></td></tr></table></figure></p>\n<p>最后调用的remove():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public boolean remove() &#123;</div><div class=\"line\">    Entry e = flushedEntry;</div><div class=\"line\">    if (e == null) &#123;</div><div class=\"line\">        clearNioBuffers();</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Object msg = e.msg; //PooledUnsafeDirectByteBuf</div><div class=\"line\">    ChannelPromise promise = e.promise;</div><div class=\"line\">    int size = e.pendingSize;</div><div class=\"line\">    removeEntry(e);</div><div class=\"line\">    if (!e.cancelled) &#123;</div><div class=\"line\">        // only release message, notify and decrement if it was not canceled before.</div><div class=\"line\">        ReferenceCountUtil.safeRelease(msg); //释放了直接内存地址，</div><div class=\"line\">        safeSuccess(promise);</div><div class=\"line\">        decrementPendingOutboundBytes(size, false, true);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // recycle the entry</div><div class=\"line\">    e.recycle(); //释放Entry</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>remove主要做了三件事:</p>\n<ul>\n<li>调用removeEntry(e)清理ChannelOutboundBuffer里面的缓存链表。</li>\n<li>调用ReferenceCountUtil.safeRelease(msg)释放该对象的引用次数, 当引用次数为0时, 那么将直接调用PooledByteBuf.deallocate()释放该ByteBuffer。</li>\n<li>调用e.recycle()来回收Entry(原理见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/04/Netty-Http%E9%80%9A%E4%BF%A1%E7%BC%96%E7%A0%81%E6%BA%90%E7%A0%81%E9%9dsdsdsdsd8%85%E8%AF%BB/\">Ndsdsdsd源码二(编码)分析</a>)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final void deallocate() &#123;</div><div class=\"line\">    if (handle &gt;= 0) &#123;</div><div class=\"line\">        final long handle = this.handle;</div><div class=\"line\">        this.handle = -1;</div><div class=\"line\">        memory = null;</div><div class=\"line\">        tmpNioBuf = null;</div><div class=\"line\">        chunk.arena.free(chunk, handle, maxLength, cache);</div><div class=\"line\">        chunk = null;</div><div class=\"line\">        recycle(); //释放</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了两件事:</p>\n<ul>\n<li>释放直接内存DirectByteBuffer占用的内存。</li>\n<li>释放PooledUnsafeDirectByteBuf对象, 使其回收进入对象池以便下次继续使用该对象。<br>我们接着看area.free()是怎么操作的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">void free(PoolChunk&lt;T&gt; chunk, long handle, int normCapacity, PoolThreadCache cache) &#123;</div><div class=\"line\">    if (chunk.unpooled) &#123;</div><div class=\"line\">        int size = chunk.chunkSize();</div><div class=\"line\">        destroyChunk(chunk);</div><div class=\"line\">        activeBytesHuge.add(-size);</div><div class=\"line\">        deallocationsHuge.increment();</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        SizeClass sizeClass = sizeClass(normCapacity);</div><div class=\"line\">        if (cache != null &amp;&amp; cache.add(this, chunk, handle, normCapacity, sizeClass)) &#123;  //放入该cache的缓存队列</div><div class=\"line\">            // cached so not free it.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        freeChunk(chunk, handle, sizeClass);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里做判断, 针对该对象是否池化做了不同判断:</p>\n<ul>\n<li>针对非池化内存, 直接将该内存块给释放了</li>\n<li>针对池化内存:</li>\n</ul>\n<ol>\n<li>检查内存属性为tiny、small、normal中的一种</li>\n<li>查找是否有该属性的缓存, 在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>我们知道, 缓存的范围只在[16B, 32kB]之间, 若内存块在这范围之内, 则将内存块放入对应的缓存中</li>\n<li>若内存块&gt;32KB, 那么将调用freeChunk()该内存块释放到公共内存池中。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">void freeChunk(PoolChunk&lt;T&gt; chunk, long handle, SizeClass sizeClass) &#123;</div><div class=\"line\">        final boolean destroyChunk;</div><div class=\"line\">        synchronized (this) &#123;</div><div class=\"line\">            destroyChunk = !chunk.parent.free(chunk, handle);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (destroyChunk) &#123;</div><div class=\"line\">            // destroyChunk not need to be called while holding the synchronized lock.</div><div class=\"line\">            destroyChunk(chunk);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>freeChunk做了如下检查:<br>调用free来释放PoolChunkList中对应的节点<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean free(PoolChunk&lt;T&gt; chunk, long handle) &#123;</div><div class=\"line\">    chunk.free(handle);</div><div class=\"line\">    if (chunk.usage() &lt; minUsage) &#123;</div><div class=\"line\">        //若当前PoolChunk使用率不满足当前链节点最低使用率要求, 从当前PoolchunkList中删掉chunk</div><div class=\"line\">        remove(chunk);</div><div class=\"line\">        // 根据目前PoolChunk使用率, 逐次检查q100-&gt;qinit的节点, 直到找到一个满足条件的节点</div><div class=\"line\">        return move0(chunk);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div><div class=\"line\"> private boolean move0(PoolChunk&lt;T&gt; chunk) &#123;</div><div class=\"line\">     //若找到当前链节点是qinit链， 那么说明该节点使用为0, PoolChunk对应的16MB内存完全空闲, 将会释放该直接内存块</div><div class=\"line\">    if (prevList == null) &#123;</div><div class=\"line\">        // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and</div><div class=\"line\">        // all memory associated with the PoolChunk will be released.</div><div class=\"line\">        assert chunk.usage() == 0;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return prevList.move(chunk); //移动到前面的链中</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>释放PoolChunk对应的16M的内存块的过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void destroyChunk(PoolChunk&lt;ByteBuffer&gt; chunk) &#123;</div><div class=\"line\">    if (PlatformDependent.useDirectBufferNoCleaner()) &#123;</div><div class=\"line\">        //将直接通过显示调用UNSAFE.freeMemory(address)方式释放内存, 并修改DIRECT_MEMORY_COUNTER值</div><div class=\"line\">        PlatformDependent.freeDirectNoCleaner(chunk.memory);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        //如果用cleaner回收内存, 将调用CleanerJava6.freeDirectBuffer()释放内存</div><div class=\"line\">        PlatformDependent.freeDirectBuffer(chunk.memory);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>整个netty池化内存回收过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty堆外内存回收.png\" height=\"400\" width=\"990\"><br>netty默认释放管理直接内存方式与DirectByteBuffer默认释放内存的方式不一致, 释放时会依次检查缓存、公共内存池, 若Poolchunk使用率为0, 那么16M直接内存将直接释放。</p>\n"},{"title":"Netty PoolArea原理探究","date":"2018-05-23T14:31:13.000Z","toc":true,"_content":"# 简介\nNetty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存, 通过io.netty.noPreferDirect参数设置。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。\n## Pool和Unpool区别\n字面意思, 分别是池化内存和非池化内存。`池化内存`的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。`非池化内存`就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数`Dio.netty.allocator.type`确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。\n这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。\n# 内存分配\n线程调用如下接口来获取内存:\n```\n    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {\n        PoolThreadCache cache = threadCache.get();\n        PoolArena<ByteBuffer> directArena = cache.directArena;\n\n        final ByteBuf buf;\n        if (directArena != null) {\n            buf = directArena.allocate(cache, initialCapacity, maxCapacity);\n        } else {\n            buf = PlatformDependent.hasUnsafe() ?\n                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :\n                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);\n        }\n\n        return toLeakAwareBuffer(buf);\n    }\n```\n主要做的事:\n+ 获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>)\n+ 从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。\n\n# PoolArena\nPoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea.png\" height=\"400\" width=\"450\"/>\nnetty将池化内存块划分为3个类型:\n```\n    enum SizeClass {\n        Tiny,\n        Small,\n        Normal\n    }\n```\nTiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。\n大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。\n```\n    //tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块\n    static final int numTinySubpagePools = 512 >>> 4;\n    //全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT\n    final PooledByteBufAllocator parent;\n    // log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]\n    private final int maxOrder;\n    //默认8k\n    final int pageSize;\n    //log(8k) =  13\n    final int pageShifts;\n    //默认16M\n    final int chunkSize;\n    //-8192\n    final int subpageOverflowMask;\n    //指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]\n    final int numSmallSubpagePools;\n     //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] tinySubpagePools;\n     //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] smallSubpagePools;//存储1024-8096大小的内存\n     //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中\n    private final PoolChunkList<T> q050;\n    private final PoolChunkList<T> q025;   //存储内存利用率25-75%的chunk\n    private final PoolChunkList<T> q000;   //存储内存利用率1-50%的chunk\n    private final PoolChunkList<T> qInit;  //存储内存利用率0-25%的chunk\n    private final PoolChunkList<T> q075;    //存储内存利用率75-100%的chunk\n    private final PoolChunkList<T> q100;   //存储内存利用率100%的chunk\n\n    // Number of thread caches backed by this arena. 该PoolArea被多少线程引用。\n    final AtomicInteger numThreadCaches = new AtomicInteger();\n\n```\nPoolArea申请内存时根据申请的大小使用不同对象进行分配:\n+ tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。\n+ smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。\n+ q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。\n他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p>\n&nbsp;&nbsp;若q025中某个PoolChunk使用率大于25%之后, 该PoolChunk将别移动到q050中。\n&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。\n&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。\n&nbsp;&nbsp;若q000使用率为0, 会被释放掉。\n\nnumThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n\n## PoolArena的内存分配\n线程分配内存主要从两个地方分配: PoolThreadCache和PoolArena\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea1.png\" height=\"300\" width=\"350\"/>\n其中PoolThreadCache线程独享, PoolArena为几个线程共享。\nnetty真正申请内存时, 首先便是调用PoolArena.allocate()函数:\n```\n private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {\n        final int normCapacity = normalizeCapacity(reqCapacity);\n         // capacity < pageSize   小于8k\n        if (isTinyOrSmall(normCapacity)) {\n            int tableIdx;\n            PoolSubpage<T>[] table;\n            boolean tiny = isTiny(normCapacity);\n            if (tiny) { // < 512\n                 //若从缓冲中取得该值\n                if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = tinyIdx(normCapacity);\n                table = tinySubpagePools;\n            } else {  //small\n                if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = smallIdx(normCapacity);\n                table = smallSubpagePools;\n            }\n\n            final PoolSubpage<T> head = table[tableIdx];\n\n            /**\n             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and\n             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.\n             */\n             //小于8k的\n            synchronized (head) {\n                 //如果分配完会从当前级别链上去掉\n                final PoolSubpage<T> s = head.next;\n                 ///该型号的tiny的内存已经分配的有一个了\n                if (s != head) {\n                    assert s.doNotDestroy && s.elemSize == normCapacity;\n                    long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n                    assert handle >= 0;\n                    s.chunk.initBufWithSubpage(buf, handle, reqCapacity);\n                    incTinySmallAllocation(tiny);\n                    return;//如果从链中找到就返回，\n                }\n            }\n            //没有找到的话，就从Poolpage中分一个\n            synchronized (this) {\n                //说明head并没有分配值，是第一次分配。\n                allocateNormal(buf, reqCapacity, normCapacity);\n            }\n\n            incTinySmallAllocation(tiny);\n            return;\n        }\n        if (normCapacity <= chunkSize) { //小于16M\n            if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {  //cache=PoolThreadCache,本地是否已经有了\n                // was able to allocate out of the cache so move on\n                return;\n            }\n            synchronized (this) {\n                allocateNormal(buf, reqCapacity, normCapacity);\n                ++allocationsNormal;\n            }\n        } else {\n            // Huge allocations are never served via the cache so just call allocateHuge\n            allocateHuge(buf, reqCapacity); //大于16M，则分配大内存\n        }\n    }\n\n```\n\nPoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:\n1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,..., 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。\n2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:\n+ 首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n+ 若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:\n```\n    static int tinyIdx(int normCapacity) {  //申请内容小于512，下标\n        return normCapacity >>> 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了\n    }\n    static int smallIdx(int normCapacity) {\n        int tableIdx = 0;\n        int i = normCapacity >>> 10; //首先是512 = 2^10\n        while (i != 0) {\n            i >>>= 1;\n            tableIdx ++;\n        }\n        return tableIdx;\n```\n可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。\n+ 检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。\n+ 若没有可分配的内存, 则会进入allocateNormal进行分配\n3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。\n4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。\n### 分配[16b, 16m]内存\n接着上述过程, 会进入allocateNormal进行内存分配\n```\nprivate void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||\n            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||\n            q075.allocate(buf, reqCapacity, normCapacity)) {\n            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存\n        }\n        //跑到Direct里面newChunk了, 将 产生第一个chunk\n        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树\n        PoolChunk<T> c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中\n        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256\n        assert handle > 0;\n        c.initBuf(buf, handle, reqCapacity);\n        qInit.add(c); //第一次分配的话，都会放入qInit\n    }\n```\n1. 首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:\n```\n    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (head == null || normCapacity > maxCapacity) { //head是可以直接寸数据的\n            // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can\n            // be handled by the PoolChunks that are contained in this PoolChunkList.\n            return false;\n        }\n        for (PoolChunk<T> cur = head;;) {\n            long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值\n            if (handle < 0) { //在poolchunk中没有找到能装得下的，那么继续找下一个\n                cur = cur.next;\n                if (cur == null) {\n                    return false;\n                }\n            } else {\n                cur.initBuf(buf, handle, reqCapacity);\n                if (cur.usage() >= maxUsage) {//chunked量用超了则移动向下一个链\n                    remove(cur);\n                    nextList.add(cur);\n                }\n                return true;\n            }\n        }\n    }\n```\n会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。\n2. 若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>\n3. 对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。\n这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:\n+ 将PoolChunk分配维持在较高的比例上。\n+ 保存一些空闲度比较大的内存, 以便大内存的分配。\n\n# 总结\n非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.\n","source":"_posts/Netty内存学习.md","raw":"---\ntitle: Netty PoolArea原理探究\ndate: 2018-05-23 22:31:13\ntags: PoolArena\ntoc: true\n---\n# 简介\nNetty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存, 通过io.netty.noPreferDirect参数设置。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。\n## Pool和Unpool区别\n字面意思, 分别是池化内存和非池化内存。`池化内存`的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。`非池化内存`就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数`Dio.netty.allocator.type`确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。\n这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。\n# 内存分配\n线程调用如下接口来获取内存:\n```\n    protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) {\n        PoolThreadCache cache = threadCache.get();\n        PoolArena<ByteBuffer> directArena = cache.directArena;\n\n        final ByteBuf buf;\n        if (directArena != null) {\n            buf = directArena.allocate(cache, initialCapacity, maxCapacity);\n        } else {\n            buf = PlatformDependent.hasUnsafe() ?\n                    UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :\n                    new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);\n        }\n\n        return toLeakAwareBuffer(buf);\n    }\n```\n主要做的事:\n+ 获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>)\n+ 从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。\n\n# PoolArena\nPoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea.png\" height=\"400\" width=\"450\"/>\nnetty将池化内存块划分为3个类型:\n```\n    enum SizeClass {\n        Tiny,\n        Small,\n        Normal\n    }\n```\nTiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。\n大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。\n```\n    //tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块\n    static final int numTinySubpagePools = 512 >>> 4;\n    //全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT\n    final PooledByteBufAllocator parent;\n    // log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]\n    private final int maxOrder;\n    //默认8k\n    final int pageSize;\n    //log(8k) =  13\n    final int pageShifts;\n    //默认16M\n    final int chunkSize;\n    //-8192\n    final int subpageOverflowMask;\n    //指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]\n    final int numSmallSubpagePools;\n     //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] tinySubpagePools;\n     //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块\n    private final PoolSubpage<T>[] smallSubpagePools;//存储1024-8096大小的内存\n     //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中\n    private final PoolChunkList<T> q050;\n    private final PoolChunkList<T> q025;   //存储内存利用率25-75%的chunk\n    private final PoolChunkList<T> q000;   //存储内存利用率1-50%的chunk\n    private final PoolChunkList<T> qInit;  //存储内存利用率0-25%的chunk\n    private final PoolChunkList<T> q075;    //存储内存利用率75-100%的chunk\n    private final PoolChunkList<T> q100;   //存储内存利用率100%的chunk\n\n    // Number of thread caches backed by this arena. 该PoolArea被多少线程引用。\n    final AtomicInteger numThreadCaches = new AtomicInteger();\n\n```\nPoolArea申请内存时根据申请的大小使用不同对象进行分配:\n+ tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。\n+ smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。\n+ q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。\n他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p>\n&nbsp;&nbsp;若q025中某个PoolChunk使用率大于25%之后, 该PoolChunk将别移动到q050中。\n&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。\n&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。\n&nbsp;&nbsp;若q000使用率为0, 会被释放掉。\n\nnumThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n\n## PoolArena的内存分配\n线程分配内存主要从两个地方分配: PoolThreadCache和PoolArena\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea1.png\" height=\"300\" width=\"350\"/>\n其中PoolThreadCache线程独享, PoolArena为几个线程共享。\nnetty真正申请内存时, 首先便是调用PoolArena.allocate()函数:\n```\n private void allocate(PoolThreadCache cache, PooledByteBuf<T> buf, final int reqCapacity) {\n        final int normCapacity = normalizeCapacity(reqCapacity);\n         // capacity < pageSize   小于8k\n        if (isTinyOrSmall(normCapacity)) {\n            int tableIdx;\n            PoolSubpage<T>[] table;\n            boolean tiny = isTiny(normCapacity);\n            if (tiny) { // < 512\n                 //若从缓冲中取得该值\n                if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = tinyIdx(normCapacity);\n                table = tinySubpagePools;\n            } else {  //small\n                if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) {\n                    // was able to allocate out of the cache so move on\n                    return;\n                }\n                tableIdx = smallIdx(normCapacity);\n                table = smallSubpagePools;\n            }\n\n            final PoolSubpage<T> head = table[tableIdx];\n\n            /**\n             * Synchronize on the head. This is needed as {@link PoolChunk#allocateSubpage(int)} and\n             * {@link PoolChunk#free(long)} may modify the doubly linked list as well.\n             */\n             //小于8k的\n            synchronized (head) {\n                 //如果分配完会从当前级别链上去掉\n                final PoolSubpage<T> s = head.next;\n                 ///该型号的tiny的内存已经分配的有一个了\n                if (s != head) {\n                    assert s.doNotDestroy && s.elemSize == normCapacity;\n                    long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点\n                    assert handle >= 0;\n                    s.chunk.initBufWithSubpage(buf, handle, reqCapacity);\n                    incTinySmallAllocation(tiny);\n                    return;//如果从链中找到就返回，\n                }\n            }\n            //没有找到的话，就从Poolpage中分一个\n            synchronized (this) {\n                //说明head并没有分配值，是第一次分配。\n                allocateNormal(buf, reqCapacity, normCapacity);\n            }\n\n            incTinySmallAllocation(tiny);\n            return;\n        }\n        if (normCapacity <= chunkSize) { //小于16M\n            if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) {  //cache=PoolThreadCache,本地是否已经有了\n                // was able to allocate out of the cache so move on\n                return;\n            }\n            synchronized (this) {\n                allocateNormal(buf, reqCapacity, normCapacity);\n                ++allocationsNormal;\n            }\n        } else {\n            // Huge allocations are never served via the cache so just call allocateHuge\n            allocateHuge(buf, reqCapacity); //大于16M，则分配大内存\n        }\n    }\n\n```\n\nPoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:\n1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,..., 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。\n2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:\n+ 首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>\n+ 若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:\n```\n    static int tinyIdx(int normCapacity) {  //申请内容小于512，下标\n        return normCapacity >>> 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了\n    }\n    static int smallIdx(int normCapacity) {\n        int tableIdx = 0;\n        int i = normCapacity >>> 10; //首先是512 = 2^10\n        while (i != 0) {\n            i >>>= 1;\n            tableIdx ++;\n        }\n        return tableIdx;\n```\n可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。\n+ 检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。\n+ 若没有可分配的内存, 则会进入allocateNormal进行分配\n3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。\n4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。\n### 分配[16b, 16m]内存\n接着上述过程, 会进入allocateNormal进行内存分配\n```\nprivate void allocateNormal(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||\n            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||\n            q075.allocate(buf, reqCapacity, normCapacity)) {\n            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存\n        }\n        //跑到Direct里面newChunk了, 将 产生第一个chunk\n        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树\n        PoolChunk<T> c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中\n        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256\n        assert handle > 0;\n        c.initBuf(buf, handle, reqCapacity);\n        qInit.add(c); //第一次分配的话，都会放入qInit\n    }\n```\n1. 首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:\n```\n    boolean allocate(PooledByteBuf<T> buf, int reqCapacity, int normCapacity) {\n        if (head == null || normCapacity > maxCapacity) { //head是可以直接寸数据的\n            // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can\n            // be handled by the PoolChunks that are contained in this PoolChunkList.\n            return false;\n        }\n        for (PoolChunk<T> cur = head;;) {\n            long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值\n            if (handle < 0) { //在poolchunk中没有找到能装得下的，那么继续找下一个\n                cur = cur.next;\n                if (cur == null) {\n                    return false;\n                }\n            } else {\n                cur.initBuf(buf, handle, reqCapacity);\n                if (cur.usage() >= maxUsage) {//chunked量用超了则移动向下一个链\n                    remove(cur);\n                    nextList.add(cur);\n                }\n                return true;\n            }\n        }\n    }\n```\n会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。\n2. 若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>\n3. 对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。\n这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:\n+ 将PoolChunk分配维持在较高的比例上。\n+ 保存一些空闲度比较大的内存, 以便大内存的分配。\n\n# 总结\n非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.\n","slug":"Netty内存学习","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8x8000sphu5dzil1i7r","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Netty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存, 通过io.netty.noPreferDirect参数设置。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。</p>\n<h2 id=\"Pool和Unpool区别\"><a href=\"#Pool和Unpool区别\" class=\"headerlink\" title=\"Pool和Unpool区别\"></a>Pool和Unpool区别</h2><p>字面意思, 分别是池化内存和非池化内存。<code>池化内存</code>的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。<code>非池化内存</code>就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数<code>Dio.netty.allocator.type</code>确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。<br>这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。</p>\n<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><p>线程调用如下接口来获取内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class=\"line\">    PoolThreadCache cache = threadCache.get();</div><div class=\"line\">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</div><div class=\"line\"></div><div class=\"line\">    final ByteBuf buf;</div><div class=\"line\">    if (directArena != null) &#123;</div><div class=\"line\">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        buf = PlatformDependent.hasUnsafe() ?</div><div class=\"line\">                UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :</div><div class=\"line\">                new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return toLeakAwareBuffer(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>)</li>\n<li>从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。</li>\n</ul>\n<h1 id=\"PoolArena\"><a href=\"#PoolArena\" class=\"headerlink\" title=\"PoolArena\"></a>PoolArena</h1><p>PoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea.png\" height=\"400\" width=\"450\"><br>netty将池化内存块划分为3个类型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum SizeClass &#123;</div><div class=\"line\">    Tiny,</div><div class=\"line\">    Small,</div><div class=\"line\">    Normal</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Tiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。<br>大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">//tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块</div><div class=\"line\">static final int numTinySubpagePools = 512 &gt;&gt;&gt; 4;</div><div class=\"line\">//全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT</div><div class=\"line\">final PooledByteBufAllocator parent;</div><div class=\"line\">// log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//默认8k</div><div class=\"line\">final int pageSize;</div><div class=\"line\">//log(8k) =  13</div><div class=\"line\">final int pageShifts;</div><div class=\"line\">//默认16M</div><div class=\"line\">final int chunkSize;</div><div class=\"line\">//-8192</div><div class=\"line\">final int subpageOverflowMask;</div><div class=\"line\">//指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]</div><div class=\"line\">final int numSmallSubpagePools;</div><div class=\"line\"> //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] tinySubpagePools;</div><div class=\"line\"> //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] smallSubpagePools;//存储1024-8096大小的内存</div><div class=\"line\"> //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q050;</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q025;   //存储内存利用率25-75%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q000;   //存储内存利用率1-50%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; qInit;  //存储内存利用率0-25%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q075;    //存储内存利用率75-100%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q100;   //存储内存利用率100%的chunk</div><div class=\"line\"></div><div class=\"line\">// Number of thread caches backed by this arena. 该PoolArea被多少线程引用。</div><div class=\"line\">final AtomicInteger numThreadCaches = new AtomicInteger();</div></pre></td></tr></table></figure></p>\n<p>PoolArea申请内存时根据申请的大小使用不同对象进行分配:</p>\n<ul>\n<li>tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。</li>\n<li>smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。</li>\n<li>q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。<br>他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p><br>&nbsp;&nbsp;若q025中某个PoolChunk使用率大于25%之后, 该PoolChunk将别移动到q050中。<br>&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。<br>&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。<br>&nbsp;&nbsp;若q000使用率为0, 会被释放掉。</p></li>\n</ul>\n<p>numThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></p>\n<h2 id=\"PoolArena的内存分配\"><a href=\"#PoolArena的内存分配\" class=\"headerlink\" title=\"PoolArena的内存分配\"></a>PoolArena的内存分配</h2><p>线程分配内存主要从两个地方分配: PoolThreadCache和PoolArena<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea1.png\" height=\"300\" width=\"350\"><br>其中PoolThreadCache线程独享, PoolArena为几个线程共享。<br>netty真正申请内存时, 首先便是调用PoolArena.allocate()函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) &#123;</div><div class=\"line\">       final int normCapacity = normalizeCapacity(reqCapacity);</div><div class=\"line\">        // capacity &lt; pageSize   小于8k</div><div class=\"line\">       if (isTinyOrSmall(normCapacity)) &#123;</div><div class=\"line\">           int tableIdx;</div><div class=\"line\">           PoolSubpage&lt;T&gt;[] table;</div><div class=\"line\">           boolean tiny = isTiny(normCapacity);</div><div class=\"line\">           if (tiny) &#123; // &lt; 512</div><div class=\"line\">                //若从缓冲中取得该值</div><div class=\"line\">               if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = tinyIdx(normCapacity);</div><div class=\"line\">               table = tinySubpagePools;</div><div class=\"line\">           &#125; else &#123;  //small</div><div class=\"line\">               if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = smallIdx(normCapacity);</div><div class=\"line\">               table = smallSubpagePools;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           final PoolSubpage&lt;T&gt; head = table[tableIdx];</div><div class=\"line\"></div><div class=\"line\">           /**</div><div class=\"line\">            * Synchronize on the head. This is needed as &#123;@link PoolChunk#allocateSubpage(int)&#125; and</div><div class=\"line\">            * &#123;@link PoolChunk#free(long)&#125; may modify the doubly linked list as well.</div><div class=\"line\">            */</div><div class=\"line\">            //小于8k的</div><div class=\"line\">           synchronized (head) &#123;</div><div class=\"line\">                //如果分配完会从当前级别链上去掉</div><div class=\"line\">               final PoolSubpage&lt;T&gt; s = head.next;</div><div class=\"line\">                ///该型号的tiny的内存已经分配的有一个了</div><div class=\"line\">               if (s != head) &#123;</div><div class=\"line\">                   assert s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</div><div class=\"line\">                   long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">                   assert handle &gt;= 0;</div><div class=\"line\">                   s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</div><div class=\"line\">                   incTinySmallAllocation(tiny);</div><div class=\"line\">                   return;//如果从链中找到就返回，</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           //没有找到的话，就从Poolpage中分一个</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               //说明head并没有分配值，是第一次分配。</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           incTinySmallAllocation(tiny);</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (normCapacity &lt;= chunkSize) &#123; //小于16M</div><div class=\"line\">           if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) &#123;  //cache=PoolThreadCache,本地是否已经有了</div><div class=\"line\">               // was able to allocate out of the cache so move on</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">               ++allocationsNormal;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           // Huge allocations are never served via the cache so just call allocateHuge</div><div class=\"line\">           allocateHuge(buf, reqCapacity); //大于16M，则分配大内存</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>PoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:<br>1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,…, 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。<br>2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:</p>\n<ul>\n<li>首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></li>\n<li>若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int tinyIdx(int normCapacity) &#123;  //申请内容小于512，下标</div><div class=\"line\">    return normCapacity &gt;&gt;&gt; 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了</div><div class=\"line\">&#125;</div><div class=\"line\">static int smallIdx(int normCapacity) &#123;</div><div class=\"line\">    int tableIdx = 0;</div><div class=\"line\">    int i = normCapacity &gt;&gt;&gt; 10; //首先是512 = 2^10</div><div class=\"line\">    while (i != 0) &#123;</div><div class=\"line\">        i &gt;&gt;&gt;= 1;</div><div class=\"line\">        tableIdx ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tableIdx;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。</p>\n<ul>\n<li>检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。</li>\n<li>若没有可分配的内存, 则会进入allocateNormal进行分配<br>3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。<br>4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。<h3 id=\"分配-16b-16m-内存\"><a href=\"#分配-16b-16m-内存\" class=\"headerlink\" title=\"分配[16b, 16m]内存\"></a>分配[16b, 16m]内存</h3>接着上述过程, 会进入allocateNormal进行内存分配<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存</div><div class=\"line\">        &#125;</div><div class=\"line\">        //跑到Direct里面newChunk了, 将 产生第一个chunk</div><div class=\"line\">        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树</div><div class=\"line\">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中</div><div class=\"line\">        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256</div><div class=\"line\">        assert handle &gt; 0;</div><div class=\"line\">        c.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">        qInit.add(c); //第一次分配的话，都会放入qInit</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    if (head == null || normCapacity &gt; maxCapacity) &#123; //head是可以直接寸数据的</div><div class=\"line\">        // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</div><div class=\"line\">        // be handled by the PoolChunks that are contained in this PoolChunkList.</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (PoolChunk&lt;T&gt; cur = head;;) &#123;</div><div class=\"line\">        long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值</div><div class=\"line\">        if (handle &lt; 0) &#123; //在poolchunk中没有找到能装得下的，那么继续找下一个</div><div class=\"line\">            cur = cur.next;</div><div class=\"line\">            if (cur == null) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            cur.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">            if (cur.usage() &gt;= maxUsage) &#123;//chunked量用超了则移动向下一个链</div><div class=\"line\">                remove(cur);</div><div class=\"line\">                nextList.add(cur);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。</p>\n<ol>\n<li>若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a></li>\n<li>对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。<br>这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:</li>\n</ol>\n<ul>\n<li>将PoolChunk分配维持在较高的比例上。</li>\n<li>保存一些空闲度比较大的内存, 以便大内存的分配。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Netty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。堆外内存又称直接内存, 通过io.netty.noPreferDirect参数设置。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它进程主动垃圾回收,垃圾回收效率也极低, 因此, netty主动创建了Pool和Unpool的概念。</p>\n<h2 id=\"Pool和Unpool区别\"><a href=\"#Pool和Unpool区别\" class=\"headerlink\" title=\"Pool和Unpool区别\"></a>Pool和Unpool区别</h2><p>字面意思, 分别是池化内存和非池化内存。<code>池化内存</code>的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用, 这样的话, 可以减少垃圾回收次数, 提高处理性能。<code>非池化内存</code>就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数<code>Dio.netty.allocator.type</code>确定netty默认使用内存的方式, 目前netty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了直接内存回收的压力。 所以在netty4时候, 默认使用pool方式。<br>这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf类型的内存, 这些内存主要由PoolArea管理, 这也是本文的重点。</p>\n<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><p>线程调用如下接口来获取内存:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected ByteBuf newDirectBuffer(int initialCapacity, int maxCapacity) &#123;</div><div class=\"line\">    PoolThreadCache cache = threadCache.get();</div><div class=\"line\">    PoolArena&lt;ByteBuffer&gt; directArena = cache.directArena;</div><div class=\"line\"></div><div class=\"line\">    final ByteBuf buf;</div><div class=\"line\">    if (directArena != null) &#123;</div><div class=\"line\">        buf = directArena.allocate(cache, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        buf = PlatformDependent.hasUnsafe() ?</div><div class=\"line\">                UnsafeByteBufUtil.newUnsafeDirectByteBuf(this, initialCapacity, maxCapacity) :</div><div class=\"line\">                new UnpooledDirectByteBuf(this, initialCapacity, maxCapacity);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    return toLeakAwareBuffer(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>获取该线程绑定的PoolThreadCache(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a>)</li>\n<li>从绑定的PoolThreadCache中获取PoolArena, 从PoolArena中开始真正分配内存。</li>\n</ul>\n<h1 id=\"PoolArena\"><a href=\"#PoolArena\" class=\"headerlink\" title=\"PoolArena\"></a>PoolArena</h1><p>PoolArena作为Netty底层内存池核心管理类, 主要原理是首先申请一些内存块, 不同的成员变量来完成不同大小的内存块分配。下图描述了Netty最重要的成员变量:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea.png\" height=\"400\" width=\"450\"><br>netty将池化内存块划分为3个类型:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">enum SizeClass &#123;</div><div class=\"line\">    Tiny,</div><div class=\"line\">    Small,</div><div class=\"line\">    Normal</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>Tiny主要解决16b-498b之间的内存块分配, small解决分配512b-4kb的内存分配, normal解决8k-16m的内存分配。<br>大致了解了这些, 为了更详细的了解分配细节, 首先对PoolArena成员变量进行简单分析。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">//tiny级别的个数, 每次递增2^4b, tiny总共管理32个等级的小内存片:[16, 32, 48, ..., 496], 注意实际只有31个级别内存块</div><div class=\"line\">static final int numTinySubpagePools = 512 &gt;&gt;&gt; 4;</div><div class=\"line\">//全局默认唯一的分配者, 见PooledByteBufAllocator.DEFAULT</div><div class=\"line\">final PooledByteBufAllocator parent;</div><div class=\"line\">// log(16M/8K) = 11,指的是normal类型的内存等级, 分别为[8k, 16k, 32k, ..., 16M]</div><div class=\"line\">private final int maxOrder;</div><div class=\"line\">//默认8k</div><div class=\"line\">final int pageSize;</div><div class=\"line\">//log(8k) =  13</div><div class=\"line\">final int pageShifts;</div><div class=\"line\">//默认16M</div><div class=\"line\">final int chunkSize;</div><div class=\"line\">//-8192</div><div class=\"line\">final int subpageOverflowMask;</div><div class=\"line\">//指的是small类型的内存等级: pageShifts - log(512) = 4,分别为[512, 1k, 2k, 4k]</div><div class=\"line\">final int numSmallSubpagePools;</div><div class=\"line\"> //small类型分31个等级[16, 32, ..., 512], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] tinySubpagePools;</div><div class=\"line\"> //small类型分31个等级[512, 1k, 2k, 4k], 每个等级都可以存放一个链(元素为PoolSubpage), 可存放未分配的该范围的内存块</div><div class=\"line\">private final PoolSubpage&lt;T&gt;[] smallSubpagePools;//存储1024-8096大小的内存</div><div class=\"line\"> //存储chunk(16M)使用率的内存块, 不同使用率的chunk, 存放在不同的对象中</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q050;</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q025;   //存储内存利用率25-75%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q000;   //存储内存利用率1-50%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; qInit;  //存储内存利用率0-25%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q075;    //存储内存利用率75-100%的chunk</div><div class=\"line\">private final PoolChunkList&lt;T&gt; q100;   //存储内存利用率100%的chunk</div><div class=\"line\"></div><div class=\"line\">// Number of thread caches backed by this arena. 该PoolArea被多少线程引用。</div><div class=\"line\">final AtomicInteger numThreadCaches = new AtomicInteger();</div></pre></td></tr></table></figure></p>\n<p>PoolArea申请内存时根据申请的大小使用不同对象进行分配:</p>\n<ul>\n<li>tinySubpagePools分配[16b, 496b]之间的内存大小, 数组中每个元素以16b为一个单位增长, 比如申请分配16b的内存, 将在下标为0对应的链中分配; 申请32b的内存, 将在下标为1对应的链中分配。</li>\n<li>smallSubpagePools分配[512b, 4k]之间的内存大小, 分配结构同tinySubpagePools一样。</li>\n<li>q050、q025、q000、qInit、q075主要负责分配[8k, 16M]大小的内存, 其存放的元素都是大小为16M的PoolChunk, 这几个成员变量不同的是元素PoolChunk的使用率不同, 比如q025里面存放的chunk使用率为[25%, 75%]。 若需要申请[16b, 4k]的内存、而tinySubpagePools、smallSubpagePools没有合适的内存块时, 会从这些对象包含的PoolChunk中分配8k的叶子节点供重新划分结构进行分配。<br>他们存储的属性PoolChunk可以在不同的属性中移动, 其中:<p><br>&nbsp;&nbsp;若q025中某个PoolChunk使用率大于25%之后, 该PoolChunk将别移动到q050中。<br>&nbsp;&nbsp;若q050中某个PoolChunk使用率小于50%之后, 该PoolChunk将别移动到q025中。<br>&nbsp;&nbsp;若qInit使用率为0, 也不会释放该节点。<br>&nbsp;&nbsp;若q000使用率为0, 会被释放掉。</p></li>\n</ul>\n<p>numThreadCaches负责统计该PoolChunk被多少NioEventLoop线程绑定, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></p>\n<h2 id=\"PoolArena的内存分配\"><a href=\"#PoolArena的内存分配\" class=\"headerlink\" title=\"PoolArena的内存分配\"></a>PoolArena的内存分配</h2><p>线程分配内存主要从两个地方分配: PoolThreadCache和PoolArena<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PoolArea1.png\" height=\"300\" width=\"350\"><br>其中PoolThreadCache线程独享, PoolArena为几个线程共享。<br>netty真正申请内存时, 首先便是调用PoolArena.allocate()函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocate(PoolThreadCache cache, PooledByteBuf&lt;T&gt; buf, final int reqCapacity) &#123;</div><div class=\"line\">       final int normCapacity = normalizeCapacity(reqCapacity);</div><div class=\"line\">        // capacity &lt; pageSize   小于8k</div><div class=\"line\">       if (isTinyOrSmall(normCapacity)) &#123;</div><div class=\"line\">           int tableIdx;</div><div class=\"line\">           PoolSubpage&lt;T&gt;[] table;</div><div class=\"line\">           boolean tiny = isTiny(normCapacity);</div><div class=\"line\">           if (tiny) &#123; // &lt; 512</div><div class=\"line\">                //若从缓冲中取得该值</div><div class=\"line\">               if (cache.allocateTiny(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = tinyIdx(normCapacity);</div><div class=\"line\">               table = tinySubpagePools;</div><div class=\"line\">           &#125; else &#123;  //small</div><div class=\"line\">               if (cache.allocateSmall(this, buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">                   // was able to allocate out of the cache so move on</div><div class=\"line\">                   return;</div><div class=\"line\">               &#125;</div><div class=\"line\">               tableIdx = smallIdx(normCapacity);</div><div class=\"line\">               table = smallSubpagePools;</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           final PoolSubpage&lt;T&gt; head = table[tableIdx];</div><div class=\"line\"></div><div class=\"line\">           /**</div><div class=\"line\">            * Synchronize on the head. This is needed as &#123;@link PoolChunk#allocateSubpage(int)&#125; and</div><div class=\"line\">            * &#123;@link PoolChunk#free(long)&#125; may modify the doubly linked list as well.</div><div class=\"line\">            */</div><div class=\"line\">            //小于8k的</div><div class=\"line\">           synchronized (head) &#123;</div><div class=\"line\">                //如果分配完会从当前级别链上去掉</div><div class=\"line\">               final PoolSubpage&lt;T&gt; s = head.next;</div><div class=\"line\">                ///该型号的tiny的内存已经分配的有一个了</div><div class=\"line\">               if (s != head) &#123;</div><div class=\"line\">                   assert s.doNotDestroy &amp;&amp; s.elemSize == normCapacity;</div><div class=\"line\">                   long handle = s.allocate();//高32放着一个PoolSubpage里面哪段的哪个，低32位放着哪个叶子节点</div><div class=\"line\">                   assert handle &gt;= 0;</div><div class=\"line\">                   s.chunk.initBufWithSubpage(buf, handle, reqCapacity);</div><div class=\"line\">                   incTinySmallAllocation(tiny);</div><div class=\"line\">                   return;//如果从链中找到就返回，</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">           //没有找到的话，就从Poolpage中分一个</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               //说明head并没有分配值，是第一次分配。</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           incTinySmallAllocation(tiny);</div><div class=\"line\">           return;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (normCapacity &lt;= chunkSize) &#123; //小于16M</div><div class=\"line\">           if (cache.allocateNormal(this, buf, reqCapacity, normCapacity)) &#123;  //cache=PoolThreadCache,本地是否已经有了</div><div class=\"line\">               // was able to allocate out of the cache so move on</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           synchronized (this) &#123;</div><div class=\"line\">               allocateNormal(buf, reqCapacity, normCapacity);</div><div class=\"line\">               ++allocationsNormal;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           // Huge allocations are never served via the cache so just call allocateHuge</div><div class=\"line\">           allocateHuge(buf, reqCapacity); //大于16M，则分配大内存</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>PoolArena.allocate()分配内存主要考虑先尝试从缓存中, 然后再尝试从PoolArena分配。tiny和small申请过程一样, 以下都以tiny申请为例。具体过程如下:<br>1). 对申请的内存进行规范化, 就是说只能申请某些固定大小的内存, 比如tiny范围的16b倍数的内存, small范围内512b, 1k, 2k, 4k范围内存, normal范围内8k, 16k,…, 16m范围内内存, 始终是2幂次方的数据。申请的内存不足16b的,按照16b去申请。<br>2). 判断是否是小于8K的内存申请, 若是申请Tiny/Small级别的内存:</p>\n<ul>\n<li>首先尝试从cache中申请, 具体申请过程参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/14/Netty-PoolThreadCache%E6%BA%90%E7%A0%81%E6%8E%A2%E7%A9%B6/\">Netty PoolThreadCache原理探究</a></li>\n<li>若在cache中申请不到的话, 接着会尝试从tinySubpagePools中申请, 首先计算出该内存在tinySubpagePools中对应的下标, 下标计算公式如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int tinyIdx(int normCapacity) &#123;  //申请内容小于512，下标</div><div class=\"line\">    return normCapacity &gt;&gt;&gt; 4;  //在tiny维护的链中找到合适自己位置的下标, 除以16，就是下标了</div><div class=\"line\">&#125;</div><div class=\"line\">static int smallIdx(int normCapacity) &#123;</div><div class=\"line\">    int tableIdx = 0;</div><div class=\"line\">    int i = normCapacity &gt;&gt;&gt; 10; //首先是512 = 2^10</div><div class=\"line\">    while (i != 0) &#123;</div><div class=\"line\">        i &gt;&gt;&gt;= 1;</div><div class=\"line\">        tableIdx ++;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return tableIdx;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出, normCapacity/16就是tiny级别的下标, normCapacity/1024就是small级别的下标。 然后再获取tinySubpagePools对应级别的内存的头结点head。</p>\n<ul>\n<li>检查对应链串是否已经有PoolSubpage可用, 若有的话, 直接进入PoolSubpage.allocate进行内存分撇, 具体可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>, 并且根据handle初始化这块内存块。</li>\n<li>若没有可分配的内存, 则会进入allocateNormal进行分配<br>3). 若分配normal类型的类型, 首先也会尝试从缓存中分配, 然后再考虑从allocateNormal进行内存分配。<br>4). 若分配大于16m的内存, 则直接通过allocateHuge()从内存池外分配内存。<h3 id=\"分配-16b-16m-内存\"><a href=\"#分配-16b-16m-内存\" class=\"headerlink\" title=\"分配[16b, 16m]内存\"></a>分配[16b, 16m]内存</h3>接着上述过程, 会进入allocateNormal进行内存分配<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void allocateNormal(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">        if (q050.allocate(buf, reqCapacity, normCapacity) || q025.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q000.allocate(buf, reqCapacity, normCapacity) || qInit.allocate(buf, reqCapacity, normCapacity) ||</div><div class=\"line\">            q075.allocate(buf, reqCapacity, normCapacity)) &#123;</div><div class=\"line\">            return;//第一次进行内存分配时，chunkList没有chunk可以分配内存</div><div class=\"line\">        &#125;</div><div class=\"line\">        //跑到Direct里面newChunk了, 将 产生第一个chunk</div><div class=\"line\">        // Add a new chunk.   https://www.jianshu.com/p/c4bd37a3555b  就是传说中的平衡树</div><div class=\"line\">        PoolChunk&lt;T&gt; c = newChunk(pageSize, maxOrder, pageShifts, chunkSize);  //需通过方法newChunk新建一个chunk进行内存分配，并添加到qInit列表中</div><div class=\"line\">        long handle = c.allocate(normCapacity); //取到平衡树里面哪个下标,比如256</div><div class=\"line\">        assert handle &gt; 0;</div><div class=\"line\">        c.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">        qInit.add(c); //第一次分配的话，都会放入qInit</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li>首先会依次检查q050、q025、q000、qInit、q075链中的PoolArea, 是否能否分配该大小的内存, 检查分配过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean allocate(PooledByteBuf&lt;T&gt; buf, int reqCapacity, int normCapacity) &#123;</div><div class=\"line\">    if (head == null || normCapacity &gt; maxCapacity) &#123; //head是可以直接寸数据的</div><div class=\"line\">        // Either this PoolChunkList is empty or the requested capacity is larger then the capacity which can</div><div class=\"line\">        // be handled by the PoolChunks that are contained in this PoolChunkList.</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (PoolChunk&lt;T&gt; cur = head;;) &#123;</div><div class=\"line\">        long handle = cur.allocate(normCapacity); //取得哪个坐标下的某个值</div><div class=\"line\">        if (handle &lt; 0) &#123; //在poolchunk中没有找到能装得下的，那么继续找下一个</div><div class=\"line\">            cur = cur.next;</div><div class=\"line\">            if (cur == null) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            cur.initBuf(buf, handle, reqCapacity);</div><div class=\"line\">            if (cur.usage() &gt;= maxUsage) &#123;//chunked量用超了则移动向下一个链</div><div class=\"line\">                remove(cur);</div><div class=\"line\">                nextList.add(cur);</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>会轮训该链所有PoolChunk, 直到找到一个符合要求的内存块, 当分配完成后, 检查该PoolChunk是否因为使用率超过阈值需要放到别的队列中。</p>\n<ol>\n<li>若没有找到, 会去内存中申请一个PoolChunk的内存块, 在该PoolChunk中分配normCapacity大小的内存, 参考见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a></li>\n<li>对PoolChunk进行初始化, 并将该PoolChunk加入qInit的链中。<br>这里有一个细节需要了解下, q050、q025、q000、qInit、q075按照这个顺序排序, 也就是说当在这几个对象都有可分配的内存时, 优先从 q050中分配, 最后从q075中分配。这样安排的考虑是:</li>\n</ol>\n<ul>\n<li>将PoolChunk分配维持在较高的比例上。</li>\n<li>保存一些空闲度比较大的内存, 以便大内存的分配。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>非内存池化的内存分配没有什么好说的, 并没有组织成什么结构来分配, 内存的释放主要由PoolChunk和PoolSubpage来释放。 本文主要讲了从poolArena上层结构tinySubpagePools、mallSubpagePools、050、q025、q000、qInit、q075分配内存、 大致的步骤, 至于从每个对象具体如何分配内存, 请看相关文章<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/20/Netty-PoolChunk%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty PoolChunk原理探究</a>、<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/07/22/Netty-PoolSubpage%E5%8E%9F%E7%90%86%E6%8E%A2%E7%A9%B6/\">Netty-PoolSubpage原理探究</a>.</p>\n"},{"title":"Netty对象回收池Recycler原理详解","date":"2019-01-16T01:09:39.000Z","toc":true,"_content":"同Netty内存池(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)一样, 为了增强Netty高性能并发能力, 减少通用对象分配的损耗, 也采用了对象池的概念。 当需要某个对象时, 首先从对象池中获取该对象, 当使用完成后, 将对象释放到对象池中, 这样达到重复使用对象的效果。基本使用如下:\n```\npublic class Cycli {\n    private static final Recycler<Cycler> CyclerRecycler = new Recycler<Cycler>() {\n        @Override\n        protected Cycler newObject(Handle<Cycler> handle) {\n            return new Cycler(handle);\n        }\n    };\n    static final class Cycler {\n        private String value;\n        public void setValue(String value) {\n            this.value = value;\n        }\n        private Recycler.Handle<Cycler> handle;\n        public Cycler(Recycler.Handle<Cycler> handle) {\n            this.handle = handle;\n        }\n        public void recycle() {\n            handle.recycle(this);\n        }\n    }\n    public static void  main(String[] args) {\n        // 1、从回收池获取对象\n        Cycler cycler1 = CyclerRecycler.get();\n        // 2、开始使用对象\n        cycler1.setValue(\"hello,java\");\n        // 3、回收对象到对象池\n        cycler1.recycle();\n        // 4、从回收池获取对象\n        Cycler cycler2 = CyclerRecycler.get();\n        //比较从对象池中获取的对象即为之前释放的对象\n        System.out.print(cycler1 == cycler2);\n    }\n}\n```\n使用比较简单, 主要定义了如下几个对象:\n+ 定义CyclerRecycler, 作为对象池的入口, 定义newObject()函数, 若对象池中没有可用对象, 则新建对象。\n+ 定义被回收的对象Cycler, 包含成员变量handle, 该handler与该对象和stack绑定的。\n+ 通过CyclerRecycler.get()从对象池中获取对象; 通过Cycler1.recycle()释放该对象到对象池。\n\n##  WeakOrderQueue、Stack介绍\n对象池通过Recycler里面WeakOrderQueue、Stack 2个类来实现。 首先放一张图来展示一个stack中两者的关系:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler1.png\" height=\"450\" width=\"650\"/>\n+ 每个线程都拥有自己的对象池, 该对象池结构如上图所示, stack作为本线程对象池的核心, 通过FastThreadLocal来实现每个线程的本地化。\n+ 本线程回收本线程产生的对象时, 会将对象以DefaultHandle的形式存放在stack的elements数组中; 若本线程thread1回收其它线程thread2产生的对象时, 将该对象放到thread2对应stack的一个WeakOrderQueue的Link中。 也就是说一个WeakOrderQueue节点存放着一个其他线程帮着本线程回收本线程生产的对象。每个stack的WeakOrderQueue链表节点个数不能超过2*cpu, 可以通过io.netty.recycler.maxDelayedQueuesPerThread控制。 也就是说最多有2*cpu个线程帮着回收对象。\n+ 每个link存放的对象是有限的, Link中DefaultHandle[]最多存放16个对象。 若thread1回收thread2产生的对象装满了一个Link, 则会再产生一个link继续存放。\n+ 当前线程从对象池中拿对象时, 首先从stack的elements中获取, 若没有的话, 将尝试从当前WeakOrderQueue节点cursor的Link中的数组对象transfer到stack的elements, 再从stack的elements中获取对象。\n+ stack的element数组最大长度32768, 可以通过io.netty.recycler.maxCapacityPerThread控制; 而Link节点中每个DefaultHandle数组默认长度16, 可以通过io.netty.recycler.linkCapacity控制;\n通过elements及Link完成了整个对象池的构建。\n\n# 从线程池获取对象\n通过调用Recycler.get()来完成:\n```\n    public final T get() {\n         // 若置为0, 将handle置为Noop_HANDLE, 代表着不被回收\n        if (maxCapacityPerThread == 0) {\n            return newObject((Handle<T>) NOOP_HANDLE);\n        }\n        // 获取当前线程对应的Stack\n        Stack<T> stack = threadLocal.get();\n        // 从对象池获取对象\n        DefaultHandle<T> handle = stack.pop();\n        // 若对象池中没有对象,则调用子类的newObject方法创建新的对象\n        if (handle == null) {\n            handle = stack.newHandle();\n            handle.value = newObject(handle);\n        }\n        return (T) handle.value;\n    }\n```\n主要做了如下事情:\n+ 首先获取本线程对应的唯一stack, 从该stack中获取对象。\n+ 若对象池中没有对象, 则主动调用newObject产生一个对象。同时完成了handle与对象、stack的绑定。\n我们接下来看如何通过stack.pop()来从对象池中获取对象:\n```\n        DefaultHandle<T> pop() {\n            //统计着elements中存放的对象个数\n            int size = this.size;\n           //若elements没有可用对象\n            if (size == 0) {\n                //就尝试从别的线程帮着回收的对象中转移一些到elements中, 也就是从WeakOrderQueue中转移一些数据出来\n                if (!scavenge()) {\n                    return null;\n                }\n                size = this.size;\n            }\n            size --;\n            DefaultHandle ret = elements[size];\n            elements[size] = null;\n            //在stack的lastRecycledId及recycleId一定是相等的\n            if (ret.lastRecycledId != ret.recycleId) {\n                throw new IllegalStateException(\"recycled multiple times\");\n            }\n            ret.recycleId = 0;\n            ret.lastRecycledId = 0;\n            this.size = size;\n            return ret;\n        }\n```\n对象在从对象池中被获取时, recycleId及lastRecycledId都被清零。\n我们看scavenge是如何回收内存的。\n```\n        boolean scavenge() {\n            //尝试从WeakOrderQueue中转移数据DefaultHandle到stack的elements中\n            if (scavengeSome()) {\n                return true;\n            }\n\n            // reset our scavenge cursor\n            prev = null;\n            cursor = head;\n            return false;\n        }\n        boolean scavengeSome() {\n             //cursor属性保存了上一次对WeakorderQueueu列表的浏览位置，每一次都从上一次的位置继续，这是一种FIFO的处理策略\n            WeakOrderQueue prev;\n            WeakOrderQueue cursor = this.cursor;\n            //若游标为null, 则是第一次从WeakorderQueueu链中获取元素\n            if (cursor == null) {\n                prev = null;\n                cursor = head;\n                //若不存在任何WeakorderQueueu, 退出\n                if (cursor == null) {\n                    return false;\n                }\n            } else {\n                prev = this.prev;\n            }\n            boolean success = false;\n            //循环的不停地从WeakOrderQueue中找到一个可用的Link\n            do {\n                //从WeakOrderQueue中转移数据到element数组中。\n                if (cursor.transfer(this)) {\n                    success = true;\n                    break;\n                }\n                WeakOrderQueue next = cursor.next;\n                //如果当前处理的WeakOrderQueue所在的线程已经消亡，则尽可能的提取里面的数据，之后从列表中删除这个WeakOrderQueue。注意owner使用WeakReference<Thread>定义, 当线程消亡后, 通过cursor.owner.get()自然变为null\n                if (cursor.owner.get() == null) {\n                    // If the thread associated with the queue is gone, unlink it, after\n                    // performing a volatile read to confirm there is no data left to collect.\n                    // We never unlink the first queue, as we don't want to synchronize on updating the head.\n                    //如果消亡的线程还有数据，\n                    if (cursor.hasFinalData()) {\n                        for (;;) {\n                            //尽量将该线程对应的WeakOrderQueue里面link对应的对象迁移到elements中\n                            if (cursor.transfer(this)) {\n                                success = true;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                   //将消亡的那个WeakOrderQueue从链中去掉\n                    if (prev != null) {\n                        prev.setNext(next);\n                    }\n                } else {\n                    prev = cursor;\n                }\n                cursor = next;\n            } while (cursor != null && !success);\n            this.prev = prev;\n            this.cursor = cursor;\n            return success;\n        }\n```\n若stack的elements中没有对象, 那么把对象从Link的DefautHandle[]中迁移到stack的elements中:\n```\n    boolean transfer(Stack<?> dst) {\n            Link head = this.head;\n            //WeakOrderQueue中整个Link链为空, 则直接退出\n            if (head == null) {\n                return false;\n            }\n            //说明head已经被读取完了，需要将head指向当前WeakOrderQueue的下一个link\n            if (head.readIndex == LINK_CAPACITY) {\n                if (head.next == null) {\n                    return false;\n                }\n                //当前链节点换头\n                this.head = head = head.next;\n            }\n            //获取当前可读的下标\n            final int srcStart = head.readIndex;\n            //当前link write的下标\n            int srcEnd = head.get();\n            //总共可读长度\n            final int srcSize = srcEnd - srcStart;\n            if (srcSize == 0) {\n                return false;\n            }\n            //计算即将写到elements中起始与终点位置\n            final int dstSize = dst.size;\n            final int expectedCapacity = dstSize + srcSize;\n            //如果超过stack当前能装下的最大elements个数\n            if (expectedCapacity > dst.elements.length) {\n                //将stack的elements扩容\n                final int actualCapacity = dst.increaseCapacity(expectedCapacity);\n                srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);\n            }\n            if (srcStart != srcEnd) {\n                final DefaultHandle[] srcElems = head.elements;\n                final DefaultHandle[] dstElems = dst.elements;\n                int newDstSize = dstSize;\n                //每个元素都开始从源迁移到目的地\n                for (int i = srcStart; i < srcEnd; i++) {\n                    DefaultHandle element = srcElems[i];\n                    //对象在被回收时, recycleId、lastRecycledId都是0, 若直接被会受到stack的element中时, recycleId=lastRecycledId=thread_id; 若被会受到Link中时, lastRecycledId被修改成当前thread_id, recycleId仍为0, 当元素从Link迁移至stack的elements时, recycleId=astRecycledId。\n                    if (element.recycleId == 0) {\n                        element.recycleId = element.lastRecycledId;\n                    } else if (element.recycleId != element.lastRecycledId) {\n                        throw new IllegalStateException(\"recycled already\");\n                    }\n                    srcElems[i] = null;\n                    //为了防止stack的elements扩张太快, 实际每8个迁移的对象中只取1个, 7个都被丢弃了\n                    if (dst.dropHandle(element)) {\n                        // Drop the object.\n                        continue;\n                    }\n                    element.stack = dst;\n                    dstElems[newDstSize ++] = element;\n                }\n                // 若当前WeakOrderQueue的head已经被迁移完了, 需要从队列中抛弃\n                if (srcEnd == LINK_CAPACITY && head.next != null) {\n                    // Add capacity back as the Link is GCed.\n                    //增加每个线程帮另一个线程最多回收的限制\n                    reclaimSpace(LINK_CAPACITY);\n                    this.head = head.next; //当前WeakOrderQueue更新head\n                }\n                //更新该head对象可读下标\n                head.readIndex = srcEnd;\n                if (dst.size == newDstSize) {\n                    return false;\n                }\n                //更新stack可用对象的个数\n                dst.size = newDstSize;\n                return true;\n            } else {\n                // The destination stack is full already.\n                return false;\n            }\n        }\n```\n从对象池中获取对象步骤总结如下:\n1. 检查stack的elements中是否有可剩余的DefaultHandle。\n2. 若没有的话, 从cursor的head开始查找当前WeakorderQueue, 并检查WeakorderQueue对应的线程是否还存活着, 若对应的帮着回收的线程不再了, 则调用transfer将该WeakorderQueue对应的所有link中的数组循环迁移到elements中, 迁移的时候每8个丢弃7个, 只有一个被回收。\n3. 若对应线程还存活着, 则调用transfer进行回收当前WeakorderQueue中的一个link的所有DefaultHandle[]到stack的elements中。\n\n# 向对象池中存放对象\n如上例所示, 释放对象时调用cycler1.recycle()即可, 最终会调用与当前对象绑定的stack.push():\n```\n        void push(DefaultHandle<?> item) {\n            Thread currentThread = Thread.currentThread();\n            //如果本线程就是产生对象的那个县城，那么直接把该对象放到stack的elements数组里\n            if (thread == currentThread) {\n                // The current Thread is the thread that belongs to the Stack, we can try to push the object now.\n                pushNow(item);\n            } else {\n                // The current Thread is not the one that belongs to the Stack, we need to signal that the push\n                // happens later.\n                //如果该stack不是本线程的stack，那么把该DefaultHandle放到该stack的WeakOrderQueue中\n                pushLater(item, currentThread);\n            }\n        }\n```\n若回收对象的线程就是产生对象的线程, 那么直接将对象放到本stack对应的elements中。\n```\n        private void pushNow(DefaultHandle<?> item) {\n            if ((item.recycleId | item.lastRecycledId) != 0) {\n                throw new IllegalStateException(\"recycled already\");\n            }\n            #俩都直接赋值相等, 则说明对象处于stack的elements中等待被读取。\n            item.recycleId = item.lastRecycledId = OWN_THREAD_ID;\n            int size = this.size;\n            //在push到对象池时, 也会丢弃7/8的元素\n            if (size >= maxCapacity || dropHandle(item)) {\n                // Hit the maximum capacity or should drop - drop the possibly youngest object.\n                return;\n            }\n            //直接把DefaultHandle放到stack的数组里，如果数组满了那么扩展该数组为当前2倍大小\n            if (size == elements.length) {\n                elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));\n            }\n            elements[size] = item;\n            this.size = size + 1;\n        }\n```\n直接存放对象时, 对象池也会丢弃7/8的对象。\n若回收对象的线程不是产生对象的线程, 我们来看下是如何将对象放到Link的数组中的:\n```\n   private void pushLater(DefaultHandle<?> item, Thread thread) {\n            // we don't want to have a ref to the queue as the value in our weak map\n            // so we null it out; to ensure there are no races with restoring it later\n            // we impose a memory ordering here (no-op on x86)\n            //DELAYED_RECYCLED里存放了当前线程向所有stack中插入的WeakOrderQueue的映射关系\n            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();\n            //获取到当前线程向stack插入的WeakOrderQueue节点\n            WeakOrderQueue queue = delayedRecycled.get(this);\n            if (queue == null) {\n                //每个stack/线程最多能向maxDelayedQueues（2*cpu）个线程的WeakOrderQueue队列添加回收的的对象\n                if (delayedRecycled.size() >= maxDelayedQueues) {//如果已经向maxDelayedQueues个线程插入过数据, 那么将1个伪造的WeakOrderQueue（DUMMY）放到delayedRecycled中，并丢弃该对象（DefaultHandle）\n                    // Add a dummy queue so we know we should drop the object\n                    delayedRecycled.put(this, WeakOrderQueue.DUMMY);\n                    return;\n                }\n                // Check if we already reached the maximum number of delayed queues and if we can allocate at all.\n               //别的线程最多向这个stack的WeakOrderQueue插入16384个对象, 检查是否可以插入, 若可以插入, 就向这个stack头插法新建WeakOrderQueue对象\n                if ((queue = WeakOrderQueue.allocate(this, thread)) == null) {\n                    // drop object\n                    return;\n                }\n                delayedRecycled.put(this, queue);\n             //已经插入满了\n            } else if (queue == WeakOrderQueue.DUMMY) {\n                // drop object\n                return;\n            }\n            queue.add(item); //向WeakOrderQueue对应的Link插入对象\n        }\n```\nDELAYED_RECYCLED实际保存的是每个线程向别的stack插入WeakOrderQueue的对应关系, 下图是一个线程保存向别的stack插入WeakOrderQueue的映射关系。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler2.png\" height=\"350\" width=\"450\"/>\n找到对应的WeakOrderQueue后, 调用add向对应的Link中插入对象:\n```\n        void add(DefaultHandle<?> handle) {\n            //这里仅仅修改lastRecycledId值, recycledId的修改时从WeakOrderQueue的link迁移到stack的elements的时候\n            handle.lastRecycledId = id;\n            Link tail = this.tail;\n            int writeIndex;\n            //若当前Link已经写满了, 那么我们再新一个Link存放对象\n            if ((writeIndex = tail.get()) == LINK_CAPACITY) {\n                if (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) {\n                    // Drop it.\n                    return;\n                }\n                // We allocate a Link so reserve the space\n                this.tail = tail = tail.next = new Link();\n                writeIndex = tail.get();\n            }\n            tail.elements[writeIndex] = handle;\n            //本Link所处的stack即为handle.stack。在对象池中可以清空, 在被转移到stack的elements时重新赋值。\n            handle.stack = null;\n            // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;\n            // this also means we guarantee visibility of an element in the queue if we see the index updated\n           //修改内存偏移地址为8的值，但是修改后不保证立马能被其他的线程看到。\n            tail.lazySet(writeIndex + 1);  //https://github.com/netty/netty/issues/8215\n        }\n```\n可以看到, 向Link中插入对象时, 仅改变对象的lastRecycledId值, 而没有改变recycledId值。\n\n# 总结\nNetty回收对象也不是把所有对象全部回收, 为了防止回收对象过多, 会在直接存入stack的elements和从Link转移到stack的elements时会丢弃7/8的废弃对象。Netty中使用对象回收的地方很多, 一个高频使用就是PooledUnsafeDirectByteBuf, 首先申请16M内存作为内存池时, 按需分配小的内存块, 这些小内存块都会被PooledUnsafeDirectByteBuf管理着。 而减少PooledUnsafeDirectByteBuf对象创建次数, 也增强了netty高性能传输数据的能力。\n","source":"_posts/Netty对象回收池Recycler原理详解.md","raw":"---\ntitle: Netty对象回收池Recycler原理详解\ndate: 2019-01-16 09:09:39\ntags: Cycler\ntoc: true\n---\n同Netty内存池(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)一样, 为了增强Netty高性能并发能力, 减少通用对象分配的损耗, 也采用了对象池的概念。 当需要某个对象时, 首先从对象池中获取该对象, 当使用完成后, 将对象释放到对象池中, 这样达到重复使用对象的效果。基本使用如下:\n```\npublic class Cycli {\n    private static final Recycler<Cycler> CyclerRecycler = new Recycler<Cycler>() {\n        @Override\n        protected Cycler newObject(Handle<Cycler> handle) {\n            return new Cycler(handle);\n        }\n    };\n    static final class Cycler {\n        private String value;\n        public void setValue(String value) {\n            this.value = value;\n        }\n        private Recycler.Handle<Cycler> handle;\n        public Cycler(Recycler.Handle<Cycler> handle) {\n            this.handle = handle;\n        }\n        public void recycle() {\n            handle.recycle(this);\n        }\n    }\n    public static void  main(String[] args) {\n        // 1、从回收池获取对象\n        Cycler cycler1 = CyclerRecycler.get();\n        // 2、开始使用对象\n        cycler1.setValue(\"hello,java\");\n        // 3、回收对象到对象池\n        cycler1.recycle();\n        // 4、从回收池获取对象\n        Cycler cycler2 = CyclerRecycler.get();\n        //比较从对象池中获取的对象即为之前释放的对象\n        System.out.print(cycler1 == cycler2);\n    }\n}\n```\n使用比较简单, 主要定义了如下几个对象:\n+ 定义CyclerRecycler, 作为对象池的入口, 定义newObject()函数, 若对象池中没有可用对象, 则新建对象。\n+ 定义被回收的对象Cycler, 包含成员变量handle, 该handler与该对象和stack绑定的。\n+ 通过CyclerRecycler.get()从对象池中获取对象; 通过Cycler1.recycle()释放该对象到对象池。\n\n##  WeakOrderQueue、Stack介绍\n对象池通过Recycler里面WeakOrderQueue、Stack 2个类来实现。 首先放一张图来展示一个stack中两者的关系:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler1.png\" height=\"450\" width=\"650\"/>\n+ 每个线程都拥有自己的对象池, 该对象池结构如上图所示, stack作为本线程对象池的核心, 通过FastThreadLocal来实现每个线程的本地化。\n+ 本线程回收本线程产生的对象时, 会将对象以DefaultHandle的形式存放在stack的elements数组中; 若本线程thread1回收其它线程thread2产生的对象时, 将该对象放到thread2对应stack的一个WeakOrderQueue的Link中。 也就是说一个WeakOrderQueue节点存放着一个其他线程帮着本线程回收本线程生产的对象。每个stack的WeakOrderQueue链表节点个数不能超过2*cpu, 可以通过io.netty.recycler.maxDelayedQueuesPerThread控制。 也就是说最多有2*cpu个线程帮着回收对象。\n+ 每个link存放的对象是有限的, Link中DefaultHandle[]最多存放16个对象。 若thread1回收thread2产生的对象装满了一个Link, 则会再产生一个link继续存放。\n+ 当前线程从对象池中拿对象时, 首先从stack的elements中获取, 若没有的话, 将尝试从当前WeakOrderQueue节点cursor的Link中的数组对象transfer到stack的elements, 再从stack的elements中获取对象。\n+ stack的element数组最大长度32768, 可以通过io.netty.recycler.maxCapacityPerThread控制; 而Link节点中每个DefaultHandle数组默认长度16, 可以通过io.netty.recycler.linkCapacity控制;\n通过elements及Link完成了整个对象池的构建。\n\n# 从线程池获取对象\n通过调用Recycler.get()来完成:\n```\n    public final T get() {\n         // 若置为0, 将handle置为Noop_HANDLE, 代表着不被回收\n        if (maxCapacityPerThread == 0) {\n            return newObject((Handle<T>) NOOP_HANDLE);\n        }\n        // 获取当前线程对应的Stack\n        Stack<T> stack = threadLocal.get();\n        // 从对象池获取对象\n        DefaultHandle<T> handle = stack.pop();\n        // 若对象池中没有对象,则调用子类的newObject方法创建新的对象\n        if (handle == null) {\n            handle = stack.newHandle();\n            handle.value = newObject(handle);\n        }\n        return (T) handle.value;\n    }\n```\n主要做了如下事情:\n+ 首先获取本线程对应的唯一stack, 从该stack中获取对象。\n+ 若对象池中没有对象, 则主动调用newObject产生一个对象。同时完成了handle与对象、stack的绑定。\n我们接下来看如何通过stack.pop()来从对象池中获取对象:\n```\n        DefaultHandle<T> pop() {\n            //统计着elements中存放的对象个数\n            int size = this.size;\n           //若elements没有可用对象\n            if (size == 0) {\n                //就尝试从别的线程帮着回收的对象中转移一些到elements中, 也就是从WeakOrderQueue中转移一些数据出来\n                if (!scavenge()) {\n                    return null;\n                }\n                size = this.size;\n            }\n            size --;\n            DefaultHandle ret = elements[size];\n            elements[size] = null;\n            //在stack的lastRecycledId及recycleId一定是相等的\n            if (ret.lastRecycledId != ret.recycleId) {\n                throw new IllegalStateException(\"recycled multiple times\");\n            }\n            ret.recycleId = 0;\n            ret.lastRecycledId = 0;\n            this.size = size;\n            return ret;\n        }\n```\n对象在从对象池中被获取时, recycleId及lastRecycledId都被清零。\n我们看scavenge是如何回收内存的。\n```\n        boolean scavenge() {\n            //尝试从WeakOrderQueue中转移数据DefaultHandle到stack的elements中\n            if (scavengeSome()) {\n                return true;\n            }\n\n            // reset our scavenge cursor\n            prev = null;\n            cursor = head;\n            return false;\n        }\n        boolean scavengeSome() {\n             //cursor属性保存了上一次对WeakorderQueueu列表的浏览位置，每一次都从上一次的位置继续，这是一种FIFO的处理策略\n            WeakOrderQueue prev;\n            WeakOrderQueue cursor = this.cursor;\n            //若游标为null, 则是第一次从WeakorderQueueu链中获取元素\n            if (cursor == null) {\n                prev = null;\n                cursor = head;\n                //若不存在任何WeakorderQueueu, 退出\n                if (cursor == null) {\n                    return false;\n                }\n            } else {\n                prev = this.prev;\n            }\n            boolean success = false;\n            //循环的不停地从WeakOrderQueue中找到一个可用的Link\n            do {\n                //从WeakOrderQueue中转移数据到element数组中。\n                if (cursor.transfer(this)) {\n                    success = true;\n                    break;\n                }\n                WeakOrderQueue next = cursor.next;\n                //如果当前处理的WeakOrderQueue所在的线程已经消亡，则尽可能的提取里面的数据，之后从列表中删除这个WeakOrderQueue。注意owner使用WeakReference<Thread>定义, 当线程消亡后, 通过cursor.owner.get()自然变为null\n                if (cursor.owner.get() == null) {\n                    // If the thread associated with the queue is gone, unlink it, after\n                    // performing a volatile read to confirm there is no data left to collect.\n                    // We never unlink the first queue, as we don't want to synchronize on updating the head.\n                    //如果消亡的线程还有数据，\n                    if (cursor.hasFinalData()) {\n                        for (;;) {\n                            //尽量将该线程对应的WeakOrderQueue里面link对应的对象迁移到elements中\n                            if (cursor.transfer(this)) {\n                                success = true;\n                            } else {\n                                break;\n                            }\n                        }\n                    }\n                   //将消亡的那个WeakOrderQueue从链中去掉\n                    if (prev != null) {\n                        prev.setNext(next);\n                    }\n                } else {\n                    prev = cursor;\n                }\n                cursor = next;\n            } while (cursor != null && !success);\n            this.prev = prev;\n            this.cursor = cursor;\n            return success;\n        }\n```\n若stack的elements中没有对象, 那么把对象从Link的DefautHandle[]中迁移到stack的elements中:\n```\n    boolean transfer(Stack<?> dst) {\n            Link head = this.head;\n            //WeakOrderQueue中整个Link链为空, 则直接退出\n            if (head == null) {\n                return false;\n            }\n            //说明head已经被读取完了，需要将head指向当前WeakOrderQueue的下一个link\n            if (head.readIndex == LINK_CAPACITY) {\n                if (head.next == null) {\n                    return false;\n                }\n                //当前链节点换头\n                this.head = head = head.next;\n            }\n            //获取当前可读的下标\n            final int srcStart = head.readIndex;\n            //当前link write的下标\n            int srcEnd = head.get();\n            //总共可读长度\n            final int srcSize = srcEnd - srcStart;\n            if (srcSize == 0) {\n                return false;\n            }\n            //计算即将写到elements中起始与终点位置\n            final int dstSize = dst.size;\n            final int expectedCapacity = dstSize + srcSize;\n            //如果超过stack当前能装下的最大elements个数\n            if (expectedCapacity > dst.elements.length) {\n                //将stack的elements扩容\n                final int actualCapacity = dst.increaseCapacity(expectedCapacity);\n                srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);\n            }\n            if (srcStart != srcEnd) {\n                final DefaultHandle[] srcElems = head.elements;\n                final DefaultHandle[] dstElems = dst.elements;\n                int newDstSize = dstSize;\n                //每个元素都开始从源迁移到目的地\n                for (int i = srcStart; i < srcEnd; i++) {\n                    DefaultHandle element = srcElems[i];\n                    //对象在被回收时, recycleId、lastRecycledId都是0, 若直接被会受到stack的element中时, recycleId=lastRecycledId=thread_id; 若被会受到Link中时, lastRecycledId被修改成当前thread_id, recycleId仍为0, 当元素从Link迁移至stack的elements时, recycleId=astRecycledId。\n                    if (element.recycleId == 0) {\n                        element.recycleId = element.lastRecycledId;\n                    } else if (element.recycleId != element.lastRecycledId) {\n                        throw new IllegalStateException(\"recycled already\");\n                    }\n                    srcElems[i] = null;\n                    //为了防止stack的elements扩张太快, 实际每8个迁移的对象中只取1个, 7个都被丢弃了\n                    if (dst.dropHandle(element)) {\n                        // Drop the object.\n                        continue;\n                    }\n                    element.stack = dst;\n                    dstElems[newDstSize ++] = element;\n                }\n                // 若当前WeakOrderQueue的head已经被迁移完了, 需要从队列中抛弃\n                if (srcEnd == LINK_CAPACITY && head.next != null) {\n                    // Add capacity back as the Link is GCed.\n                    //增加每个线程帮另一个线程最多回收的限制\n                    reclaimSpace(LINK_CAPACITY);\n                    this.head = head.next; //当前WeakOrderQueue更新head\n                }\n                //更新该head对象可读下标\n                head.readIndex = srcEnd;\n                if (dst.size == newDstSize) {\n                    return false;\n                }\n                //更新stack可用对象的个数\n                dst.size = newDstSize;\n                return true;\n            } else {\n                // The destination stack is full already.\n                return false;\n            }\n        }\n```\n从对象池中获取对象步骤总结如下:\n1. 检查stack的elements中是否有可剩余的DefaultHandle。\n2. 若没有的话, 从cursor的head开始查找当前WeakorderQueue, 并检查WeakorderQueue对应的线程是否还存活着, 若对应的帮着回收的线程不再了, 则调用transfer将该WeakorderQueue对应的所有link中的数组循环迁移到elements中, 迁移的时候每8个丢弃7个, 只有一个被回收。\n3. 若对应线程还存活着, 则调用transfer进行回收当前WeakorderQueue中的一个link的所有DefaultHandle[]到stack的elements中。\n\n# 向对象池中存放对象\n如上例所示, 释放对象时调用cycler1.recycle()即可, 最终会调用与当前对象绑定的stack.push():\n```\n        void push(DefaultHandle<?> item) {\n            Thread currentThread = Thread.currentThread();\n            //如果本线程就是产生对象的那个县城，那么直接把该对象放到stack的elements数组里\n            if (thread == currentThread) {\n                // The current Thread is the thread that belongs to the Stack, we can try to push the object now.\n                pushNow(item);\n            } else {\n                // The current Thread is not the one that belongs to the Stack, we need to signal that the push\n                // happens later.\n                //如果该stack不是本线程的stack，那么把该DefaultHandle放到该stack的WeakOrderQueue中\n                pushLater(item, currentThread);\n            }\n        }\n```\n若回收对象的线程就是产生对象的线程, 那么直接将对象放到本stack对应的elements中。\n```\n        private void pushNow(DefaultHandle<?> item) {\n            if ((item.recycleId | item.lastRecycledId) != 0) {\n                throw new IllegalStateException(\"recycled already\");\n            }\n            #俩都直接赋值相等, 则说明对象处于stack的elements中等待被读取。\n            item.recycleId = item.lastRecycledId = OWN_THREAD_ID;\n            int size = this.size;\n            //在push到对象池时, 也会丢弃7/8的元素\n            if (size >= maxCapacity || dropHandle(item)) {\n                // Hit the maximum capacity or should drop - drop the possibly youngest object.\n                return;\n            }\n            //直接把DefaultHandle放到stack的数组里，如果数组满了那么扩展该数组为当前2倍大小\n            if (size == elements.length) {\n                elements = Arrays.copyOf(elements, min(size << 1, maxCapacity));\n            }\n            elements[size] = item;\n            this.size = size + 1;\n        }\n```\n直接存放对象时, 对象池也会丢弃7/8的对象。\n若回收对象的线程不是产生对象的线程, 我们来看下是如何将对象放到Link的数组中的:\n```\n   private void pushLater(DefaultHandle<?> item, Thread thread) {\n            // we don't want to have a ref to the queue as the value in our weak map\n            // so we null it out; to ensure there are no races with restoring it later\n            // we impose a memory ordering here (no-op on x86)\n            //DELAYED_RECYCLED里存放了当前线程向所有stack中插入的WeakOrderQueue的映射关系\n            Map<Stack<?>, WeakOrderQueue> delayedRecycled = DELAYED_RECYCLED.get();\n            //获取到当前线程向stack插入的WeakOrderQueue节点\n            WeakOrderQueue queue = delayedRecycled.get(this);\n            if (queue == null) {\n                //每个stack/线程最多能向maxDelayedQueues（2*cpu）个线程的WeakOrderQueue队列添加回收的的对象\n                if (delayedRecycled.size() >= maxDelayedQueues) {//如果已经向maxDelayedQueues个线程插入过数据, 那么将1个伪造的WeakOrderQueue（DUMMY）放到delayedRecycled中，并丢弃该对象（DefaultHandle）\n                    // Add a dummy queue so we know we should drop the object\n                    delayedRecycled.put(this, WeakOrderQueue.DUMMY);\n                    return;\n                }\n                // Check if we already reached the maximum number of delayed queues and if we can allocate at all.\n               //别的线程最多向这个stack的WeakOrderQueue插入16384个对象, 检查是否可以插入, 若可以插入, 就向这个stack头插法新建WeakOrderQueue对象\n                if ((queue = WeakOrderQueue.allocate(this, thread)) == null) {\n                    // drop object\n                    return;\n                }\n                delayedRecycled.put(this, queue);\n             //已经插入满了\n            } else if (queue == WeakOrderQueue.DUMMY) {\n                // drop object\n                return;\n            }\n            queue.add(item); //向WeakOrderQueue对应的Link插入对象\n        }\n```\nDELAYED_RECYCLED实际保存的是每个线程向别的stack插入WeakOrderQueue的对应关系, 下图是一个线程保存向别的stack插入WeakOrderQueue的映射关系。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler2.png\" height=\"350\" width=\"450\"/>\n找到对应的WeakOrderQueue后, 调用add向对应的Link中插入对象:\n```\n        void add(DefaultHandle<?> handle) {\n            //这里仅仅修改lastRecycledId值, recycledId的修改时从WeakOrderQueue的link迁移到stack的elements的时候\n            handle.lastRecycledId = id;\n            Link tail = this.tail;\n            int writeIndex;\n            //若当前Link已经写满了, 那么我们再新一个Link存放对象\n            if ((writeIndex = tail.get()) == LINK_CAPACITY) {\n                if (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) {\n                    // Drop it.\n                    return;\n                }\n                // We allocate a Link so reserve the space\n                this.tail = tail = tail.next = new Link();\n                writeIndex = tail.get();\n            }\n            tail.elements[writeIndex] = handle;\n            //本Link所处的stack即为handle.stack。在对象池中可以清空, 在被转移到stack的elements时重新赋值。\n            handle.stack = null;\n            // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;\n            // this also means we guarantee visibility of an element in the queue if we see the index updated\n           //修改内存偏移地址为8的值，但是修改后不保证立马能被其他的线程看到。\n            tail.lazySet(writeIndex + 1);  //https://github.com/netty/netty/issues/8215\n        }\n```\n可以看到, 向Link中插入对象时, 仅改变对象的lastRecycledId值, 而没有改变recycledId值。\n\n# 总结\nNetty回收对象也不是把所有对象全部回收, 为了防止回收对象过多, 会在直接存入stack的elements和从Link转移到stack的elements时会丢弃7/8的废弃对象。Netty中使用对象回收的地方很多, 一个高频使用就是PooledUnsafeDirectByteBuf, 首先申请16M内存作为内存池时, 按需分配小的内存块, 这些小内存块都会被PooledUnsafeDirectByteBuf管理着。 而减少PooledUnsafeDirectByteBuf对象创建次数, 也增强了netty高性能传输数据的能力。\n","slug":"Netty对象回收池Recycler原理详解","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xa000tphu51vczjj5q","content":"<p>同Netty内存池(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)一样, 为了增强Netty高性能并发能力, 减少通用对象分配的损耗, 也采用了对象池的概念。 当需要某个对象时, 首先从对象池中获取该对象, 当使用完成后, 将对象释放到对象池中, 这样达到重复使用对象的效果。基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Cycli &#123;</div><div class=\"line\">    private static final Recycler&lt;Cycler&gt; CyclerRecycler = new Recycler&lt;Cycler&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        protected Cycler newObject(Handle&lt;Cycler&gt; handle) &#123;</div><div class=\"line\">            return new Cycler(handle);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    static final class Cycler &#123;</div><div class=\"line\">        private String value;</div><div class=\"line\">        public void setValue(String value) &#123;</div><div class=\"line\">            this.value = value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        private Recycler.Handle&lt;Cycler&gt; handle;</div><div class=\"line\">        public Cycler(Recycler.Handle&lt;Cycler&gt; handle) &#123;</div><div class=\"line\">            this.handle = handle;</div><div class=\"line\">        &#125;</div><div class=\"line\">        public void recycle() &#123;</div><div class=\"line\">            handle.recycle(this);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public static void  main(String[] args) &#123;</div><div class=\"line\">        // 1、从回收池获取对象</div><div class=\"line\">        Cycler cycler1 = CyclerRecycler.get();</div><div class=\"line\">        // 2、开始使用对象</div><div class=\"line\">        cycler1.setValue(&quot;hello,java&quot;);</div><div class=\"line\">        // 3、回收对象到对象池</div><div class=\"line\">        cycler1.recycle();</div><div class=\"line\">        // 4、从回收池获取对象</div><div class=\"line\">        Cycler cycler2 = CyclerRecycler.get();</div><div class=\"line\">        //比较从对象池中获取的对象即为之前释放的对象</div><div class=\"line\">        System.out.print(cycler1 == cycler2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用比较简单, 主要定义了如下几个对象:</p>\n<ul>\n<li>定义CyclerRecycler, 作为对象池的入口, 定义newObject()函数, 若对象池中没有可用对象, 则新建对象。</li>\n<li>定义被回收的对象Cycler, 包含成员变量handle, 该handler与该对象和stack绑定的。</li>\n<li>通过CyclerRecycler.get()从对象池中获取对象; 通过Cycler1.recycle()释放该对象到对象池。</li>\n</ul>\n<h2 id=\"WeakOrderQueue、Stack介绍\"><a href=\"#WeakOrderQueue、Stack介绍\" class=\"headerlink\" title=\"WeakOrderQueue、Stack介绍\"></a>WeakOrderQueue、Stack介绍</h2><p>对象池通过Recycler里面WeakOrderQueue、Stack 2个类来实现。 首先放一张图来展示一个stack中两者的关系:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler1.png\" height=\"450\" width=\"650\"></p>\n<ul>\n<li>每个线程都拥有自己的对象池, 该对象池结构如上图所示, stack作为本线程对象池的核心, 通过FastThreadLocal来实现每个线程的本地化。</li>\n<li>本线程回收本线程产生的对象时, 会将对象以DefaultHandle的形式存放在stack的elements数组中; 若本线程thread1回收其它线程thread2产生的对象时, 将该对象放到thread2对应stack的一个WeakOrderQueue的Link中。 也就是说一个WeakOrderQueue节点存放着一个其他线程帮着本线程回收本线程生产的对象。每个stack的WeakOrderQueue链表节点个数不能超过2<em>cpu, 可以通过io.netty.recycler.maxDelayedQueuesPerThread控制。 也就是说最多有2</em>cpu个线程帮着回收对象。</li>\n<li>每个link存放的对象是有限的, Link中DefaultHandle[]最多存放16个对象。 若thread1回收thread2产生的对象装满了一个Link, 则会再产生一个link继续存放。</li>\n<li>当前线程从对象池中拿对象时, 首先从stack的elements中获取, 若没有的话, 将尝试从当前WeakOrderQueue节点cursor的Link中的数组对象transfer到stack的elements, 再从stack的elements中获取对象。</li>\n<li>stack的element数组最大长度32768, 可以通过io.netty.recycler.maxCapacityPerThread控制; 而Link节点中每个DefaultHandle数组默认长度16, 可以通过io.netty.recycler.linkCapacity控制;<br>通过elements及Link完成了整个对象池的构建。</li>\n</ul>\n<h1 id=\"从线程池获取对象\"><a href=\"#从线程池获取对象\" class=\"headerlink\" title=\"从线程池获取对象\"></a>从线程池获取对象</h1><p>通过调用Recycler.get()来完成:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final T get() &#123;</div><div class=\"line\">     // 若置为0, 将handle置为Noop_HANDLE, 代表着不被回收</div><div class=\"line\">    if (maxCapacityPerThread == 0) &#123;</div><div class=\"line\">        return newObject((Handle&lt;T&gt;) NOOP_HANDLE);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 获取当前线程对应的Stack</div><div class=\"line\">    Stack&lt;T&gt; stack = threadLocal.get();</div><div class=\"line\">    // 从对象池获取对象</div><div class=\"line\">    DefaultHandle&lt;T&gt; handle = stack.pop();</div><div class=\"line\">    // 若对象池中没有对象,则调用子类的newObject方法创建新的对象</div><div class=\"line\">    if (handle == null) &#123;</div><div class=\"line\">        handle = stack.newHandle();</div><div class=\"line\">        handle.value = newObject(handle);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return (T) handle.value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先获取本线程对应的唯一stack, 从该stack中获取对象。</li>\n<li>若对象池中没有对象, 则主动调用newObject产生一个对象。同时完成了handle与对象、stack的绑定。<br>我们接下来看如何通过stack.pop()来从对象池中获取对象:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">DefaultHandle&lt;T&gt; pop() &#123;</div><div class=\"line\">    //统计着elements中存放的对象个数</div><div class=\"line\">    int size = this.size;</div><div class=\"line\">   //若elements没有可用对象</div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        //就尝试从别的线程帮着回收的对象中转移一些到elements中, 也就是从WeakOrderQueue中转移一些数据出来</div><div class=\"line\">        if (!scavenge()) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        size = this.size;</div><div class=\"line\">    &#125;</div><div class=\"line\">    size --;</div><div class=\"line\">    DefaultHandle ret = elements[size];</div><div class=\"line\">    elements[size] = null;</div><div class=\"line\">    //在stack的lastRecycledId及recycleId一定是相等的</div><div class=\"line\">    if (ret.lastRecycledId != ret.recycleId) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;recycled multiple times&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ret.recycleId = 0;</div><div class=\"line\">    ret.lastRecycledId = 0;</div><div class=\"line\">    this.size = size;</div><div class=\"line\">    return ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对象在从对象池中被获取时, recycleId及lastRecycledId都被清零。<br>我们看scavenge是如何回收内存的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean scavenge() &#123;</div><div class=\"line\">    //尝试从WeakOrderQueue中转移数据DefaultHandle到stack的elements中</div><div class=\"line\">    if (scavengeSome()) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // reset our scavenge cursor</div><div class=\"line\">    prev = null;</div><div class=\"line\">    cursor = head;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\">boolean scavengeSome() &#123;</div><div class=\"line\">     //cursor属性保存了上一次对WeakorderQueueu列表的浏览位置，每一次都从上一次的位置继续，这是一种FIFO的处理策略</div><div class=\"line\">    WeakOrderQueue prev;</div><div class=\"line\">    WeakOrderQueue cursor = this.cursor;</div><div class=\"line\">    //若游标为null, 则是第一次从WeakorderQueueu链中获取元素</div><div class=\"line\">    if (cursor == null) &#123;</div><div class=\"line\">        prev = null;</div><div class=\"line\">        cursor = head;</div><div class=\"line\">        //若不存在任何WeakorderQueueu, 退出</div><div class=\"line\">        if (cursor == null) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        prev = this.prev;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean success = false;</div><div class=\"line\">    //循环的不停地从WeakOrderQueue中找到一个可用的Link</div><div class=\"line\">    do &#123;</div><div class=\"line\">        //从WeakOrderQueue中转移数据到element数组中。</div><div class=\"line\">        if (cursor.transfer(this)) &#123;</div><div class=\"line\">            success = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        WeakOrderQueue next = cursor.next;</div><div class=\"line\">        //如果当前处理的WeakOrderQueue所在的线程已经消亡，则尽可能的提取里面的数据，之后从列表中删除这个WeakOrderQueue。注意owner使用WeakReference&lt;Thread&gt;定义, 当线程消亡后, 通过cursor.owner.get()自然变为null</div><div class=\"line\">        if (cursor.owner.get() == null) &#123;</div><div class=\"line\">            // If the thread associated with the queue is gone, unlink it, after</div><div class=\"line\">            // performing a volatile read to confirm there is no data left to collect.</div><div class=\"line\">            // We never unlink the first queue, as we don&apos;t want to synchronize on updating the head.</div><div class=\"line\">            //如果消亡的线程还有数据，</div><div class=\"line\">            if (cursor.hasFinalData()) &#123;</div><div class=\"line\">                for (;;) &#123;</div><div class=\"line\">                    //尽量将该线程对应的WeakOrderQueue里面link对应的对象迁移到elements中</div><div class=\"line\">                    if (cursor.transfer(this)) &#123;</div><div class=\"line\">                        success = true;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">           //将消亡的那个WeakOrderQueue从链中去掉</div><div class=\"line\">            if (prev != null) &#123;</div><div class=\"line\">                prev.setNext(next);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            prev = cursor;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cursor = next;</div><div class=\"line\">    &#125; while (cursor != null &amp;&amp; !success);</div><div class=\"line\">    this.prev = prev;</div><div class=\"line\">    this.cursor = cursor;</div><div class=\"line\">    return success;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>若stack的elements中没有对象, 那么把对象从Link的DefautHandle[]中迁移到stack的elements中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean transfer(Stack&lt;?&gt; dst) &#123;</div><div class=\"line\">        Link head = this.head;</div><div class=\"line\">        //WeakOrderQueue中整个Link链为空, 则直接退出</div><div class=\"line\">        if (head == null) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //说明head已经被读取完了，需要将head指向当前WeakOrderQueue的下一个link</div><div class=\"line\">        if (head.readIndex == LINK_CAPACITY) &#123;</div><div class=\"line\">            if (head.next == null) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //当前链节点换头</div><div class=\"line\">            this.head = head = head.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //获取当前可读的下标</div><div class=\"line\">        final int srcStart = head.readIndex;</div><div class=\"line\">        //当前link write的下标</div><div class=\"line\">        int srcEnd = head.get();</div><div class=\"line\">        //总共可读长度</div><div class=\"line\">        final int srcSize = srcEnd - srcStart;</div><div class=\"line\">        if (srcSize == 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //计算即将写到elements中起始与终点位置</div><div class=\"line\">        final int dstSize = dst.size;</div><div class=\"line\">        final int expectedCapacity = dstSize + srcSize;</div><div class=\"line\">        //如果超过stack当前能装下的最大elements个数</div><div class=\"line\">        if (expectedCapacity &gt; dst.elements.length) &#123;</div><div class=\"line\">            //将stack的elements扩容</div><div class=\"line\">            final int actualCapacity = dst.increaseCapacity(expectedCapacity);</div><div class=\"line\">            srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (srcStart != srcEnd) &#123;</div><div class=\"line\">            final DefaultHandle[] srcElems = head.elements;</div><div class=\"line\">            final DefaultHandle[] dstElems = dst.elements;</div><div class=\"line\">            int newDstSize = dstSize;</div><div class=\"line\">            //每个元素都开始从源迁移到目的地</div><div class=\"line\">            for (int i = srcStart; i &lt; srcEnd; i++) &#123;</div><div class=\"line\">                DefaultHandle element = srcElems[i];</div><div class=\"line\">                //对象在被回收时, recycleId、lastRecycledId都是0, 若直接被会受到stack的element中时, recycleId=lastRecycledId=thread_id; 若被会受到Link中时, lastRecycledId被修改成当前thread_id, recycleId仍为0, 当元素从Link迁移至stack的elements时, recycleId=astRecycledId。</div><div class=\"line\">                if (element.recycleId == 0) &#123;</div><div class=\"line\">                    element.recycleId = element.lastRecycledId;</div><div class=\"line\">                &#125; else if (element.recycleId != element.lastRecycledId) &#123;</div><div class=\"line\">                    throw new IllegalStateException(&quot;recycled already&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                srcElems[i] = null;</div><div class=\"line\">                //为了防止stack的elements扩张太快, 实际每8个迁移的对象中只取1个, 7个都被丢弃了</div><div class=\"line\">                if (dst.dropHandle(element)) &#123;</div><div class=\"line\">                    // Drop the object.</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                element.stack = dst;</div><div class=\"line\">                dstElems[newDstSize ++] = element;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // 若当前WeakOrderQueue的head已经被迁移完了, 需要从队列中抛弃</div><div class=\"line\">            if (srcEnd == LINK_CAPACITY &amp;&amp; head.next != null) &#123;</div><div class=\"line\">                // Add capacity back as the Link is GCed.</div><div class=\"line\">                //增加每个线程帮另一个线程最多回收的限制</div><div class=\"line\">                reclaimSpace(LINK_CAPACITY);</div><div class=\"line\">                this.head = head.next; //当前WeakOrderQueue更新head</div><div class=\"line\">            &#125;</div><div class=\"line\">            //更新该head对象可读下标</div><div class=\"line\">            head.readIndex = srcEnd;</div><div class=\"line\">            if (dst.size == newDstSize) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //更新stack可用对象的个数</div><div class=\"line\">            dst.size = newDstSize;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // The destination stack is full already.</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>从对象池中获取对象步骤总结如下:</p>\n<ol>\n<li>检查stack的elements中是否有可剩余的DefaultHandle。</li>\n<li>若没有的话, 从cursor的head开始查找当前WeakorderQueue, 并检查WeakorderQueue对应的线程是否还存活着, 若对应的帮着回收的线程不再了, 则调用transfer将该WeakorderQueue对应的所有link中的数组循环迁移到elements中, 迁移的时候每8个丢弃7个, 只有一个被回收。</li>\n<li>若对应线程还存活着, 则调用transfer进行回收当前WeakorderQueue中的一个link的所有DefaultHandle[]到stack的elements中。</li>\n</ol>\n<h1 id=\"向对象池中存放对象\"><a href=\"#向对象池中存放对象\" class=\"headerlink\" title=\"向对象池中存放对象\"></a>向对象池中存放对象</h1><p>如上例所示, 释放对象时调用cycler1.recycle()即可, 最终会调用与当前对象绑定的stack.push():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">void push(DefaultHandle&lt;?&gt; item) &#123;</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    //如果本线程就是产生对象的那个县城，那么直接把该对象放到stack的elements数组里</div><div class=\"line\">    if (thread == currentThread) &#123;</div><div class=\"line\">        // The current Thread is the thread that belongs to the Stack, we can try to push the object now.</div><div class=\"line\">        pushNow(item);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // The current Thread is not the one that belongs to the Stack, we need to signal that the push</div><div class=\"line\">        // happens later.</div><div class=\"line\">        //如果该stack不是本线程的stack，那么把该DefaultHandle放到该stack的WeakOrderQueue中</div><div class=\"line\">        pushLater(item, currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>若回收对象的线程就是产生对象的线程, 那么直接将对象放到本stack对应的elements中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void pushNow(DefaultHandle&lt;?&gt; item) &#123;</div><div class=\"line\">    if ((item.recycleId | item.lastRecycledId) != 0) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;recycled already&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    #俩都直接赋值相等, 则说明对象处于stack的elements中等待被读取。</div><div class=\"line\">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</div><div class=\"line\">    int size = this.size;</div><div class=\"line\">    //在push到对象池时, 也会丢弃7/8的元素</div><div class=\"line\">    if (size &gt;= maxCapacity || dropHandle(item)) &#123;</div><div class=\"line\">        // Hit the maximum capacity or should drop - drop the possibly youngest object.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //直接把DefaultHandle放到stack的数组里，如果数组满了那么扩展该数组为当前2倍大小</div><div class=\"line\">    if (size == elements.length) &#123;</div><div class=\"line\">        elements = Arrays.copyOf(elements, min(size &lt;&lt; 1, maxCapacity));</div><div class=\"line\">    &#125;</div><div class=\"line\">    elements[size] = item;</div><div class=\"line\">    this.size = size + 1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>直接存放对象时, 对象池也会丢弃7/8的对象。<br>若回收对象的线程不是产生对象的线程, 我们来看下是如何将对象放到Link的数组中的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) &#123;</div><div class=\"line\">         // we don&apos;t want to have a ref to the queue as the value in our weak map</div><div class=\"line\">         // so we null it out; to ensure there are no races with restoring it later</div><div class=\"line\">         // we impose a memory ordering here (no-op on x86)</div><div class=\"line\">         //DELAYED_RECYCLED里存放了当前线程向所有stack中插入的WeakOrderQueue的映射关系</div><div class=\"line\">         Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</div><div class=\"line\">         //获取到当前线程向stack插入的WeakOrderQueue节点</div><div class=\"line\">         WeakOrderQueue queue = delayedRecycled.get(this);</div><div class=\"line\">         if (queue == null) &#123;</div><div class=\"line\">             //每个stack/线程最多能向maxDelayedQueues（2*cpu）个线程的WeakOrderQueue队列添加回收的的对象</div><div class=\"line\">             if (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;//如果已经向maxDelayedQueues个线程插入过数据, 那么将1个伪造的WeakOrderQueue（DUMMY）放到delayedRecycled中，并丢弃该对象（DefaultHandle）</div><div class=\"line\">                 // Add a dummy queue so we know we should drop the object</div><div class=\"line\">                 delayedRecycled.put(this, WeakOrderQueue.DUMMY);</div><div class=\"line\">                 return;</div><div class=\"line\">             &#125;</div><div class=\"line\">             // Check if we already reached the maximum number of delayed queues and if we can allocate at all.</div><div class=\"line\">            //别的线程最多向这个stack的WeakOrderQueue插入16384个对象, 检查是否可以插入, 若可以插入, 就向这个stack头插法新建WeakOrderQueue对象</div><div class=\"line\">             if ((queue = WeakOrderQueue.allocate(this, thread)) == null) &#123;</div><div class=\"line\">                 // drop object</div><div class=\"line\">                 return;</div><div class=\"line\">             &#125;</div><div class=\"line\">             delayedRecycled.put(this, queue);</div><div class=\"line\">          //已经插入满了</div><div class=\"line\">         &#125; else if (queue == WeakOrderQueue.DUMMY) &#123;</div><div class=\"line\">             // drop object</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         queue.add(item); //向WeakOrderQueue对应的Link插入对象</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<p>DELAYED_RECYCLED实际保存的是每个线程向别的stack插入WeakOrderQueue的对应关系, 下图是一个线程保存向别的stack插入WeakOrderQueue的映射关系。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler2.png\" height=\"350\" width=\"450\"><br>找到对应的WeakOrderQueue后, 调用add向对应的Link中插入对象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">void add(DefaultHandle&lt;?&gt; handle) &#123;</div><div class=\"line\">    //这里仅仅修改lastRecycledId值, recycledId的修改时从WeakOrderQueue的link迁移到stack的elements的时候</div><div class=\"line\">    handle.lastRecycledId = id;</div><div class=\"line\">    Link tail = this.tail;</div><div class=\"line\">    int writeIndex;</div><div class=\"line\">    //若当前Link已经写满了, 那么我们再新一个Link存放对象</div><div class=\"line\">    if ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</div><div class=\"line\">        if (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) &#123;</div><div class=\"line\">            // Drop it.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // We allocate a Link so reserve the space</div><div class=\"line\">        this.tail = tail = tail.next = new Link();</div><div class=\"line\">        writeIndex = tail.get();</div><div class=\"line\">    &#125;</div><div class=\"line\">    tail.elements[writeIndex] = handle;</div><div class=\"line\">    //本Link所处的stack即为handle.stack。在对象池中可以清空, 在被转移到stack的elements时重新赋值。</div><div class=\"line\">    handle.stack = null;</div><div class=\"line\">    // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;</div><div class=\"line\">    // this also means we guarantee visibility of an element in the queue if we see the index updated</div><div class=\"line\">   //修改内存偏移地址为8的值，但是修改后不保证立马能被其他的线程看到。</div><div class=\"line\">    tail.lazySet(writeIndex + 1);  //https://github.com/netty/netty/issues/8215</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, 向Link中插入对象时, 仅改变对象的lastRecycledId值, 而没有改变recycledId值。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Netty回收对象也不是把所有对象全部回收, 为了防止回收对象过多, 会在直接存入stack的elements和从Link转移到stack的elements时会丢弃7/8的废弃对象。Netty中使用对象回收的地方很多, 一个高频使用就是PooledUnsafeDirectByteBuf, 首先申请16M内存作为内存池时, 按需分配小的内存块, 这些小内存块都会被PooledUnsafeDirectByteBuf管理着。 而减少PooledUnsafeDirectByteBuf对象创建次数, 也增强了netty高性能传输数据的能力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>同Netty内存池(可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/05/23/Netty%E5%86%85%E5%AD%98%E5%AD%A6%E4%B9%A0/\">Netty PoolArea原理探究</a>)一样, 为了增强Netty高性能并发能力, 减少通用对象分配的损耗, 也采用了对象池的概念。 当需要某个对象时, 首先从对象池中获取该对象, 当使用完成后, 将对象释放到对象池中, 这样达到重复使用对象的效果。基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Cycli &#123;</div><div class=\"line\">    private static final Recycler&lt;Cycler&gt; CyclerRecycler = new Recycler&lt;Cycler&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        protected Cycler newObject(Handle&lt;Cycler&gt; handle) &#123;</div><div class=\"line\">            return new Cycler(handle);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;;</div><div class=\"line\">    static final class Cycler &#123;</div><div class=\"line\">        private String value;</div><div class=\"line\">        public void setValue(String value) &#123;</div><div class=\"line\">            this.value = value;</div><div class=\"line\">        &#125;</div><div class=\"line\">        private Recycler.Handle&lt;Cycler&gt; handle;</div><div class=\"line\">        public Cycler(Recycler.Handle&lt;Cycler&gt; handle) &#123;</div><div class=\"line\">            this.handle = handle;</div><div class=\"line\">        &#125;</div><div class=\"line\">        public void recycle() &#123;</div><div class=\"line\">            handle.recycle(this);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    public static void  main(String[] args) &#123;</div><div class=\"line\">        // 1、从回收池获取对象</div><div class=\"line\">        Cycler cycler1 = CyclerRecycler.get();</div><div class=\"line\">        // 2、开始使用对象</div><div class=\"line\">        cycler1.setValue(&quot;hello,java&quot;);</div><div class=\"line\">        // 3、回收对象到对象池</div><div class=\"line\">        cycler1.recycle();</div><div class=\"line\">        // 4、从回收池获取对象</div><div class=\"line\">        Cycler cycler2 = CyclerRecycler.get();</div><div class=\"line\">        //比较从对象池中获取的对象即为之前释放的对象</div><div class=\"line\">        System.out.print(cycler1 == cycler2);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用比较简单, 主要定义了如下几个对象:</p>\n<ul>\n<li>定义CyclerRecycler, 作为对象池的入口, 定义newObject()函数, 若对象池中没有可用对象, 则新建对象。</li>\n<li>定义被回收的对象Cycler, 包含成员变量handle, 该handler与该对象和stack绑定的。</li>\n<li>通过CyclerRecycler.get()从对象池中获取对象; 通过Cycler1.recycle()释放该对象到对象池。</li>\n</ul>\n<h2 id=\"WeakOrderQueue、Stack介绍\"><a href=\"#WeakOrderQueue、Stack介绍\" class=\"headerlink\" title=\"WeakOrderQueue、Stack介绍\"></a>WeakOrderQueue、Stack介绍</h2><p>对象池通过Recycler里面WeakOrderQueue、Stack 2个类来实现。 首先放一张图来展示一个stack中两者的关系:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler1.png\" height=\"450\" width=\"650\"></p>\n<ul>\n<li>每个线程都拥有自己的对象池, 该对象池结构如上图所示, stack作为本线程对象池的核心, 通过FastThreadLocal来实现每个线程的本地化。</li>\n<li>本线程回收本线程产生的对象时, 会将对象以DefaultHandle的形式存放在stack的elements数组中; 若本线程thread1回收其它线程thread2产生的对象时, 将该对象放到thread2对应stack的一个WeakOrderQueue的Link中。 也就是说一个WeakOrderQueue节点存放着一个其他线程帮着本线程回收本线程生产的对象。每个stack的WeakOrderQueue链表节点个数不能超过2<em>cpu, 可以通过io.netty.recycler.maxDelayedQueuesPerThread控制。 也就是说最多有2</em>cpu个线程帮着回收对象。</li>\n<li>每个link存放的对象是有限的, Link中DefaultHandle[]最多存放16个对象。 若thread1回收thread2产生的对象装满了一个Link, 则会再产生一个link继续存放。</li>\n<li>当前线程从对象池中拿对象时, 首先从stack的elements中获取, 若没有的话, 将尝试从当前WeakOrderQueue节点cursor的Link中的数组对象transfer到stack的elements, 再从stack的elements中获取对象。</li>\n<li>stack的element数组最大长度32768, 可以通过io.netty.recycler.maxCapacityPerThread控制; 而Link节点中每个DefaultHandle数组默认长度16, 可以通过io.netty.recycler.linkCapacity控制;<br>通过elements及Link完成了整个对象池的构建。</li>\n</ul>\n<h1 id=\"从线程池获取对象\"><a href=\"#从线程池获取对象\" class=\"headerlink\" title=\"从线程池获取对象\"></a>从线程池获取对象</h1><p>通过调用Recycler.get()来完成:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final T get() &#123;</div><div class=\"line\">     // 若置为0, 将handle置为Noop_HANDLE, 代表着不被回收</div><div class=\"line\">    if (maxCapacityPerThread == 0) &#123;</div><div class=\"line\">        return newObject((Handle&lt;T&gt;) NOOP_HANDLE);</div><div class=\"line\">    &#125;</div><div class=\"line\">    // 获取当前线程对应的Stack</div><div class=\"line\">    Stack&lt;T&gt; stack = threadLocal.get();</div><div class=\"line\">    // 从对象池获取对象</div><div class=\"line\">    DefaultHandle&lt;T&gt; handle = stack.pop();</div><div class=\"line\">    // 若对象池中没有对象,则调用子类的newObject方法创建新的对象</div><div class=\"line\">    if (handle == null) &#123;</div><div class=\"line\">        handle = stack.newHandle();</div><div class=\"line\">        handle.value = newObject(handle);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return (T) handle.value;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先获取本线程对应的唯一stack, 从该stack中获取对象。</li>\n<li>若对象池中没有对象, 则主动调用newObject产生一个对象。同时完成了handle与对象、stack的绑定。<br>我们接下来看如何通过stack.pop()来从对象池中获取对象:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">DefaultHandle&lt;T&gt; pop() &#123;</div><div class=\"line\">    //统计着elements中存放的对象个数</div><div class=\"line\">    int size = this.size;</div><div class=\"line\">   //若elements没有可用对象</div><div class=\"line\">    if (size == 0) &#123;</div><div class=\"line\">        //就尝试从别的线程帮着回收的对象中转移一些到elements中, 也就是从WeakOrderQueue中转移一些数据出来</div><div class=\"line\">        if (!scavenge()) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        size = this.size;</div><div class=\"line\">    &#125;</div><div class=\"line\">    size --;</div><div class=\"line\">    DefaultHandle ret = elements[size];</div><div class=\"line\">    elements[size] = null;</div><div class=\"line\">    //在stack的lastRecycledId及recycleId一定是相等的</div><div class=\"line\">    if (ret.lastRecycledId != ret.recycleId) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;recycled multiple times&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    ret.recycleId = 0;</div><div class=\"line\">    ret.lastRecycledId = 0;</div><div class=\"line\">    this.size = size;</div><div class=\"line\">    return ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>对象在从对象池中被获取时, recycleId及lastRecycledId都被清零。<br>我们看scavenge是如何回收内存的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean scavenge() &#123;</div><div class=\"line\">    //尝试从WeakOrderQueue中转移数据DefaultHandle到stack的elements中</div><div class=\"line\">    if (scavengeSome()) &#123;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // reset our scavenge cursor</div><div class=\"line\">    prev = null;</div><div class=\"line\">    cursor = head;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div><div class=\"line\">boolean scavengeSome() &#123;</div><div class=\"line\">     //cursor属性保存了上一次对WeakorderQueueu列表的浏览位置，每一次都从上一次的位置继续，这是一种FIFO的处理策略</div><div class=\"line\">    WeakOrderQueue prev;</div><div class=\"line\">    WeakOrderQueue cursor = this.cursor;</div><div class=\"line\">    //若游标为null, 则是第一次从WeakorderQueueu链中获取元素</div><div class=\"line\">    if (cursor == null) &#123;</div><div class=\"line\">        prev = null;</div><div class=\"line\">        cursor = head;</div><div class=\"line\">        //若不存在任何WeakorderQueueu, 退出</div><div class=\"line\">        if (cursor == null) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        prev = this.prev;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean success = false;</div><div class=\"line\">    //循环的不停地从WeakOrderQueue中找到一个可用的Link</div><div class=\"line\">    do &#123;</div><div class=\"line\">        //从WeakOrderQueue中转移数据到element数组中。</div><div class=\"line\">        if (cursor.transfer(this)) &#123;</div><div class=\"line\">            success = true;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        WeakOrderQueue next = cursor.next;</div><div class=\"line\">        //如果当前处理的WeakOrderQueue所在的线程已经消亡，则尽可能的提取里面的数据，之后从列表中删除这个WeakOrderQueue。注意owner使用WeakReference&lt;Thread&gt;定义, 当线程消亡后, 通过cursor.owner.get()自然变为null</div><div class=\"line\">        if (cursor.owner.get() == null) &#123;</div><div class=\"line\">            // If the thread associated with the queue is gone, unlink it, after</div><div class=\"line\">            // performing a volatile read to confirm there is no data left to collect.</div><div class=\"line\">            // We never unlink the first queue, as we don&apos;t want to synchronize on updating the head.</div><div class=\"line\">            //如果消亡的线程还有数据，</div><div class=\"line\">            if (cursor.hasFinalData()) &#123;</div><div class=\"line\">                for (;;) &#123;</div><div class=\"line\">                    //尽量将该线程对应的WeakOrderQueue里面link对应的对象迁移到elements中</div><div class=\"line\">                    if (cursor.transfer(this)) &#123;</div><div class=\"line\">                        success = true;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">           //将消亡的那个WeakOrderQueue从链中去掉</div><div class=\"line\">            if (prev != null) &#123;</div><div class=\"line\">                prev.setNext(next);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            prev = cursor;</div><div class=\"line\">        &#125;</div><div class=\"line\">        cursor = next;</div><div class=\"line\">    &#125; while (cursor != null &amp;&amp; !success);</div><div class=\"line\">    this.prev = prev;</div><div class=\"line\">    this.cursor = cursor;</div><div class=\"line\">    return success;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>若stack的elements中没有对象, 那么把对象从Link的DefautHandle[]中迁移到stack的elements中:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean transfer(Stack&lt;?&gt; dst) &#123;</div><div class=\"line\">        Link head = this.head;</div><div class=\"line\">        //WeakOrderQueue中整个Link链为空, 则直接退出</div><div class=\"line\">        if (head == null) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //说明head已经被读取完了，需要将head指向当前WeakOrderQueue的下一个link</div><div class=\"line\">        if (head.readIndex == LINK_CAPACITY) &#123;</div><div class=\"line\">            if (head.next == null) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //当前链节点换头</div><div class=\"line\">            this.head = head = head.next;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //获取当前可读的下标</div><div class=\"line\">        final int srcStart = head.readIndex;</div><div class=\"line\">        //当前link write的下标</div><div class=\"line\">        int srcEnd = head.get();</div><div class=\"line\">        //总共可读长度</div><div class=\"line\">        final int srcSize = srcEnd - srcStart;</div><div class=\"line\">        if (srcSize == 0) &#123;</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //计算即将写到elements中起始与终点位置</div><div class=\"line\">        final int dstSize = dst.size;</div><div class=\"line\">        final int expectedCapacity = dstSize + srcSize;</div><div class=\"line\">        //如果超过stack当前能装下的最大elements个数</div><div class=\"line\">        if (expectedCapacity &gt; dst.elements.length) &#123;</div><div class=\"line\">            //将stack的elements扩容</div><div class=\"line\">            final int actualCapacity = dst.increaseCapacity(expectedCapacity);</div><div class=\"line\">            srcEnd = min(srcStart + actualCapacity - dstSize, srcEnd);</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (srcStart != srcEnd) &#123;</div><div class=\"line\">            final DefaultHandle[] srcElems = head.elements;</div><div class=\"line\">            final DefaultHandle[] dstElems = dst.elements;</div><div class=\"line\">            int newDstSize = dstSize;</div><div class=\"line\">            //每个元素都开始从源迁移到目的地</div><div class=\"line\">            for (int i = srcStart; i &lt; srcEnd; i++) &#123;</div><div class=\"line\">                DefaultHandle element = srcElems[i];</div><div class=\"line\">                //对象在被回收时, recycleId、lastRecycledId都是0, 若直接被会受到stack的element中时, recycleId=lastRecycledId=thread_id; 若被会受到Link中时, lastRecycledId被修改成当前thread_id, recycleId仍为0, 当元素从Link迁移至stack的elements时, recycleId=astRecycledId。</div><div class=\"line\">                if (element.recycleId == 0) &#123;</div><div class=\"line\">                    element.recycleId = element.lastRecycledId;</div><div class=\"line\">                &#125; else if (element.recycleId != element.lastRecycledId) &#123;</div><div class=\"line\">                    throw new IllegalStateException(&quot;recycled already&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                srcElems[i] = null;</div><div class=\"line\">                //为了防止stack的elements扩张太快, 实际每8个迁移的对象中只取1个, 7个都被丢弃了</div><div class=\"line\">                if (dst.dropHandle(element)) &#123;</div><div class=\"line\">                    // Drop the object.</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                element.stack = dst;</div><div class=\"line\">                dstElems[newDstSize ++] = element;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // 若当前WeakOrderQueue的head已经被迁移完了, 需要从队列中抛弃</div><div class=\"line\">            if (srcEnd == LINK_CAPACITY &amp;&amp; head.next != null) &#123;</div><div class=\"line\">                // Add capacity back as the Link is GCed.</div><div class=\"line\">                //增加每个线程帮另一个线程最多回收的限制</div><div class=\"line\">                reclaimSpace(LINK_CAPACITY);</div><div class=\"line\">                this.head = head.next; //当前WeakOrderQueue更新head</div><div class=\"line\">            &#125;</div><div class=\"line\">            //更新该head对象可读下标</div><div class=\"line\">            head.readIndex = srcEnd;</div><div class=\"line\">            if (dst.size == newDstSize) &#123;</div><div class=\"line\">                return false;</div><div class=\"line\">            &#125;</div><div class=\"line\">            //更新stack可用对象的个数</div><div class=\"line\">            dst.size = newDstSize;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // The destination stack is full already.</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>从对象池中获取对象步骤总结如下:</p>\n<ol>\n<li>检查stack的elements中是否有可剩余的DefaultHandle。</li>\n<li>若没有的话, 从cursor的head开始查找当前WeakorderQueue, 并检查WeakorderQueue对应的线程是否还存活着, 若对应的帮着回收的线程不再了, 则调用transfer将该WeakorderQueue对应的所有link中的数组循环迁移到elements中, 迁移的时候每8个丢弃7个, 只有一个被回收。</li>\n<li>若对应线程还存活着, 则调用transfer进行回收当前WeakorderQueue中的一个link的所有DefaultHandle[]到stack的elements中。</li>\n</ol>\n<h1 id=\"向对象池中存放对象\"><a href=\"#向对象池中存放对象\" class=\"headerlink\" title=\"向对象池中存放对象\"></a>向对象池中存放对象</h1><p>如上例所示, 释放对象时调用cycler1.recycle()即可, 最终会调用与当前对象绑定的stack.push():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">void push(DefaultHandle&lt;?&gt; item) &#123;</div><div class=\"line\">    Thread currentThread = Thread.currentThread();</div><div class=\"line\">    //如果本线程就是产生对象的那个县城，那么直接把该对象放到stack的elements数组里</div><div class=\"line\">    if (thread == currentThread) &#123;</div><div class=\"line\">        // The current Thread is the thread that belongs to the Stack, we can try to push the object now.</div><div class=\"line\">        pushNow(item);</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // The current Thread is not the one that belongs to the Stack, we need to signal that the push</div><div class=\"line\">        // happens later.</div><div class=\"line\">        //如果该stack不是本线程的stack，那么把该DefaultHandle放到该stack的WeakOrderQueue中</div><div class=\"line\">        pushLater(item, currentThread);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>若回收对象的线程就是产生对象的线程, 那么直接将对象放到本stack对应的elements中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void pushNow(DefaultHandle&lt;?&gt; item) &#123;</div><div class=\"line\">    if ((item.recycleId | item.lastRecycledId) != 0) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;recycled already&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    #俩都直接赋值相等, 则说明对象处于stack的elements中等待被读取。</div><div class=\"line\">    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;</div><div class=\"line\">    int size = this.size;</div><div class=\"line\">    //在push到对象池时, 也会丢弃7/8的元素</div><div class=\"line\">    if (size &gt;= maxCapacity || dropHandle(item)) &#123;</div><div class=\"line\">        // Hit the maximum capacity or should drop - drop the possibly youngest object.</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //直接把DefaultHandle放到stack的数组里，如果数组满了那么扩展该数组为当前2倍大小</div><div class=\"line\">    if (size == elements.length) &#123;</div><div class=\"line\">        elements = Arrays.copyOf(elements, min(size &lt;&lt; 1, maxCapacity));</div><div class=\"line\">    &#125;</div><div class=\"line\">    elements[size] = item;</div><div class=\"line\">    this.size = size + 1;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>直接存放对象时, 对象池也会丢弃7/8的对象。<br>若回收对象的线程不是产生对象的线程, 我们来看下是如何将对象放到Link的数组中的:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void pushLater(DefaultHandle&lt;?&gt; item, Thread thread) &#123;</div><div class=\"line\">         // we don&apos;t want to have a ref to the queue as the value in our weak map</div><div class=\"line\">         // so we null it out; to ensure there are no races with restoring it later</div><div class=\"line\">         // we impose a memory ordering here (no-op on x86)</div><div class=\"line\">         //DELAYED_RECYCLED里存放了当前线程向所有stack中插入的WeakOrderQueue的映射关系</div><div class=\"line\">         Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get();</div><div class=\"line\">         //获取到当前线程向stack插入的WeakOrderQueue节点</div><div class=\"line\">         WeakOrderQueue queue = delayedRecycled.get(this);</div><div class=\"line\">         if (queue == null) &#123;</div><div class=\"line\">             //每个stack/线程最多能向maxDelayedQueues（2*cpu）个线程的WeakOrderQueue队列添加回收的的对象</div><div class=\"line\">             if (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;//如果已经向maxDelayedQueues个线程插入过数据, 那么将1个伪造的WeakOrderQueue（DUMMY）放到delayedRecycled中，并丢弃该对象（DefaultHandle）</div><div class=\"line\">                 // Add a dummy queue so we know we should drop the object</div><div class=\"line\">                 delayedRecycled.put(this, WeakOrderQueue.DUMMY);</div><div class=\"line\">                 return;</div><div class=\"line\">             &#125;</div><div class=\"line\">             // Check if we already reached the maximum number of delayed queues and if we can allocate at all.</div><div class=\"line\">            //别的线程最多向这个stack的WeakOrderQueue插入16384个对象, 检查是否可以插入, 若可以插入, 就向这个stack头插法新建WeakOrderQueue对象</div><div class=\"line\">             if ((queue = WeakOrderQueue.allocate(this, thread)) == null) &#123;</div><div class=\"line\">                 // drop object</div><div class=\"line\">                 return;</div><div class=\"line\">             &#125;</div><div class=\"line\">             delayedRecycled.put(this, queue);</div><div class=\"line\">          //已经插入满了</div><div class=\"line\">         &#125; else if (queue == WeakOrderQueue.DUMMY) &#123;</div><div class=\"line\">             // drop object</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         queue.add(item); //向WeakOrderQueue对应的Link插入对象</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<p>DELAYED_RECYCLED实际保存的是每个线程向别的stack插入WeakOrderQueue的对应关系, 下图是一个线程保存向别的stack插入WeakOrderQueue的映射关系。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty_Cycler2.png\" height=\"350\" width=\"450\"><br>找到对应的WeakOrderQueue后, 调用add向对应的Link中插入对象:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">void add(DefaultHandle&lt;?&gt; handle) &#123;</div><div class=\"line\">    //这里仅仅修改lastRecycledId值, recycledId的修改时从WeakOrderQueue的link迁移到stack的elements的时候</div><div class=\"line\">    handle.lastRecycledId = id;</div><div class=\"line\">    Link tail = this.tail;</div><div class=\"line\">    int writeIndex;</div><div class=\"line\">    //若当前Link已经写满了, 那么我们再新一个Link存放对象</div><div class=\"line\">    if ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;</div><div class=\"line\">        if (!reserveSpace(availableSharedCapacity, LINK_CAPACITY)) &#123;</div><div class=\"line\">            // Drop it.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // We allocate a Link so reserve the space</div><div class=\"line\">        this.tail = tail = tail.next = new Link();</div><div class=\"line\">        writeIndex = tail.get();</div><div class=\"line\">    &#125;</div><div class=\"line\">    tail.elements[writeIndex] = handle;</div><div class=\"line\">    //本Link所处的stack即为handle.stack。在对象池中可以清空, 在被转移到stack的elements时重新赋值。</div><div class=\"line\">    handle.stack = null;</div><div class=\"line\">    // we lazy set to ensure that setting stack to null appears before we unnull it in the owning thread;</div><div class=\"line\">    // this also means we guarantee visibility of an element in the queue if we see the index updated</div><div class=\"line\">   //修改内存偏移地址为8的值，但是修改后不保证立马能被其他的线程看到。</div><div class=\"line\">    tail.lazySet(writeIndex + 1);  //https://github.com/netty/netty/issues/8215</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看到, 向Link中插入对象时, 仅改变对象的lastRecycledId值, 而没有改变recycledId值。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Netty回收对象也不是把所有对象全部回收, 为了防止回收对象过多, 会在直接存入stack的elements和从Link转移到stack的elements时会丢弃7/8的废弃对象。Netty中使用对象回收的地方很多, 一个高频使用就是PooledUnsafeDirectByteBuf, 首先申请16M内存作为内存池时, 按需分配小的内存块, 这些小内存块都会被PooledUnsafeDirectByteBuf管理着。 而减少PooledUnsafeDirectByteBuf对象创建次数, 也增强了netty高性能传输数据的能力。</p>\n"},{"title":"Netty Thrift方式通信编解码源码解读","date":"2018-03-25T03:11:12.000Z","toc":true,"_content":"# 介绍\n## 零拷贝\nNetty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\">参考</a>)：\n1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。\n3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\n\n## 编解码处理器\n编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例\n解码处理器目前接触比较多的两种:\n+ ByteToMessageDecoder\nByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。\n+ MessageToMessageDecoder\nMessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。\n\n## 代码引入\n需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):\n```\n        public final void read() {\n            final ChannelConfig config = config();\n            final ChannelPipeline pipeline = pipeline();\n            final ByteBufAllocator allocator = config.getAllocator();\n            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取\n            allocHandle.reset(config);\n            ByteBuf byteBuf = null;\n            boolean close = false;\n            try {\n                do {\n                    byteBuf = allocHandle.allocate(allocator);\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                    if (allocHandle.lastBytesRead() <= 0) { // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接\n                        // nothing was read. release the buffer.\n                        byteBuf.release();\n                        byteBuf = null;\n                        close = allocHandle.lastBytesRead() < 0;\n                        break;\n                    }\n                    allocHandle.incMessagesRead(1);\n                    readPending = false;\n                    pipeline.fireChannelRead(byteBuf);\n                    byteBuf = null;\n                } while (allocHandle.continueReading());\n                allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）\n                pipeline.fireChannelReadComplete();// 本轮数据读取完毕\n                if (close) {// 如果读取的时候发生错误则关闭连接\n                    closeOnRead(pipeline);\n                }\n            } catch (Throwable t) {\n                handleReadException(pipeline, byteBuf, t, close, allocHandle);\n            } finally {\n\n            }\n        }\n    }\n ```\n这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。\n# ByteToMessageDecoder\n属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。\n回到代码里, 需要关注channelRead:\n```\n@Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ByteBuf) {    //PoolUnsafeDirectByteBuf\n            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合\n            try {\n                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf\n                first = cumulation == null;\n                if (first) {\n                    cumulation = data;\n                } else {\n                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR\n                }\n                callDecode(ctx, cumulation, out);\n            } catch (DecoderException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw new DecoderException(t);\n            } finally {//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)\n                if (cumulation != null && !cumulation.isReadable()) {\n                    numReads = 0;\n                    cumulation.release();\n                    cumulation = null;\n                } else if (++ numReads >= discardAfterReads) {\n                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.\n                    // See https://github.com/netty/netty/issues/4275\n                    numReads = 0;\n                    discardSomeReadBytes();\n                }\n\n                int size = out.size();\n                decodeWasNull = !out.insertSinceRecycled();\n                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message\n                out.recycle();\n            }\n        } else {\n            ctx.fireChannelRead(msg);\n        }\n    }\n```\n主要做的事情:\n1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。\n2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。\n```\n @Override\n        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf\n            final ByteBuf buffer;\n            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()\n                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {\n                // Expand cumulation (by replace it) when either there is not more room in the buffer\n                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or\n                // duplicate().retain() or if its read-only.\n                //\n                // See:\n                // - https://github.com/netty/netty/issues/2327\n                // - https://github.com/netty/netty/issues/1764\n                buffer = expandCumulation(alloc, cumulation, in.readableBytes());\n            } else {\n                buffer = cumulation;\n            }\n            buffer.writeBytes(in); //将新的数据，写入这个cumulation\n            in.release();  //释放资源\n            return buffer;\n        }\n```\n+ 首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation\n```\n   ByteBuf oldCumulation = cumulation;\n        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据\n        cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据\n        oldCumulation.release(); //释放旧的缓冲区\n        return cumulation;\n```\ncumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。\n3) 解码callDecode\n```\n             while (in.isReadable()) {\n                int outSize = out.size();\n                if (outSize > 0) { //out为经过转码形成帧的的数据\n                    fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个\n                    out.clear();\n                    outSize = 0;\n                }\n                int oldInputLength = in.readableBytes();  //24\n                decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode\n                if (outSize == out.size()) { //decode没有解析出东西\n                    if (oldInputLength == in.readableBytes()) { //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐\n                        break;\n                    } else { //还是向前消费了许多东西，可能读到了坏的帧，丢弃了\n                        continue;\n                    }\n                }\n                if (oldInputLength == in.readableBytes()) {  //说明outSize < out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题\n                    throw new DecoderException(\n                            StringUtil.simpleClassName(getClass()) +\n                                    \".decode() did not read anything but decoded a message.\");\n                }\n              }\n```\n+ 首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。\n+ 开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在`LengthFieldBasedFrameDecoder`里实现。\n+ 对这轮解析结果进行分析:\n     若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。\n     若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。\n     若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。\n4) 检查是否还有帧可以继续向上传递。\n```\n static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {\n        if (msgs instanceof CodecOutputList) {   //都单个单个的发送\n            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                ctx.fireChannelRead(msgs.get(i));\n            }\n        }\n    }\n```\n可以看出实际也是每个帧单独向上发送的。\n\n# LengthFieldBasedFrameDecoder\nLengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)即可: 从原始byte in中解析出一个帧, 放入out中。\n我们需要理解几个属性的函数:\n+ maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。\n+ lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。\n+ lengthFieldLength: 定义帧长度的字段本身的长度。\n+ lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉\n+ initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分\n+ failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。\n+ discardingTooLongFrame: 当帧解析出来的帧内容长度 > maxFrameLength时,并且剩余缓存可读字段 < 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。\n+ tooLongFrameLength: 超过长度限制maxFrameLength的帧长度\n+ bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容\n关系如下:<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Thrift%E5%B8%A7.png\"/>\n也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\"> 参考/a>\n其中:\n+ head1和head2可以由用户自定义语义。\n+ 有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength\n解码函数如下:\n```\n       if (discardingTooLongFrame) {//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢\n            long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度\n            int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数\n            in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度\n            bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度\n            this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度\n            failIfNecessary(false);\n        }\n        //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回\n        if (in.readableBytes() < lengthFieldEndOffset) {//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码\n            return null; //当前帧没有value\n        }\n       // 拿到长度字段的起始偏移量index\n        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置\n        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度\n        if (frameLength < 0) {\n            in.skipBytes(lengthFieldEndOffset);\n            throw new CorruptedFrameException(\n                    \"negative pre-adjustment length field: \" + frameLength);\n        }\n        // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)\n        frameLength += lengthAdjustment + lengthFieldEndOffset;\n        if (frameLength < lengthFieldEndOffset) {\n            in.skipBytes(lengthFieldEndOffset);//当前帧忽略过\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than lengthFieldEndOffset: \" + lengthFieldEndOffset);\n        }\n        // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。\n        if (frameLength > maxFrameLength) {\n            long discard = frameLength - in.readableBytes();//前面\n            tooLongFrameLength = frameLength;\n            // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n            if (discard < 0) {// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n                // buffer contains more bytes then the frameLength so we can discard all now\n                in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面\n            } else {\n                // Enter the discard mode and discard everything received so far.\n                discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧\n                bytesToDiscard = discard;\n                in.skipBytes(in.readableBytes());//丢弃整个帧\n            }\n            failIfNecessary(true);\n            return null;\n        }\n        // never overflows because it's less than maxFrameLength\n        int frameLengthInt = (int) frameLength;\n        if (in.readableBytes() < frameLengthInt) {  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环\n            return null;\n        }\n        if (initialBytesToStrip > frameLengthInt) {\n            in.skipBytes(frameLengthInt);\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than initialBytesToStrip: \" + initialBytesToStrip);\n        }\n        in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content\n        // extract frame\n        int readerIndex = in.readerIndex();\n        int actualFrameLength = frameLengthInt - initialBytesToStrip;\n        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);\n        in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置\n        return frame;\n```\n主要操作如下:\n1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:\n```\nprivate void failIfNecessary(boolean firstDetectionOfTooLongFrame) {\n        if (bytesToDiscard == 0) { //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态\n            // Reset to the initial state and tell the handlers that\n            // the frame was too large.\n            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度\n            this.tooLongFrameLength = 0; //主要是复位\n            discardingTooLongFrame = false;\n            if (!failFast || firstDetectionOfTooLongFrame) {// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理\n                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃\n            }\n        } else {  //第一次遇到，发现当前帧长度太长了\n            // Keep discarding and notify handlers if necessary.\n            if (failFast && firstDetectionOfTooLongFrame) {\n                fail(tooLongFrameLength); //是第一次遇到，直接丢失\n            }\n        }\n    }\n```\n+ 当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。\n+ 反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。\n2) 若当前缓存可读byte < 长度偏移量, 直接退出继续, 数据仍然放在了缓存。\n3) 计算出帧整体的长度,包括了length + head2 + content:\n```\nframeLength += lengthAdjustment + lengthFieldEndOffset;\n```\n4) 检查帧frameLength是否超过的阈值,若超过了:\n+ 检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度\n+ 否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。\n并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。\n5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。\n6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。\n","source":"_posts/Netty通信编解码源码解读.md","raw":"---\ntitle: Netty Thrift方式通信编解码源码解读\ndate: 2018-03-25 11:11:12\ntags:\ntoc: true\n---\n# 介绍\n## 零拷贝\nNetty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\">参考</a>)：\n1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。\n3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\n\n## 编解码处理器\n编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例\n解码处理器目前接触比较多的两种:\n+ ByteToMessageDecoder\nByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。\n+ MessageToMessageDecoder\nMessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。\n\n## 代码引入\n需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):\n```\n        public final void read() {\n            final ChannelConfig config = config();\n            final ChannelPipeline pipeline = pipeline();\n            final ByteBufAllocator allocator = config.getAllocator();\n            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取\n            allocHandle.reset(config);\n            ByteBuf byteBuf = null;\n            boolean close = false;\n            try {\n                do {\n                    byteBuf = allocHandle.allocate(allocator);\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                    if (allocHandle.lastBytesRead() <= 0) { // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接\n                        // nothing was read. release the buffer.\n                        byteBuf.release();\n                        byteBuf = null;\n                        close = allocHandle.lastBytesRead() < 0;\n                        break;\n                    }\n                    allocHandle.incMessagesRead(1);\n                    readPending = false;\n                    pipeline.fireChannelRead(byteBuf);\n                    byteBuf = null;\n                } while (allocHandle.continueReading());\n                allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）\n                pipeline.fireChannelReadComplete();// 本轮数据读取完毕\n                if (close) {// 如果读取的时候发生错误则关闭连接\n                    closeOnRead(pipeline);\n                }\n            } catch (Throwable t) {\n                handleReadException(pipeline, byteBuf, t, close, allocHandle);\n            } finally {\n\n            }\n        }\n    }\n ```\n这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。\n# ByteToMessageDecoder\n属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。\n回到代码里, 需要关注channelRead:\n```\n@Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ByteBuf) {    //PoolUnsafeDirectByteBuf\n            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合\n            try {\n                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf\n                first = cumulation == null;\n                if (first) {\n                    cumulation = data;\n                } else {\n                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR\n                }\n                callDecode(ctx, cumulation, out);\n            } catch (DecoderException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw new DecoderException(t);\n            } finally {//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)\n                if (cumulation != null && !cumulation.isReadable()) {\n                    numReads = 0;\n                    cumulation.release();\n                    cumulation = null;\n                } else if (++ numReads >= discardAfterReads) {\n                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.\n                    // See https://github.com/netty/netty/issues/4275\n                    numReads = 0;\n                    discardSomeReadBytes();\n                }\n\n                int size = out.size();\n                decodeWasNull = !out.insertSinceRecycled();\n                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message\n                out.recycle();\n            }\n        } else {\n            ctx.fireChannelRead(msg);\n        }\n    }\n```\n主要做的事情:\n1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。\n2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。\n```\n @Override\n        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf\n            final ByteBuf buffer;\n            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()\n                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {\n                // Expand cumulation (by replace it) when either there is not more room in the buffer\n                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or\n                // duplicate().retain() or if its read-only.\n                //\n                // See:\n                // - https://github.com/netty/netty/issues/2327\n                // - https://github.com/netty/netty/issues/1764\n                buffer = expandCumulation(alloc, cumulation, in.readableBytes());\n            } else {\n                buffer = cumulation;\n            }\n            buffer.writeBytes(in); //将新的数据，写入这个cumulation\n            in.release();  //释放资源\n            return buffer;\n        }\n```\n+ 首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation\n```\n   ByteBuf oldCumulation = cumulation;\n        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据\n        cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据\n        oldCumulation.release(); //释放旧的缓冲区\n        return cumulation;\n```\ncumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。\n3) 解码callDecode\n```\n             while (in.isReadable()) {\n                int outSize = out.size();\n                if (outSize > 0) { //out为经过转码形成帧的的数据\n                    fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个\n                    out.clear();\n                    outSize = 0;\n                }\n                int oldInputLength = in.readableBytes();  //24\n                decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode\n                if (outSize == out.size()) { //decode没有解析出东西\n                    if (oldInputLength == in.readableBytes()) { //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐\n                        break;\n                    } else { //还是向前消费了许多东西，可能读到了坏的帧，丢弃了\n                        continue;\n                    }\n                }\n                if (oldInputLength == in.readableBytes()) {  //说明outSize < out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题\n                    throw new DecoderException(\n                            StringUtil.simpleClassName(getClass()) +\n                                    \".decode() did not read anything but decoded a message.\");\n                }\n              }\n```\n+ 首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。\n+ 开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在`LengthFieldBasedFrameDecoder`里实现。\n+ 对这轮解析结果进行分析:\n     若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。\n     若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。\n     若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。\n4) 检查是否还有帧可以继续向上传递。\n```\n static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {\n        if (msgs instanceof CodecOutputList) {   //都单个单个的发送\n            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                ctx.fireChannelRead(msgs.get(i));\n            }\n        }\n    }\n```\n可以看出实际也是每个帧单独向上发送的。\n\n# LengthFieldBasedFrameDecoder\nLengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)即可: 从原始byte in中解析出一个帧, 放入out中。\n我们需要理解几个属性的函数:\n+ maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。\n+ lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。\n+ lengthFieldLength: 定义帧长度的字段本身的长度。\n+ lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉\n+ initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分\n+ failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。\n+ discardingTooLongFrame: 当帧解析出来的帧内容长度 > maxFrameLength时,并且剩余缓存可读字段 < 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。\n+ tooLongFrameLength: 超过长度限制maxFrameLength的帧长度\n+ bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容\n关系如下:<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Thrift%E5%B8%A7.png\"/>\n也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\"> 参考/a>\n其中:\n+ head1和head2可以由用户自定义语义。\n+ 有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength\n解码函数如下:\n```\n       if (discardingTooLongFrame) {//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢\n            long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度\n            int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数\n            in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度\n            bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度\n            this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度\n            failIfNecessary(false);\n        }\n        //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回\n        if (in.readableBytes() < lengthFieldEndOffset) {//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码\n            return null; //当前帧没有value\n        }\n       // 拿到长度字段的起始偏移量index\n        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置\n        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度\n        if (frameLength < 0) {\n            in.skipBytes(lengthFieldEndOffset);\n            throw new CorruptedFrameException(\n                    \"negative pre-adjustment length field: \" + frameLength);\n        }\n        // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)\n        frameLength += lengthAdjustment + lengthFieldEndOffset;\n        if (frameLength < lengthFieldEndOffset) {\n            in.skipBytes(lengthFieldEndOffset);//当前帧忽略过\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than lengthFieldEndOffset: \" + lengthFieldEndOffset);\n        }\n        // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。\n        if (frameLength > maxFrameLength) {\n            long discard = frameLength - in.readableBytes();//前面\n            tooLongFrameLength = frameLength;\n            // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n            if (discard < 0) {// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n                // buffer contains more bytes then the frameLength so we can discard all now\n                in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面\n            } else {\n                // Enter the discard mode and discard everything received so far.\n                discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧\n                bytesToDiscard = discard;\n                in.skipBytes(in.readableBytes());//丢弃整个帧\n            }\n            failIfNecessary(true);\n            return null;\n        }\n        // never overflows because it's less than maxFrameLength\n        int frameLengthInt = (int) frameLength;\n        if (in.readableBytes() < frameLengthInt) {  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环\n            return null;\n        }\n        if (initialBytesToStrip > frameLengthInt) {\n            in.skipBytes(frameLengthInt);\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than initialBytesToStrip: \" + initialBytesToStrip);\n        }\n        in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content\n        // extract frame\n        int readerIndex = in.readerIndex();\n        int actualFrameLength = frameLengthInt - initialBytesToStrip;\n        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);\n        in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置\n        return frame;\n```\n主要操作如下:\n1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:\n```\nprivate void failIfNecessary(boolean firstDetectionOfTooLongFrame) {\n        if (bytesToDiscard == 0) { //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态\n            // Reset to the initial state and tell the handlers that\n            // the frame was too large.\n            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度\n            this.tooLongFrameLength = 0; //主要是复位\n            discardingTooLongFrame = false;\n            if (!failFast || firstDetectionOfTooLongFrame) {// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理\n                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃\n            }\n        } else {  //第一次遇到，发现当前帧长度太长了\n            // Keep discarding and notify handlers if necessary.\n            if (failFast && firstDetectionOfTooLongFrame) {\n                fail(tooLongFrameLength); //是第一次遇到，直接丢失\n            }\n        }\n    }\n```\n+ 当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。\n+ 反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。\n2) 若当前缓存可读byte < 长度偏移量, 直接退出继续, 数据仍然放在了缓存。\n3) 计算出帧整体的长度,包括了length + head2 + content:\n```\nframeLength += lengthAdjustment + lengthFieldEndOffset;\n```\n4) 检查帧frameLength是否超过的阈值,若超过了:\n+ 检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度\n+ 否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。\n并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。\n5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。\n6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。\n","slug":"Netty通信编解码源码解读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xc000vphu5fpytlf30","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>Netty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\" target=\"_blank\" rel=\"external\">参考</a>)：<br>1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p>\n<h2 id=\"编解码处理器\"><a href=\"#编解码处理器\" class=\"headerlink\" title=\"编解码处理器\"></a>编解码处理器</h2><p>编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例<br>解码处理器目前接触比较多的两种:</p>\n<ul>\n<li>ByteToMessageDecoder<br>ByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。</li>\n<li>MessageToMessageDecoder<br>MessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。</li>\n</ul>\n<h2 id=\"代码引入\"><a href=\"#代码引入\" class=\"headerlink\" title=\"代码引入\"></a>代码引入</h2><p>需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    public final void read() &#123;</div><div class=\"line\">        final ChannelConfig config = config();</div><div class=\"line\">        final ChannelPipeline pipeline = pipeline();</div><div class=\"line\">        final ByteBufAllocator allocator = config.getAllocator();</div><div class=\"line\">        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取</div><div class=\"line\">        allocHandle.reset(config);</div><div class=\"line\">        ByteBuf byteBuf = null;</div><div class=\"line\">        boolean close = false;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                byteBuf = allocHandle.allocate(allocator);</div><div class=\"line\">                allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class=\"line\">                if (allocHandle.lastBytesRead() &lt;= 0) &#123; // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接</div><div class=\"line\">                    // nothing was read. release the buffer.</div><div class=\"line\">                    byteBuf.release();</div><div class=\"line\">                    byteBuf = null;</div><div class=\"line\">                    close = allocHandle.lastBytesRead() &lt; 0;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                allocHandle.incMessagesRead(1);</div><div class=\"line\">                readPending = false;</div><div class=\"line\">                pipeline.fireChannelRead(byteBuf);</div><div class=\"line\">                byteBuf = null;</div><div class=\"line\">            &#125; while (allocHandle.continueReading());</div><div class=\"line\">            allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）</div><div class=\"line\">            pipeline.fireChannelReadComplete();// 本轮数据读取完毕</div><div class=\"line\">            if (close) &#123;// 如果读取的时候发生错误则关闭连接</div><div class=\"line\">                closeOnRead(pipeline);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable t) &#123;</div><div class=\"line\">            handleReadException(pipeline, byteBuf, t, close, allocHandle);</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。</p>\n<h1 id=\"ByteToMessageDecoder\"><a href=\"#ByteToMessageDecoder\" class=\"headerlink\" title=\"ByteToMessageDecoder\"></a>ByteToMessageDecoder</h1><p>属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。<br>回到代码里, 需要关注channelRead:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class=\"line\">        if (msg instanceof ByteBuf) &#123;    //PoolUnsafeDirectByteBuf</div><div class=\"line\">            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf</div><div class=\"line\">                first = cumulation == null;</div><div class=\"line\">                if (first) &#123;</div><div class=\"line\">                    cumulation = data;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR</div><div class=\"line\">                &#125;</div><div class=\"line\">                callDecode(ctx, cumulation, out);</div><div class=\"line\">            &#125; catch (DecoderException e) &#123;</div><div class=\"line\">                throw e;</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                throw new DecoderException(t);</div><div class=\"line\">            &#125; finally &#123;//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)</div><div class=\"line\">                if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    cumulation.release();</div><div class=\"line\">                    cumulation = null;</div><div class=\"line\">                &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</div><div class=\"line\">                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/4275</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    discardSomeReadBytes();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                int size = out.size();</div><div class=\"line\">                decodeWasNull = !out.insertSinceRecycled();</div><div class=\"line\">                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message</div><div class=\"line\">                out.recycle();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.fireChannelRead(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事情:<br>1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。<br>2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">       public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) &#123;  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf</div><div class=\"line\">           final ByteBuf buffer;</div><div class=\"line\">           if (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</div><div class=\"line\">                   || cumulation.refCnt() &gt; 1 || cumulation.isReadOnly()) &#123;</div><div class=\"line\">               // Expand cumulation (by replace it) when either there is not more room in the buffer</div><div class=\"line\">               // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</div><div class=\"line\">               // duplicate().retain() or if its read-only.</div><div class=\"line\">               //</div><div class=\"line\">               // See:</div><div class=\"line\">               // - https://github.com/netty/netty/issues/2327</div><div class=\"line\">               // - https://github.com/netty/netty/issues/1764</div><div class=\"line\">               buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               buffer = cumulation;</div><div class=\"line\">           &#125;</div><div class=\"line\">           buffer.writeBytes(in); //将新的数据，写入这个cumulation</div><div class=\"line\">           in.release();  //释放资源</div><div class=\"line\">           return buffer;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf oldCumulation = cumulation;</div><div class=\"line\">     cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据</div><div class=\"line\">     cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据</div><div class=\"line\">     oldCumulation.release(); //释放旧的缓冲区</div><div class=\"line\">     return cumulation;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>cumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。<br>3) 解码callDecode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (in.isReadable()) &#123;</div><div class=\"line\">   int outSize = out.size();</div><div class=\"line\">   if (outSize &gt; 0) &#123; //out为经过转码形成帧的的数据</div><div class=\"line\">       fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个</div><div class=\"line\">       out.clear();</div><div class=\"line\">       outSize = 0;</div><div class=\"line\">   &#125;</div><div class=\"line\">   int oldInputLength = in.readableBytes();  //24</div><div class=\"line\">   decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode</div><div class=\"line\">   if (outSize == out.size()) &#123; //decode没有解析出东西</div><div class=\"line\">       if (oldInputLength == in.readableBytes()) &#123; //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐</div><div class=\"line\">           break;</div><div class=\"line\">       &#125; else &#123; //还是向前消费了许多东西，可能读到了坏的帧，丢弃了</div><div class=\"line\">           continue;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   if (oldInputLength == in.readableBytes()) &#123;  //说明outSize &lt; out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题</div><div class=\"line\">       throw new DecoderException(</div><div class=\"line\">               StringUtil.simpleClassName(getClass()) +</div><div class=\"line\">                       &quot;.decode() did not read anything but decoded a message.&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。</li>\n<li>开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在<code>LengthFieldBasedFrameDecoder</code>里实现。</li>\n<li>对这轮解析结果进行分析:<br>   若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。<br>   若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。<br>   若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。<br>4) 检查是否还有帧可以继续向上传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements) &#123;</div><div class=\"line\">       if (msgs instanceof CodecOutputList) &#123;   //都单个单个的发送</div><div class=\"line\">           fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           for (int i = 0; i &lt; numElements; i++) &#123;</div><div class=\"line\">               ctx.fireChannelRead(msgs.get(i));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出实际也是每个帧单独向上发送的。</p>\n<h1 id=\"LengthFieldBasedFrameDecoder\"><a href=\"#LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"LengthFieldBasedFrameDecoder\"></a>LengthFieldBasedFrameDecoder</h1><p>LengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<object> out)即可: 从原始byte in中解析出一个帧, 放入out中。<br>我们需要理解几个属性的函数:</object></p>\n<ul>\n<li>maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。</li>\n<li>lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。</li>\n<li>lengthFieldLength: 定义帧长度的字段本身的长度。</li>\n<li>lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉</li>\n<li>initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分</li>\n<li>failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。</li>\n<li>discardingTooLongFrame: 当帧解析出来的帧内容长度 &gt; maxFrameLength时,并且剩余缓存可读字段 &lt; 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。</li>\n<li>tooLongFrameLength: 超过长度限制maxFrameLength的帧长度</li>\n<li>bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容<br>关系如下:<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Thrift%E5%B8%A7.png\"><br>也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\" target=\"_blank\" rel=\"external\"> 参考/a&gt;<br>其中:</a></li>\n<li>head1和head2可以由用户自定义语义。</li>\n<li>有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength<br>解码函数如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (discardingTooLongFrame) &#123;//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢</div><div class=\"line\">     long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度</div><div class=\"line\">     int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数</div><div class=\"line\">     in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度</div><div class=\"line\">     bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度</div><div class=\"line\">     this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度</div><div class=\"line\">     failIfNecessary(false);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回</div><div class=\"line\"> if (in.readableBytes() &lt; lengthFieldEndOffset) &#123;//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码</div><div class=\"line\">     return null; //当前帧没有value</div><div class=\"line\"> &#125;</div><div class=\"line\">// 拿到长度字段的起始偏移量index</div><div class=\"line\"> int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置</div><div class=\"line\"> long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度</div><div class=\"line\"> if (frameLength &lt; 0) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;negative pre-adjustment length field: &quot; + frameLength);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)</div><div class=\"line\"> frameLength += lengthAdjustment + lengthFieldEndOffset;</div><div class=\"line\"> if (frameLength &lt; lengthFieldEndOffset) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);//当前帧忽略过</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than lengthFieldEndOffset: &quot; + lengthFieldEndOffset);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。</div><div class=\"line\"> if (frameLength &gt; maxFrameLength) &#123;</div><div class=\"line\">     long discard = frameLength - in.readableBytes();//前面</div><div class=\"line\">     tooLongFrameLength = frameLength;</div><div class=\"line\">     // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">     if (discard &lt; 0) &#123;// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">         // buffer contains more bytes then the frameLength so we can discard all now</div><div class=\"line\">         in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Enter the discard mode and discard everything received so far.</div><div class=\"line\">         discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧</div><div class=\"line\">         bytesToDiscard = discard;</div><div class=\"line\">         in.skipBytes(in.readableBytes());//丢弃整个帧</div><div class=\"line\">     &#125;</div><div class=\"line\">     failIfNecessary(true);</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> // never overflows because it&apos;s less than maxFrameLength</div><div class=\"line\"> int frameLengthInt = (int) frameLength;</div><div class=\"line\"> if (in.readableBytes() &lt; frameLengthInt) &#123;  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> if (initialBytesToStrip &gt; frameLengthInt) &#123;</div><div class=\"line\">     in.skipBytes(frameLengthInt);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than initialBytesToStrip: &quot; + initialBytesToStrip);</div><div class=\"line\"> &#125;</div><div class=\"line\"> in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content</div><div class=\"line\"> // extract frame</div><div class=\"line\"> int readerIndex = in.readerIndex();</div><div class=\"line\"> int actualFrameLength = frameLengthInt - initialBytesToStrip;</div><div class=\"line\"> ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);</div><div class=\"line\"> in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置</div><div class=\"line\"> return frame;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要操作如下:<br>1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void failIfNecessary(boolean firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">        if (bytesToDiscard == 0) &#123; //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态</div><div class=\"line\">            // Reset to the initial state and tell the handlers that</div><div class=\"line\">            // the frame was too large.</div><div class=\"line\">            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度</div><div class=\"line\">            this.tooLongFrameLength = 0; //主要是复位</div><div class=\"line\">            discardingTooLongFrame = false;</div><div class=\"line\">            if (!failFast || firstDetectionOfTooLongFrame) &#123;// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理</div><div class=\"line\">                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;  //第一次遇到，发现当前帧长度太长了</div><div class=\"line\">            // Keep discarding and notify handlers if necessary.</div><div class=\"line\">            if (failFast &amp;&amp; firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">                fail(tooLongFrameLength); //是第一次遇到，直接丢失</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。</li>\n<li>反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。<br>2) 若当前缓存可读byte &lt; 长度偏移量, 直接退出继续, 数据仍然放在了缓存。<br>3) 计算出帧整体的长度,包括了length + head2 + content:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameLength += lengthAdjustment + lengthFieldEndOffset;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>4) 检查帧frameLength是否超过的阈值,若超过了:</p>\n<ul>\n<li>检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度</li>\n<li>否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。<br>并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。<br>5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。<br>6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>Netty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\" target=\"_blank\" rel=\"external\">参考</a>)：<br>1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p>\n<h2 id=\"编解码处理器\"><a href=\"#编解码处理器\" class=\"headerlink\" title=\"编解码处理器\"></a>编解码处理器</h2><p>编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例<br>解码处理器目前接触比较多的两种:</p>\n<ul>\n<li>ByteToMessageDecoder<br>ByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。</li>\n<li>MessageToMessageDecoder<br>MessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。</li>\n</ul>\n<h2 id=\"代码引入\"><a href=\"#代码引入\" class=\"headerlink\" title=\"代码引入\"></a>代码引入</h2><p>需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    public final void read() &#123;</div><div class=\"line\">        final ChannelConfig config = config();</div><div class=\"line\">        final ChannelPipeline pipeline = pipeline();</div><div class=\"line\">        final ByteBufAllocator allocator = config.getAllocator();</div><div class=\"line\">        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取</div><div class=\"line\">        allocHandle.reset(config);</div><div class=\"line\">        ByteBuf byteBuf = null;</div><div class=\"line\">        boolean close = false;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                byteBuf = allocHandle.allocate(allocator);</div><div class=\"line\">                allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class=\"line\">                if (allocHandle.lastBytesRead() &lt;= 0) &#123; // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接</div><div class=\"line\">                    // nothing was read. release the buffer.</div><div class=\"line\">                    byteBuf.release();</div><div class=\"line\">                    byteBuf = null;</div><div class=\"line\">                    close = allocHandle.lastBytesRead() &lt; 0;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                allocHandle.incMessagesRead(1);</div><div class=\"line\">                readPending = false;</div><div class=\"line\">                pipeline.fireChannelRead(byteBuf);</div><div class=\"line\">                byteBuf = null;</div><div class=\"line\">            &#125; while (allocHandle.continueReading());</div><div class=\"line\">            allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）</div><div class=\"line\">            pipeline.fireChannelReadComplete();// 本轮数据读取完毕</div><div class=\"line\">            if (close) &#123;// 如果读取的时候发生错误则关闭连接</div><div class=\"line\">                closeOnRead(pipeline);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable t) &#123;</div><div class=\"line\">            handleReadException(pipeline, byteBuf, t, close, allocHandle);</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。</p>\n<h1 id=\"ByteToMessageDecoder\"><a href=\"#ByteToMessageDecoder\" class=\"headerlink\" title=\"ByteToMessageDecoder\"></a>ByteToMessageDecoder</h1><p>属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。<br>回到代码里, 需要关注channelRead:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class=\"line\">        if (msg instanceof ByteBuf) &#123;    //PoolUnsafeDirectByteBuf</div><div class=\"line\">            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf</div><div class=\"line\">                first = cumulation == null;</div><div class=\"line\">                if (first) &#123;</div><div class=\"line\">                    cumulation = data;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR</div><div class=\"line\">                &#125;</div><div class=\"line\">                callDecode(ctx, cumulation, out);</div><div class=\"line\">            &#125; catch (DecoderException e) &#123;</div><div class=\"line\">                throw e;</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                throw new DecoderException(t);</div><div class=\"line\">            &#125; finally &#123;//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)</div><div class=\"line\">                if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    cumulation.release();</div><div class=\"line\">                    cumulation = null;</div><div class=\"line\">                &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</div><div class=\"line\">                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/4275</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    discardSomeReadBytes();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                int size = out.size();</div><div class=\"line\">                decodeWasNull = !out.insertSinceRecycled();</div><div class=\"line\">                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message</div><div class=\"line\">                out.recycle();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.fireChannelRead(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事情:<br>1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。<br>2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">       public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) &#123;  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf</div><div class=\"line\">           final ByteBuf buffer;</div><div class=\"line\">           if (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</div><div class=\"line\">                   || cumulation.refCnt() &gt; 1 || cumulation.isReadOnly()) &#123;</div><div class=\"line\">               // Expand cumulation (by replace it) when either there is not more room in the buffer</div><div class=\"line\">               // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</div><div class=\"line\">               // duplicate().retain() or if its read-only.</div><div class=\"line\">               //</div><div class=\"line\">               // See:</div><div class=\"line\">               // - https://github.com/netty/netty/issues/2327</div><div class=\"line\">               // - https://github.com/netty/netty/issues/1764</div><div class=\"line\">               buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               buffer = cumulation;</div><div class=\"line\">           &#125;</div><div class=\"line\">           buffer.writeBytes(in); //将新的数据，写入这个cumulation</div><div class=\"line\">           in.release();  //释放资源</div><div class=\"line\">           return buffer;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf oldCumulation = cumulation;</div><div class=\"line\">     cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据</div><div class=\"line\">     cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据</div><div class=\"line\">     oldCumulation.release(); //释放旧的缓冲区</div><div class=\"line\">     return cumulation;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>cumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。<br>3) 解码callDecode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (in.isReadable()) &#123;</div><div class=\"line\">   int outSize = out.size();</div><div class=\"line\">   if (outSize &gt; 0) &#123; //out为经过转码形成帧的的数据</div><div class=\"line\">       fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个</div><div class=\"line\">       out.clear();</div><div class=\"line\">       outSize = 0;</div><div class=\"line\">   &#125;</div><div class=\"line\">   int oldInputLength = in.readableBytes();  //24</div><div class=\"line\">   decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode</div><div class=\"line\">   if (outSize == out.size()) &#123; //decode没有解析出东西</div><div class=\"line\">       if (oldInputLength == in.readableBytes()) &#123; //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐</div><div class=\"line\">           break;</div><div class=\"line\">       &#125; else &#123; //还是向前消费了许多东西，可能读到了坏的帧，丢弃了</div><div class=\"line\">           continue;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   if (oldInputLength == in.readableBytes()) &#123;  //说明outSize &lt; out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题</div><div class=\"line\">       throw new DecoderException(</div><div class=\"line\">               StringUtil.simpleClassName(getClass()) +</div><div class=\"line\">                       &quot;.decode() did not read anything but decoded a message.&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。</li>\n<li>开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在<code>LengthFieldBasedFrameDecoder</code>里实现。</li>\n<li>对这轮解析结果进行分析:<br>   若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。<br>   若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。<br>   若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。<br>4) 检查是否还有帧可以继续向上传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements) &#123;</div><div class=\"line\">       if (msgs instanceof CodecOutputList) &#123;   //都单个单个的发送</div><div class=\"line\">           fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           for (int i = 0; i &lt; numElements; i++) &#123;</div><div class=\"line\">               ctx.fireChannelRead(msgs.get(i));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出实际也是每个帧单独向上发送的。</p>\n<h1 id=\"LengthFieldBasedFrameDecoder\"><a href=\"#LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"LengthFieldBasedFrameDecoder\"></a>LengthFieldBasedFrameDecoder</h1><p>LengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<object> out)即可: 从原始byte in中解析出一个帧, 放入out中。<br>我们需要理解几个属性的函数:</object></p>\n<ul>\n<li>maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。</li>\n<li>lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。</li>\n<li>lengthFieldLength: 定义帧长度的字段本身的长度。</li>\n<li>lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉</li>\n<li>initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分</li>\n<li>failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。</li>\n<li>discardingTooLongFrame: 当帧解析出来的帧内容长度 &gt; maxFrameLength时,并且剩余缓存可读字段 &lt; 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。</li>\n<li>tooLongFrameLength: 超过长度限制maxFrameLength的帧长度</li>\n<li>bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容<br>关系如下:<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Thrift%E5%B8%A7.png\"><br>也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\" target=\"_blank\" rel=\"external\"> 参考/a&gt;<br>其中:</a></li>\n<li>head1和head2可以由用户自定义语义。</li>\n<li>有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength<br>解码函数如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (discardingTooLongFrame) &#123;//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢</div><div class=\"line\">     long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度</div><div class=\"line\">     int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数</div><div class=\"line\">     in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度</div><div class=\"line\">     bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度</div><div class=\"line\">     this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度</div><div class=\"line\">     failIfNecessary(false);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回</div><div class=\"line\"> if (in.readableBytes() &lt; lengthFieldEndOffset) &#123;//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码</div><div class=\"line\">     return null; //当前帧没有value</div><div class=\"line\"> &#125;</div><div class=\"line\">// 拿到长度字段的起始偏移量index</div><div class=\"line\"> int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置</div><div class=\"line\"> long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度</div><div class=\"line\"> if (frameLength &lt; 0) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;negative pre-adjustment length field: &quot; + frameLength);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)</div><div class=\"line\"> frameLength += lengthAdjustment + lengthFieldEndOffset;</div><div class=\"line\"> if (frameLength &lt; lengthFieldEndOffset) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);//当前帧忽略过</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than lengthFieldEndOffset: &quot; + lengthFieldEndOffset);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。</div><div class=\"line\"> if (frameLength &gt; maxFrameLength) &#123;</div><div class=\"line\">     long discard = frameLength - in.readableBytes();//前面</div><div class=\"line\">     tooLongFrameLength = frameLength;</div><div class=\"line\">     // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">     if (discard &lt; 0) &#123;// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">         // buffer contains more bytes then the frameLength so we can discard all now</div><div class=\"line\">         in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Enter the discard mode and discard everything received so far.</div><div class=\"line\">         discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧</div><div class=\"line\">         bytesToDiscard = discard;</div><div class=\"line\">         in.skipBytes(in.readableBytes());//丢弃整个帧</div><div class=\"line\">     &#125;</div><div class=\"line\">     failIfNecessary(true);</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> // never overflows because it&apos;s less than maxFrameLength</div><div class=\"line\"> int frameLengthInt = (int) frameLength;</div><div class=\"line\"> if (in.readableBytes() &lt; frameLengthInt) &#123;  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> if (initialBytesToStrip &gt; frameLengthInt) &#123;</div><div class=\"line\">     in.skipBytes(frameLengthInt);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than initialBytesToStrip: &quot; + initialBytesToStrip);</div><div class=\"line\"> &#125;</div><div class=\"line\"> in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content</div><div class=\"line\"> // extract frame</div><div class=\"line\"> int readerIndex = in.readerIndex();</div><div class=\"line\"> int actualFrameLength = frameLengthInt - initialBytesToStrip;</div><div class=\"line\"> ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);</div><div class=\"line\"> in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置</div><div class=\"line\"> return frame;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要操作如下:<br>1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void failIfNecessary(boolean firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">        if (bytesToDiscard == 0) &#123; //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态</div><div class=\"line\">            // Reset to the initial state and tell the handlers that</div><div class=\"line\">            // the frame was too large.</div><div class=\"line\">            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度</div><div class=\"line\">            this.tooLongFrameLength = 0; //主要是复位</div><div class=\"line\">            discardingTooLongFrame = false;</div><div class=\"line\">            if (!failFast || firstDetectionOfTooLongFrame) &#123;// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理</div><div class=\"line\">                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;  //第一次遇到，发现当前帧长度太长了</div><div class=\"line\">            // Keep discarding and notify handlers if necessary.</div><div class=\"line\">            if (failFast &amp;&amp; firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">                fail(tooLongFrameLength); //是第一次遇到，直接丢失</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。</li>\n<li>反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。<br>2) 若当前缓存可读byte &lt; 长度偏移量, 直接退出继续, 数据仍然放在了缓存。<br>3) 计算出帧整体的长度,包括了length + head2 + content:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameLength += lengthAdjustment + lengthFieldEndOffset;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>4) 检查帧frameLength是否超过的阈值,若超过了:</p>\n<ul>\n<li>检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度</li>\n<li>否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。<br>并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。<br>5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。<br>6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。</li>\n</ul>\n"},{"title":"NioEventLoop篇","date":"2018-01-22T00:53:40.000Z","toc":true,"_content":"# 介绍\n在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:\n```\n            ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {...}\n            });\n```\n调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:\n```\n public void execute(Runnable task) {\n        boolean inEventLoop = inEventLoop();\n        if (inEventLoop) {\n            addTask(task);\n        } else {\n            startThread();\n            addTask(task);\n            if (isShutdown() && removeTask(task)) {\n                reject();\n            }\n        }\n        if (!addTaskWakesUp && wakesUpForTask(task)) {\n            wakeup(inEventLoop);\n        }\n    }\n```\n首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。\n## startThread\nstartThread用来启动NioEventLoop里面的执行线程,代码如下:\n```\n  executor.execute(new Runnable() { //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动\n            @Override\n            public void run() {\n                thread = Thread.currentThread(); //获取当前这个线程\n                if (interrupted) {\n                    thread.interrupt();\n                }\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环\n                    success = true;\n                } catch (Throwable t) {\n                }\n```\nexecutor实际是ThreadPerTaskExecutor, execute将跑到ThreadPerTaskExecutor.execute():\n```\n @Override\n    public void execute(Runnable command) {\n        threadFactory.newThread(command).start();\n    }\n```\n这里真正唤醒了线程new Runnable()后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。\n因为NioEventLoop对应的线程比较重要, 弄清楚如何启动该线程对我们了解很有帮助, 我们来捋一捋这个过程,下图是涉及到的类及函数\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/NioEventLoop1.png\" height=\"300\" width=\"450\"/>\n1. 首先eventLoop.execute(), 主函数返回。\n2. 进入了SingleThreadEventExecutor.execute(), 首先检查thread变量是否为null, 若为空并且检查state状态为not_started, 代表没有启动, 则调用executor.execute()\n3. 调用executor.execute()后, 产生线程并启动, 线程的run()如上所示, 会对thread赋值, 然后调用NioEventLoop.run()开始死循环执行。\n\n# NioEventLoop\nNioEventLoop作为Netty多线程的重要类, 我们可以将其看成一个只有一个线程的线程池\ntask分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。\n+ 非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头`ch.eventLoop().execute`)\n+ IO型: Accetp、Write、read等从远程节点发送过来的请求。\n\n为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:\n+ 若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。\n+ 若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。\n\nNioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:\n\n```\n  @Override\n    protected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n                        // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                        // before calling 'selector.wakeup()' to reduce the wake-up\n                        // overhead. (Selector.wakeup() is an expensive operation.)\n                        //\n                        // However, there is a race condition in this approach.\n                        // The race condition is triggered when 'wakenUp' is set to\n                        // true too early.\n                        //\n                        // 'wakenUp' is set to true too early if:\n                        // 1) Selector is waken up between 'wakenUp.set(false)' and\n                        //    'selector.select(...)'. (BAD)\n                        // 2) Selector is waken up between 'selector.select(...)' and\n                        //    'if (wakenUp.get()) { ... }'. (OK)\n                        //\n                        // In the first case, 'wakenUp' is set to true and the\n                        // following 'selector.select(...)' will wake up immediately.\n                        // Until 'wakenUp' is set to false again in the next round,\n                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                        // any attempt to wake up the Selector will fail, too, causing\n                        // the following 'selector.select(...)' call to block\n                        // unnecessarily.\n                        //\n                        // To fix this problem, we wake up the selector again if wakenUp\n                        // is true immediately after selector.select(...).\n                        // It is inefficient in that it wakes up the selector for both\n                        // the first case (BAD - wake-up required) and the second case\n                        // (OK - no wake-up required).\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                        // fallthrough\n                }\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\nselector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()\nNioEventLoop.run()部分的逻辑还是比较清楚:\n(1) 检查是否累计有task:\n```\n@Override\n    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {\n        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要\n    }\n```\n进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:\n```\nint selectNow() throws IOException {//相当于复写了NIO的select函数\n        try {\n            return selector.selectNow(); //返回的0, 直接跳出switch循环\n        } finally {\n            // restore wakeup state if needed\n            if (wakenUp.get()) {\n                selector.wakeup();\n            }\n        }\n    }\n```\n若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。\n(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。\nwakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:\n```\nprivate void select(boolean oldWakenUp) throws IOException {\n        Selector selector = this.selector;\n        try {\n            int selectCnt = 0;\n            long currentTimeNanos = System.nanoTime();\n            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间\n            for (;;) {  //timeoutMillis下次等待需要的时间\n                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns\n                if (timeoutMillis <= 0) {//距离第一个执行计划开始时间已经过了（1ms）\n                    if (selectCnt == 0) { //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()\n                        selector.selectNow();\n                        selectCnt = 1;\n                    }\n                    break;\n                }\n                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call\n                // Selector#wakeup. So we need to check task queue again before executing select operation.\n                // If we don't, the task might be pended until select operation was timed out.\n                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.\n                if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                int selectedKeys = selector.select(timeoutMillis);\n                selectCnt ++;\n                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环\n                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                    // - Selected something,\n                    // - waken up by user, or\n                    // - the task queue has a pending task.\n                    // - a scheduled task is ready for processing\n                    break;\n                }\n                long time = System.nanoTime();//selector.select(timeoutMillis);\n                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                    // timeoutMillis elapsed without anything selected.\n                    selectCnt = 1;\n                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                        selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。\n                    // The selector returned prematurely many times in a row.\n                    // Rebuild the selector to work around the problem.\n                    rebuildSelector();\n                    selector = this.selector;\n                    // Select again to populate selectedKeys.\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                currentTimeNanos = time;\n            }\n\n        } catch (CancelledKeyException e) {\n        }\n    }\n\n```\n可以看出代码做了如下事情:\n2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时\n如果当前时间 > 截止时间 + 0.5ms的话,就立刻退出执行task。\n2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。\n+ 此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。\n+ 若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。\n别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:\n ```\nprotected void wakeup(boolean inEventLoop) { //inEventLoop说的是NioEventLoop还没有启动\n        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n            selector.wakeup();\n        }\n    }\n ```\n 当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。\n2.3 执行selector.select(timeoutMillis)\n+ 若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。\n+ 若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。\n+ 若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。\n\n2.4 检查是否需要跳出循环:\n+ 有IO task了\n+ 上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。\n+ 此轮有task处于penging.\n+ 有schedule task截止时间已经到了。\nselect(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。\n这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:\n```\nivate void rebuildSelector0() {\n        newSelectorTuple = openSelector();//打开一个新的Selector\n        // Register all channels to the new Selector.\n        int nChannels = 0;\n        for (SelectionKey key: oldSelector.keys()) {////SelectionKey无效或者已经注册上了则跳过\n            Object a = key.attachment();\n            try {\n                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {\n                    continue;\n                }\n                int interestOps = key.interestOps();\n                key.cancel();//取消SelectionKey\n                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);\n            }\n        }\n        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector\n        unwrappedSelector = newSelectorTuple.unwrappedSelector;\n```\n主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。\n如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过`SELECTOR_AUTO_REBUILD_THRESHOLD`则说明触发了, 默认为512次。\n\nselect(wakenUp.getAndSet(false))完成后,会有这段代码\n```\nif (wakenUp.get()) {\n        selector.wakeup(); //下次\n }\n```\n参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。\n假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:\n```\nif (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n```\n那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -> 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)\n```\n     if (hasTasks() && wakenUp.compareAndSet(false, true)) {//若果当前有task，并且是可以叫醒的，则中断selector.select\n                    selector.selectNow();//selectNow()返回，否则会耽误任务执行\n                    selectCnt = 1;   //\n                    break;\n                }\n```\n\n只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。\n所以说, 那部分代码是没有没有意义的。\n\n(3) 开始执行IO task和非IO task\n前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。\n## IO任务执行processSelectedKeysPlain\nprocessSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:\n```\n        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n        eventLoop = ch.eventLoop();\n        try {\n            int readyOps = k.readyOps();\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n                unsafe.finishConnect();\n            }\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) { //如果是写\n                ch.unsafe().forceFlush();\n            }\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read(); //这里很重要，NioMessageUnsafe\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n```\n这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)\n ###  SelectionKey.OP_ACCEPT部分\n 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面\n```\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config(); //NioServerSocketChannelConf\n            final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline\n            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n            allocHandle.reset(config);\n\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    do { //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法\n                        int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        allocHandle.incMessagesRead(localRead);\n                    } while (allocHandle.continueReading()); //当前连接是否该继续\n                } catch (Throwable t) {\n                    exception = t;\n                }\n\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n                    readPending = false;//// 对每个连接调用pipeline的fireChannelRead\n                    pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面\n                }\n                readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf\n                allocHandle.readComplete();\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    inputShutdown = true;\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                // Check if there is a readPending which was not processed yet.\n                // This could be for two reasons:\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n                //\n                // See https://github.com/netty/netty/issues/2254\n                if (!readPending && !config.isAutoRead()) {\n                    removeReadOp();\n                }\n            }\n```\n1. 循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:\n```\n         SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，\n        try {\n            if (ch != null) {\n                buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel\n                return 1;\n            }\n        } catch (Throwable t) {\n        }\n\n        return 0;\n```\n同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个\nSocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。\nNioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:\n```\n         this.parent = parent; //NioServerSocketChannel\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。\n```\n\n2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。\n初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:\n ```\npublic final ChannelPipeline fireChannelRead(Object msg) { //msg是新建立的SocketChannel\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了\n        return this;\n    }\n```\n读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以`static`注释的。\n```\n static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { ////msg是新建立的NioSocketChannel\n        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next); //pipe是同一个，\n        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为\n        if (executor.inEventLoop()) { //本线程是否是EventLoop线程\n            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类\n        } else {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    next.invokeChannelRead(m);\n                }\n            });\n        }\n    }\n````\n2.1 会以根据HeadContext开始讲起:\n+ 首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。\n```\n public EventExecutor executor() {  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop\n        if (executor == null) {\n            return channel().eventLoop();\n        } else {\n            return executor;\n        }\n    }\n\n```\n+ 确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的`static void invokeChannelRead`\nstatic void invokeChannelRead\n```\n private AbstractChannelHandlerContext findContextInbound() { //从Head当前位置找，直到向后找到一个inbound的，就退出\n        AbstractChannelHandlerContext ctx = this;\n        do {\n            ctx = ctx.next;//直接找下一个\n        } while (!ctx.inbound);\n        return ctx;\n    }\n```\n到第二个Context, 其中会执行`((ChannelInboundHandler) handler()).channelRead(this, msg)`, 即ServerBootstrapAcceptor.channelRead(), 如下所示:\n```\n public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            final Channel child = (Channel) msg; //// child = NioSocketChannel\n            child.pipeline().addLast(childHandler);\n            setChannelOptions(child, childOptions, logger);\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n            try {  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接\n                childGroup.register(child).addListener(new ChannelFutureListener() {   ///这里使用的是childGroup\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) { //如果有连接完成，但是失败的情况下\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n            }\n```\n主要做的事:\n+ 其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.\n+ 从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。\n+ 当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。\n\n其中第二步骤, 注册的代码在`ServerBootStrap初始篇`中已经展示, 为了讲解方便在此再次罗列:\n```\n                 boolean firstRegistration = neverRegistered;\n                doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中\n                neverRegistered = false;\n                registered = true;// register状态设置为true，\n\n                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n                // user may already fire events through the pipeline in the ChannelFutureListener.\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0->accept\n                pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n```\n其中需要注意的是:\n+ invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:\nHeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n+ 会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:\n```\n public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireChannelActive();\n\n            readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性\n        }\n```\nctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin\n```\n@Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。\n### SelectionKey.OP_READ\n 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在`Netty通信编解码源码解读`讲解。\n\n## 执行非IO Task.\n进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:\n```\nprotected boolean runAllTasks(long timeoutNanos) {//处理非I/O任务。\n        fetchFromScheduledTaskQueue();\n        Runnable task = pollTask();//从\n        if (task == null) {\n            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()\n            return false;\n        }\n        //截止时间=ScheduledFutureTask当前相对时间+ 超时\n        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;\n        long runTasks = 0;\n        long lastExecutionTime;\n        for (;;) {\n            safeExecute(task);  //顺序执行所有task\n\n            runTasks ++;\n\n            // Check timeout every 64 tasks because nanoTime() is relatively expensive.\n            // XXX: Hard-coded value - will make it configurable if it is really a problem.\n            if ((runTasks & 0x3F) == 0) {  //当64个task后\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                if (lastExecutionTime >= deadline) {//当前时间超过截止时间，那么就退出\n                    break;\n                }\n            }\n\n            task = pollTask();\n            if (task == null) {\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                break;\n            }\n        }\n\n        afterRunningAllTasks();\n        this.lastExecutionTime = lastExecutionTime;\n        return true;\n    }\n```\n主要做了如下几件事:\n+ 从schedule队列取出任务向taskQueue中存放, 是一个有size<=16的、根据截至时间有优先级的阻塞队列。\n+ 从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.\n\nNioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。","source":"_posts/NioEventLoop篇.md","raw":"---\ntitle: NioEventLoop篇\ndate: 2018-01-22 08:53:40\ntags: NioEventLoop\ntoc: true\n---\n# 介绍\n在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:\n```\n            ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {...}\n            });\n```\n调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:\n```\n public void execute(Runnable task) {\n        boolean inEventLoop = inEventLoop();\n        if (inEventLoop) {\n            addTask(task);\n        } else {\n            startThread();\n            addTask(task);\n            if (isShutdown() && removeTask(task)) {\n                reject();\n            }\n        }\n        if (!addTaskWakesUp && wakesUpForTask(task)) {\n            wakeup(inEventLoop);\n        }\n    }\n```\n首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。\n## startThread\nstartThread用来启动NioEventLoop里面的执行线程,代码如下:\n```\n  executor.execute(new Runnable() { //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动\n            @Override\n            public void run() {\n                thread = Thread.currentThread(); //获取当前这个线程\n                if (interrupted) {\n                    thread.interrupt();\n                }\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环\n                    success = true;\n                } catch (Throwable t) {\n                }\n```\nexecutor实际是ThreadPerTaskExecutor, execute将跑到ThreadPerTaskExecutor.execute():\n```\n @Override\n    public void execute(Runnable command) {\n        threadFactory.newThread(command).start();\n    }\n```\n这里真正唤醒了线程new Runnable()后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。\n因为NioEventLoop对应的线程比较重要, 弄清楚如何启动该线程对我们了解很有帮助, 我们来捋一捋这个过程,下图是涉及到的类及函数\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/NioEventLoop1.png\" height=\"300\" width=\"450\"/>\n1. 首先eventLoop.execute(), 主函数返回。\n2. 进入了SingleThreadEventExecutor.execute(), 首先检查thread变量是否为null, 若为空并且检查state状态为not_started, 代表没有启动, 则调用executor.execute()\n3. 调用executor.execute()后, 产生线程并启动, 线程的run()如上所示, 会对thread赋值, 然后调用NioEventLoop.run()开始死循环执行。\n\n# NioEventLoop\nNioEventLoop作为Netty多线程的重要类, 我们可以将其看成一个只有一个线程的线程池\ntask分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。\n+ 非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头`ch.eventLoop().execute`)\n+ IO型: Accetp、Write、read等从远程节点发送过来的请求。\n\n为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:\n+ 若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。\n+ 若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。\n\nNioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:\n\n```\n  @Override\n    protected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n                        // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                        // before calling 'selector.wakeup()' to reduce the wake-up\n                        // overhead. (Selector.wakeup() is an expensive operation.)\n                        //\n                        // However, there is a race condition in this approach.\n                        // The race condition is triggered when 'wakenUp' is set to\n                        // true too early.\n                        //\n                        // 'wakenUp' is set to true too early if:\n                        // 1) Selector is waken up between 'wakenUp.set(false)' and\n                        //    'selector.select(...)'. (BAD)\n                        // 2) Selector is waken up between 'selector.select(...)' and\n                        //    'if (wakenUp.get()) { ... }'. (OK)\n                        //\n                        // In the first case, 'wakenUp' is set to true and the\n                        // following 'selector.select(...)' will wake up immediately.\n                        // Until 'wakenUp' is set to false again in the next round,\n                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                        // any attempt to wake up the Selector will fail, too, causing\n                        // the following 'selector.select(...)' call to block\n                        // unnecessarily.\n                        //\n                        // To fix this problem, we wake up the selector again if wakenUp\n                        // is true immediately after selector.select(...).\n                        // It is inefficient in that it wakes up the selector for both\n                        // the first case (BAD - wake-up required) and the second case\n                        // (OK - no wake-up required).\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                        // fallthrough\n                }\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\nselector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()\nNioEventLoop.run()部分的逻辑还是比较清楚:\n(1) 检查是否累计有task:\n```\n@Override\n    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {\n        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要\n    }\n```\n进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:\n```\nint selectNow() throws IOException {//相当于复写了NIO的select函数\n        try {\n            return selector.selectNow(); //返回的0, 直接跳出switch循环\n        } finally {\n            // restore wakeup state if needed\n            if (wakenUp.get()) {\n                selector.wakeup();\n            }\n        }\n    }\n```\n若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。\n(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。\nwakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:\n```\nprivate void select(boolean oldWakenUp) throws IOException {\n        Selector selector = this.selector;\n        try {\n            int selectCnt = 0;\n            long currentTimeNanos = System.nanoTime();\n            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间\n            for (;;) {  //timeoutMillis下次等待需要的时间\n                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns\n                if (timeoutMillis <= 0) {//距离第一个执行计划开始时间已经过了（1ms）\n                    if (selectCnt == 0) { //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()\n                        selector.selectNow();\n                        selectCnt = 1;\n                    }\n                    break;\n                }\n                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call\n                // Selector#wakeup. So we need to check task queue again before executing select operation.\n                // If we don't, the task might be pended until select operation was timed out.\n                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.\n                if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                int selectedKeys = selector.select(timeoutMillis);\n                selectCnt ++;\n                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环\n                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                    // - Selected something,\n                    // - waken up by user, or\n                    // - the task queue has a pending task.\n                    // - a scheduled task is ready for processing\n                    break;\n                }\n                long time = System.nanoTime();//selector.select(timeoutMillis);\n                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                    // timeoutMillis elapsed without anything selected.\n                    selectCnt = 1;\n                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                        selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。\n                    // The selector returned prematurely many times in a row.\n                    // Rebuild the selector to work around the problem.\n                    rebuildSelector();\n                    selector = this.selector;\n                    // Select again to populate selectedKeys.\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                currentTimeNanos = time;\n            }\n\n        } catch (CancelledKeyException e) {\n        }\n    }\n\n```\n可以看出代码做了如下事情:\n2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时\n如果当前时间 > 截止时间 + 0.5ms的话,就立刻退出执行task。\n2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。\n+ 此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。\n+ 若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。\n别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:\n ```\nprotected void wakeup(boolean inEventLoop) { //inEventLoop说的是NioEventLoop还没有启动\n        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n            selector.wakeup();\n        }\n    }\n ```\n 当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。\n2.3 执行selector.select(timeoutMillis)\n+ 若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。\n+ 若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。\n+ 若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。\n\n2.4 检查是否需要跳出循环:\n+ 有IO task了\n+ 上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。\n+ 此轮有task处于penging.\n+ 有schedule task截止时间已经到了。\nselect(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。\n这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:\n```\nivate void rebuildSelector0() {\n        newSelectorTuple = openSelector();//打开一个新的Selector\n        // Register all channels to the new Selector.\n        int nChannels = 0;\n        for (SelectionKey key: oldSelector.keys()) {////SelectionKey无效或者已经注册上了则跳过\n            Object a = key.attachment();\n            try {\n                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {\n                    continue;\n                }\n                int interestOps = key.interestOps();\n                key.cancel();//取消SelectionKey\n                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);\n            }\n        }\n        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector\n        unwrappedSelector = newSelectorTuple.unwrappedSelector;\n```\n主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。\n如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过`SELECTOR_AUTO_REBUILD_THRESHOLD`则说明触发了, 默认为512次。\n\nselect(wakenUp.getAndSet(false))完成后,会有这段代码\n```\nif (wakenUp.get()) {\n        selector.wakeup(); //下次\n }\n```\n参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。\n假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:\n```\nif (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n```\n那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -> 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)\n```\n     if (hasTasks() && wakenUp.compareAndSet(false, true)) {//若果当前有task，并且是可以叫醒的，则中断selector.select\n                    selector.selectNow();//selectNow()返回，否则会耽误任务执行\n                    selectCnt = 1;   //\n                    break;\n                }\n```\n\n只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。\n所以说, 那部分代码是没有没有意义的。\n\n(3) 开始执行IO task和非IO task\n前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。\n## IO任务执行processSelectedKeysPlain\nprocessSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:\n```\n        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n        eventLoop = ch.eventLoop();\n        try {\n            int readyOps = k.readyOps();\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n                unsafe.finishConnect();\n            }\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) { //如果是写\n                ch.unsafe().forceFlush();\n            }\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read(); //这里很重要，NioMessageUnsafe\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n```\n这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)\n ###  SelectionKey.OP_ACCEPT部分\n 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面\n```\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config(); //NioServerSocketChannelConf\n            final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline\n            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n            allocHandle.reset(config);\n\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    do { //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法\n                        int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        allocHandle.incMessagesRead(localRead);\n                    } while (allocHandle.continueReading()); //当前连接是否该继续\n                } catch (Throwable t) {\n                    exception = t;\n                }\n\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n                    readPending = false;//// 对每个连接调用pipeline的fireChannelRead\n                    pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面\n                }\n                readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf\n                allocHandle.readComplete();\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    inputShutdown = true;\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                // Check if there is a readPending which was not processed yet.\n                // This could be for two reasons:\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n                //\n                // See https://github.com/netty/netty/issues/2254\n                if (!readPending && !config.isAutoRead()) {\n                    removeReadOp();\n                }\n            }\n```\n1. 循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:\n```\n         SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，\n        try {\n            if (ch != null) {\n                buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel\n                return 1;\n            }\n        } catch (Throwable t) {\n        }\n\n        return 0;\n```\n同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个\nSocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。\nNioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:\n```\n         this.parent = parent; //NioServerSocketChannel\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。\n```\n\n2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。\n初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:\n ```\npublic final ChannelPipeline fireChannelRead(Object msg) { //msg是新建立的SocketChannel\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了\n        return this;\n    }\n```\n读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以`static`注释的。\n```\n static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { ////msg是新建立的NioSocketChannel\n        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next); //pipe是同一个，\n        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为\n        if (executor.inEventLoop()) { //本线程是否是EventLoop线程\n            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类\n        } else {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    next.invokeChannelRead(m);\n                }\n            });\n        }\n    }\n````\n2.1 会以根据HeadContext开始讲起:\n+ 首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。\n```\n public EventExecutor executor() {  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop\n        if (executor == null) {\n            return channel().eventLoop();\n        } else {\n            return executor;\n        }\n    }\n\n```\n+ 确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的`static void invokeChannelRead`\nstatic void invokeChannelRead\n```\n private AbstractChannelHandlerContext findContextInbound() { //从Head当前位置找，直到向后找到一个inbound的，就退出\n        AbstractChannelHandlerContext ctx = this;\n        do {\n            ctx = ctx.next;//直接找下一个\n        } while (!ctx.inbound);\n        return ctx;\n    }\n```\n到第二个Context, 其中会执行`((ChannelInboundHandler) handler()).channelRead(this, msg)`, 即ServerBootstrapAcceptor.channelRead(), 如下所示:\n```\n public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            final Channel child = (Channel) msg; //// child = NioSocketChannel\n            child.pipeline().addLast(childHandler);\n            setChannelOptions(child, childOptions, logger);\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n            try {  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接\n                childGroup.register(child).addListener(new ChannelFutureListener() {   ///这里使用的是childGroup\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) { //如果有连接完成，但是失败的情况下\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n            }\n```\n主要做的事:\n+ 其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.\n+ 从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。\n+ 当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。\n\n其中第二步骤, 注册的代码在`ServerBootStrap初始篇`中已经展示, 为了讲解方便在此再次罗列:\n```\n                 boolean firstRegistration = neverRegistered;\n                doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中\n                neverRegistered = false;\n                registered = true;// register状态设置为true，\n\n                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n                // user may already fire events through the pipeline in the ChannelFutureListener.\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0->accept\n                pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n```\n其中需要注意的是:\n+ invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:\nHeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n+ 会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:\n```\n public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireChannelActive();\n\n            readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性\n        }\n```\nctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin\n```\n@Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。\n### SelectionKey.OP_READ\n 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在`Netty通信编解码源码解读`讲解。\n\n## 执行非IO Task.\n进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:\n```\nprotected boolean runAllTasks(long timeoutNanos) {//处理非I/O任务。\n        fetchFromScheduledTaskQueue();\n        Runnable task = pollTask();//从\n        if (task == null) {\n            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()\n            return false;\n        }\n        //截止时间=ScheduledFutureTask当前相对时间+ 超时\n        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;\n        long runTasks = 0;\n        long lastExecutionTime;\n        for (;;) {\n            safeExecute(task);  //顺序执行所有task\n\n            runTasks ++;\n\n            // Check timeout every 64 tasks because nanoTime() is relatively expensive.\n            // XXX: Hard-coded value - will make it configurable if it is really a problem.\n            if ((runTasks & 0x3F) == 0) {  //当64个task后\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                if (lastExecutionTime >= deadline) {//当前时间超过截止时间，那么就退出\n                    break;\n                }\n            }\n\n            task = pollTask();\n            if (task == null) {\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                break;\n            }\n        }\n\n        afterRunningAllTasks();\n        this.lastExecutionTime = lastExecutionTime;\n        return true;\n    }\n```\n主要做了如下几件事:\n+ 从schedule队列取出任务向taskQueue中存放, 是一个有size<=16的、根据截至时间有优先级的阻塞队列。\n+ 从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.\n\nNioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。","slug":"NioEventLoop篇","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xd000wphu502qg87fq","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch.eventLoop().execute(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;...&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void execute(Runnable task) &#123;</div><div class=\"line\">       boolean inEventLoop = inEventLoop();</div><div class=\"line\">       if (inEventLoop) &#123;</div><div class=\"line\">           addTask(task);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           startThread();</div><div class=\"line\">           addTask(task);</div><div class=\"line\">           if (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">               reject();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">           wakeup(inEventLoop);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。</p>\n<h2 id=\"startThread\"><a href=\"#startThread\" class=\"headerlink\" title=\"startThread\"></a>startThread</h2><p>startThread用来启动NioEventLoop里面的执行线程,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">executor.execute(new Runnable() &#123; //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动</div><div class=\"line\">          @Override</div><div class=\"line\">          public void run() &#123;</div><div class=\"line\">              thread = Thread.currentThread(); //获取当前这个线程</div><div class=\"line\">              if (interrupted) &#123;</div><div class=\"line\">                  thread.interrupt();</div><div class=\"line\">              &#125;</div><div class=\"line\">              boolean success = false;</div><div class=\"line\">              updateLastExecutionTime();</div><div class=\"line\">              try &#123;</div><div class=\"line\">                  SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环</div><div class=\"line\">                  success = true;</div><div class=\"line\">              &#125; catch (Throwable t) &#123;</div><div class=\"line\">              &#125;</div></pre></td></tr></table></figure></p>\n<p>executor实际是ThreadPerTaskExecutor, execute将跑到ThreadPerTaskExecutor.execute():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">   public void execute(Runnable command) &#123;</div><div class=\"line\">       threadFactory.newThread(command).start();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里真正唤醒了线程new Runnable()后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。<br>因为NioEventLoop对应的线程比较重要, 弄清楚如何启动该线程对我们了解很有帮助, 我们来捋一捋这个过程,下图是涉及到的类及函数<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/NioEventLoop1.png\" height=\"300\" width=\"450\"></p>\n<ol>\n<li>首先eventLoop.execute(), 主函数返回。</li>\n<li>进入了SingleThreadEventExecutor.execute(), 首先检查thread变量是否为null, 若为空并且检查state状态为not_started, 代表没有启动, 则调用executor.execute()</li>\n<li>调用executor.execute()后, 产生线程并启动, 线程的run()如上所示, 会对thread赋值, 然后调用NioEventLoop.run()开始死循环执行。</li>\n</ol>\n<h1 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h1><p>NioEventLoop作为Netty多线程的重要类, 我们可以将其看成一个只有一个线程的线程池<br>task分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。</p>\n<ul>\n<li>非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头<code>ch.eventLoop().execute</code>)</li>\n<li>IO型: Accetp、Write、read等从远程节点发送过来的请求。</li>\n</ul>\n<p>为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:</p>\n<ul>\n<li>若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。</li>\n<li>若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。</li>\n</ul>\n<p>NioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  protected void run() &#123;</div><div class=\"line\">      for (;;) &#123;</div><div class=\"line\">          try &#123;</div><div class=\"line\">              switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) &#123;</div><div class=\"line\">                  case SelectStrategy.CONTINUE:</div><div class=\"line\">                      continue;</div><div class=\"line\">                  case SelectStrategy.SELECT:</div><div class=\"line\">                      select(wakenUp.getAndSet(false));</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</div><div class=\"line\">                      // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</div><div class=\"line\">                      // overhead. (Selector.wakeup() is an expensive operation.)</div><div class=\"line\">                      //</div><div class=\"line\">                      // However, there is a race condition in this approach.</div><div class=\"line\">                      // The race condition is triggered when &apos;wakenUp&apos; is set to</div><div class=\"line\">                      // true too early.</div><div class=\"line\">                      //</div><div class=\"line\">                      // &apos;wakenUp&apos; is set to true too early if:</div><div class=\"line\">                      // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</div><div class=\"line\">                      //    &apos;selector.select(...)&apos;. (BAD)</div><div class=\"line\">                      // 2) Selector is waken up between &apos;selector.select(...)&apos; and</div><div class=\"line\">                      //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</div><div class=\"line\">                      //</div><div class=\"line\">                      // In the first case, &apos;wakenUp&apos; is set to true and the</div><div class=\"line\">                      // following &apos;selector.select(...)&apos; will wake up immediately.</div><div class=\"line\">                      // Until &apos;wakenUp&apos; is set to false again in the next round,</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</div><div class=\"line\">                      // any attempt to wake up the Selector will fail, too, causing</div><div class=\"line\">                      // the following &apos;selector.select(...)&apos; call to block</div><div class=\"line\">                      // unnecessarily.</div><div class=\"line\">                      //</div><div class=\"line\">                      // To fix this problem, we wake up the selector again if wakenUp</div><div class=\"line\">                      // is true immediately after selector.select(...).</div><div class=\"line\">                      // It is inefficient in that it wakes up the selector for both</div><div class=\"line\">                      // the first case (BAD - wake-up required) and the second case</div><div class=\"line\">                      // (OK - no wake-up required).</div><div class=\"line\"></div><div class=\"line\">                      if (wakenUp.get()) &#123;</div><div class=\"line\">                          selector.wakeup();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                  default:</div><div class=\"line\">                      // fallthrough</div><div class=\"line\">              &#125;</div><div class=\"line\">              cancelledKeys = 0;</div><div class=\"line\">              needsToSelectAgain = false;</div><div class=\"line\">              final int ioRatio = this.ioRatio;</div><div class=\"line\">              if (ioRatio == 100) &#123;</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      runAllTasks();</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125; else &#123;</div><div class=\"line\">                  final long ioStartTime = System.nanoTime();</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      final long ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                      runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">          // Always handle shutdown even if the loop processing threw an exception.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              if (isShuttingDown()) &#123;</div><div class=\"line\">                  closeAll();</div><div class=\"line\">                  if (confirmShutdown()) &#123;</div><div class=\"line\">                      return;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>selector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()<br>NioEventLoop.run()部分的逻辑还是比较清楚:<br>(1) 检查是否累计有task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;</div><div class=\"line\">        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int selectNow() throws IOException &#123;//相当于复写了NIO的select函数</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return selector.selectNow(); //返回的0, 直接跳出switch循环</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // restore wakeup state if needed</div><div class=\"line\">            if (wakenUp.get()) &#123;</div><div class=\"line\">                selector.wakeup();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。<br>(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。<br>wakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</div><div class=\"line\">        Selector selector = this.selector;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            int selectCnt = 0;</div><div class=\"line\">            long currentTimeNanos = System.nanoTime();</div><div class=\"line\">            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间</div><div class=\"line\">            for (;;) &#123;  //timeoutMillis下次等待需要的时间</div><div class=\"line\">                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns</div><div class=\"line\">                if (timeoutMillis &lt;= 0) &#123;//距离第一个执行计划开始时间已经过了（1ms）</div><div class=\"line\">                    if (selectCnt == 0) &#123; //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()</div><div class=\"line\">                        selector.selectNow();</div><div class=\"line\">                        selectCnt = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</div><div class=\"line\">                // Selector#wakeup. So we need to check task queue again before executing select operation.</div><div class=\"line\">                // If we don&apos;t, the task might be pended until select operation was timed out.</div><div class=\"line\">                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</div><div class=\"line\">                if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int selectedKeys = selector.select(timeoutMillis);</div><div class=\"line\">                selectCnt ++;</div><div class=\"line\">                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环</div><div class=\"line\">                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class=\"line\">                    // - Selected something,</div><div class=\"line\">                    // - waken up by user, or</div><div class=\"line\">                    // - the task queue has a pending task.</div><div class=\"line\">                    // - a scheduled task is ready for processing</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                long time = System.nanoTime();//selector.select(timeoutMillis);</div><div class=\"line\">                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class=\"line\">                    // timeoutMillis elapsed without anything selected.</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class=\"line\">                        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。</div><div class=\"line\">                    // The selector returned prematurely many times in a row.</div><div class=\"line\">                    // Rebuild the selector to work around the problem.</div><div class=\"line\">                    rebuildSelector();</div><div class=\"line\">                    selector = this.selector;</div><div class=\"line\">                    // Select again to populate selectedKeys.</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentTimeNanos = time;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出代码做了如下事情:<br>2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时<br>如果当前时间 &gt; 截止时间 + 0.5ms的话,就立刻退出执行task。<br>2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。</p>\n<ul>\n<li>此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。</li>\n<li><p>若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。<br>别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void wakeup(boolean inEventLoop) &#123; //inEventLoop说的是NioEventLoop还没有启动</div><div class=\"line\">        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">            selector.wakeup();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。<br>2.3 执行selector.select(timeoutMillis)</p>\n</li>\n<li>若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。</li>\n<li>若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。</li>\n<li>若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。</li>\n</ul>\n<p>2.4 检查是否需要跳出循环:</p>\n<ul>\n<li>有IO task了</li>\n<li>上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。</li>\n<li>此轮有task处于penging.</li>\n<li>有schedule task截止时间已经到了。<br>select(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。<br>这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ivate void rebuildSelector0() &#123;</div><div class=\"line\">        newSelectorTuple = openSelector();//打开一个新的Selector</div><div class=\"line\">        // Register all channels to the new Selector.</div><div class=\"line\">        int nChannels = 0;</div><div class=\"line\">        for (SelectionKey key: oldSelector.keys()) &#123;////SelectionKey无效或者已经注册上了则跳过</div><div class=\"line\">            Object a = key.attachment();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int interestOps = key.interestOps();</div><div class=\"line\">                key.cancel();//取消SelectionKey</div><div class=\"line\">                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector</div><div class=\"line\">        unwrappedSelector = newSelectorTuple.unwrappedSelector;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。<br>如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>则说明触发了, 默认为512次。</p>\n<p>select(wakenUp.getAndSet(false))完成后,会有这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (wakenUp.get()) &#123;</div><div class=\"line\">        selector.wakeup(); //下次</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。<br>假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div></pre></td></tr></table></figure></p>\n<p>那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -&gt; 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;//若果当前有task，并且是可以叫醒的，则中断selector.select</div><div class=\"line\">               selector.selectNow();//selectNow()返回，否则会耽误任务执行</div><div class=\"line\">               selectCnt = 1;   //</div><div class=\"line\">               break;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。<br>所以说, 那部分代码是没有没有意义的。</p>\n<p>(3) 开始执行IO task和非IO task<br>前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。</p>\n<h2 id=\"IO任务执行processSelectedKeysPlain\"><a href=\"#IO任务执行processSelectedKeysPlain\" class=\"headerlink\" title=\"IO任务执行processSelectedKeysPlain\"></a>IO任务执行processSelectedKeysPlain</h2><p>processSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class=\"line\">eventLoop = ch.eventLoop();</div><div class=\"line\">try &#123;</div><div class=\"line\">    int readyOps = k.readyOps();</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class=\"line\">        int ops = k.interestOps();</div><div class=\"line\">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class=\"line\">        k.interestOps(ops);</div><div class=\"line\">        unsafe.finishConnect();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; //如果是写</div><div class=\"line\">        ch.unsafe().forceFlush();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class=\"line\">        unsafe.read(); //这里很重要，NioMessageUnsafe</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (CancelledKeyException ignored) &#123;</div><div class=\"line\">    unsafe.close(unsafe.voidPromise());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)</p>\n<h3 id=\"SelectionKey-OP-ACCEPT部分\"><a href=\"#SelectionKey-OP-ACCEPT部分\" class=\"headerlink\" title=\"SelectionKey.OP_ACCEPT部分\"></a>SelectionKey.OP_ACCEPT部分</h3><p> 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert eventLoop().inEventLoop();</div><div class=\"line\">final ChannelConfig config = config(); //NioServerSocketChannelConf</div><div class=\"line\">final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline</div><div class=\"line\">final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class=\"line\">allocHandle.reset(config);</div><div class=\"line\"></div><div class=\"line\">boolean closed = false;</div><div class=\"line\">Throwable exception = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        do &#123; //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法</div><div class=\"line\">            int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接</div><div class=\"line\">            if (localRead == 0) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localRead &lt; 0) &#123;</div><div class=\"line\">                closed = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            allocHandle.incMessagesRead(localRead);</div><div class=\"line\">        &#125; while (allocHandle.continueReading()); //当前连接是否该继续</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">        exception = t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int size = readBuf.size();</div><div class=\"line\">    for (int i = 0; i &lt; size; i ++) &#123;</div><div class=\"line\">        readPending = false;//// 对每个连接调用pipeline的fireChannelRead</div><div class=\"line\">        pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面</div><div class=\"line\">    &#125;</div><div class=\"line\">    readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf</div><div class=\"line\">    allocHandle.readComplete();</div><div class=\"line\">    pipeline.fireChannelReadComplete();</div><div class=\"line\"></div><div class=\"line\">    if (exception != null) &#123;</div><div class=\"line\">        closed = closeOnReadError(exception);</div><div class=\"line\"></div><div class=\"line\">        pipeline.fireExceptionCaught(exception);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (closed) &#123;</div><div class=\"line\">        inputShutdown = true;</div><div class=\"line\">        if (isOpen()) &#123;</div><div class=\"line\">            close(voidPromise());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    // Check if there is a readPending which was not processed yet.</div><div class=\"line\">    // This could be for two reasons:</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</div><div class=\"line\">    //</div><div class=\"line\">    // See https://github.com/netty/netty/issues/2254</div><div class=\"line\">    if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</div><div class=\"line\">        removeReadOp();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，</div><div class=\"line\">try &#123;</div><div class=\"line\">    if (ch != null) &#123;</div><div class=\"line\">        buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return 0;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个<br>SocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。<br>NioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> this.parent = parent; //NioServerSocketChannel</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。</div></pre></td></tr></table></figure></p>\n<p>2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。<br>初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ChannelPipeline fireChannelRead(Object msg) &#123; //msg是新建立的SocketChannel</div><div class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以<code>static</code>注释的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; ////msg是新建立的NioSocketChannel</div><div class=\"line\">        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next); //pipe是同一个，</div><div class=\"line\">        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为</div><div class=\"line\">        if (executor.inEventLoop()) &#123; //本线程是否是EventLoop线程</div><div class=\"line\">            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            executor.execute(new Runnable() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void run() &#123;</div><div class=\"line\">                    next.invokeChannelRead(m);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>2.1 会以根据HeadContext开始讲起:</p>\n<ul>\n<li><p>首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor executor() &#123;  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop</div><div class=\"line\">       if (executor == null) &#123;</div><div class=\"line\">           return channel().eventLoop();</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return executor;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的<code>static void invokeChannelRead</code><br>static void invokeChannelRead</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AbstractChannelHandlerContext findContextInbound() &#123; //从Head当前位置找，直到向后找到一个inbound的，就退出</div><div class=\"line\">       AbstractChannelHandlerContext ctx = this;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           ctx = ctx.next;//直接找下一个</div><div class=\"line\">       &#125; while (!ctx.inbound);</div><div class=\"line\">       return ctx;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到第二个Context, 其中会执行<code>((ChannelInboundHandler) handler()).channelRead(this, msg)</code>, 即ServerBootstrapAcceptor.channelRead(), 如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</div><div class=\"line\">           final Channel child = (Channel) msg; //// child = NioSocketChannel</div><div class=\"line\">           child.pipeline().addLast(childHandler);</div><div class=\"line\">           setChannelOptions(child, childOptions, logger);</div><div class=\"line\">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</div><div class=\"line\">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class=\"line\">           &#125;</div><div class=\"line\">           try &#123;  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接</div><div class=\"line\">               childGroup.register(child).addListener(new ChannelFutureListener() &#123;   ///这里使用的是childGroup</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                       if (!future.isSuccess()) &#123; //如果有连接完成，但是失败的情况下</div><div class=\"line\">                           forceClose(child, future.cause());</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.</li>\n<li>从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。</li>\n<li>当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。</li>\n</ul>\n<p>其中第二步骤, 注册的代码在<code>ServerBootStrap初始篇</code>中已经展示, 为了讲解方便在此再次罗列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean firstRegistration = neverRegistered;</div><div class=\"line\">doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中</div><div class=\"line\">neverRegistered = false;</div><div class=\"line\">registered = true;// register状态设置为true，</div><div class=\"line\"></div><div class=\"line\">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</div><div class=\"line\">// user may already fire events through the pipeline in the ChannelFutureListener.</div><div class=\"line\">pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0-&gt;accept</div><div class=\"line\">pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，</div><div class=\"line\">// Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">// multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">if (isActive()) &#123;  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用</div><div class=\"line\">    if (firstRegistration) &#123;</div><div class=\"line\">        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()</div><div class=\"line\">    &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">        // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">        // again so that we process inbound data.</div><div class=\"line\">        //</div><div class=\"line\">        // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">        beginRead();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中需要注意的是:</p>\n<ul>\n<li>invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:<br>HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.</li>\n<li>会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">           ctx.fireChannelActive();</div><div class=\"line\"></div><div class=\"line\">           readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">        // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">        final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">        if (!selectionKey.isValid()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        readPending = true;</div><div class=\"line\"></div><div class=\"line\">        final int interestOps = selectionKey.interestOps();</div><div class=\"line\">        if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">            selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。</p>\n<h3 id=\"SelectionKey-OP-READ\"><a href=\"#SelectionKey-OP-READ\" class=\"headerlink\" title=\"SelectionKey.OP_READ\"></a>SelectionKey.OP_READ</h3><p> 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在<code>Netty通信编解码源码解读</code>讲解。</p>\n<h2 id=\"执行非IO-Task\"><a href=\"#执行非IO-Task\" class=\"headerlink\" title=\"执行非IO Task.\"></a>执行非IO Task.</h2><p>进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;//处理非I/O任务。</div><div class=\"line\">        fetchFromScheduledTaskQueue();</div><div class=\"line\">        Runnable task = pollTask();//从</div><div class=\"line\">        if (task == null) &#123;</div><div class=\"line\">            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //截止时间=ScheduledFutureTask当前相对时间+ 超时</div><div class=\"line\">        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class=\"line\">        long runTasks = 0;</div><div class=\"line\">        long lastExecutionTime;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            safeExecute(task);  //顺序执行所有task</div><div class=\"line\"></div><div class=\"line\">            runTasks ++;</div><div class=\"line\"></div><div class=\"line\">            // Check timeout every 64 tasks because nanoTime() is relatively expensive.</div><div class=\"line\">            // XXX: Hard-coded value - will make it configurable if it is really a problem.</div><div class=\"line\">            if ((runTasks &amp; 0x3F) == 0) &#123;  //当64个task后</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                if (lastExecutionTime &gt;= deadline) &#123;//当前时间超过截止时间，那么就退出</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            task = pollTask();</div><div class=\"line\">            if (task == null) &#123;</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        afterRunningAllTasks();</div><div class=\"line\">        this.lastExecutionTime = lastExecutionTime;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几件事:</p>\n<ul>\n<li>从schedule队列取出任务向taskQueue中存放, 是一个有size&lt;=16的、根据截至时间有优先级的阻塞队列。</li>\n<li>从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.</li>\n</ul>\n<p>NioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch.eventLoop().execute(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;...&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void execute(Runnable task) &#123;</div><div class=\"line\">       boolean inEventLoop = inEventLoop();</div><div class=\"line\">       if (inEventLoop) &#123;</div><div class=\"line\">           addTask(task);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           startThread();</div><div class=\"line\">           addTask(task);</div><div class=\"line\">           if (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">               reject();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">           wakeup(inEventLoop);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。</p>\n<h2 id=\"startThread\"><a href=\"#startThread\" class=\"headerlink\" title=\"startThread\"></a>startThread</h2><p>startThread用来启动NioEventLoop里面的执行线程,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">executor.execute(new Runnable() &#123; //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动</div><div class=\"line\">          @Override</div><div class=\"line\">          public void run() &#123;</div><div class=\"line\">              thread = Thread.currentThread(); //获取当前这个线程</div><div class=\"line\">              if (interrupted) &#123;</div><div class=\"line\">                  thread.interrupt();</div><div class=\"line\">              &#125;</div><div class=\"line\">              boolean success = false;</div><div class=\"line\">              updateLastExecutionTime();</div><div class=\"line\">              try &#123;</div><div class=\"line\">                  SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环</div><div class=\"line\">                  success = true;</div><div class=\"line\">              &#125; catch (Throwable t) &#123;</div><div class=\"line\">              &#125;</div></pre></td></tr></table></figure></p>\n<p>executor实际是ThreadPerTaskExecutor, execute将跑到ThreadPerTaskExecutor.execute():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">   public void execute(Runnable command) &#123;</div><div class=\"line\">       threadFactory.newThread(command).start();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里真正唤醒了线程new Runnable()后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。<br>因为NioEventLoop对应的线程比较重要, 弄清楚如何启动该线程对我们了解很有帮助, 我们来捋一捋这个过程,下图是涉及到的类及函数<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/NioEventLoop1.png\" height=\"300\" width=\"450\"></p>\n<ol>\n<li>首先eventLoop.execute(), 主函数返回。</li>\n<li>进入了SingleThreadEventExecutor.execute(), 首先检查thread变量是否为null, 若为空并且检查state状态为not_started, 代表没有启动, 则调用executor.execute()</li>\n<li>调用executor.execute()后, 产生线程并启动, 线程的run()如上所示, 会对thread赋值, 然后调用NioEventLoop.run()开始死循环执行。</li>\n</ol>\n<h1 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h1><p>NioEventLoop作为Netty多线程的重要类, 我们可以将其看成一个只有一个线程的线程池<br>task分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。</p>\n<ul>\n<li>非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头<code>ch.eventLoop().execute</code>)</li>\n<li>IO型: Accetp、Write、read等从远程节点发送过来的请求。</li>\n</ul>\n<p>为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:</p>\n<ul>\n<li>若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。</li>\n<li>若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。</li>\n</ul>\n<p>NioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  protected void run() &#123;</div><div class=\"line\">      for (;;) &#123;</div><div class=\"line\">          try &#123;</div><div class=\"line\">              switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) &#123;</div><div class=\"line\">                  case SelectStrategy.CONTINUE:</div><div class=\"line\">                      continue;</div><div class=\"line\">                  case SelectStrategy.SELECT:</div><div class=\"line\">                      select(wakenUp.getAndSet(false));</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</div><div class=\"line\">                      // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</div><div class=\"line\">                      // overhead. (Selector.wakeup() is an expensive operation.)</div><div class=\"line\">                      //</div><div class=\"line\">                      // However, there is a race condition in this approach.</div><div class=\"line\">                      // The race condition is triggered when &apos;wakenUp&apos; is set to</div><div class=\"line\">                      // true too early.</div><div class=\"line\">                      //</div><div class=\"line\">                      // &apos;wakenUp&apos; is set to true too early if:</div><div class=\"line\">                      // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</div><div class=\"line\">                      //    &apos;selector.select(...)&apos;. (BAD)</div><div class=\"line\">                      // 2) Selector is waken up between &apos;selector.select(...)&apos; and</div><div class=\"line\">                      //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</div><div class=\"line\">                      //</div><div class=\"line\">                      // In the first case, &apos;wakenUp&apos; is set to true and the</div><div class=\"line\">                      // following &apos;selector.select(...)&apos; will wake up immediately.</div><div class=\"line\">                      // Until &apos;wakenUp&apos; is set to false again in the next round,</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</div><div class=\"line\">                      // any attempt to wake up the Selector will fail, too, causing</div><div class=\"line\">                      // the following &apos;selector.select(...)&apos; call to block</div><div class=\"line\">                      // unnecessarily.</div><div class=\"line\">                      //</div><div class=\"line\">                      // To fix this problem, we wake up the selector again if wakenUp</div><div class=\"line\">                      // is true immediately after selector.select(...).</div><div class=\"line\">                      // It is inefficient in that it wakes up the selector for both</div><div class=\"line\">                      // the first case (BAD - wake-up required) and the second case</div><div class=\"line\">                      // (OK - no wake-up required).</div><div class=\"line\"></div><div class=\"line\">                      if (wakenUp.get()) &#123;</div><div class=\"line\">                          selector.wakeup();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                  default:</div><div class=\"line\">                      // fallthrough</div><div class=\"line\">              &#125;</div><div class=\"line\">              cancelledKeys = 0;</div><div class=\"line\">              needsToSelectAgain = false;</div><div class=\"line\">              final int ioRatio = this.ioRatio;</div><div class=\"line\">              if (ioRatio == 100) &#123;</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      runAllTasks();</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125; else &#123;</div><div class=\"line\">                  final long ioStartTime = System.nanoTime();</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      final long ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                      runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">          // Always handle shutdown even if the loop processing threw an exception.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              if (isShuttingDown()) &#123;</div><div class=\"line\">                  closeAll();</div><div class=\"line\">                  if (confirmShutdown()) &#123;</div><div class=\"line\">                      return;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>selector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()<br>NioEventLoop.run()部分的逻辑还是比较清楚:<br>(1) 检查是否累计有task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;</div><div class=\"line\">        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int selectNow() throws IOException &#123;//相当于复写了NIO的select函数</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return selector.selectNow(); //返回的0, 直接跳出switch循环</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // restore wakeup state if needed</div><div class=\"line\">            if (wakenUp.get()) &#123;</div><div class=\"line\">                selector.wakeup();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。<br>(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。<br>wakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</div><div class=\"line\">        Selector selector = this.selector;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            int selectCnt = 0;</div><div class=\"line\">            long currentTimeNanos = System.nanoTime();</div><div class=\"line\">            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间</div><div class=\"line\">            for (;;) &#123;  //timeoutMillis下次等待需要的时间</div><div class=\"line\">                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns</div><div class=\"line\">                if (timeoutMillis &lt;= 0) &#123;//距离第一个执行计划开始时间已经过了（1ms）</div><div class=\"line\">                    if (selectCnt == 0) &#123; //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()</div><div class=\"line\">                        selector.selectNow();</div><div class=\"line\">                        selectCnt = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</div><div class=\"line\">                // Selector#wakeup. So we need to check task queue again before executing select operation.</div><div class=\"line\">                // If we don&apos;t, the task might be pended until select operation was timed out.</div><div class=\"line\">                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</div><div class=\"line\">                if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int selectedKeys = selector.select(timeoutMillis);</div><div class=\"line\">                selectCnt ++;</div><div class=\"line\">                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环</div><div class=\"line\">                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class=\"line\">                    // - Selected something,</div><div class=\"line\">                    // - waken up by user, or</div><div class=\"line\">                    // - the task queue has a pending task.</div><div class=\"line\">                    // - a scheduled task is ready for processing</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                long time = System.nanoTime();//selector.select(timeoutMillis);</div><div class=\"line\">                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class=\"line\">                    // timeoutMillis elapsed without anything selected.</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class=\"line\">                        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。</div><div class=\"line\">                    // The selector returned prematurely many times in a row.</div><div class=\"line\">                    // Rebuild the selector to work around the problem.</div><div class=\"line\">                    rebuildSelector();</div><div class=\"line\">                    selector = this.selector;</div><div class=\"line\">                    // Select again to populate selectedKeys.</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentTimeNanos = time;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出代码做了如下事情:<br>2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时<br>如果当前时间 &gt; 截止时间 + 0.5ms的话,就立刻退出执行task。<br>2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。</p>\n<ul>\n<li>此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。</li>\n<li><p>若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。<br>别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void wakeup(boolean inEventLoop) &#123; //inEventLoop说的是NioEventLoop还没有启动</div><div class=\"line\">        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">            selector.wakeup();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。<br>2.3 执行selector.select(timeoutMillis)</p>\n</li>\n<li>若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。</li>\n<li>若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。</li>\n<li>若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。</li>\n</ul>\n<p>2.4 检查是否需要跳出循环:</p>\n<ul>\n<li>有IO task了</li>\n<li>上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。</li>\n<li>此轮有task处于penging.</li>\n<li>有schedule task截止时间已经到了。<br>select(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。<br>这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ivate void rebuildSelector0() &#123;</div><div class=\"line\">        newSelectorTuple = openSelector();//打开一个新的Selector</div><div class=\"line\">        // Register all channels to the new Selector.</div><div class=\"line\">        int nChannels = 0;</div><div class=\"line\">        for (SelectionKey key: oldSelector.keys()) &#123;////SelectionKey无效或者已经注册上了则跳过</div><div class=\"line\">            Object a = key.attachment();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int interestOps = key.interestOps();</div><div class=\"line\">                key.cancel();//取消SelectionKey</div><div class=\"line\">                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector</div><div class=\"line\">        unwrappedSelector = newSelectorTuple.unwrappedSelector;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。<br>如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>则说明触发了, 默认为512次。</p>\n<p>select(wakenUp.getAndSet(false))完成后,会有这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (wakenUp.get()) &#123;</div><div class=\"line\">        selector.wakeup(); //下次</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。<br>假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div></pre></td></tr></table></figure></p>\n<p>那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -&gt; 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;//若果当前有task，并且是可以叫醒的，则中断selector.select</div><div class=\"line\">               selector.selectNow();//selectNow()返回，否则会耽误任务执行</div><div class=\"line\">               selectCnt = 1;   //</div><div class=\"line\">               break;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。<br>所以说, 那部分代码是没有没有意义的。</p>\n<p>(3) 开始执行IO task和非IO task<br>前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。</p>\n<h2 id=\"IO任务执行processSelectedKeysPlain\"><a href=\"#IO任务执行processSelectedKeysPlain\" class=\"headerlink\" title=\"IO任务执行processSelectedKeysPlain\"></a>IO任务执行processSelectedKeysPlain</h2><p>processSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class=\"line\">eventLoop = ch.eventLoop();</div><div class=\"line\">try &#123;</div><div class=\"line\">    int readyOps = k.readyOps();</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class=\"line\">        int ops = k.interestOps();</div><div class=\"line\">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class=\"line\">        k.interestOps(ops);</div><div class=\"line\">        unsafe.finishConnect();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; //如果是写</div><div class=\"line\">        ch.unsafe().forceFlush();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class=\"line\">        unsafe.read(); //这里很重要，NioMessageUnsafe</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (CancelledKeyException ignored) &#123;</div><div class=\"line\">    unsafe.close(unsafe.voidPromise());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)</p>\n<h3 id=\"SelectionKey-OP-ACCEPT部分\"><a href=\"#SelectionKey-OP-ACCEPT部分\" class=\"headerlink\" title=\"SelectionKey.OP_ACCEPT部分\"></a>SelectionKey.OP_ACCEPT部分</h3><p> 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert eventLoop().inEventLoop();</div><div class=\"line\">final ChannelConfig config = config(); //NioServerSocketChannelConf</div><div class=\"line\">final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline</div><div class=\"line\">final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class=\"line\">allocHandle.reset(config);</div><div class=\"line\"></div><div class=\"line\">boolean closed = false;</div><div class=\"line\">Throwable exception = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        do &#123; //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法</div><div class=\"line\">            int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接</div><div class=\"line\">            if (localRead == 0) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localRead &lt; 0) &#123;</div><div class=\"line\">                closed = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            allocHandle.incMessagesRead(localRead);</div><div class=\"line\">        &#125; while (allocHandle.continueReading()); //当前连接是否该继续</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">        exception = t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int size = readBuf.size();</div><div class=\"line\">    for (int i = 0; i &lt; size; i ++) &#123;</div><div class=\"line\">        readPending = false;//// 对每个连接调用pipeline的fireChannelRead</div><div class=\"line\">        pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面</div><div class=\"line\">    &#125;</div><div class=\"line\">    readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf</div><div class=\"line\">    allocHandle.readComplete();</div><div class=\"line\">    pipeline.fireChannelReadComplete();</div><div class=\"line\"></div><div class=\"line\">    if (exception != null) &#123;</div><div class=\"line\">        closed = closeOnReadError(exception);</div><div class=\"line\"></div><div class=\"line\">        pipeline.fireExceptionCaught(exception);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (closed) &#123;</div><div class=\"line\">        inputShutdown = true;</div><div class=\"line\">        if (isOpen()) &#123;</div><div class=\"line\">            close(voidPromise());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    // Check if there is a readPending which was not processed yet.</div><div class=\"line\">    // This could be for two reasons:</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</div><div class=\"line\">    //</div><div class=\"line\">    // See https://github.com/netty/netty/issues/2254</div><div class=\"line\">    if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</div><div class=\"line\">        removeReadOp();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，</div><div class=\"line\">try &#123;</div><div class=\"line\">    if (ch != null) &#123;</div><div class=\"line\">        buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return 0;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个<br>SocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。<br>NioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> this.parent = parent; //NioServerSocketChannel</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。</div></pre></td></tr></table></figure></p>\n<p>2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。<br>初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ChannelPipeline fireChannelRead(Object msg) &#123; //msg是新建立的SocketChannel</div><div class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以<code>static</code>注释的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; ////msg是新建立的NioSocketChannel</div><div class=\"line\">        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next); //pipe是同一个，</div><div class=\"line\">        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为</div><div class=\"line\">        if (executor.inEventLoop()) &#123; //本线程是否是EventLoop线程</div><div class=\"line\">            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            executor.execute(new Runnable() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void run() &#123;</div><div class=\"line\">                    next.invokeChannelRead(m);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>2.1 会以根据HeadContext开始讲起:</p>\n<ul>\n<li><p>首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor executor() &#123;  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop</div><div class=\"line\">       if (executor == null) &#123;</div><div class=\"line\">           return channel().eventLoop();</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return executor;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的<code>static void invokeChannelRead</code><br>static void invokeChannelRead</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AbstractChannelHandlerContext findContextInbound() &#123; //从Head当前位置找，直到向后找到一个inbound的，就退出</div><div class=\"line\">       AbstractChannelHandlerContext ctx = this;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           ctx = ctx.next;//直接找下一个</div><div class=\"line\">       &#125; while (!ctx.inbound);</div><div class=\"line\">       return ctx;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到第二个Context, 其中会执行<code>((ChannelInboundHandler) handler()).channelRead(this, msg)</code>, 即ServerBootstrapAcceptor.channelRead(), 如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</div><div class=\"line\">           final Channel child = (Channel) msg; //// child = NioSocketChannel</div><div class=\"line\">           child.pipeline().addLast(childHandler);</div><div class=\"line\">           setChannelOptions(child, childOptions, logger);</div><div class=\"line\">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</div><div class=\"line\">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class=\"line\">           &#125;</div><div class=\"line\">           try &#123;  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接</div><div class=\"line\">               childGroup.register(child).addListener(new ChannelFutureListener() &#123;   ///这里使用的是childGroup</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                       if (!future.isSuccess()) &#123; //如果有连接完成，但是失败的情况下</div><div class=\"line\">                           forceClose(child, future.cause());</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.</li>\n<li>从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。</li>\n<li>当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。</li>\n</ul>\n<p>其中第二步骤, 注册的代码在<code>ServerBootStrap初始篇</code>中已经展示, 为了讲解方便在此再次罗列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean firstRegistration = neverRegistered;</div><div class=\"line\">doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中</div><div class=\"line\">neverRegistered = false;</div><div class=\"line\">registered = true;// register状态设置为true，</div><div class=\"line\"></div><div class=\"line\">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</div><div class=\"line\">// user may already fire events through the pipeline in the ChannelFutureListener.</div><div class=\"line\">pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0-&gt;accept</div><div class=\"line\">pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，</div><div class=\"line\">// Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">// multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">if (isActive()) &#123;  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用</div><div class=\"line\">    if (firstRegistration) &#123;</div><div class=\"line\">        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()</div><div class=\"line\">    &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">        // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">        // again so that we process inbound data.</div><div class=\"line\">        //</div><div class=\"line\">        // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">        beginRead();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中需要注意的是:</p>\n<ul>\n<li>invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:<br>HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.</li>\n<li>会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">           ctx.fireChannelActive();</div><div class=\"line\"></div><div class=\"line\">           readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">        // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">        final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">        if (!selectionKey.isValid()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        readPending = true;</div><div class=\"line\"></div><div class=\"line\">        final int interestOps = selectionKey.interestOps();</div><div class=\"line\">        if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">            selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。</p>\n<h3 id=\"SelectionKey-OP-READ\"><a href=\"#SelectionKey-OP-READ\" class=\"headerlink\" title=\"SelectionKey.OP_READ\"></a>SelectionKey.OP_READ</h3><p> 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在<code>Netty通信编解码源码解读</code>讲解。</p>\n<h2 id=\"执行非IO-Task\"><a href=\"#执行非IO-Task\" class=\"headerlink\" title=\"执行非IO Task.\"></a>执行非IO Task.</h2><p>进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;//处理非I/O任务。</div><div class=\"line\">        fetchFromScheduledTaskQueue();</div><div class=\"line\">        Runnable task = pollTask();//从</div><div class=\"line\">        if (task == null) &#123;</div><div class=\"line\">            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //截止时间=ScheduledFutureTask当前相对时间+ 超时</div><div class=\"line\">        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class=\"line\">        long runTasks = 0;</div><div class=\"line\">        long lastExecutionTime;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            safeExecute(task);  //顺序执行所有task</div><div class=\"line\"></div><div class=\"line\">            runTasks ++;</div><div class=\"line\"></div><div class=\"line\">            // Check timeout every 64 tasks because nanoTime() is relatively expensive.</div><div class=\"line\">            // XXX: Hard-coded value - will make it configurable if it is really a problem.</div><div class=\"line\">            if ((runTasks &amp; 0x3F) == 0) &#123;  //当64个task后</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                if (lastExecutionTime &gt;= deadline) &#123;//当前时间超过截止时间，那么就退出</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            task = pollTask();</div><div class=\"line\">            if (task == null) &#123;</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        afterRunningAllTasks();</div><div class=\"line\">        this.lastExecutionTime = lastExecutionTime;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几件事:</p>\n<ul>\n<li>从schedule队列取出任务向taskQueue中存放, 是一个有size&lt;=16的、根据截至时间有优先级的阻塞队列。</li>\n<li>从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.</li>\n</ul>\n<p>NioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。</p>\n"},{"title":"ReentrantLock源码解读","date":"2017-07-23T11:47:30.000Z","toc":true,"_content":"ReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。\n基本使用如下:\n```\nReentrantLock lock = new ReentrantLock(true);\n//尝试获取锁,获取不到就阻塞\nlock.lock();\n......\n//释放锁,获取完了唤醒被阻塞的线程\nlock.unlock();\n```\n我们需要注意, 调用lock.lock()和lock.unlock()的线程必须是一个, lock.unlock()会对线程检查, 只有当调用lock.lock()的线程和本线程一致, 才可以解锁。可以看到, 是不是很像关键字synchronized的作用?\n# 简介\nAbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。\n## AbstractQueuedSynchronizer详解\n接下来将首先介绍两个重要的属性变量:\n`state`\nAbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了`volatile`关键字，这里没使用Synchronized来保证原子性的原因:\n+ state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。\n+ Synchronized实现互斥的成本要比volatile很高。\n`Node`\nAbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：\n```\n{\n     volatile int waitStatus;\n     volatile Node prev;\n     volatile Node next;\n     volatile Thread thread;\n     Node nextWaiter;\n\n}```\n\n|属性|介绍|\n|:-|:-|\n|waitStatus|当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态\n|prev|当前节点的前一个节点\n|next|当前节点的后继节点|\n|thread|当前节点所拥有的线程|\n|nextWaiter|表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。\nnextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS6.png\" height=\"200\" width=\"600\"/>\n上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。\n\nAQS中等待锁的线程队列与运行线程结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS.png\" height=\"250\" width=\"450\"/>\n### ReentrantLock详解\nReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。\n本文就以公平锁的获取与释放作为主线进行讲解。\n```\n    public static ReentrantLock lock = new ReentrantLock(true);\n    lock.lock()\n```\n这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值`1`的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。\n            selfInterrupt();\n    }\n```\n主要做了如下几个事情:\n+ 尝试去获取锁, 若获取到了, 就直接退出。\n+ 若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)\n### 尝试获取锁\n代码在FairSync中定义了:\n```\n        protected final boolean tryAcquire(int acquires) {\n             final Thread current = Thread.currentThread();\n            int c = getState();//首先读取state变量\n            if (c == 0) {\n                 ////判断sate值是否为0,在这里0就表示初始状态\n                if (!hasQueuedPredecessors() &&\n                    //采用CAS原子操作修改sate的值，\n                    compareAndSetState(0, acquires)) {\n                    //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            //当前线程就是抢占线程，那么是可以直接进入的\n            else if (current == getExclusiveOwnerThread()) {\n                //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            //否则就不能获取到，获取不到锁，但是不会改变state的值\n            return false;\n        }\n```\nFairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:\n1. 若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待\n2. 第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。\n3. 若当前线程获取不到锁, 是不会对status的值产生任何改变的。\n\n#### 加入等待队列\n若没有获取到锁, 则开始将线程加入等待队列addWaiter:\n```\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        //尾插法，尾部不为空\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n```\n首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。\n若目前还没有等待的节点, 那么构造等待队列:\n```\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            //初始化，只要没值，先把头和尾给初始化了再继续\n            if (t == null) { // Must initialize\n                //头部应该是空，这里要设置成new node()\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS1.png\" height=\"200\" width=\"250\"/>\n这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。\n#### 设置等待队列\n线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:\n```\n    //如果在整个等待过程中被中断过，则返回true，否则返回false。\n    final boolean acquireQueued(final Node node, int arg) {\n        //说明没有获取成功，退出时因为发生异常了\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) { //开始自旋\n                final Node p = node.predecessor(); //查找前继节点\n                //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node); //那么设置该节点为头结点,将该线程对应的节点清空,变成无状态的头\n                    p.next = null; // help GC 抛弃该节点，等待被回收\n                    failed = false;\n                    return interrupted;\n                } //说明没有获取到锁，是否需要睡眠等待\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                   //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的\n                   parkAndCheckInterrupt())\n                    //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)  //这里基本是执行不到的，除非遇到非运行时异常\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始`自旋`, 主要做了如下检查:\n+ 检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。\n+ 否则说明没有获取到锁, 那么检查该线程是否可以睡眠:\n```\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;//头结点，waitState默认为0\n        //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true; //那么本节点可以放心睡眠\n        //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev; //改变链路\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */ //\n             //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:\n1. 当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。\n2. 若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。\n3. 若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。\n在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS2.png\" height=\"200\" width=\"250\"/>\n\n有个问题: 这里为啥在else那里不直接可以去睡眠呢?\n假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。\n+ 若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。\n```\n    private final boolean parkAndCheckInterrupt() {\n        //能否响应中断请求, 从等待中退出，但是不会抛出异常\n        LockSupport.park(this);\n        //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递\n        return Thread.interrupted();\n    }\n```\n这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。\n至此, 获取锁的过程已经全部完成, 整体过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS4.png\" height=\"260\" width=\"800\"/>\n要么获取到锁, 那么线程进入等待队列安心睡眠。\n### 释放锁\n释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两个事情:\n+ 尝试将状态复位, 比如status置为0, 排他线程置为null.\n```\n        protected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) { //释放的时候，把status给清0了\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。\n+ 若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:\n```\n      private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        //置零当前线程所在的结点状态，允许失败。\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        //节点被取消了，cancel 才大于1\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                //从后向前找，找到最近一个有效的节点\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null) //反正叫醒后继节点\n            LockSupport.unpark(s.thread);\n    }\n```\n唤醒后继节点也是比较简单的:\n1. 首先将本节点waitStatus置为0(初始值)\n2. 如果后继节点被取消了(waitStatus>0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。\n释放锁过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS5.png\" height=\"200\" width=\"450\"/>\n注意, 对阻塞队列的结构的修改都是被唤醒线程进行的, 释放锁的线程没有做这些操作\n### 总结\n线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。","source":"_posts/ReentrantLock源码解读.md","raw":"---\ntitle: ReentrantLock源码解读\ndate: 2017-07-23 19:47:30\ntags: ReentrantLock\ntoc: true\n---\nReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。\n基本使用如下:\n```\nReentrantLock lock = new ReentrantLock(true);\n//尝试获取锁,获取不到就阻塞\nlock.lock();\n......\n//释放锁,获取完了唤醒被阻塞的线程\nlock.unlock();\n```\n我们需要注意, 调用lock.lock()和lock.unlock()的线程必须是一个, lock.unlock()会对线程检查, 只有当调用lock.lock()的线程和本线程一致, 才可以解锁。可以看到, 是不是很像关键字synchronized的作用?\n# 简介\nAbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。\n## AbstractQueuedSynchronizer详解\n接下来将首先介绍两个重要的属性变量:\n`state`\nAbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了`volatile`关键字，这里没使用Synchronized来保证原子性的原因:\n+ state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。\n+ Synchronized实现互斥的成本要比volatile很高。\n`Node`\nAbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：\n```\n{\n     volatile int waitStatus;\n     volatile Node prev;\n     volatile Node next;\n     volatile Thread thread;\n     Node nextWaiter;\n\n}```\n\n|属性|介绍|\n|:-|:-|\n|waitStatus|当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态\n|prev|当前节点的前一个节点\n|next|当前节点的后继节点|\n|thread|当前节点所拥有的线程|\n|nextWaiter|表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。\nnextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS6.png\" height=\"200\" width=\"600\"/>\n上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。\n\nAQS中等待锁的线程队列与运行线程结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS.png\" height=\"250\" width=\"450\"/>\n### ReentrantLock详解\nReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。\n本文就以公平锁的获取与释放作为主线进行讲解。\n```\n    public static ReentrantLock lock = new ReentrantLock(true);\n    lock.lock()\n```\n这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值`1`的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。\n            selfInterrupt();\n    }\n```\n主要做了如下几个事情:\n+ 尝试去获取锁, 若获取到了, 就直接退出。\n+ 若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)\n### 尝试获取锁\n代码在FairSync中定义了:\n```\n        protected final boolean tryAcquire(int acquires) {\n             final Thread current = Thread.currentThread();\n            int c = getState();//首先读取state变量\n            if (c == 0) {\n                 ////判断sate值是否为0,在这里0就表示初始状态\n                if (!hasQueuedPredecessors() &&\n                    //采用CAS原子操作修改sate的值，\n                    compareAndSetState(0, acquires)) {\n                    //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            //当前线程就是抢占线程，那么是可以直接进入的\n            else if (current == getExclusiveOwnerThread()) {\n                //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            //否则就不能获取到，获取不到锁，但是不会改变state的值\n            return false;\n        }\n```\nFairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:\n1. 若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待\n2. 第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。\n3. 若当前线程获取不到锁, 是不会对status的值产生任何改变的。\n\n#### 加入等待队列\n若没有获取到锁, 则开始将线程加入等待队列addWaiter:\n```\n    private Node addWaiter(Node mode) {\n        Node node = new Node(Thread.currentThread(), mode);\n        // Try the fast path of enq; backup to full enq on failure\n        Node pred = tail;\n        //尾插法，尾部不为空\n        if (pred != null) {\n            node.prev = pred;\n            if (compareAndSetTail(pred, node)) {\n                pred.next = node;\n                return node;\n            }\n        }\n        enq(node);\n        return node;\n    }\n```\n首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。\n若目前还没有等待的节点, 那么构造等待队列:\n```\n    private Node enq(final Node node) {\n        for (;;) {\n            Node t = tail;\n            //初始化，只要没值，先把头和尾给初始化了再继续\n            if (t == null) { // Must initialize\n                //头部应该是空，这里要设置成new node()\n                if (compareAndSetHead(new Node()))\n                    tail = head;\n            } else {\n                node.prev = t;\n                //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node\n                if (compareAndSetTail(t, node)) {\n                    t.next = node;\n                    return t;\n                }\n            }\n        }\n    }\n```\n注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS1.png\" height=\"200\" width=\"250\"/>\n这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。\n#### 设置等待队列\n线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:\n```\n    //如果在整个等待过程中被中断过，则返回true，否则返回false。\n    final boolean acquireQueued(final Node node, int arg) {\n        //说明没有获取成功，退出时因为发生异常了\n        boolean failed = true;\n        try {\n            boolean interrupted = false;\n            for (;;) { //开始自旋\n                final Node p = node.predecessor(); //查找前继节点\n                //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去\n                if (p == head && tryAcquire(arg)) {\n                    setHead(node); //那么设置该节点为头结点,将该线程对应的节点清空,变成无状态的头\n                    p.next = null; // help GC 抛弃该节点，等待被回收\n                    failed = false;\n                    return interrupted;\n                } //说明没有获取到锁，是否需要睡眠等待\n                if (shouldParkAfterFailedAcquire(p, node) &&\n                   //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的\n                   parkAndCheckInterrupt())\n                    //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待\n                    interrupted = true;\n            }\n        } finally {\n            if (failed)  //这里基本是执行不到的，除非遇到非运行时异常\n                cancelAcquire(node);\n        }\n    }\n```\n注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始`自旋`, 主要做了如下检查:\n+ 检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。\n+ 否则说明没有获取到锁, 那么检查该线程是否可以睡眠:\n```\n    private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {\n        int ws = pred.waitStatus;//头结点，waitState默认为0\n        //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点\n        if (ws == Node.SIGNAL)\n            /*\n             * This node has already set status asking a release\n             * to signal it, so it can safely park.\n             */\n            return true; //那么本节点可以放心睡眠\n        //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃\n        if (ws > 0) {\n            /*\n             * Predecessor was cancelled. Skip over predecessors and\n             * indicate retry.\n             */\n            do {\n                node.prev = pred = pred.prev; //改变链路\n            } while (pred.waitStatus > 0);\n            pred.next = node;\n        } else {\n            /*\n             * waitStatus must be 0 or PROPAGATE.  Indicate that we\n             * need a signal, but don't park yet.  Caller will need to\n             * retry to make sure it cannot acquire before parking.\n             */ //\n             //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知\n            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);\n        }\n        return false;\n    }\n```\n这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:\n1. 当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。\n2. 若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。\n3. 若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。\n在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS2.png\" height=\"200\" width=\"250\"/>\n\n有个问题: 这里为啥在else那里不直接可以去睡眠呢?\n假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。\n+ 若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。\n```\n    private final boolean parkAndCheckInterrupt() {\n        //能否响应中断请求, 从等待中退出，但是不会抛出异常\n        LockSupport.park(this);\n        //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递\n        return Thread.interrupted();\n    }\n```\n这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。\n至此, 获取锁的过程已经全部完成, 整体过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS4.png\" height=\"260\" width=\"800\"/>\n要么获取到锁, 那么线程进入等待队列安心睡眠。\n### 释放锁\n释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两个事情:\n+ 尝试将状态复位, 比如status置为0, 排他线程置为null.\n```\n        protected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) { //释放的时候，把status给清0了\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n```\n这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。\n+ 若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:\n```\n      private void unparkSuccessor(Node node) {\n        /*\n         * If status is negative (i.e., possibly needing signal) try\n         * to clear in anticipation of signalling.  It is OK if this\n         * fails or if status is changed by waiting thread.\n         */\n        int ws = node.waitStatus;\n        //置零当前线程所在的结点状态，允许失败。\n        if (ws < 0)\n            compareAndSetWaitStatus(node, ws, 0);\n        /*\n         * Thread to unpark is held in successor, which is normally\n         * just the next node.  But if cancelled or apparently null,\n         * traverse backwards from tail to find the actual\n         * non-cancelled successor.\n         */\n        Node s = node.next;\n        //节点被取消了，cancel 才大于1\n        if (s == null || s.waitStatus > 0) {\n            s = null;\n            for (Node t = tail; t != null && t != node; t = t.prev)\n                //从后向前找，找到最近一个有效的节点\n                if (t.waitStatus <= 0)\n                    s = t;\n        }\n        if (s != null) //反正叫醒后继节点\n            LockSupport.unpark(s.thread);\n    }\n```\n唤醒后继节点也是比较简单的:\n1. 首先将本节点waitStatus置为0(初始值)\n2. 如果后继节点被取消了(waitStatus>0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。\n释放锁过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS5.png\" height=\"200\" width=\"450\"/>\n注意, 对阻塞队列的结构的修改都是被唤醒线程进行的, 释放锁的线程没有做这些操作\n### 总结\n线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。","slug":"ReentrantLock源码解读","published":1,"updated":"2019-06-22T09:10:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xe000xphu597mpfbfj","content":"<p>ReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">//尝试获取锁,获取不到就阻塞</div><div class=\"line\">lock.lock();</div><div class=\"line\">......</div><div class=\"line\">//释放锁,获取完了唤醒被阻塞的线程</div><div class=\"line\">lock.unlock();</div></pre></td></tr></table></figure></p>\n<p>我们需要注意, 调用lock.lock()和lock.unlock()的线程必须是一个, lock.unlock()会对线程检查, 只有当调用lock.lock()的线程和本线程一致, 才可以解锁。可以看到, 是不是很像关键字synchronized的作用?</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>AbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。</p>\n<h2 id=\"AbstractQueuedSynchronizer详解\"><a href=\"#AbstractQueuedSynchronizer详解\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer详解\"></a>AbstractQueuedSynchronizer详解</h2><p>接下来将首先介绍两个重要的属性变量:<br><code>state</code><br>AbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了<code>volatile</code>关键字，这里没使用Synchronized来保证原子性的原因:</p>\n<ul>\n<li>state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。</li>\n<li>Synchronized实现互斥的成本要比volatile很高。<br><code>Node</code><br>AbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     volatile int waitStatus;</div><div class=\"line\">     volatile Node prev;</div><div class=\"line\">     volatile Node next;</div><div class=\"line\">     volatile Thread thread;</div><div class=\"line\">     Node nextWaiter;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">waitStatus</td>\n<td style=\"text-align:left\">当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prev</td>\n<td style=\"text-align:left\">当前节点的前一个节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">当前节点的后继节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">当前节点所拥有的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nextWaiter</td>\n<td style=\"text-align:left\">表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。</td>\n</tr>\n</tbody>\n</table>\n<p>nextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS6.png\" height=\"200\" width=\"600\"><br>上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。</p>\n<p>AQS中等待锁的线程队列与运行线程结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS.png\" height=\"250\" width=\"450\"></p>\n<h3 id=\"ReentrantLock详解\"><a href=\"#ReentrantLock详解\" class=\"headerlink\" title=\"ReentrantLock详解\"></a>ReentrantLock详解</h3><p>ReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。<br>本文就以公平锁的获取与释放作为主线进行讲解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">lock.lock()</div></pre></td></tr></table></figure></p>\n<p>这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值<code>1</code>的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几个事情:</p>\n<ul>\n<li>尝试去获取锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁\"></a>尝试获取锁</h3>代码在FairSync中定义了:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">     final Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();//首先读取state变量</div><div class=\"line\">    if (c == 0) &#123;</div><div class=\"line\">         ////判断sate值是否为0,在这里0就表示初始状态</div><div class=\"line\">        if (!hasQueuedPredecessors() &amp;&amp;</div><div class=\"line\">            //采用CAS原子操作修改sate的值，</div><div class=\"line\">            compareAndSetState(0, acquires)) &#123;</div><div class=\"line\">            //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程</div><div class=\"line\">            setExclusiveOwnerThread(current);</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //当前线程就是抢占线程，那么是可以直接进入的</div><div class=\"line\">    else if (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">        //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放</div><div class=\"line\">        int nextc = c + acquires;</div><div class=\"line\">        if (nextc &lt; 0)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        setState(nextc);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //否则就不能获取到，获取不到锁，但是不会改变state的值</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>FairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:</p>\n<ol>\n<li>若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待</li>\n<li>第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。</li>\n<li>若当前线程获取不到锁, 是不会对status的值产生任何改变的。</li>\n</ol>\n<h4 id=\"加入等待队列\"><a href=\"#加入等待队列\" class=\"headerlink\" title=\"加入等待队列\"></a>加入等待队列</h4><p>若没有获取到锁, 则开始将线程加入等待队列addWaiter:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node addWaiter(Node mode) &#123;</div><div class=\"line\">    Node node = new Node(Thread.currentThread(), mode);</div><div class=\"line\">    // Try the fast path of enq; backup to full enq on failure</div><div class=\"line\">    Node pred = tail;</div><div class=\"line\">    //尾插法，尾部不为空</div><div class=\"line\">    if (pred != null) &#123;</div><div class=\"line\">        node.prev = pred;</div><div class=\"line\">        if (compareAndSetTail(pred, node)) &#123;</div><div class=\"line\">            pred.next = node;</div><div class=\"line\">            return node;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    enq(node);</div><div class=\"line\">    return node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。<br>若目前还没有等待的节点, 那么构造等待队列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node enq(final Node node) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node t = tail;</div><div class=\"line\">        //初始化，只要没值，先把头和尾给初始化了再继续</div><div class=\"line\">        if (t == null) &#123; // Must initialize</div><div class=\"line\">            //头部应该是空，这里要设置成new node()</div><div class=\"line\">            if (compareAndSetHead(new Node()))</div><div class=\"line\">                tail = head;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            node.prev = t;</div><div class=\"line\">            //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node</div><div class=\"line\">            if (compareAndSetTail(t, node)) &#123;</div><div class=\"line\">                t.next = node;</div><div class=\"line\">                return t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS1.png\" height=\"200\" width=\"250\"><br>这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。</p>\n<h4 id=\"设置等待队列\"><a href=\"#设置等待队列\" class=\"headerlink\" title=\"设置等待队列\"></a>设置等待队列</h4><p>线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如果在整个等待过程中被中断过，则返回true，否则返回false。</div><div class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class=\"line\">    //说明没有获取成功，退出时因为发生异常了</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        boolean interrupted = false;</div><div class=\"line\">        for (;;) &#123; //开始自旋</div><div class=\"line\">            final Node p = node.predecessor(); //查找前继节点</div><div class=\"line\">            //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去</div><div class=\"line\">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class=\"line\">                setHead(node); //那么设置该节点为头结点,将该线程对应的节点清空,变成无状态的头</div><div class=\"line\">                p.next = null; // help GC 抛弃该节点，等待被回收</div><div class=\"line\">                failed = false;</div><div class=\"line\">                return interrupted;</div><div class=\"line\">            &#125; //说明没有获取到锁，是否需要睡眠等待</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">               //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的</div><div class=\"line\">               parkAndCheckInterrupt())</div><div class=\"line\">                //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待</div><div class=\"line\">                interrupted = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)  //这里基本是执行不到的，除非遇到非运行时异常</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始<code>自旋</code>, 主要做了如下检查:</p>\n<ul>\n<li>检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。</li>\n<li>否则说明没有获取到锁, 那么检查该线程是否可以睡眠:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class=\"line\">    int ws = pred.waitStatus;//头结点，waitState默认为0</div><div class=\"line\">    //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点</div><div class=\"line\">    if (ws == Node.SIGNAL)</div><div class=\"line\">        /*</div><div class=\"line\">         * This node has already set status asking a release</div><div class=\"line\">         * to signal it, so it can safely park.</div><div class=\"line\">         */</div><div class=\"line\">        return true; //那么本节点可以放心睡眠</div><div class=\"line\">    //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃</div><div class=\"line\">    if (ws &gt; 0) &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * Predecessor was cancelled. Skip over predecessors and</div><div class=\"line\">         * indicate retry.</div><div class=\"line\">         */</div><div class=\"line\">        do &#123;</div><div class=\"line\">            node.prev = pred = pred.prev; //改变链路</div><div class=\"line\">        &#125; while (pred.waitStatus &gt; 0);</div><div class=\"line\">        pred.next = node;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class=\"line\">         * need a signal, but don&apos;t park yet.  Caller will need to</div><div class=\"line\">         * retry to make sure it cannot acquire before parking.</div><div class=\"line\">         */ //</div><div class=\"line\">         //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知</div><div class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:</p>\n<ol>\n<li>当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。</li>\n<li>若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。</li>\n<li>若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。<br>在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS2.png\" height=\"200\" width=\"250\"></li>\n</ol>\n<p>有个问题: 这里为啥在else那里不直接可以去睡眠呢?<br>假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。</p>\n<ul>\n<li>若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</div><div class=\"line\">    //能否响应中断请求, 从等待中退出，但是不会抛出异常</div><div class=\"line\">    LockSupport.park(this);</div><div class=\"line\">    //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递</div><div class=\"line\">    return Thread.interrupted();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。<br>至此, 获取锁的过程已经全部完成, 整体过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS4.png\" height=\"260\" width=\"800\"><br>要么获取到锁, 那么线程进入等待队列安心睡眠。</p>\n<h3 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h3><p>释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了两个事情:</p>\n<ul>\n<li>尝试将状态复位, 比如status置为0, 排他线程置为null.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryRelease(int releases) &#123;</div><div class=\"line\">    int c = getState() - releases;</div><div class=\"line\">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class=\"line\">        throw new IllegalMonitorStateException();</div><div class=\"line\">    boolean free = false;</div><div class=\"line\">    if (c == 0) &#123; //释放的时候，把status给清0了</div><div class=\"line\">        free = true;</div><div class=\"line\">        setExclusiveOwnerThread(null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    setState(c);</div><div class=\"line\">    return free;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。</p>\n<ul>\n<li>若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">  private void unparkSuccessor(Node node) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * If status is negative (i.e., possibly needing signal) try</div><div class=\"line\">     * to clear in anticipation of signalling.  It is OK if this</div><div class=\"line\">     * fails or if status is changed by waiting thread.</div><div class=\"line\">     */</div><div class=\"line\">    int ws = node.waitStatus;</div><div class=\"line\">    //置零当前线程所在的结点状态，允许失败。</div><div class=\"line\">    if (ws &lt; 0)</div><div class=\"line\">        compareAndSetWaitStatus(node, ws, 0);</div><div class=\"line\">    /*</div><div class=\"line\">     * Thread to unpark is held in successor, which is normally</div><div class=\"line\">     * just the next node.  But if cancelled or apparently null,</div><div class=\"line\">     * traverse backwards from tail to find the actual</div><div class=\"line\">     * non-cancelled successor.</div><div class=\"line\">     */</div><div class=\"line\">    Node s = node.next;</div><div class=\"line\">    //节点被取消了，cancel 才大于1</div><div class=\"line\">    if (s == null || s.waitStatus &gt; 0) &#123;</div><div class=\"line\">        s = null;</div><div class=\"line\">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</div><div class=\"line\">            //从后向前找，找到最近一个有效的节点</div><div class=\"line\">            if (t.waitStatus &lt;= 0)</div><div class=\"line\">                s = t;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (s != null) //反正叫醒后继节点</div><div class=\"line\">        LockSupport.unpark(s.thread);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>唤醒后继节点也是比较简单的:</p>\n<ol>\n<li>首先将本节点waitStatus置为0(初始值)</li>\n<li>如果后继节点被取消了(waitStatus&gt;0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。<br>释放锁过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS5.png\" height=\"200\" width=\"450\"><br>注意, 对阻塞队列的结构的修改都是被唤醒线程进行的, 释放锁的线程没有做这些操作<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>ReentrantLock作为线程之间相互通信的工具, 在实际项目中较多的被使用到, 了解ReentrantLock, 就不得不提AbstractQueuedSynchronizer(AQS), 本文章将对这两个类展开详述。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">//尝试获取锁,获取不到就阻塞</div><div class=\"line\">lock.lock();</div><div class=\"line\">......</div><div class=\"line\">//释放锁,获取完了唤醒被阻塞的线程</div><div class=\"line\">lock.unlock();</div></pre></td></tr></table></figure></p>\n<p>我们需要注意, 调用lock.lock()和lock.unlock()的线程必须是一个, lock.unlock()会对线程检查, 只有当调用lock.lock()的线程和本线程一致, 才可以解锁。可以看到, 是不是很像关键字synchronized的作用?</p>\n<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>AbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义, 在CountDownLatch、Semaphore都可以看到该类的实现。</p>\n<h2 id=\"AbstractQueuedSynchronizer详解\"><a href=\"#AbstractQueuedSynchronizer详解\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer详解\"></a>AbstractQueuedSynchronizer详解</h2><p>接下来将首先介绍两个重要的属性变量:<br><code>state</code><br>AbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义。 在多线程针对state的操作，必须保证state状态的原子性，使用了<code>volatile</code>关键字，这里没使用Synchronized来保证原子性的原因:</p>\n<ul>\n<li>state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。</li>\n<li>Synchronized实现互斥的成本要比volatile很高。<br><code>Node</code><br>AbstractQueuedSynchronizer实现了FIFO队列，该队列存放着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     volatile int waitStatus;</div><div class=\"line\">     volatile Node prev;</div><div class=\"line\">     volatile Node next;</div><div class=\"line\">     volatile Thread thread;</div><div class=\"line\">     Node nextWaiter;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">waitStatus</td>\n<td style=\"text-align:left\">当前节点的状态:<br>CANCELLED:当前线程取消执行, 值为1，<br>SIGNAL:当该节点释放锁的时候,需要唤醒后继节点, 值为-1<br>CONDITION:当前节点在等待某种condition发生, 值为-2<br>PROPAGATE: 当前节点主要共享锁, 当节点设置为该值, 那么无条件向后传递锁释放的的信号, 值为-3<br>0: 表示初始状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prev</td>\n<td style=\"text-align:left\">当前节点的前一个节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">当前节点的后继节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">当前节点所拥有的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nextWaiter</td>\n<td style=\"text-align:left\">表明本线程和下游公用一个获取获取锁的信号, 该线程被唤醒后, 该线程?又顺便把下一个节点也唤醒, 比如CountDownLatch中, 上游把锁释放了, 会向后继续传递释放锁的信号。</td>\n</tr>\n</tbody>\n</table>\n<p>nextWaiter=signal与waitStatus=shared的区别是: waitStatus=signal主要体现在线程主动调用释放锁操作unlock()后, 去唤醒等待队列中第一个线程。 waitStatus=shared体现在, 若当前线程尝试获取锁被阻塞后, 被别的线程唤醒后, 当前线程把获取锁的信号向后传递, 也去主动唤醒阻塞的线程。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS6.png\" height=\"200\" width=\"600\"><br>上图可知, 当share时, 线程在获取锁后, 首先唤醒下一个线程再继续run运行; 而signal时, 线程在获取锁后, 首先运行, 在run运行中, 通过主动调用unlock()来唤醒下一个阻塞的线程。</p>\n<p>AQS中等待锁的线程队列与运行线程结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS.png\" height=\"250\" width=\"450\"></p>\n<h3 id=\"ReentrantLock详解\"><a href=\"#ReentrantLock详解\" class=\"headerlink\" title=\"ReentrantLock详解\"></a>ReentrantLock详解</h3><p>ReentrantLock作为可重入的独享锁, 分为两类, 公平锁FairSync和非公平锁NonfairSync, 公平的体现在于: 当已经有线程处于等待状态时(等待队列不为空), 新来需要获取锁的线程能否可能插队先获取锁, 可以的话, 就是非公平锁; 不能立马获取到锁, 而必须排队的就是公平锁。<br>本文就以公平锁的获取与释放作为主线进行讲解。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static ReentrantLock lock = new ReentrantLock(true);</div><div class=\"line\">lock.lock()</div></pre></td></tr></table></figure></p>\n<p>这样开始尝试获取锁, 实际调用的FairSync.acquire(1), 这里取值<code>1</code>的含义可以理解为尝试将state状态从0设置为1, 当status状态为0时, 说明是没有锁的。 真正调用的是AbstractQueuedSynchronizer函数的acquire:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        //说明本次退出中间有线程调用过thread.interrput(), 这里将中断信号复原。</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几个事情:</p>\n<ul>\n<li>尝试去获取锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。(parkAndCheckInterrup()把中断信号清掉了)<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁\"></a>尝试获取锁</h3>代码在FairSync中定义了:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">     final Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();//首先读取state变量</div><div class=\"line\">    if (c == 0) &#123;</div><div class=\"line\">         ////判断sate值是否为0,在这里0就表示初始状态</div><div class=\"line\">        if (!hasQueuedPredecessors() &amp;&amp;</div><div class=\"line\">            //采用CAS原子操作修改sate的值，</div><div class=\"line\">            compareAndSetState(0, acquires)) &#123;</div><div class=\"line\">            //如果修改成功，则将AQS的执行者设置为currentThread；这里的执行者其实就是获得执行权的线程</div><div class=\"line\">            setExclusiveOwnerThread(current);</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //当前线程就是抢占线程，那么是可以直接进入的</div><div class=\"line\">    else if (current == getExclusiveOwnerThread()) &#123;</div><div class=\"line\">        //注意这里，会+acquires，可重入式的，每次都得释放，不然锁就不会释放</div><div class=\"line\">        int nextc = c + acquires;</div><div class=\"line\">        if (nextc &lt; 0)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        setState(nextc);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //否则就不能获取到，获取不到锁，但是不会改变state的值</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>FairSync尝试获取锁的过程比较简单: 若status为0, 那么说明锁还没有被使用, 可以获取返回true, 否则就返回false, 我们需要注意的几个地方:</p>\n<ol>\n<li>若status为0, 这里会进行hasQueuedPredecessors()判断, 只有等待队列中没有节点, 才能立刻获取到, 这里可以体现公平锁FIFO的属性, 只要有线程处于等待队里, 那么该节点就该去等待</li>\n<li>第二个条件体现了可重入锁的性质, 只要获取锁的线程就是当前线程, 那么该线程照样可以获取到, 只是将state增加了。 同时说明, 同一线程两次调用lock.lock(), 那么一定需要两次lock.unlock()进行解锁才行。</li>\n<li>若当前线程获取不到锁, 是不会对status的值产生任何改变的。</li>\n</ol>\n<h4 id=\"加入等待队列\"><a href=\"#加入等待队列\" class=\"headerlink\" title=\"加入等待队列\"></a>加入等待队列</h4><p>若没有获取到锁, 则开始将线程加入等待队列addWaiter:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node addWaiter(Node mode) &#123;</div><div class=\"line\">    Node node = new Node(Thread.currentThread(), mode);</div><div class=\"line\">    // Try the fast path of enq; backup to full enq on failure</div><div class=\"line\">    Node pred = tail;</div><div class=\"line\">    //尾插法，尾部不为空</div><div class=\"line\">    if (pred != null) &#123;</div><div class=\"line\">        node.prev = pred;</div><div class=\"line\">        if (compareAndSetTail(pred, node)) &#123;</div><div class=\"line\">            pred.next = node;</div><div class=\"line\">            return node;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    enq(node);</div><div class=\"line\">    return node;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先将当前线程作为参数构造等待节点Node, 传递的mode为EXCLUSIVE, 然后进行尾插法, 若等待队列不为空, 通过compareAndSetTail()原子操作将当前节点node设置为tail节点。<br>若目前还没有等待的节点, 那么构造等待队列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private Node enq(final Node node) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        Node t = tail;</div><div class=\"line\">        //初始化，只要没值，先把头和尾给初始化了再继续</div><div class=\"line\">        if (t == null) &#123; // Must initialize</div><div class=\"line\">            //头部应该是空，这里要设置成new node()</div><div class=\"line\">            if (compareAndSetHead(new Node()))</div><div class=\"line\">                tail = head;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            node.prev = t;</div><div class=\"line\">            //尾部目前应该是t,然后尾部设置为node，里面尾部tail已经设置指向了node</div><div class=\"line\">            if (compareAndSetTail(t, node)) &#123;</div><div class=\"line\">                t.next = node;</div><div class=\"line\">                return t;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意这里for()死循环, 直到当前节点构建出来了等待队列才会退出, 否则不停地重试(重试的原因是可能其他线程也在构造或者向等待线程插入节点, 允许操作失败), 构建完成后, 等待队列如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS1.png\" height=\"200\" width=\"250\"><br>这里需要注意的是, 最开始的的时候, 会虚构出来了一个Node()作为head节点, 可以理解代表着当前拥有锁的那个线程对应的节点。</p>\n<h4 id=\"设置等待队列\"><a href=\"#设置等待队列\" class=\"headerlink\" title=\"设置等待队列\"></a>设置等待队列</h4><p>线程加入等待队列后, 是不能够立马跑去睡眠的, 还需要检查等待队列前继节点是否符合要求, 只有当前继节点waitState为SIGNAL, 那么本节点才可以去睡觉:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">//如果在整个等待过程中被中断过，则返回true，否则返回false。</div><div class=\"line\">final boolean acquireQueued(final Node node, int arg) &#123;</div><div class=\"line\">    //说明没有获取成功，退出时因为发生异常了</div><div class=\"line\">    boolean failed = true;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        boolean interrupted = false;</div><div class=\"line\">        for (;;) &#123; //开始自旋</div><div class=\"line\">            final Node p = node.predecessor(); //查找前继节点</div><div class=\"line\">            //该节点前节点是头结点，并且获取到了锁,只要不满足这个条件，该节点将一直阻塞下去</div><div class=\"line\">            if (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class=\"line\">                setHead(node); //那么设置该节点为头结点,将该线程对应的节点清空,变成无状态的头</div><div class=\"line\">                p.next = null; // help GC 抛弃该节点，等待被回收</div><div class=\"line\">                failed = false;</div><div class=\"line\">                return interrupted;</div><div class=\"line\">            &#125; //说明没有获取到锁，是否需要睡眠等待</div><div class=\"line\">            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class=\"line\">               //等待又唤醒，可能是别人调用了LockSupport.unlock()，也有可能别人调用了thread.interrupt()唤醒的</div><div class=\"line\">               parkAndCheckInterrupt())</div><div class=\"line\">                //如果因为是被别人用thread.interrupt()唤醒的话，并不会退出并继续等待</div><div class=\"line\">                interrupted = true;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (failed)  //这里基本是执行不到的，除非遇到非运行时异常</div><div class=\"line\">            cancelAcquire(node);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>注意该函数中p.next = null操作, 此时p已经从等待队列链中完全脱离了, 该节点就可以等待gc回收了。 该线程开始<code>自旋</code>, 主要做了如下检查:</p>\n<ul>\n<li>检查前继节点是否是head, 尝试获取锁(此时statue为0) ,若能够获取到锁, 说明头结点已经对应的那个线程已经释放了锁, 本节点又是作为等待队列排在最前面那个节点(head节点指向了释放锁那个线程), 直接获取锁。</li>\n<li>否则说明没有获取到锁, 那么检查该线程是否可以睡眠:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123;</div><div class=\"line\">    int ws = pred.waitStatus;//头结点，waitState默认为0</div><div class=\"line\">    //前驱节点为消息通知模式，当释放锁或者取消时，会通知下个节点</div><div class=\"line\">    if (ws == Node.SIGNAL)</div><div class=\"line\">        /*</div><div class=\"line\">         * This node has already set status asking a release</div><div class=\"line\">         * to signal it, so it can safely park.</div><div class=\"line\">         */</div><div class=\"line\">        return true; //那么本节点可以放心睡眠</div><div class=\"line\">    //前节点被取消了，自己加塞到前面，前继节点被无引用了，过会就会被丢弃</div><div class=\"line\">    if (ws &gt; 0) &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * Predecessor was cancelled. Skip over predecessors and</div><div class=\"line\">         * indicate retry.</div><div class=\"line\">         */</div><div class=\"line\">        do &#123;</div><div class=\"line\">            node.prev = pred = pred.prev; //改变链路</div><div class=\"line\">        &#125; while (pred.waitStatus &gt; 0);</div><div class=\"line\">        pred.next = node;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        /*</div><div class=\"line\">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</div><div class=\"line\">         * need a signal, but don&apos;t park yet.  Caller will need to</div><div class=\"line\">         * retry to make sure it cannot acquire before parking.</div><div class=\"line\">         */ //</div><div class=\"line\">         //若是非cancel和非signal(比如任何节点加入时， statue都是0，等待后继节点改变)，将前节点设置为通知信号，等待被通知</div><div class=\"line\">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里主要检查前继节点的waitStatus字段, 最前面介绍node时对取值也有详细的介绍:</p>\n<ol>\n<li>当前继节点为SIGNAL, 那么说明本节点可以放心去睡眠了, 因为前继节点的线程释放锁的时候, 会通过LockSupport.unlock()唤醒。</li>\n<li>若前继节点为cancel状态, 那么向前找, 直到找到一个不为cancel的节点, 并将为cancel的节点从整个等待队列中去掉, 以便gc回收。</li>\n<li>若找到一个非signal、非cancel的前继节点, 将该前继续节点状态置为signal, 以便前继节点唤醒后继节点。<br>在释放节点时(release()), 只要当前状态不为0, 就会唤醒后继节点。此时等待队列如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS2.png\" height=\"200\" width=\"250\"></li>\n</ol>\n<p>有个问题: 这里为啥在else那里不直接可以去睡眠呢?<br>假如前继节点释放锁的时候，此时发现自己不为SIGNAL，那么就不唤醒后继节点， 此时后继节点将自己设置为了SIGNAL， 那么此时设置也是无用的，形成了死等待。 所以自己在睡眠之前，再去检查下前继节点是否已经释放了锁，若释放了锁，就直接执行，没有释放锁，才能安慰睡觉。</p>\n<ul>\n<li>若可以睡眠了, 那么线程就通过LockSupport.park(this)进入睡眠。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">private final boolean parkAndCheckInterrupt() &#123;</div><div class=\"line\">    //能否响应中断请求, 从等待中退出，但是不会抛出异常</div><div class=\"line\">    LockSupport.park(this);</div><div class=\"line\">    //检测当前线程是否有中断，若有中断, 那么清空中断,把信号向外传递</div><div class=\"line\">    return Thread.interrupted();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里我们需要知道, 该线程从睡眠中被唤醒, 有可能是通过LockSupport.unpark(this)、也有可能是通过thread.interrupt()方式唤醒的, 第一种唤醒是有意义的, 对于第二种唤醒并没有意义,我们在acquireQueued中自旋时会忽略这种情况。<br>至此, 获取锁的过程已经全部完成, 整体过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS4.png\" height=\"260\" width=\"800\"><br>要么获取到锁, 那么线程进入等待队列安心睡眠。</p>\n<h3 id=\"释放锁\"><a href=\"#释放锁\" class=\"headerlink\" title=\"释放锁\"></a>释放锁</h3><p>释放锁只需要调用sync.release(1)就行了, 实际调用的AbstractQueuedSynchronizer里面的函数:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了两个事情:</p>\n<ul>\n<li>尝试将状态复位, 比如status置为0, 排他线程置为null.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryRelease(int releases) &#123;</div><div class=\"line\">    int c = getState() - releases;</div><div class=\"line\">    if (Thread.currentThread() != getExclusiveOwnerThread())</div><div class=\"line\">        throw new IllegalMonitorStateException();</div><div class=\"line\">    boolean free = false;</div><div class=\"line\">    if (c == 0) &#123; //释放的时候，把status给清0了</div><div class=\"line\">        free = true;</div><div class=\"line\">        setExclusiveOwnerThread(null);</div><div class=\"line\">    &#125;</div><div class=\"line\">    setState(c);</div><div class=\"line\">    return free;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这里实现有个需要注意的地方, ReentrantLock释放了, c为啥不为0, 因为ReentrantLock支持锁的可重入, 允许同一个线程两次获取锁。</p>\n<ul>\n<li>若等待队列有节点, 并且当前节点不为0(初始化), 那么就会去尝试唤醒后继一个有效的节点:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">  private void unparkSuccessor(Node node) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * If status is negative (i.e., possibly needing signal) try</div><div class=\"line\">     * to clear in anticipation of signalling.  It is OK if this</div><div class=\"line\">     * fails or if status is changed by waiting thread.</div><div class=\"line\">     */</div><div class=\"line\">    int ws = node.waitStatus;</div><div class=\"line\">    //置零当前线程所在的结点状态，允许失败。</div><div class=\"line\">    if (ws &lt; 0)</div><div class=\"line\">        compareAndSetWaitStatus(node, ws, 0);</div><div class=\"line\">    /*</div><div class=\"line\">     * Thread to unpark is held in successor, which is normally</div><div class=\"line\">     * just the next node.  But if cancelled or apparently null,</div><div class=\"line\">     * traverse backwards from tail to find the actual</div><div class=\"line\">     * non-cancelled successor.</div><div class=\"line\">     */</div><div class=\"line\">    Node s = node.next;</div><div class=\"line\">    //节点被取消了，cancel 才大于1</div><div class=\"line\">    if (s == null || s.waitStatus &gt; 0) &#123;</div><div class=\"line\">        s = null;</div><div class=\"line\">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</div><div class=\"line\">            //从后向前找，找到最近一个有效的节点</div><div class=\"line\">            if (t.waitStatus &lt;= 0)</div><div class=\"line\">                s = t;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (s != null) //反正叫醒后继节点</div><div class=\"line\">        LockSupport.unpark(s.thread);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>唤醒后继节点也是比较简单的:</p>\n<ol>\n<li>首先将本节点waitStatus置为0(初始值)</li>\n<li>如果后继节点被取消了(waitStatus&gt;0), 那么在后继节点中找到一个最靠近的、非cancel状态的节点, 然后唤醒这个节点上的线程。 这里不用将cancel状态的节点从队列中去掉, 在节点尝试获取锁的时候会自动干这个事。<br>释放锁过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/AQS5.png\" height=\"200\" width=\"450\"><br>注意, 对阻塞队列的结构的修改都是被唤醒线程进行的, 释放锁的线程没有做这些操作<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3>线程在获取锁的时候, 主要根据ReentrantLock里面的状态status来识别是否可以获取锁, 若为0, 那么锁未被获取; 若为1, 说明锁被一个线程获取; 若大于1, 说明发生了线程重入。 若没有获取到, 则将自己加入等待队列, 然后睡眠。 线程在释放锁时, 也会唤醒等待队列排在前面的线程。</li>\n</ol>\n"},{"title":"Semaphore源码分析","date":"2017-08-15T09:56:32.000Z","toc":true,"_content":"Semaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\n基本使用如下:\n```\nSemaphore semp = new Semaphore(2, fasle);\n//若被别的线程通过中断唤醒了, 那么就直接抛出异常\npublic void acquire();\n//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出\npublic void acquireUninterruptibly()\n//尝试获取锁, 若获取不到就直接退出\npublic boolean tryAcquire()\n//再unit内等待获取锁, 获取不到就直接抛出异常\npublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n\n//释放一个锁。\npublic void release()\n```\nSemaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数\n|锁类型|介绍|\n|:-|:-|\n|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|\n|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|\n|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|\n|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|\n# acquire获取过程\n锁获取与其他几个AQS获取过程一样:\n```\n     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n            //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n+ 首先该线程是否有中断信号, 若有的话,直接退出\n+ 尝试获取锁, 若获取到了, 那么就回退\n+ 否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。\n唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。\n```\n        protected int tryAcquireShared(int acquires) {\n            for (;;) {\n                if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长\n                    return -1;\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n```\n示例展示的是公平锁锁, 做了如下检查:\n+ 检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)\n+ 若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。\n我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。\n\n# 释放锁release\n释放锁会调用releaseShared:\n```\n    public final boolean releaseShared(int arg) {\n         //如果status彻底为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。\n\n# 总结\nSemaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。\n","source":"_posts/Semaphore源码解读.md","raw":"---\ntitle: Semaphore源码分析\ndate: 2017-08-15 17:56:32\ntags:\ntoc: true\n---\nSemaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。\n基本使用如下:\n```\nSemaphore semp = new Semaphore(2, fasle);\n//若被别的线程通过中断唤醒了, 那么就直接抛出异常\npublic void acquire();\n//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出\npublic void acquireUninterruptibly()\n//尝试获取锁, 若获取不到就直接退出\npublic boolean tryAcquire()\n//再unit内等待获取锁, 获取不到就直接抛出异常\npublic boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException\n\n//释放一个锁。\npublic void release()\n```\nSemaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数\n|锁类型|介绍|\n|:-|:-|\n|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|\n|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|\n|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|\n|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|\n# acquire获取过程\n锁获取与其他几个AQS获取过程一样:\n```\n     public final void acquireSharedInterruptibly(int arg) throws InterruptedException {\n        if (Thread.interrupted())\n            throw new InterruptedException();\n            //如果为0， 就说明获取到了，不为0， 则说明没有获取到\n        if (tryAcquireShared(arg) < 0)\n            doAcquireSharedInterruptibly(arg);\n    }\n```\n+ 首先该线程是否有中断信号, 若有的话,直接退出\n+ 尝试获取锁, 若获取到了, 那么就回退\n+ 否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。\n唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。\n```\n        protected int tryAcquireShared(int acquires) {\n            for (;;) {\n                if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长\n                    return -1;\n                int available = getState();\n                int remaining = available - acquires;\n                if (remaining < 0 ||\n                    compareAndSetState(available, remaining))\n                    return remaining;\n            }\n        }\n```\n示例展示的是公平锁锁, 做了如下检查:\n+ 检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)\n+ 若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。\n我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。\n\n# 释放锁release\n释放锁会调用releaseShared:\n```\n    public final boolean releaseShared(int arg) {\n         //如果status彻底为0， 那么就说明可以唤醒await()了\n        if (tryReleaseShared(arg)) {\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。\n\n# 总结\nSemaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。\n","slug":"Semaphore源码解读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xh0010phu58g9ixjdn","content":"<p>Semaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Semaphore semp = new Semaphore(2, fasle);</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么就直接抛出异常</div><div class=\"line\">public void acquire();</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出</div><div class=\"line\">public void acquireUninterruptibly()</div><div class=\"line\">//尝试获取锁, 若获取不到就直接退出</div><div class=\"line\">public boolean tryAcquire()</div><div class=\"line\">//再unit内等待获取锁, 获取不到就直接抛出异常</div><div class=\"line\">public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</div><div class=\"line\"></div><div class=\"line\">//释放一个锁。</div><div class=\"line\">public void release()</div></pre></td></tr></table></figure></p>\n<p>Semaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数<br>|锁类型|介绍|<br>|:-|:-|<br>|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|<br>|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|<br>|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|<br>|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|</p>\n<h1 id=\"acquire获取过程\"><a href=\"#acquire获取过程\" class=\"headerlink\" title=\"acquire获取过程\"></a>acquire获取过程</h1><p>锁获取与其他几个AQS获取过程一样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">        //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先该线程是否有中断信号, 若有的话,直接退出</li>\n<li>尝试获取锁, 若获取到了, 那么就回退</li>\n<li>否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。<br>唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected int tryAcquireShared(int acquires) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长</div><div class=\"line\">            return -1;</div><div class=\"line\">        int available = getState();</div><div class=\"line\">        int remaining = available - acquires;</div><div class=\"line\">        if (remaining &lt; 0 ||</div><div class=\"line\">            compareAndSetState(available, remaining))</div><div class=\"line\">            return remaining;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例展示的是公平锁锁, 做了如下检查:</p>\n<ul>\n<li>检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)</li>\n<li>若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。<br>我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。</li>\n</ul>\n<h1 id=\"释放锁release\"><a href=\"#释放锁release\" class=\"headerlink\" title=\"释放锁release\"></a>释放锁release</h1><p>释放锁会调用releaseShared:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">     //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Semaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Semaphore信号量底层也是使用AQS(参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>)来进行锁的互斥。<br>基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Semaphore semp = new Semaphore(2, fasle);</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么就直接抛出异常</div><div class=\"line\">public void acquire();</div><div class=\"line\">//若被别的线程通过中断唤醒了, 那么将中断再放到本线程里退出</div><div class=\"line\">public void acquireUninterruptibly()</div><div class=\"line\">//尝试获取锁, 若获取不到就直接退出</div><div class=\"line\">public boolean tryAcquire()</div><div class=\"line\">//再unit内等待获取锁, 获取不到就直接抛出异常</div><div class=\"line\">public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException</div><div class=\"line\"></div><div class=\"line\">//释放一个锁。</div><div class=\"line\">public void release()</div></pre></td></tr></table></figure></p>\n<p>Semaphore构造函数中, 2代表获取锁的并发, false代表非公平锁。信号量Semaphore的用户是限制访问的并发, 最大只能两个线程获取锁, 别的线程线程获取时都只能等着。statue最大为2, 代表可剩余的锁个数<br>|锁类型|介绍|<br>|:-|:-|<br>|ReentrantLock|互斥可重入锁, 获取锁并发为1, 谁获取锁谁可以执行, 否则阻塞|<br>|CountDownLatch|共享锁, 类似n个钥匙一起才能打开一个锁, 打开之后会唤醒所有阻塞的线程再一起执行|<br>|ReentrantReadWriteLock|有读锁和写锁同时构成, 读锁之间共享锁, 写锁——读锁会互斥|<br>|Semaphore|并发控制所, 允许同时只有n个线程可以访问, 别的线程只能阻塞, 仅当一个线程释放锁才能唤醒另外一个阻塞的线程|</p>\n<h1 id=\"acquire获取过程\"><a href=\"#acquire获取过程\" class=\"headerlink\" title=\"acquire获取过程\"></a>acquire获取过程</h1><p>锁获取与其他几个AQS获取过程一样:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123;</div><div class=\"line\">    if (Thread.interrupted())</div><div class=\"line\">        throw new InterruptedException();</div><div class=\"line\">        //如果为0， 就说明获取到了，不为0， 则说明没有获取到</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireSharedInterruptibly(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先该线程是否有中断信号, 若有的话,直接退出</li>\n<li>尝试获取锁, 若获取到了, 那么就回退</li>\n<li>否则通过调用<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly()将自己加入等待队列。<br>唯一的区别就是Semaphore调用自己实现的tryAcquireShared来尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected int tryAcquireShared(int acquires) &#123;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        if (hasQueuedPredecessors()) //首先检查是否有别的线程比当前登的时间更长</div><div class=\"line\">            return -1;</div><div class=\"line\">        int available = getState();</div><div class=\"line\">        int remaining = available - acquires;</div><div class=\"line\">        if (remaining &lt; 0 ||</div><div class=\"line\">            compareAndSetState(available, remaining))</div><div class=\"line\">            return remaining;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>示例展示的是公平锁锁, 做了如下检查:</p>\n<ul>\n<li>检查是否已经有线程在排队, 若有的话, 那么获取锁失败(体现先来后到的原则)</li>\n<li>若没有线程在排队, 那么尝试获取acquires, 若state大于remaining个, 那么获取成果获取锁, 否则获取锁失败。<br>我们需要知道, Semaphore调用的doAcquireSharedInterruptibly来进入阻塞队列排队, 本身设置为SHRAD模式, 若别的线程将本线程唤醒后, 本线程也会把唤醒信号分享给后续阻塞线程, 然后大家一起去竞争锁。</li>\n</ul>\n<h1 id=\"释放锁release\"><a href=\"#释放锁release\" class=\"headerlink\" title=\"释放锁release\"></a>释放锁release</h1><p>释放锁会调用releaseShared:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">     //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123;</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在tryReleaseShared将锁还给state(默认+1), 使用了for(;;)为了一定的释放成功才可以退出, 释放成功了, 尝试去调用doReleaseShared(具体参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>)来继续唤醒新的head节点。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>Semaphore信号量可以限制并发访问的次数, 使用起来也比较简单; 也分公平锁和费公平锁, 与ReentrantLock讲解的概念一样。</p>\n"},{"title":"ReentrantReadWriteLock源码解读","date":"2017-07-27T22:18:19.000Z","toc":true,"_content":"首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:\n```\nReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n//获取读锁\nreadWriteLock.readLock().lock();\n//释放读锁\nreadWriteLock.readLock().unlock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n```\n根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:\n```\n    public ReentrantReadWriteLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n        readerLock = new ReadLock(this);\n        writerLock = new WriteLock(this);\n    }\n\n```\n这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。\n# 读锁\n## 获取读锁\n通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:\n```\n    public final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\n首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。\n### 尝试获取锁:\n```\n        protected final int tryAcquireShared(int unused) {\n            /*\n             * Walkthrough:\n             * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队\n             * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到\n             *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁\n             *    because of queue policy. If not, try\n             *    to grant by CASing state and updating count.\n             *    Note that step does not check for reentrant\n             *    acquires, which is postponed to full version\n             *    to avoid having to check hold count in\n             *    the more typical non-reentrant case.\n             * 3. If step 2 fails either because thread\n             *    apparently not eligible or CAS fails or count\n             *    saturated, chain to version with full retry loop.\n             */\n            Thread current = Thread.currentThread();\n            int c = getState();\n            //同一个线程先写锁再读锁是可以获取锁的\n            if (exclusiveCount(c) != 0 &&\n                getExclusiveOwnerThread() != current)\n                 //当前获取写锁的线程不是本身\n                return -1;\n            int r = sharedCount(c);\n            //阻塞队列队列第一个不是写锁，\n            if (!readerShouldBlock() &&\n                r < MAX_COUNT &&\n                //会左移动16位\n                compareAndSetState(c, c + SHARED_UNIT)) {\n                if (r == 0) {//若是第一个读锁\n                    firstReader = current;\n                    firstReaderHoldCount = 1;\n                } else if (firstReader == current) {//就是本身线程\n                    firstReaderHoldCount++;\n                } else { //不是第一个获取读锁的线程\n                    HoldCounter rh = cachedHoldCounter;\n                    //上一个节点不存在，或者存在了不是自己的\n                    if (rh == null || rh.tid != getThreadId(current))\n                        //那就生成自己的，并且缓存起来\n                        cachedHoldCounter = rh = readHolds.get();\n                    else if (rh.count == 0) //若上一个获取的节点就是自己，\n                        readHolds.set(rh);\n                    rh.count++; //上一次获取锁+1\n                }\n                return 1;\n            }\n            //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）\n            return fullTryAcquireShared(current);\n        }\n```\n做了做了如下事情:\n+ 首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败\n+ 做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。\n  1.检查等待队列中, head节点不是写线程阻塞\n  2.再检查读锁没有达到65536的上限\n  3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:\n  3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。\n  3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1\n  3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。\n如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。\n```\n        final int fullTryAcquireShared(Thread current) {//（有写锁在等待、读达到最大值，status设置不成功）\n            /*\n             * This code is in part redundant with that in\n             * tryAcquireShared but is simpler overall by not\n             * complicating tryAcquireShared with interactions between\n             * retries and lazily reading hold counts.\n             */\n            HoldCounter rh = null;\n            for (;;) {\n                int c = getState();\n                if (exclusiveCount(c) != 0) {//有写锁\n                    //写锁是本身？\n                    if (getExclusiveOwnerThread() != current)\n                        return -1;\n                        //当前获取写锁的是本线程，那么直接返回（降级锁）\n                    // else we hold the exclusive lock; blocking here\n                    // would cause deadlock.\n                } else if (readerShouldBlock()) { //是否下一个要唤醒的是写锁\n                    // Make sure we're not acquiring read lock reentrantly\n                    if (firstReader == current) {//当前读锁线程第一个获取了读锁，那么继续可以读\n                        // assert firstReaderHoldCount > 0;\n                    } else { //当前有第一个写阻塞，而第一个读锁又不是自己\n                        //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）\n                        if (rh == null) {\n                            //一般最后一次获取所得，就是当前线程\n                            rh = cachedHoldCounter;\n                            if (rh == null || rh.tid != getThreadId(current)) {\n                                rh = readHolds.get();//当前线程信息\n                                //当前线程非可重入，在阻塞之前，要清空记录\n                                if (rh.count == 0)\n                                    readHolds.remove();\n                            }\n                        }\n                        //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧\n                        if (rh.count == 0)\n                            return -1;\n                    }\n                }\n                if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的\n                    throw new Error(\"Maximum lock count exceeded\");\n                if (compareAndSetState(c, c + SHARED_UNIT)) { //那么去设置\n                    if (sharedCount(c) == 0) { //第一次获取读锁\n                        firstReader = current;\n                        firstReaderHoldCount = 1;\n                    } else if (firstReader == current) {\n                        firstReaderHoldCount++;\n                    } else { //不是自己首先申请的读锁\n                        if (rh == null)\n                            rh = cachedHoldCounter;\n                        if (rh == null || rh.tid != getThreadId(current))\n                            rh = readHolds.get(); //获取到本线程的锁记录\n                        else if (rh.count == 0)//为0的时候都已经从线程中删掉了\n                            readHolds.set(rh);\n                        rh.count++;\n                        cachedHoldCounter = rh; // cache for release最后获取锁的线程\n                    }\n                    return 1;\n                }\n            }\n        }\n```\n此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。\n+ 首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。\n+ 反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。\n1. 若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。\n2. 若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。\n+ 检查读锁线程是否超过阈值65536\n+ 设置读锁的state.\n尝试获取流程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"/>\n### 加入阻塞队列\n加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号\n## unlock()\n通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:\n```\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) { //如果status彻底为0， 那么就说明可以唤醒await()了\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两件事:\n+ 首先尝试释放读锁, 并检查读锁线程state是否为0\n+ 若读锁线程state为0, 那么唤醒阻塞队列线程。\n尝试释放锁的过程如下:\n```\n        protected final boolean tryReleaseShared(int unused) {\n            Thread current = Thread.currentThread();\n            if (firstReader == current) { //本节点是第一个读取数据的线程\n                // assert firstReaderHoldCount > 0;\n                if (firstReaderHoldCount == 1)\n                    firstReader = null;  //最开始获取读锁的线程，去掉\n                else\n                    firstReaderHoldCount--;\n            } else {  //不是第一个读取数据的线程\n                HoldCounter rh = cachedHoldCounter;\n                if (rh == null || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                int count = rh.count;\n                if (count <= 1) { //把本线程访问记录从Localhost中去掉\n                    readHolds.remove();\n                    if (count <= 0)\n                        throw unmatchedUnlockException();\n                }\n                --rh.count;\n            }\n            for (;;) {\n                int c = getState();\n                int nextc = c - SHARED_UNIT; //\n                if (compareAndSetState(c, nextc))\n                    // Releasing the read lock has no effect on readers,\n                    // but it may allow waiting writers to proceed if\n                    // both read and write locks are now free.\n                    return nextc == 0;\n            }\n        }\n```\n+ 检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。\n+ 反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。\n+ 开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。\n若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。\n唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。\n可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。\n# 写锁\n## lock()\n写锁获取主要通过 sync.acquire(1)尝试获取:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n该函数主要分为三步:\n+ 尝试去获取写锁, 若获取到了, 就直接退出。\n+ 若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。\n来看第一步:\n```\n        protected final boolean tryAcquire(int acquires) {\n            /*\n             * Walkthrough:\n             * 1. If read count nonzero or write count nonzero\n             *    and owner is a different thread, fail.\n             * 2. If count would saturate, fail. (This can only\n             *    happen if count is already nonzero.)\n             * 3. Otherwise, this thread is eligible for lock if\n             *    it is either a reentrant acquire or\n             *    queue policy allows it. If so, update state\n             *    and set owner.\n             */\n            Thread current = Thread.currentThread();\n            //当前锁个数\n            int c = getState();\n            //写锁个数\n            int w = exclusiveCount(c);\n             ////当前锁个数 != 0（是否已经有线程持有锁），线程重入\n            if (c != 0) {\n                // (Note: if c != 0 and w == 0 then shared count != 0)\n                //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出\n                if (w == 0 || current != getExclusiveOwnerThread())\n                    return false;\n                //当前写锁， 是本身线程，可重入，但是不能超过65536个\n                if (w + exclusiveCount(acquires) > MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                // Reentrant acquire\n                //写锁可重入\n                setState(c + acquires);\n                return true;\n            }   //当前没有锁\n            //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false\n            if (writerShouldBlock() ||\n                !compareAndSetState(c, c + acquires))\n                return false;\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n```\n+ 首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。\n+ 反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。\n再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>acquireQueued()\n第三步也很简单, 就是把中断信号向外传递。\n## unlock()\n写锁释放时,调用release()方法, 如下:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n+ 释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。\n+ 若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。\n也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。\n\n# 总结\nReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。","source":"_posts/ReentrantReadWriteLock源码解读.md","raw":"---\ntitle: ReentrantReadWriteLock源码解读\ndate: 2017-07-28 06:18:19\ntags:\ntoc: true\n---\n首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:\n```\nReadWriteLock readWriteLock = new ReentrantReadWriteLock();\n//获取读锁\nreadWriteLock.readLock().lock();\n//释放读锁\nreadWriteLock.readLock().unlock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n//获取写锁\nreadWriteLock.writeLock().lock();\n```\n根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:\n```\n    public ReentrantReadWriteLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n        readerLock = new ReadLock(this);\n        writerLock = new WriteLock(this);\n    }\n\n```\n这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。\n# 读锁\n## 获取读锁\n通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:\n```\n    public final void acquireShared(int arg) {\n        if (tryAcquireShared(arg) < 0)\n            doAcquireShared(arg);\n    }\n```\n首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。\n### 尝试获取锁:\n```\n        protected final int tryAcquireShared(int unused) {\n            /*\n             * Walkthrough:\n             * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队\n             * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到\n             *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁\n             *    because of queue policy. If not, try\n             *    to grant by CASing state and updating count.\n             *    Note that step does not check for reentrant\n             *    acquires, which is postponed to full version\n             *    to avoid having to check hold count in\n             *    the more typical non-reentrant case.\n             * 3. If step 2 fails either because thread\n             *    apparently not eligible or CAS fails or count\n             *    saturated, chain to version with full retry loop.\n             */\n            Thread current = Thread.currentThread();\n            int c = getState();\n            //同一个线程先写锁再读锁是可以获取锁的\n            if (exclusiveCount(c) != 0 &&\n                getExclusiveOwnerThread() != current)\n                 //当前获取写锁的线程不是本身\n                return -1;\n            int r = sharedCount(c);\n            //阻塞队列队列第一个不是写锁，\n            if (!readerShouldBlock() &&\n                r < MAX_COUNT &&\n                //会左移动16位\n                compareAndSetState(c, c + SHARED_UNIT)) {\n                if (r == 0) {//若是第一个读锁\n                    firstReader = current;\n                    firstReaderHoldCount = 1;\n                } else if (firstReader == current) {//就是本身线程\n                    firstReaderHoldCount++;\n                } else { //不是第一个获取读锁的线程\n                    HoldCounter rh = cachedHoldCounter;\n                    //上一个节点不存在，或者存在了不是自己的\n                    if (rh == null || rh.tid != getThreadId(current))\n                        //那就生成自己的，并且缓存起来\n                        cachedHoldCounter = rh = readHolds.get();\n                    else if (rh.count == 0) //若上一个获取的节点就是自己，\n                        readHolds.set(rh);\n                    rh.count++; //上一次获取锁+1\n                }\n                return 1;\n            }\n            //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）\n            return fullTryAcquireShared(current);\n        }\n```\n做了做了如下事情:\n+ 首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败\n+ 做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。\n  1.检查等待队列中, head节点不是写线程阻塞\n  2.再检查读锁没有达到65536的上限\n  3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:\n  3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。\n  3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1\n  3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。\n如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。\n```\n        final int fullTryAcquireShared(Thread current) {//（有写锁在等待、读达到最大值，status设置不成功）\n            /*\n             * This code is in part redundant with that in\n             * tryAcquireShared but is simpler overall by not\n             * complicating tryAcquireShared with interactions between\n             * retries and lazily reading hold counts.\n             */\n            HoldCounter rh = null;\n            for (;;) {\n                int c = getState();\n                if (exclusiveCount(c) != 0) {//有写锁\n                    //写锁是本身？\n                    if (getExclusiveOwnerThread() != current)\n                        return -1;\n                        //当前获取写锁的是本线程，那么直接返回（降级锁）\n                    // else we hold the exclusive lock; blocking here\n                    // would cause deadlock.\n                } else if (readerShouldBlock()) { //是否下一个要唤醒的是写锁\n                    // Make sure we're not acquiring read lock reentrantly\n                    if (firstReader == current) {//当前读锁线程第一个获取了读锁，那么继续可以读\n                        // assert firstReaderHoldCount > 0;\n                    } else { //当前有第一个写阻塞，而第一个读锁又不是自己\n                        //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）\n                        if (rh == null) {\n                            //一般最后一次获取所得，就是当前线程\n                            rh = cachedHoldCounter;\n                            if (rh == null || rh.tid != getThreadId(current)) {\n                                rh = readHolds.get();//当前线程信息\n                                //当前线程非可重入，在阻塞之前，要清空记录\n                                if (rh.count == 0)\n                                    readHolds.remove();\n                            }\n                        }\n                        //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧\n                        if (rh.count == 0)\n                            return -1;\n                    }\n                }\n                if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的\n                    throw new Error(\"Maximum lock count exceeded\");\n                if (compareAndSetState(c, c + SHARED_UNIT)) { //那么去设置\n                    if (sharedCount(c) == 0) { //第一次获取读锁\n                        firstReader = current;\n                        firstReaderHoldCount = 1;\n                    } else if (firstReader == current) {\n                        firstReaderHoldCount++;\n                    } else { //不是自己首先申请的读锁\n                        if (rh == null)\n                            rh = cachedHoldCounter;\n                        if (rh == null || rh.tid != getThreadId(current))\n                            rh = readHolds.get(); //获取到本线程的锁记录\n                        else if (rh.count == 0)//为0的时候都已经从线程中删掉了\n                            readHolds.set(rh);\n                        rh.count++;\n                        cachedHoldCounter = rh; // cache for release最后获取锁的线程\n                    }\n                    return 1;\n                }\n            }\n        }\n```\n此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。\n+ 首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。\n+ 反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。\n1. 若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。\n2. 若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。\n+ 检查读锁线程是否超过阈值65536\n+ 设置读锁的state.\n尝试获取流程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"/>\n### 加入阻塞队列\n加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号\n## unlock()\n通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:\n```\n    public final boolean releaseShared(int arg) {\n        if (tryReleaseShared(arg)) { //如果status彻底为0， 那么就说明可以唤醒await()了\n            doReleaseShared();\n            return true;\n        }\n        return false;\n    }\n```\n主要做了两件事:\n+ 首先尝试释放读锁, 并检查读锁线程state是否为0\n+ 若读锁线程state为0, 那么唤醒阻塞队列线程。\n尝试释放锁的过程如下:\n```\n        protected final boolean tryReleaseShared(int unused) {\n            Thread current = Thread.currentThread();\n            if (firstReader == current) { //本节点是第一个读取数据的线程\n                // assert firstReaderHoldCount > 0;\n                if (firstReaderHoldCount == 1)\n                    firstReader = null;  //最开始获取读锁的线程，去掉\n                else\n                    firstReaderHoldCount--;\n            } else {  //不是第一个读取数据的线程\n                HoldCounter rh = cachedHoldCounter;\n                if (rh == null || rh.tid != getThreadId(current))\n                    rh = readHolds.get();\n                int count = rh.count;\n                if (count <= 1) { //把本线程访问记录从Localhost中去掉\n                    readHolds.remove();\n                    if (count <= 0)\n                        throw unmatchedUnlockException();\n                }\n                --rh.count;\n            }\n            for (;;) {\n                int c = getState();\n                int nextc = c - SHARED_UNIT; //\n                if (compareAndSetState(c, nextc))\n                    // Releasing the read lock has no effect on readers,\n                    // but it may allow waiting writers to proceed if\n                    // both read and write locks are now free.\n                    return nextc == 0;\n            }\n        }\n```\n+ 检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。\n+ 反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。\n+ 开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。\n若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。\n唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。\n可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。\n# 写锁\n## lock()\n写锁获取主要通过 sync.acquire(1)尝试获取:\n```\n    public final void acquire(int arg) {\n        if (!tryAcquire(arg) &&\n            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n    }\n```\n该函数主要分为三步:\n+ 尝试去获取写锁, 若获取到了, 就直接退出。\n+ 若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。\n+ 若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。\n来看第一步:\n```\n        protected final boolean tryAcquire(int acquires) {\n            /*\n             * Walkthrough:\n             * 1. If read count nonzero or write count nonzero\n             *    and owner is a different thread, fail.\n             * 2. If count would saturate, fail. (This can only\n             *    happen if count is already nonzero.)\n             * 3. Otherwise, this thread is eligible for lock if\n             *    it is either a reentrant acquire or\n             *    queue policy allows it. If so, update state\n             *    and set owner.\n             */\n            Thread current = Thread.currentThread();\n            //当前锁个数\n            int c = getState();\n            //写锁个数\n            int w = exclusiveCount(c);\n             ////当前锁个数 != 0（是否已经有线程持有锁），线程重入\n            if (c != 0) {\n                // (Note: if c != 0 and w == 0 then shared count != 0)\n                //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出\n                if (w == 0 || current != getExclusiveOwnerThread())\n                    return false;\n                //当前写锁， 是本身线程，可重入，但是不能超过65536个\n                if (w + exclusiveCount(acquires) > MAX_COUNT)\n                    throw new Error(\"Maximum lock count exceeded\");\n                // Reentrant acquire\n                //写锁可重入\n                setState(c + acquires);\n                return true;\n            }   //当前没有锁\n            //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false\n            if (writerShouldBlock() ||\n                !compareAndSetState(c, c + acquires))\n                return false;\n            setExclusiveOwnerThread(current);\n            return true;\n        }\n```\n+ 首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。\n+ 反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。\n再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>acquireQueued()\n第三步也很简单, 就是把中断信号向外传递。\n## unlock()\n写锁释放时,调用release()方法, 如下:\n```\n    public final boolean release(int arg) {\n        if (tryRelease(arg)) {\n            Node h = head;\n            //当前节点为signal状态，需要唤醒后继节点\n            if (h != null && h.waitStatus != 0)\n                unparkSuccessor(h);\n            return true;\n        }\n        return false;\n    }\n```\n+ 释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。\n+ 若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。\n也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。\n\n# 总结\nReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。","slug":"ReentrantReadWriteLock源码解读","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xj0011phu55wdtukpd","content":"<p>首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</div><div class=\"line\">//获取读锁</div><div class=\"line\">readWriteLock.readLock().lock();</div><div class=\"line\">//释放读锁</div><div class=\"line\">readWriteLock.readLock().unlock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div></pre></td></tr></table></figure></p>\n<p>根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ReentrantReadWriteLock(boolean fair) &#123;</div><div class=\"line\">    sync = fair ? new FairSync() : new NonfairSync();</div><div class=\"line\">    readerLock = new ReadLock(this);</div><div class=\"line\">    writerLock = new WriteLock(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。</p>\n<h1 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h1><h2 id=\"获取读锁\"><a href=\"#获取读锁\" class=\"headerlink\" title=\"获取读锁\"></a>获取读锁</h2><p>通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireShared(int arg) &#123;</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireShared(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。</p>\n<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁:\"></a>尝试获取锁:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final int tryAcquireShared(int unused) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队</div><div class=\"line\">     * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到</div><div class=\"line\">     *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁</div><div class=\"line\">     *    because of queue policy. If not, try</div><div class=\"line\">     *    to grant by CASing state and updating count.</div><div class=\"line\">     *    Note that step does not check for reentrant</div><div class=\"line\">     *    acquires, which is postponed to full version</div><div class=\"line\">     *    to avoid having to check hold count in</div><div class=\"line\">     *    the more typical non-reentrant case.</div><div class=\"line\">     * 3. If step 2 fails either because thread</div><div class=\"line\">     *    apparently not eligible or CAS fails or count</div><div class=\"line\">     *    saturated, chain to version with full retry loop.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //同一个线程先写锁再读锁是可以获取锁的</div><div class=\"line\">    if (exclusiveCount(c) != 0 &amp;&amp;</div><div class=\"line\">        getExclusiveOwnerThread() != current)</div><div class=\"line\">         //当前获取写锁的线程不是本身</div><div class=\"line\">        return -1;</div><div class=\"line\">    int r = sharedCount(c);</div><div class=\"line\">    //阻塞队列队列第一个不是写锁，</div><div class=\"line\">    if (!readerShouldBlock() &amp;&amp;</div><div class=\"line\">        r &lt; MAX_COUNT &amp;&amp;</div><div class=\"line\">        //会左移动16位</div><div class=\"line\">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class=\"line\">        if (r == 0) &#123;//若是第一个读锁</div><div class=\"line\">            firstReader = current;</div><div class=\"line\">            firstReaderHoldCount = 1;</div><div class=\"line\">        &#125; else if (firstReader == current) &#123;//就是本身线程</div><div class=\"line\">            firstReaderHoldCount++;</div><div class=\"line\">        &#125; else &#123; //不是第一个获取读锁的线程</div><div class=\"line\">            HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">            //上一个节点不存在，或者存在了不是自己的</div><div class=\"line\">            if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                //那就生成自己的，并且缓存起来</div><div class=\"line\">                cachedHoldCounter = rh = readHolds.get();</div><div class=\"line\">            else if (rh.count == 0) //若上一个获取的节点就是自己，</div><div class=\"line\">                readHolds.set(rh);</div><div class=\"line\">            rh.count++; //上一次获取锁+1</div><div class=\"line\">        &#125;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）</div><div class=\"line\">    return fullTryAcquireShared(current);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>做了做了如下事情:</p>\n<ul>\n<li>首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败</li>\n<li>做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。<br>1.检查等待队列中, head节点不是写线程阻塞<br>2.再检查读锁没有达到65536的上限<br>3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:<br>3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。<br>3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1<br>3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。<br>如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int fullTryAcquireShared(Thread current) &#123;//（有写锁在等待、读达到最大值，status设置不成功）</div><div class=\"line\">    /*</div><div class=\"line\">     * This code is in part redundant with that in</div><div class=\"line\">     * tryAcquireShared but is simpler overall by not</div><div class=\"line\">     * complicating tryAcquireShared with interactions between</div><div class=\"line\">     * retries and lazily reading hold counts.</div><div class=\"line\">     */</div><div class=\"line\">    HoldCounter rh = null;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        if (exclusiveCount(c) != 0) &#123;//有写锁</div><div class=\"line\">            //写锁是本身？</div><div class=\"line\">            if (getExclusiveOwnerThread() != current)</div><div class=\"line\">                return -1;</div><div class=\"line\">                //当前获取写锁的是本线程，那么直接返回（降级锁）</div><div class=\"line\">            // else we hold the exclusive lock; blocking here</div><div class=\"line\">            // would cause deadlock.</div><div class=\"line\">        &#125; else if (readerShouldBlock()) &#123; //是否下一个要唤醒的是写锁</div><div class=\"line\">            // Make sure we&apos;re not acquiring read lock reentrantly</div><div class=\"line\">            if (firstReader == current) &#123;//当前读锁线程第一个获取了读锁，那么继续可以读</div><div class=\"line\">                // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">            &#125; else &#123; //当前有第一个写阻塞，而第一个读锁又不是自己</div><div class=\"line\">                //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）</div><div class=\"line\">                if (rh == null) &#123;</div><div class=\"line\">                    //一般最后一次获取所得，就是当前线程</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class=\"line\">                        rh = readHolds.get();//当前线程信息</div><div class=\"line\">                        //当前线程非可重入，在阻塞之前，要清空记录</div><div class=\"line\">                        if (rh.count == 0)</div><div class=\"line\">                            readHolds.remove();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧</div><div class=\"line\">                if (rh.count == 0)</div><div class=\"line\">                    return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123; //那么去设置</div><div class=\"line\">            if (sharedCount(c) == 0) &#123; //第一次获取读锁</div><div class=\"line\">                firstReader = current;</div><div class=\"line\">                firstReaderHoldCount = 1;</div><div class=\"line\">            &#125; else if (firstReader == current) &#123;</div><div class=\"line\">                firstReaderHoldCount++;</div><div class=\"line\">            &#125; else &#123; //不是自己首先申请的读锁</div><div class=\"line\">                if (rh == null)</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                    rh = readHolds.get(); //获取到本线程的锁记录</div><div class=\"line\">                else if (rh.count == 0)//为0的时候都已经从线程中删掉了</div><div class=\"line\">                    readHolds.set(rh);</div><div class=\"line\">                rh.count++;</div><div class=\"line\">                cachedHoldCounter = rh; // cache for release最后获取锁的线程</div><div class=\"line\">            &#125;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。</p>\n<ul>\n<li>首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。</li>\n<li>反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。</li>\n</ul>\n<ol>\n<li>若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。</li>\n<li>若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。</li>\n</ol>\n<ul>\n<li>检查读锁线程是否超过阈值65536</li>\n<li>设置读锁的state.<br>尝试获取流程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"><h3 id=\"加入阻塞队列\"><a href=\"#加入阻塞队列\" class=\"headerlink\" title=\"加入阻塞队列\"></a>加入阻塞队列</h3>加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号<h2 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2>通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123; //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了两件事:</p>\n<ul>\n<li>首先尝试释放读锁, 并检查读锁线程state是否为0</li>\n<li><p>若读锁线程state为0, 那么唤醒阻塞队列线程。<br>尝试释放锁的过程如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryReleaseShared(int unused) &#123;</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    if (firstReader == current) &#123; //本节点是第一个读取数据的线程</div><div class=\"line\">        // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">        if (firstReaderHoldCount == 1)</div><div class=\"line\">            firstReader = null;  //最开始获取读锁的线程，去掉</div><div class=\"line\">        else</div><div class=\"line\">            firstReaderHoldCount--;</div><div class=\"line\">    &#125; else &#123;  //不是第一个读取数据的线程</div><div class=\"line\">        HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">        if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">            rh = readHolds.get();</div><div class=\"line\">        int count = rh.count;</div><div class=\"line\">        if (count &lt;= 1) &#123; //把本线程访问记录从Localhost中去掉</div><div class=\"line\">            readHolds.remove();</div><div class=\"line\">            if (count &lt;= 0)</div><div class=\"line\">                throw unmatchedUnlockException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        --rh.count;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        int nextc = c - SHARED_UNIT; //</div><div class=\"line\">        if (compareAndSetState(c, nextc))</div><div class=\"line\">            // Releasing the read lock has no effect on readers,</div><div class=\"line\">            // but it may allow waiting writers to proceed if</div><div class=\"line\">            // both read and write locks are now free.</div><div class=\"line\">            return nextc == 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。</p>\n</li>\n<li>反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。</li>\n<li>开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。<br>若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。<br>唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。<br>可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。<h1 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h1><h2 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h2>写锁获取主要通过 sync.acquire(1)尝试获取:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp;</div><div class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该函数主要分为三步:</p>\n<ul>\n<li>尝试去获取写锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li><p>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。<br>来看第一步:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If read count nonzero or write count nonzero</div><div class=\"line\">     *    and owner is a different thread, fail.</div><div class=\"line\">     * 2. If count would saturate, fail. (This can only</div><div class=\"line\">     *    happen if count is already nonzero.)</div><div class=\"line\">     * 3. Otherwise, this thread is eligible for lock if</div><div class=\"line\">     *    it is either a reentrant acquire or</div><div class=\"line\">     *    queue policy allows it. If so, update state</div><div class=\"line\">     *    and set owner.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    //当前锁个数</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //写锁个数</div><div class=\"line\">    int w = exclusiveCount(c);</div><div class=\"line\">     ////当前锁个数 != 0（是否已经有线程持有锁），线程重入</div><div class=\"line\">    if (c != 0) &#123;</div><div class=\"line\">        // (Note: if c != 0 and w == 0 then shared count != 0)</div><div class=\"line\">        //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出</div><div class=\"line\">        if (w == 0 || current != getExclusiveOwnerThread())</div><div class=\"line\">            return false;</div><div class=\"line\">        //当前写锁， 是本身线程，可重入，但是不能超过65536个</div><div class=\"line\">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        // Reentrant acquire</div><div class=\"line\">        //写锁可重入</div><div class=\"line\">        setState(c + acquires);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;   //当前没有锁</div><div class=\"line\">    //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false</div><div class=\"line\">    if (writerShouldBlock() ||</div><div class=\"line\">        !compareAndSetState(c, c + acquires))</div><div class=\"line\">        return false;</div><div class=\"line\">    setExclusiveOwnerThread(current);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。</p>\n</li>\n<li><p>反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。<br>再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>acquireQueued()<br>第三步也很简单, 就是把中断信号向外传递。</p>\n<h2 id=\"unlock-1\"><a href=\"#unlock-1\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2><p>写锁释放时,调用release()方法, 如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。</p>\n</li>\n<li>若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。<br>也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先回顾下ReentrantLock、CountDownLatch的区别: ReentrantLock是互斥锁, CountDownLatch是共享锁, 有没有哪种锁能够部分场景互斥, 部分场景共享呢, 那就是本文的主角:ReentrantReadWriteLock, 也是以AQS为基础实现的第三种应用。 要注意, ReentrantReadWriteLock与ReentrantLock没有一点关系。基本使用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ReadWriteLock readWriteLock = new ReentrantReadWriteLock();</div><div class=\"line\">//获取读锁</div><div class=\"line\">readWriteLock.readLock().lock();</div><div class=\"line\">//释放读锁</div><div class=\"line\">readWriteLock.readLock().unlock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div><div class=\"line\">//获取写锁</div><div class=\"line\">readWriteLock.writeLock().lock();</div></pre></td></tr></table></figure></p>\n<p>根据锁的名称, 基本也能猜出大致互斥关系, 读锁与读锁共享, 读锁与写锁互斥, 写锁与写锁互斥。读锁和写锁分为公平锁和非公平锁, 默认为非公平锁, 读锁和写锁这么初始化:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ReentrantReadWriteLock(boolean fair) &#123;</div><div class=\"line\">    sync = fair ? new FairSync() : new NonfairSync();</div><div class=\"line\">    readerLock = new ReadLock(this);</div><div class=\"line\">    writerLock = new WriteLock(this);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里首先讲下state的含义: 读锁和写锁共享同一个state, 其为int, 高16位记录读共享的次数, 低16位记录写互斥的次数, 可能有人会问, 写不是互斥吗? 这里写锁也是可重入的。所以防止越界, 读写都不能超过2^16(65536)次。</p>\n<h1 id=\"读锁\"><a href=\"#读锁\" class=\"headerlink\" title=\"读锁\"></a>读锁</h1><h2 id=\"获取读锁\"><a href=\"#获取读锁\" class=\"headerlink\" title=\"获取读锁\"></a>获取读锁</h2><p>通过lock()获取读锁, 首先进入AQS.acquireShared(1), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquireShared(int arg) &#123;</div><div class=\"line\">    if (tryAcquireShared(arg) &lt; 0)</div><div class=\"line\">        doAcquireShared(arg);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>首先尝试获取锁, 若获取到了, 则开始共享锁, 否则加入阻塞队列。</p>\n<h3 id=\"尝试获取锁\"><a href=\"#尝试获取锁\" class=\"headerlink\" title=\"尝试获取锁:\"></a>尝试获取锁:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final int tryAcquireShared(int unused) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If write lock held by another thread, fail.  先有别人写锁，直接排队</div><div class=\"line\">     * 2. Otherwise, this thread is eligible for       自己写锁，自己读锁，检查排队的第一个不是写锁，获取到</div><div class=\"line\">     *    lock wrt state, so ask if it should block    自己写锁，自己读锁，第一个排队的是写锁</div><div class=\"line\">     *    because of queue policy. If not, try</div><div class=\"line\">     *    to grant by CASing state and updating count.</div><div class=\"line\">     *    Note that step does not check for reentrant</div><div class=\"line\">     *    acquires, which is postponed to full version</div><div class=\"line\">     *    to avoid having to check hold count in</div><div class=\"line\">     *    the more typical non-reentrant case.</div><div class=\"line\">     * 3. If step 2 fails either because thread</div><div class=\"line\">     *    apparently not eligible or CAS fails or count</div><div class=\"line\">     *    saturated, chain to version with full retry loop.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //同一个线程先写锁再读锁是可以获取锁的</div><div class=\"line\">    if (exclusiveCount(c) != 0 &amp;&amp;</div><div class=\"line\">        getExclusiveOwnerThread() != current)</div><div class=\"line\">         //当前获取写锁的线程不是本身</div><div class=\"line\">        return -1;</div><div class=\"line\">    int r = sharedCount(c);</div><div class=\"line\">    //阻塞队列队列第一个不是写锁，</div><div class=\"line\">    if (!readerShouldBlock() &amp;&amp;</div><div class=\"line\">        r &lt; MAX_COUNT &amp;&amp;</div><div class=\"line\">        //会左移动16位</div><div class=\"line\">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</div><div class=\"line\">        if (r == 0) &#123;//若是第一个读锁</div><div class=\"line\">            firstReader = current;</div><div class=\"line\">            firstReaderHoldCount = 1;</div><div class=\"line\">        &#125; else if (firstReader == current) &#123;//就是本身线程</div><div class=\"line\">            firstReaderHoldCount++;</div><div class=\"line\">        &#125; else &#123; //不是第一个获取读锁的线程</div><div class=\"line\">            HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">            //上一个节点不存在，或者存在了不是自己的</div><div class=\"line\">            if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                //那就生成自己的，并且缓存起来</div><div class=\"line\">                cachedHoldCounter = rh = readHolds.get();</div><div class=\"line\">            else if (rh.count == 0) //若上一个获取的节点就是自己，</div><div class=\"line\">                readHolds.set(rh);</div><div class=\"line\">            rh.count++; //上一次获取锁+1</div><div class=\"line\">        &#125;</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">    //不该获取到锁（有第一个写锁在阻塞、读达到最大值，status设置不成功）</div><div class=\"line\">    return fullTryAcquireShared(current);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>做了做了如下事情:</p>\n<ul>\n<li>首先检查是不是已经有写锁获取到锁, 同时这个获取写锁的不是自己, 那么获取锁失败</li>\n<li>做些检查工作, 若都满足, 那么该线程就获还是可以取到了读锁的。<br>1.检查等待队列中, head节点不是写线程阻塞<br>2.再检查读锁没有达到65536的上限<br>3.同时尝试设置读锁+1, 因为读锁为高16位, compareAndSetState(c, c + SHARED_UNIT))的目的通过偏移来完成的。如果都符合条件且操作成功,  同时还需要做如下工作:<br>3.1 若本线程是第一个获取到读锁的, 那么firstReader记录下该线程, firstReaderHoldCount记录了该线程获取读锁的可重入次数, 记录这些变量,是为了某种情况下读线程的可重入操作, 后面会介绍。<br>3.2 若本线程是第一个获取读锁的那个线程, 重入次数+1<br>3.3 若本节点不是第一个获取读锁的线程,  那么根据LocalThread记录本线程可重入的次数。 cachedHoldCounter缓存的是上次获取读锁线程的信息, 既然有了LocalThread:readHolds, 此变量不是显得多此一举? 存在的意义就是为了减少通过LocalThread.get()获取当前线程重入信息, 以减轻该操作对性能的影响。<br>如果上述检查和操作没有成功的话, 那么进入fullTryAcquireShared()进一步再次尝试获取锁。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div></pre></td><td class=\"code\"><pre><div class=\"line\">final int fullTryAcquireShared(Thread current) &#123;//（有写锁在等待、读达到最大值，status设置不成功）</div><div class=\"line\">    /*</div><div class=\"line\">     * This code is in part redundant with that in</div><div class=\"line\">     * tryAcquireShared but is simpler overall by not</div><div class=\"line\">     * complicating tryAcquireShared with interactions between</div><div class=\"line\">     * retries and lazily reading hold counts.</div><div class=\"line\">     */</div><div class=\"line\">    HoldCounter rh = null;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        if (exclusiveCount(c) != 0) &#123;//有写锁</div><div class=\"line\">            //写锁是本身？</div><div class=\"line\">            if (getExclusiveOwnerThread() != current)</div><div class=\"line\">                return -1;</div><div class=\"line\">                //当前获取写锁的是本线程，那么直接返回（降级锁）</div><div class=\"line\">            // else we hold the exclusive lock; blocking here</div><div class=\"line\">            // would cause deadlock.</div><div class=\"line\">        &#125; else if (readerShouldBlock()) &#123; //是否下一个要唤醒的是写锁</div><div class=\"line\">            // Make sure we&apos;re not acquiring read lock reentrantly</div><div class=\"line\">            if (firstReader == current) &#123;//当前读锁线程第一个获取了读锁，那么继续可以读</div><div class=\"line\">                // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">            &#125; else &#123; //当前有第一个写阻塞，而第一个读锁又不是自己</div><div class=\"line\">                //已经有写锁等待了，获取当前（这里说的意思呢，就是检查当前是第几次可重入，如果一次都没有可重入过，那就直接失败，若不是第一个可重入，那就获取到锁）</div><div class=\"line\">                if (rh == null) &#123;</div><div class=\"line\">                    //一般最后一次获取所得，就是当前线程</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                    if (rh == null || rh.tid != getThreadId(current)) &#123;</div><div class=\"line\">                        rh = readHolds.get();//当前线程信息</div><div class=\"line\">                        //当前线程非可重入，在阻塞之前，要清空记录</div><div class=\"line\">                        if (rh.count == 0)</div><div class=\"line\">                            readHolds.remove();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                //该线程若是第一次可重入，那么就也去排队吧，如果不是第第一个次可重入，那就去排队吧</div><div class=\"line\">                if (rh.count == 0)</div><div class=\"line\">                    return -1;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (sharedCount(c) == MAX_COUNT) //是否达到了最大值，这里是可以读取超过65536的</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        if (compareAndSetState(c, c + SHARED_UNIT)) &#123; //那么去设置</div><div class=\"line\">            if (sharedCount(c) == 0) &#123; //第一次获取读锁</div><div class=\"line\">                firstReader = current;</div><div class=\"line\">                firstReaderHoldCount = 1;</div><div class=\"line\">            &#125; else if (firstReader == current) &#123;</div><div class=\"line\">                firstReaderHoldCount++;</div><div class=\"line\">            &#125; else &#123; //不是自己首先申请的读锁</div><div class=\"line\">                if (rh == null)</div><div class=\"line\">                    rh = cachedHoldCounter;</div><div class=\"line\">                if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">                    rh = readHolds.get(); //获取到本线程的锁记录</div><div class=\"line\">                else if (rh.count == 0)//为0的时候都已经从线程中删掉了</div><div class=\"line\">                    readHolds.set(rh);</div><div class=\"line\">                rh.count++;</div><div class=\"line\">                cachedHoldCounter = rh; // cache for release最后获取锁的线程</div><div class=\"line\">            &#125;</div><div class=\"line\">            return 1;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此函数的前提条件是:要么阻塞队列第一个线程为写线程, 要么原子更新读state失败, 次函数循环执行, 就是是保证原子操作失败后的重试。</p>\n<ul>\n<li>首先检查是否有写锁, 如果存在写锁, 再检查获取写锁的线程是否是当前线程, 若是的话, 那么会获取到锁, 这里实现了锁降级(由写锁降为读锁)的功能。</li>\n<li>反之, 检查是否有写线程在阻塞, 若是, 若这个阻塞的线程是本身, 那么不影响获取锁。 若不是, 这里就要详细分类了, 此时的场景是别的线程获取了读锁, 而有写线程被阻塞。</li>\n</ul>\n<ol>\n<li>若本线程是第一次获取读锁, 本次获取读锁不是可重入的, 那么为了防止获取写锁的线程饿死, 禁止新的线程获取读锁, 新的读锁线程将也处于阻塞队列。 同时将本线程从readHolds中删掉。</li>\n<li>若该线程之前获取了锁, 并且还没有释放, 那么此时获取锁是允许的, 那么同意继续获取读锁, 此时算是该线程读锁的可重入。</li>\n</ol>\n<ul>\n<li>检查读锁线程是否超过阈值65536</li>\n<li>设置读锁的state.<br>尝试获取流程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ReetrantReadWriteLock1.png\" height=\"250\" width=\"700\"><h3 id=\"加入阻塞队列\"><a href=\"#加入阻塞队列\" class=\"headerlink\" title=\"加入阻塞队列\"></a>加入阻塞队列</h3>加入阻塞队列调用的是doAcquireShared, 大致实现可参考<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doAcquireSharedInterruptibly(), 这里添加的节点的nextWaiter为SHARED, 表示该节点唤醒换后, 会继续向后继节点传播该信号<h2 id=\"unlock\"><a href=\"#unlock\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2>通过unlock()释放读锁, 首先进入sync.releaseShared(1)释放:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean releaseShared(int arg) &#123;</div><div class=\"line\">    if (tryReleaseShared(arg)) &#123; //如果status彻底为0， 那么就说明可以唤醒await()了</div><div class=\"line\">        doReleaseShared();</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了两件事:</p>\n<ul>\n<li>首先尝试释放读锁, 并检查读锁线程state是否为0</li>\n<li><p>若读锁线程state为0, 那么唤醒阻塞队列线程。<br>尝试释放锁的过程如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryReleaseShared(int unused) &#123;</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    if (firstReader == current) &#123; //本节点是第一个读取数据的线程</div><div class=\"line\">        // assert firstReaderHoldCount &gt; 0;</div><div class=\"line\">        if (firstReaderHoldCount == 1)</div><div class=\"line\">            firstReader = null;  //最开始获取读锁的线程，去掉</div><div class=\"line\">        else</div><div class=\"line\">            firstReaderHoldCount--;</div><div class=\"line\">    &#125; else &#123;  //不是第一个读取数据的线程</div><div class=\"line\">        HoldCounter rh = cachedHoldCounter;</div><div class=\"line\">        if (rh == null || rh.tid != getThreadId(current))</div><div class=\"line\">            rh = readHolds.get();</div><div class=\"line\">        int count = rh.count;</div><div class=\"line\">        if (count &lt;= 1) &#123; //把本线程访问记录从Localhost中去掉</div><div class=\"line\">            readHolds.remove();</div><div class=\"line\">            if (count &lt;= 0)</div><div class=\"line\">                throw unmatchedUnlockException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        --rh.count;</div><div class=\"line\">    &#125;</div><div class=\"line\">    for (;;) &#123;</div><div class=\"line\">        int c = getState();</div><div class=\"line\">        int nextc = c - SHARED_UNIT; //</div><div class=\"line\">        if (compareAndSetState(c, nextc))</div><div class=\"line\">            // Releasing the read lock has no effect on readers,</div><div class=\"line\">            // but it may allow waiting writers to proceed if</div><div class=\"line\">            // both read and write locks are now free.</div><div class=\"line\">            return nextc == 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查本线程是否是第一个获取读锁的线程, 若是的话, 分别修改firstReaderHoldCount及firstReader对应的值。</p>\n</li>\n<li>反之, 修改readHolds里面关于当前线程的获取锁情况, cachedHoldCounter是为了减少ThreadLocal.get()的访问次数。</li>\n<li>开始修改state读锁的标志, 这里使用for是为了保证失败后的尝试。<br>若此时读锁已经全部释放, 那么返回true, 表明可以唤醒阻塞队列的线程了。<br>唤醒阻塞队列的线程过程doReleaseShared, 具体过程请看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/08/24/CountDownLatch%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">CountDownLatch源码解读</a>doReleaseShared(), 主要做的工作就是检查后续阻塞队列, 若是signal, 那么就唤醒阻塞线程。<br>可以看出, readLock的获取与释放主要过程与CountDownLatch操作及其相似的, 不同的是尝试获取锁的步骤不同。<h1 id=\"写锁\"><a href=\"#写锁\" class=\"headerlink\" title=\"写锁\"></a>写锁</h1><h2 id=\"lock\"><a href=\"#lock\" class=\"headerlink\" title=\"lock()\"></a>lock()</h2>写锁获取主要通过 sync.acquire(1)尝试获取:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final void acquire(int arg) &#123;</div><div class=\"line\">    if (!tryAcquire(arg) &amp;&amp;</div><div class=\"line\">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class=\"line\">        selfInterrupt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该函数主要分为三步:</p>\n<ul>\n<li>尝试去获取写锁, 若获取到了, 就直接退出。</li>\n<li>若没有获取到写锁, 那么将当前线程构成一个Node, 放入线程阻塞队列, 线程进入睡眠等待。</li>\n<li><p>若本次没有获取到锁、从阻塞队列中被唤醒, 并且acquireQueued()返回true, 那么说明该线程被别人调用了中断, 我们需要将该中断再置位向外传递。<br>来看第一步:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected final boolean tryAcquire(int acquires) &#123;</div><div class=\"line\">    /*</div><div class=\"line\">     * Walkthrough:</div><div class=\"line\">     * 1. If read count nonzero or write count nonzero</div><div class=\"line\">     *    and owner is a different thread, fail.</div><div class=\"line\">     * 2. If count would saturate, fail. (This can only</div><div class=\"line\">     *    happen if count is already nonzero.)</div><div class=\"line\">     * 3. Otherwise, this thread is eligible for lock if</div><div class=\"line\">     *    it is either a reentrant acquire or</div><div class=\"line\">     *    queue policy allows it. If so, update state</div><div class=\"line\">     *    and set owner.</div><div class=\"line\">     */</div><div class=\"line\">    Thread current = Thread.currentThread();</div><div class=\"line\">    //当前锁个数</div><div class=\"line\">    int c = getState();</div><div class=\"line\">    //写锁个数</div><div class=\"line\">    int w = exclusiveCount(c);</div><div class=\"line\">     ////当前锁个数 != 0（是否已经有线程持有锁），线程重入</div><div class=\"line\">    if (c != 0) &#123;</div><div class=\"line\">        // (Note: if c != 0 and w == 0 then shared count != 0)</div><div class=\"line\">        //w == 0,表示写线程数为0， 有读锁； 有写锁，但是不是当前线程，也退出</div><div class=\"line\">        if (w == 0 || current != getExclusiveOwnerThread())</div><div class=\"line\">            return false;</div><div class=\"line\">        //当前写锁， 是本身线程，可重入，但是不能超过65536个</div><div class=\"line\">        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)</div><div class=\"line\">            throw new Error(&quot;Maximum lock count exceeded&quot;);</div><div class=\"line\">        // Reentrant acquire</div><div class=\"line\">        //写锁可重入</div><div class=\"line\">        setState(c + acquires);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;   //当前没有锁</div><div class=\"line\">    //是否该阻塞， 公平锁考考虑等待队列的线程。非公平锁就不用考虑等待队列的线程，直接false</div><div class=\"line\">    if (writerShouldBlock() ||</div><div class=\"line\">        !compareAndSetState(c, c + acquires))</div><div class=\"line\">        return false;</div><div class=\"line\">    setExclusiveOwnerThread(current);</div><div class=\"line\">    return true;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>首先检查是否锁不为0(读+写)。 若读+写不为0, 而写锁为0, 说明有读锁, 本线程获取锁失败; 或者写锁也不为0, 并且获取写锁的那个线程不是本线程, 说明不是写线程的重入,也获取锁失败。 若以上两步有成功的话, 则获取锁成功。</p>\n</li>\n<li><p>反正则说明当前state=0(没有读+写线程), 那么成功获取到锁。 writerShouldBlock()对于写锁始终未false。<br>再来看第二步, 也就是说明本线程没有获取到锁, 那么将本线程加入阻塞队里等待唤醒, nextWaiter设置为EXCLUSIVE,  acquireQueued(addWaiter(Node.EXCLUSIVE), arg))具体怎么实现请去查看<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>acquireQueued()<br>第三步也很简单, 就是把中断信号向外传递。</p>\n<h2 id=\"unlock-1\"><a href=\"#unlock-1\" class=\"headerlink\" title=\"unlock()\"></a>unlock()</h2><p>写锁释放时,调用release()方法, 如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final boolean release(int arg) &#123;</div><div class=\"line\">    if (tryRelease(arg)) &#123;</div><div class=\"line\">        Node h = head;</div><div class=\"line\">        //当前节点为signal状态，需要唤醒后继节点</div><div class=\"line\">        if (h != null &amp;&amp; h.waitStatus != 0)</div><div class=\"line\">            unparkSuccessor(h);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return false;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>释放锁时tryRelease会做最基本的检查, 比如记录的那个获取写锁的线程是否是本线程。</p>\n</li>\n<li>若成功释放, 唤醒下一个阻塞的线程,  unparkSuccessor实现可见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2017/07/23/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">ReentrantLock源码解读</a>。<br>也可以看出, writedLock的获取与释放主要过程与ReentrantLock操作及其相似的, 不同的是尝试获取锁的函数不同。</li>\n</ul>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>ReentrantReadWriteLock读锁与写锁可以认为分别是ReentrantLock、CountDownLatch的实现, 不同的是对state赋予的含义不同。</p>\n"},{"title":"CopyOnWriteArrayList原理分析","date":"2017-09-17T02:14:15.000Z","toc":true,"_content":"CopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。\n## 成员变量\n+ lock\nfinal transient ReentrantLock lock = new ReentrantLock();\n使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。\n+ array\nprivate transient volatile Object[] array;\n真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。\n## 添加数据add\n```\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n主要做了如下事情:\n+ 首先获取互斥可重入锁。 若获取不到, 则被阻塞。\n+ 将原来数组元素copy到新的数组\n+ 将新添加元素都放到数组newElements最后。\n+ 替换原来数组elements\n过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"/>\n## 总结\nCopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。","source":"_posts/copyOnWriteArrayListy原理解读.md","raw":"---\ntitle: CopyOnWriteArrayList原理分析\ndate: 2017-09-17 10:14:15\ntags:\ntoc: true\n---\nCopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。\n## 成员变量\n+ lock\nfinal transient ReentrantLock lock = new ReentrantLock();\n使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。\n+ array\nprivate transient volatile Object[] array;\n真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。\n## 添加数据add\n```\n    public boolean add(E e) {\n        final ReentrantLock lock = this.lock;\n        lock.lock();\n        try {\n            Object[] elements = getArray();\n            int len = elements.length;\n            Object[] newElements = Arrays.copyOf(elements, len + 1);\n            newElements[len] = e;\n            setArray(newElements);\n            return true;\n        } finally {\n            lock.unlock();\n        }\n    }\n```\n主要做了如下事情:\n+ 首先获取互斥可重入锁。 若获取不到, 则被阻塞。\n+ 将原来数组元素copy到新的数组\n+ 将新添加元素都放到数组newElements最后。\n+ 替换原来数组elements\n过程如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"/>\n## 总结\nCopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。","slug":"copyOnWriteArrayListy原理解读","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xl0013phu5kpd38bdl","content":"<p>CopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。</p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><ul>\n<li>lock<br>final transient ReentrantLock lock = new ReentrantLock();<br>使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。</li>\n<li>array<br>private transient volatile Object[] array;<br>真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。<h2 id=\"添加数据add\"><a href=\"#添加数据add\" class=\"headerlink\" title=\"添加数据add\"></a>添加数据add</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean add(E e) &#123;</div><div class=\"line\">    final ReentrantLock lock = this.lock;</div><div class=\"line\">    lock.lock();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Object[] elements = getArray();</div><div class=\"line\">        int len = elements.length;</div><div class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class=\"line\">        newElements[len] = e;</div><div class=\"line\">        setArray(newElements);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        lock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先获取互斥可重入锁。 若获取不到, 则被阻塞。</li>\n<li>将原来数组元素copy到新的数组</li>\n<li>将新添加元素都放到数组newElements最后。</li>\n<li>替换原来数组elements<br>过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>CopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>CopyOnWriteArrayList是为了解决并发场景下对ArrayList读写的, 可以根据名称大致可知如何使用: 当写入的时候的对ArrayList进行copy。使用场景: 读多写少。</p>\n<h2 id=\"成员变量\"><a href=\"#成员变量\" class=\"headerlink\" title=\"成员变量\"></a>成员变量</h2><ul>\n<li>lock<br>final transient ReentrantLock lock = new ReentrantLock();<br>使用ReentrantLock互斥可重入锁, 在向CopyOnWriteArrayList写入数据前, 首先获取锁, 然后才能继续。若获取不到, 则被阻塞。</li>\n<li>array<br>private transient volatile Object[] array;<br>真正存放数据的地方, 由Object可知, CopyOnWriteArrayList可以存放任何类型的对象。 这里使用了volatile属性, 确保该操作是原子可见的, 该线程添加元素对别的线程都是立刻可见的。<h2 id=\"添加数据add\"><a href=\"#添加数据add\" class=\"headerlink\" title=\"添加数据add\"></a>添加数据add</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">public boolean add(E e) &#123;</div><div class=\"line\">    final ReentrantLock lock = this.lock;</div><div class=\"line\">    lock.lock();</div><div class=\"line\">    try &#123;</div><div class=\"line\">        Object[] elements = getArray();</div><div class=\"line\">        int len = elements.length;</div><div class=\"line\">        Object[] newElements = Arrays.copyOf(elements, len + 1);</div><div class=\"line\">        newElements[len] = e;</div><div class=\"line\">        setArray(newElements);</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        lock.unlock();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先获取互斥可重入锁。 若获取不到, 则被阻塞。</li>\n<li>将原来数组元素copy到新的数组</li>\n<li>将新添加元素都放到数组newElements最后。</li>\n<li>替换原来数组elements<br>过程如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/CopyOnWriteArrayList.png\" height=\"300\" width=\"350\"><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2>CopyOnWriteArrayList在添加元素时, 需要获取锁, 可知互斥写入, 并发为1。 若多线程同时写入, 效率非常低下, 而且会出现线程复制数组而直接丢弃原来数组, 导致大量gc。CopyOnWriteArrayList主要在查多写少的情况下。</li>\n</ul>\n"},{"title":"ServerBootstrap初始篇","date":"2018-01-14T10:32:43.000Z","toc":true,"_content":"&emsp;本文将以一个最简单的netty服务器端代码进行讲解。\n# 服务器示例\n ```\n public class HelloServer {\n    /**\n     * 服务端监听的端口地址\n     */\n    private static final int portNumber = 7878;\n    public static void main(String[] args) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup,WorkGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.childHandler(new HelloServerInitializer());\n            ChannelFuture f = b.bind(portNumber).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nclass HelloServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override       //  ch = NioSocketChannel\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n        pipeline.addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n        // 自己的逻辑Handler\n        pipeline.addLast(\"handler\", new HelloServerHandler());\n    }\n}\n\nclass HelloServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n        // 收到消息直接打印输出\n        System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);\n        // 返回客户端消息 - 我已经接收到了你的消息\n        ctx.writeAndFlush(\"Received your message !\\n\");\n    }\n    /*\n     *\n     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)\n     *\n     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述\n     * */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");\n        super.channelActive(ctx);\n    }\n}\n ```\n # NioEventLoop和NioEventLoopGroup分析\n  + NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为`NettyRuntime.availableProcessors() * 2)`\n  + NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。\n\n# 一些概念对应关系\n  + 一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。\n  + NioEventLoop里面处理task的线程唯一。\n  + Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty%E6%A6%82%E5%BF%B5.png\" />\n\n\n# 具体过程分析\n ## 首先分析AbstractBootstrap.doBind()\n ```\n    private ChannelFuture doBind(final SocketAddress localAddress) {\n       final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel(); //NioServerSocketChannel\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            // At this point we know that the registration was complete and successful.\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            // Registration future is almost always fulfilled already, but just in case it's not.\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                        // IllegalStateException once we try to access the EventLoop of the Channel.\n                        promise.setFailure(cause);\n                    } else {\n                        // Registration was successful, so set the correct executor to use.\n                        // See https://github.com/netty/netty/issues/2586\n                        promise.registered();\n\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n    }\n```\n主要干的事:\n1. 生成并初始化NioServerSocketChannel,见initAndRegister():\n2. 检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见`doBind0`)。\n\ninitAndRegister()主要作用:\n(1) 生成一个NioServerSocketChannel, 实际使用的`SelectorProvider.provider().openServerSocketChannel()`;\nNioServerSocketChannel构造函数如下:\n```\n        this.parent = parent;\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe; 而NioServerSocketChannel对应着NioMessageUnsafe\n        unsafe = newUnsafe();\n        pipeline = newChannelPipeline();//// 初始化pipeline，\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false); //\n        } catch (IOException e) {\n            try {\n                ch.close();\n            } catch (IOException e2) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Failed to close a partially initialized socket.\", e2);\n                }\n            }\n            throw new ChannelException(\"Failed to enter non-blocking mode.\", e);\n        }\n```\n+ 每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:\n```\nthis.channel = ObjectUtil.checkNotNull(channel, \"channel\");\ntail = new TailContext(this);   //只是in\nhead = new HeadContext(this);  //只是out\n\nhead.next = tail;\ntail.prev = head;\n```\n基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。\n+ TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身\n+ ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())\n+ 将该channel设置为非block类型,这里是不是与NIO很像。\n(2) 调用channel()对channel初始化(见`分析init(channel)`)\n(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。\n\n&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。\n\n<font size=6>分析init(channel)</font>\n<p>代码实际会跑到ServerBootstrap.init():\n\n```\n            ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine\n            p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(final Channel ch) throws Exception {//NioServerSocketChannel\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n                ch.eventLoop().execute(new Runnable() {//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n```\n主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>此时, NioServerSocketChannel对应的pipeline中handler结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine.png\" height=\"200\" width=\"450\"/>\n\n<font size=6>p.addLast</font>\n<p>具体添加代码操作如下:\n\n```\n        synchronized (this) {\n            newCtx = newContext(group, filterName(name, handler), handler);\n            addLast0(newCtx);\n            if (!registered) {//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的\n                newCtx.setAddPending();\n                callHandlerCallbackLater(newCtx, true);\n                return this;\n            }\n            EventExecutor executor = newCtx.executor();\n            if (!executor.inEventLoop()) {\n                newCtx.setAddPending();\n                executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        callHandlerAdded0(newCtx);\n                    }\n                });\n                return this;\n            }\n        }\n        callHandlerAdded0(newCtx);\n        return this;\n```\n\n主要操作就是:\n+ 新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。\n+ 将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。\n+ 如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());\n  若注册了, 那么调用callHandlerAdded0()->ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:\n  ```\n  @SuppressWarnings(\"unchecked\")\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.\n            try {\n                initChannel((C) ctx.channel());\n            } catch (Throwable cause) {\n                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).\n                // We do so to prevent multiple calls to initChannel(...).\n                exceptionCaught(ctx, cause);\n            } finally {\n                remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型\n            }\n            return true;\n        }\n        return false;\n    }\n  ```\n  + 这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 把会向pipeLine添加ServerBootstrapAcceptor的操作当成一个task, 传递给NilEventLoop, 等待执行形成一个最终的handler链。 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。\n  + 这里还需要注意ChannelInitializer.remove(ctx)会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样NioServerSocketChannel对应的pipeline结构如下:\n  <img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine2.png\" height=\"200\" width=\"650\"/>\n\n<font size=6>register</font><p>\n根据`config().group().register(channel)`进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:\n当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。\n```\npublic EventExecutor next() {\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n```\n如何判断一个数是否为2^n呢, 方法如下:\n```\nprivate static boolean isPowerOfTwo(int val) {\n    return (val & -val) == val;\n}\n```\n选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:\n```\n            try {\n                // check if the channel is still open as it could be closed in the mean time when the register\n                // call was outside of the eventLoop\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n                doRegister();\n                neverRegistered = false;\n                registered = true;\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise);\n                pipeline.fireChannelRegistered();\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                // Close the channel directly to avoid FD leak.\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n```\ndoRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:\n```\n        for (;;) {\n            try {\n                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                    // cached and not removed because no Select.select(..) operation was called yet.\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    // We forced a select operation on the selector before but the SelectionKey is still cached\n                    // for whatever reason. JDK bug ?\n                    throw e;\n                }\n            }\n        }\n```\n这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。\n我们先了解NioServerSocketChannel与NioSocketChannel的继承关系:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ServerBootstrap1.png\" height=\"200\" width=\"450\"/>\n可以看到:\n+ NioServerSocketChannel在初始化时候就声明readInterestOp为OP_ACCEPT, 而NioSocketChannel在初始化时声明readInterestOp为OP_READ。\n+ NioServerSocketChannel对应NioMessage, 当bossdui对应的NioEventLoop为新的连接建立NioSocketChannel时, 都会进入NioMessage.read()进行初始化。当NioSocketChannel对应着NioByteUnsafe, 当work对应的NioSocketchannel接收到数据时, 会进入NioByteUnsafe.read()只来接收数据。\n\n继续回到register()上,  channel与selector完成register之后:\n1. 执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD->ServerBootstrapAcceptor->TAIL\n2. 执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:\n```\n boolean wasActive = isActive();\n            try {\n                 //doBind0最终调用channel.bind方法对执行端口进行绑定\n                doBind(localAddress);\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n            //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了\n            if (!wasActive && isActive()) {\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        //最终修改的是NioServerSocketChannel的可Accept属性\n                        pipeline.fireChannelActive();\n                    }\n                });\n            }\n```\nNioServerSocketChannel在初始化时只是将readInterestOp赋值为OP_ACCEPT, 而被注册感兴趣OP_ACCEPT是在这里, 真正调用了AbstractNioCHannel.doBeginRead来实现注册\n```\n    @Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine1.png\" height=\"300\" width=\"550\"/>\n其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:\n```\nnew ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)\n```\ncurrentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。\n\n","source":"_posts/ServerBootstrap初始篇.md","raw":"---\ntitle: ServerBootstrap初始篇\ndate: 2018-01-14 18:32:43\ntags: netty4, ServerBootstrap, Initiale\ntoc: true\n---\n&emsp;本文将以一个最简单的netty服务器端代码进行讲解。\n# 服务器示例\n ```\n public class HelloServer {\n    /**\n     * 服务端监听的端口地址\n     */\n    private static final int portNumber = 7878;\n    public static void main(String[] args) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup,WorkGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.childHandler(new HelloServerInitializer());\n            ChannelFuture f = b.bind(portNumber).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nclass HelloServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override       //  ch = NioSocketChannel\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n        pipeline.addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n        // 自己的逻辑Handler\n        pipeline.addLast(\"handler\", new HelloServerHandler());\n    }\n}\n\nclass HelloServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n        // 收到消息直接打印输出\n        System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);\n        // 返回客户端消息 - 我已经接收到了你的消息\n        ctx.writeAndFlush(\"Received your message !\\n\");\n    }\n    /*\n     *\n     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)\n     *\n     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述\n     * */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");\n        super.channelActive(ctx);\n    }\n}\n ```\n # NioEventLoop和NioEventLoopGroup分析\n  + NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为`NettyRuntime.availableProcessors() * 2)`\n  + NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。\n\n# 一些概念对应关系\n  + 一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。\n  + NioEventLoop里面处理task的线程唯一。\n  + Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty%E6%A6%82%E5%BF%B5.png\" />\n\n\n# 具体过程分析\n ## 首先分析AbstractBootstrap.doBind()\n ```\n    private ChannelFuture doBind(final SocketAddress localAddress) {\n       final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel(); //NioServerSocketChannel\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            // At this point we know that the registration was complete and successful.\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            // Registration future is almost always fulfilled already, but just in case it's not.\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                        // IllegalStateException once we try to access the EventLoop of the Channel.\n                        promise.setFailure(cause);\n                    } else {\n                        // Registration was successful, so set the correct executor to use.\n                        // See https://github.com/netty/netty/issues/2586\n                        promise.registered();\n\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n    }\n```\n主要干的事:\n1. 生成并初始化NioServerSocketChannel,见initAndRegister():\n2. 检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见`doBind0`)。\n\ninitAndRegister()主要作用:\n(1) 生成一个NioServerSocketChannel, 实际使用的`SelectorProvider.provider().openServerSocketChannel()`;\nNioServerSocketChannel构造函数如下:\n```\n        this.parent = parent;\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe; 而NioServerSocketChannel对应着NioMessageUnsafe\n        unsafe = newUnsafe();\n        pipeline = newChannelPipeline();//// 初始化pipeline，\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false); //\n        } catch (IOException e) {\n            try {\n                ch.close();\n            } catch (IOException e2) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Failed to close a partially initialized socket.\", e2);\n                }\n            }\n            throw new ChannelException(\"Failed to enter non-blocking mode.\", e);\n        }\n```\n+ 每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:\n```\nthis.channel = ObjectUtil.checkNotNull(channel, \"channel\");\ntail = new TailContext(this);   //只是in\nhead = new HeadContext(this);  //只是out\n\nhead.next = tail;\ntail.prev = head;\n```\n基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。\n+ TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身\n+ ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())\n+ 将该channel设置为非block类型,这里是不是与NIO很像。\n(2) 调用channel()对channel初始化(见`分析init(channel)`)\n(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。\n\n&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。\n\n<font size=6>分析init(channel)</font>\n<p>代码实际会跑到ServerBootstrap.init():\n\n```\n            ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine\n            p.addLast(new ChannelInitializer<Channel>() {\n            @Override\n            public void initChannel(final Channel ch) throws Exception {//NioServerSocketChannel\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n                ch.eventLoop().execute(new Runnable() {//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n```\n主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>此时, NioServerSocketChannel对应的pipeline中handler结构如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine.png\" height=\"200\" width=\"450\"/>\n\n<font size=6>p.addLast</font>\n<p>具体添加代码操作如下:\n\n```\n        synchronized (this) {\n            newCtx = newContext(group, filterName(name, handler), handler);\n            addLast0(newCtx);\n            if (!registered) {//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的\n                newCtx.setAddPending();\n                callHandlerCallbackLater(newCtx, true);\n                return this;\n            }\n            EventExecutor executor = newCtx.executor();\n            if (!executor.inEventLoop()) {\n                newCtx.setAddPending();\n                executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        callHandlerAdded0(newCtx);\n                    }\n                });\n                return this;\n            }\n        }\n        callHandlerAdded0(newCtx);\n        return this;\n```\n\n主要操作就是:\n+ 新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。\n+ 将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。\n+ 如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());\n  若注册了, 那么调用callHandlerAdded0()->ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:\n  ```\n  @SuppressWarnings(\"unchecked\")\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.\n            try {\n                initChannel((C) ctx.channel());\n            } catch (Throwable cause) {\n                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).\n                // We do so to prevent multiple calls to initChannel(...).\n                exceptionCaught(ctx, cause);\n            } finally {\n                remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型\n            }\n            return true;\n        }\n        return false;\n    }\n  ```\n  + 这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 把会向pipeLine添加ServerBootstrapAcceptor的操作当成一个task, 传递给NilEventLoop, 等待执行形成一个最终的handler链。 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。\n  + 这里还需要注意ChannelInitializer.remove(ctx)会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样NioServerSocketChannel对应的pipeline结构如下:\n  <img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine2.png\" height=\"200\" width=\"650\"/>\n\n<font size=6>register</font><p>\n根据`config().group().register(channel)`进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:\n当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。\n```\npublic EventExecutor next() {\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n```\n如何判断一个数是否为2^n呢, 方法如下:\n```\nprivate static boolean isPowerOfTwo(int val) {\n    return (val & -val) == val;\n}\n```\n选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:\n```\n            try {\n                // check if the channel is still open as it could be closed in the mean time when the register\n                // call was outside of the eventLoop\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n                doRegister();\n                neverRegistered = false;\n                registered = true;\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise);\n                pipeline.fireChannelRegistered();\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                // Close the channel directly to avoid FD leak.\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n```\ndoRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:\n```\n        for (;;) {\n            try {\n                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                    // cached and not removed because no Select.select(..) operation was called yet.\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    // We forced a select operation on the selector before but the SelectionKey is still cached\n                    // for whatever reason. JDK bug ?\n                    throw e;\n                }\n            }\n        }\n```\n这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。\n我们先了解NioServerSocketChannel与NioSocketChannel的继承关系:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ServerBootstrap1.png\" height=\"200\" width=\"450\"/>\n可以看到:\n+ NioServerSocketChannel在初始化时候就声明readInterestOp为OP_ACCEPT, 而NioSocketChannel在初始化时声明readInterestOp为OP_READ。\n+ NioServerSocketChannel对应NioMessage, 当bossdui对应的NioEventLoop为新的连接建立NioSocketChannel时, 都会进入NioMessage.read()进行初始化。当NioSocketChannel对应着NioByteUnsafe, 当work对应的NioSocketchannel接收到数据时, 会进入NioByteUnsafe.read()只来接收数据。\n\n继续回到register()上,  channel与selector完成register之后:\n1. 执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD->ServerBootstrapAcceptor->TAIL\n2. 执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:\n```\n boolean wasActive = isActive();\n            try {\n                 //doBind0最终调用channel.bind方法对执行端口进行绑定\n                doBind(localAddress);\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n            //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了\n            if (!wasActive && isActive()) {\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        //最终修改的是NioServerSocketChannel的可Accept属性\n                        pipeline.fireChannelActive();\n                    }\n                });\n            }\n```\nNioServerSocketChannel在初始化时只是将readInterestOp赋值为OP_ACCEPT, 而被注册感兴趣OP_ACCEPT是在这里, 真正调用了AbstractNioCHannel.doBeginRead来实现注册\n```\n    @Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n\n自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine1.png\" height=\"300\" width=\"550\"/>\n其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:\n```\nnew ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)\n```\ncurrentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。\n\n","slug":"ServerBootstrap初始篇","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xm0015phu5hy1incvd","content":"<p>&emsp;本文将以一个最简单的netty服务器端代码进行讲解。</p>\n<h1 id=\"服务器示例\"><a href=\"#服务器示例\" class=\"headerlink\" title=\"服务器示例\"></a>服务器示例</h1> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class HelloServer &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * 服务端监听的端口地址</div><div class=\"line\">     */</div><div class=\"line\">    private static final int portNumber = 7878;</div><div class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</div><div class=\"line\">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</div><div class=\"line\">        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ServerBootstrap b = new ServerBootstrap();</div><div class=\"line\">            b.group(bossGroup,WorkGroup);</div><div class=\"line\">            b.channel(NioServerSocketChannel.class);</div><div class=\"line\">            b.childHandler(new HelloServerInitializer());</div><div class=\"line\">            ChannelFuture f = b.bind(portNumber).sync();</div><div class=\"line\">            f.channel().closeFuture().sync();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            bossGroup.shutdownGracefully();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</div><div class=\"line\">    @Override       //  ch = NioSocketChannel</div><div class=\"line\">    protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</div><div class=\"line\">        pipeline.addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(4));</div><div class=\"line\">        pipeline.addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.UTF_8));</div><div class=\"line\">        pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</div><div class=\"line\">        // 自己的逻辑Handler</div><div class=\"line\">        pipeline.addLast(&quot;handler&quot;, new HelloServerHandler());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</div><div class=\"line\">        // 收到消息直接打印输出</div><div class=\"line\">        System.out.println(ctx.channel().remoteAddress() + &quot; Say : &quot; + msg);</div><div class=\"line\">        // 返回客户端消息 - 我已经接收到了你的消息</div><div class=\"line\">        ctx.writeAndFlush(&quot;Received your message !\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">     *</div><div class=\"line\">     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)</div><div class=\"line\">     *</div><div class=\"line\">     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述</div><div class=\"line\">     * */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">        ctx.writeAndFlush(&quot;Welcome to &quot; + InetAddress.getLocalHost().getHostName() + &quot; service!\\n&quot;);</div><div class=\"line\">        super.channelActive(ctx);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"NioEventLoop和NioEventLoopGroup分析\"><a href=\"#NioEventLoop和NioEventLoopGroup分析\" class=\"headerlink\" title=\"NioEventLoop和NioEventLoopGroup分析\"></a>NioEventLoop和NioEventLoopGroup分析</h1><ul>\n<li>NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为<code>NettyRuntime.availableProcessors() * 2)</code></li>\n<li>NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。</li>\n</ul>\n<h1 id=\"一些概念对应关系\"><a href=\"#一些概念对应关系\" class=\"headerlink\" title=\"一些概念对应关系\"></a>一些概念对应关系</h1><ul>\n<li>一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。</li>\n<li>NioEventLoop里面处理task的线程唯一。</li>\n<li>Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty%E6%A6%82%E5%BF%B5.png\"></li>\n</ul>\n<h1 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h1><h2 id=\"首先分析AbstractBootstrap-doBind\"><a href=\"#首先分析AbstractBootstrap-doBind\" class=\"headerlink\" title=\"首先分析AbstractBootstrap.doBind()\"></a>首先分析AbstractBootstrap.doBind()</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</div><div class=\"line\">   final ChannelFuture regFuture = initAndRegister();</div><div class=\"line\">    final Channel channel = regFuture.channel(); //NioServerSocketChannel</div><div class=\"line\">    if (regFuture.cause() != null) &#123;</div><div class=\"line\">        return regFuture;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (regFuture.isDone()) &#123;</div><div class=\"line\">        // At this point we know that the registration was complete and successful.</div><div class=\"line\">        ChannelPromise promise = channel.newPromise();</div><div class=\"line\">        doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">        return promise;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Registration future is almost always fulfilled already, but just in case it&apos;s not.</div><div class=\"line\">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</div><div class=\"line\">        regFuture.addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                Throwable cause = future.cause();</div><div class=\"line\">                if (cause != null) &#123;</div><div class=\"line\">                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</div><div class=\"line\">                    // IllegalStateException once we try to access the EventLoop of the Channel.</div><div class=\"line\">                    promise.setFailure(cause);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Registration was successful, so set the correct executor to use.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/2586</div><div class=\"line\">                    promise.registered();</div><div class=\"line\"></div><div class=\"line\">                    doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要干的事:</p>\n<ol>\n<li>生成并初始化NioServerSocketChannel,见initAndRegister():</li>\n<li>检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见<code>doBind0</code>)。</li>\n</ol>\n<p>initAndRegister()主要作用:<br>(1) 生成一个NioServerSocketChannel, 实际使用的<code>SelectorProvider.provider().openServerSocketChannel()</code>;<br>NioServerSocketChannel构造函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.parent = parent;</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">// 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe; 而NioServerSocketChannel对应着NioMessageUnsafe</div><div class=\"line\">unsafe = newUnsafe();</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline，</div><div class=\"line\">this.ch = ch;</div><div class=\"line\">this.readInterestOp = readInterestOp;</div><div class=\"line\">try &#123;</div><div class=\"line\">    ch.configureBlocking(false); //</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        ch.close();</div><div class=\"line\">    &#125; catch (IOException e2) &#123;</div><div class=\"line\">        if (logger.isWarnEnabled()) &#123;</div><div class=\"line\">            logger.warn(</div><div class=\"line\">                    &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class=\"line\">tail = new TailContext(this);   //只是in</div><div class=\"line\">head = new HeadContext(this);  //只是out</div><div class=\"line\"></div><div class=\"line\">head.next = tail;</div><div class=\"line\">tail.prev = head;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。</p>\n<ul>\n<li>TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身</li>\n<li>ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())</li>\n<li>将该channel设置为非block类型,这里是不是与NIO很像。<br>(2) 调用channel()对channel初始化(见<code>分析init(channel)</code>)<br>(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。</li>\n</ul>\n<p>&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。</p>\n<p><font size=\"6\">分析init(channel)</font></p>\n<p></p><p>代码实际会跑到ServerBootstrap.init():</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine</div><div class=\"line\">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void initChannel(final Channel ch) throws Exception &#123;//NioServerSocketChannel</div><div class=\"line\">        final ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        ChannelHandler handler = config.handler();</div><div class=\"line\">        if (handler != null) &#123;</div><div class=\"line\">            pipeline.addLast(handler);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ch.eventLoop().execute(new Runnable() &#123;//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                pipeline.addLast(new ServerBootstrapAcceptor(</div><div class=\"line\">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>此时, NioServerSocketChannel对应的pipeline中handler结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine.png\" height=\"200\" width=\"450\"></p>\n<p><font size=\"6\">p.addLast</font></p>\n<p></p><p>具体添加代码操作如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">    newCtx = newContext(group, filterName(name, handler), handler);</div><div class=\"line\">    addLast0(newCtx);</div><div class=\"line\">    if (!registered) &#123;//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        callHandlerCallbackLater(newCtx, true);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    EventExecutor executor = newCtx.executor();</div><div class=\"line\">    if (!executor.inEventLoop()) &#123;</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        executor.execute(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                callHandlerAdded0(newCtx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">callHandlerAdded0(newCtx);</div><div class=\"line\">return this;</div></pre></td></tr></table></figure>\n<p>主要操作就是:</p>\n<ul>\n<li>新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。</li>\n<li>将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。</li>\n<li><p>如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());<br>若注册了, 那么调用callHandlerAdded0()-&gt;ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">  private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">      if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              initChannel((C) ctx.channel());</div><div class=\"line\">          &#125; catch (Throwable cause) &#123;</div><div class=\"line\">              // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</div><div class=\"line\">              // We do so to prevent multiple calls to initChannel(...).</div><div class=\"line\">              exceptionCaught(ctx, cause);</div><div class=\"line\">          &#125; finally &#123;</div><div class=\"line\">              remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型</div><div class=\"line\">          &#125;</div><div class=\"line\">          return true;</div><div class=\"line\">      &#125;</div><div class=\"line\">      return false;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 把会向pipeLine添加ServerBootstrapAcceptor的操作当成一个task, 传递给NilEventLoop, 等待执行形成一个最终的handler链。 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。</li>\n<li>这里还需要注意ChannelInitializer.remove(ctx)会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样NioServerSocketChannel对应的pipeline结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine2.png\" height=\"200\" width=\"650\"></li>\n</ul>\n</li>\n</ul>\n<p><font size=\"6\">register</font></p><p><br>根据<code>config().group().register(channel)</code>进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:<br>当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor next() &#123;</div><div class=\"line\">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如何判断一个数是否为2^n呢, 方法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isPowerOfTwo(int val) &#123;</div><div class=\"line\">    return (val &amp; -val) == val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    // check if the channel is still open as it could be closed in the mean time when the register</div><div class=\"line\">    // call was outside of the eventLoop</div><div class=\"line\">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean firstRegistration = neverRegistered;</div><div class=\"line\">    doRegister();</div><div class=\"line\">    neverRegistered = false;</div><div class=\"line\">    registered = true;</div><div class=\"line\">    pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">    safeSetSuccess(promise);</div><div class=\"line\">    pipeline.fireChannelRegistered();</div><div class=\"line\">    // Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">    // multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">    if (isActive()) &#123;</div><div class=\"line\">        if (firstRegistration) &#123;</div><div class=\"line\">            pipeline.fireChannelActive();</div><div class=\"line\">        &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">            // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">            // again so that we process inbound data.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">            beginRead();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">    // Close the channel directly to avoid FD leak.</div><div class=\"line\">    closeForcibly();</div><div class=\"line\">    closeFuture.setClosed();</div><div class=\"line\">    safeSetFailure(promise, t);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>doRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        if (!selected) &#123;</div><div class=\"line\">            // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</div><div class=\"line\">            // cached and not removed because no Select.select(..) operation was called yet.</div><div class=\"line\">            eventLoop().selectNow();</div><div class=\"line\">            selected = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We forced a select operation on the selector before but the SelectionKey is still cached</div><div class=\"line\">            // for whatever reason. JDK bug ?</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。<br>我们先了解NioServerSocketChannel与NioSocketChannel的继承关系:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ServerBootstrap1.png\" height=\"200\" width=\"450\"><br>可以看到:</p>\n<ul>\n<li>NioServerSocketChannel在初始化时候就声明readInterestOp为OP_ACCEPT, 而NioSocketChannel在初始化时声明readInterestOp为OP_READ。</li>\n<li>NioServerSocketChannel对应NioMessage, 当bossdui对应的NioEventLoop为新的连接建立NioSocketChannel时, 都会进入NioMessage.read()进行初始化。当NioSocketChannel对应着NioByteUnsafe, 当work对应的NioSocketchannel接收到数据时, 会进入NioByteUnsafe.read()只来接收数据。</li>\n</ul>\n<p>继续回到register()上,  channel与selector完成register之后:</p>\n<ol>\n<li>执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD-&gt;ServerBootstrapAcceptor-&gt;TAIL</li>\n<li>执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean wasActive = isActive();</div><div class=\"line\">           try &#123;</div><div class=\"line\">                //doBind0最终调用channel.bind方法对执行端口进行绑定</div><div class=\"line\">               doBind(localAddress);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">               safeSetFailure(promise, t);</div><div class=\"line\">               closeIfClosed();</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了</div><div class=\"line\">           if (!wasActive &amp;&amp; isActive()) &#123;</div><div class=\"line\">               invokeLater(new Runnable() &#123;</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void run() &#123;</div><div class=\"line\">                       //最终修改的是NioServerSocketChannel的可Accept属性</div><div class=\"line\">                       pipeline.fireChannelActive();</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>NioServerSocketChannel在初始化时只是将readInterestOp赋值为OP_ACCEPT, 而被注册感兴趣OP_ACCEPT是在这里, 真正调用了AbstractNioCHannel.doBeginRead来实现注册<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">    // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">    final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">    if (!selectionKey.isValid()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    readPending = true;</div><div class=\"line\"></div><div class=\"line\">    final int interestOps = selectionKey.interestOps();</div><div class=\"line\">    if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine1.png\" height=\"300\" width=\"550\"><br>其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)</div></pre></td></tr></table></figure></p>\n<p>currentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&emsp;本文将以一个最简单的netty服务器端代码进行讲解。</p>\n<h1 id=\"服务器示例\"><a href=\"#服务器示例\" class=\"headerlink\" title=\"服务器示例\"></a>服务器示例</h1> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class HelloServer &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * 服务端监听的端口地址</div><div class=\"line\">     */</div><div class=\"line\">    private static final int portNumber = 7878;</div><div class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</div><div class=\"line\">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</div><div class=\"line\">        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ServerBootstrap b = new ServerBootstrap();</div><div class=\"line\">            b.group(bossGroup,WorkGroup);</div><div class=\"line\">            b.channel(NioServerSocketChannel.class);</div><div class=\"line\">            b.childHandler(new HelloServerInitializer());</div><div class=\"line\">            ChannelFuture f = b.bind(portNumber).sync();</div><div class=\"line\">            f.channel().closeFuture().sync();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            bossGroup.shutdownGracefully();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</div><div class=\"line\">    @Override       //  ch = NioSocketChannel</div><div class=\"line\">    protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</div><div class=\"line\">        pipeline.addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(4));</div><div class=\"line\">        pipeline.addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.UTF_8));</div><div class=\"line\">        pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</div><div class=\"line\">        // 自己的逻辑Handler</div><div class=\"line\">        pipeline.addLast(&quot;handler&quot;, new HelloServerHandler());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</div><div class=\"line\">        // 收到消息直接打印输出</div><div class=\"line\">        System.out.println(ctx.channel().remoteAddress() + &quot; Say : &quot; + msg);</div><div class=\"line\">        // 返回客户端消息 - 我已经接收到了你的消息</div><div class=\"line\">        ctx.writeAndFlush(&quot;Received your message !\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">     *</div><div class=\"line\">     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)</div><div class=\"line\">     *</div><div class=\"line\">     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述</div><div class=\"line\">     * */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">        ctx.writeAndFlush(&quot;Welcome to &quot; + InetAddress.getLocalHost().getHostName() + &quot; service!\\n&quot;);</div><div class=\"line\">        super.channelActive(ctx);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"NioEventLoop和NioEventLoopGroup分析\"><a href=\"#NioEventLoop和NioEventLoopGroup分析\" class=\"headerlink\" title=\"NioEventLoop和NioEventLoopGroup分析\"></a>NioEventLoop和NioEventLoopGroup分析</h1><ul>\n<li>NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为<code>NettyRuntime.availableProcessors() * 2)</code></li>\n<li>NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。</li>\n</ul>\n<h1 id=\"一些概念对应关系\"><a href=\"#一些概念对应关系\" class=\"headerlink\" title=\"一些概念对应关系\"></a>一些概念对应关系</h1><ul>\n<li>一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。</li>\n<li>NioEventLoop里面处理task的线程唯一。</li>\n<li>Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/Netty%E6%A6%82%E5%BF%B5.png\"></li>\n</ul>\n<h1 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h1><h2 id=\"首先分析AbstractBootstrap-doBind\"><a href=\"#首先分析AbstractBootstrap-doBind\" class=\"headerlink\" title=\"首先分析AbstractBootstrap.doBind()\"></a>首先分析AbstractBootstrap.doBind()</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">private ChannelFuture doBind(final SocketAddress localAddress) &#123;</div><div class=\"line\">   final ChannelFuture regFuture = initAndRegister();</div><div class=\"line\">    final Channel channel = regFuture.channel(); //NioServerSocketChannel</div><div class=\"line\">    if (regFuture.cause() != null) &#123;</div><div class=\"line\">        return regFuture;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (regFuture.isDone()) &#123;</div><div class=\"line\">        // At this point we know that the registration was complete and successful.</div><div class=\"line\">        ChannelPromise promise = channel.newPromise();</div><div class=\"line\">        doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">        return promise;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        // Registration future is almost always fulfilled already, but just in case it&apos;s not.</div><div class=\"line\">        final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</div><div class=\"line\">        regFuture.addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                Throwable cause = future.cause();</div><div class=\"line\">                if (cause != null) &#123;</div><div class=\"line\">                    // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</div><div class=\"line\">                    // IllegalStateException once we try to access the EventLoop of the Channel.</div><div class=\"line\">                    promise.setFailure(cause);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Registration was successful, so set the correct executor to use.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/2586</div><div class=\"line\">                    promise.registered();</div><div class=\"line\"></div><div class=\"line\">                    doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return promise;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>主要干的事:</p>\n<ol>\n<li>生成并初始化NioServerSocketChannel,见initAndRegister():</li>\n<li>检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见<code>doBind0</code>)。</li>\n</ol>\n<p>initAndRegister()主要作用:<br>(1) 生成一个NioServerSocketChannel, 实际使用的<code>SelectorProvider.provider().openServerSocketChannel()</code>;<br>NioServerSocketChannel构造函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.parent = parent;</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">// 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe; 而NioServerSocketChannel对应着NioMessageUnsafe</div><div class=\"line\">unsafe = newUnsafe();</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline，</div><div class=\"line\">this.ch = ch;</div><div class=\"line\">this.readInterestOp = readInterestOp;</div><div class=\"line\">try &#123;</div><div class=\"line\">    ch.configureBlocking(false); //</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        ch.close();</div><div class=\"line\">    &#125; catch (IOException e2) &#123;</div><div class=\"line\">        if (logger.isWarnEnabled()) &#123;</div><div class=\"line\">            logger.warn(</div><div class=\"line\">                    &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class=\"line\">tail = new TailContext(this);   //只是in</div><div class=\"line\">head = new HeadContext(this);  //只是out</div><div class=\"line\"></div><div class=\"line\">head.next = tail;</div><div class=\"line\">tail.prev = head;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。</p>\n<ul>\n<li>TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身</li>\n<li>ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())</li>\n<li>将该channel设置为非block类型,这里是不是与NIO很像。<br>(2) 调用channel()对channel初始化(见<code>分析init(channel)</code>)<br>(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。</li>\n</ul>\n<p>&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。</p>\n<p><font size=\"6\">分析init(channel)</font></p>\n<p></p><p>代码实际会跑到ServerBootstrap.init():</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine</div><div class=\"line\">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    public void initChannel(final Channel ch) throws Exception &#123;//NioServerSocketChannel</div><div class=\"line\">        final ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        ChannelHandler handler = config.handler();</div><div class=\"line\">        if (handler != null) &#123;</div><div class=\"line\">            pipeline.addLast(handler);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ch.eventLoop().execute(new Runnable() &#123;//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                pipeline.addLast(new ServerBootstrapAcceptor(</div><div class=\"line\">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>此时, NioServerSocketChannel对应的pipeline中handler结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine.png\" height=\"200\" width=\"450\"></p>\n<p><font size=\"6\">p.addLast</font></p>\n<p></p><p>具体添加代码操作如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">    newCtx = newContext(group, filterName(name, handler), handler);</div><div class=\"line\">    addLast0(newCtx);</div><div class=\"line\">    if (!registered) &#123;//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        callHandlerCallbackLater(newCtx, true);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    EventExecutor executor = newCtx.executor();</div><div class=\"line\">    if (!executor.inEventLoop()) &#123;</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        executor.execute(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                callHandlerAdded0(newCtx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">callHandlerAdded0(newCtx);</div><div class=\"line\">return this;</div></pre></td></tr></table></figure>\n<p>主要操作就是:</p>\n<ul>\n<li>新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。</li>\n<li>将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。</li>\n<li><p>如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());<br>若注册了, 那么调用callHandlerAdded0()-&gt;ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">  private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">      if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              initChannel((C) ctx.channel());</div><div class=\"line\">          &#125; catch (Throwable cause) &#123;</div><div class=\"line\">              // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</div><div class=\"line\">              // We do so to prevent multiple calls to initChannel(...).</div><div class=\"line\">              exceptionCaught(ctx, cause);</div><div class=\"line\">          &#125; finally &#123;</div><div class=\"line\">              remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型</div><div class=\"line\">          &#125;</div><div class=\"line\">          return true;</div><div class=\"line\">      &#125;</div><div class=\"line\">      return false;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 把会向pipeLine添加ServerBootstrapAcceptor的操作当成一个task, 传递给NilEventLoop, 等待执行形成一个最终的handler链。 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。</li>\n<li>这里还需要注意ChannelInitializer.remove(ctx)会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样NioServerSocketChannel对应的pipeline结构如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine2.png\" height=\"200\" width=\"650\"></li>\n</ul>\n</li>\n</ul>\n<p><font size=\"6\">register</font></p><p><br>根据<code>config().group().register(channel)</code>进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:<br>当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor next() &#123;</div><div class=\"line\">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如何判断一个数是否为2^n呢, 方法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isPowerOfTwo(int val) &#123;</div><div class=\"line\">    return (val &amp; -val) == val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    // check if the channel is still open as it could be closed in the mean time when the register</div><div class=\"line\">    // call was outside of the eventLoop</div><div class=\"line\">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean firstRegistration = neverRegistered;</div><div class=\"line\">    doRegister();</div><div class=\"line\">    neverRegistered = false;</div><div class=\"line\">    registered = true;</div><div class=\"line\">    pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">    safeSetSuccess(promise);</div><div class=\"line\">    pipeline.fireChannelRegistered();</div><div class=\"line\">    // Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">    // multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">    if (isActive()) &#123;</div><div class=\"line\">        if (firstRegistration) &#123;</div><div class=\"line\">            pipeline.fireChannelActive();</div><div class=\"line\">        &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">            // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">            // again so that we process inbound data.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">            beginRead();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">    // Close the channel directly to avoid FD leak.</div><div class=\"line\">    closeForcibly();</div><div class=\"line\">    closeFuture.setClosed();</div><div class=\"line\">    safeSetFailure(promise, t);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>doRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        if (!selected) &#123;</div><div class=\"line\">            // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</div><div class=\"line\">            // cached and not removed because no Select.select(..) operation was called yet.</div><div class=\"line\">            eventLoop().selectNow();</div><div class=\"line\">            selected = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We forced a select operation on the selector before but the SelectionKey is still cached</div><div class=\"line\">            // for whatever reason. JDK bug ?</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。<br>我们先了解NioServerSocketChannel与NioSocketChannel的继承关系:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/ServerBootstrap1.png\" height=\"200\" width=\"450\"><br>可以看到:</p>\n<ul>\n<li>NioServerSocketChannel在初始化时候就声明readInterestOp为OP_ACCEPT, 而NioSocketChannel在初始化时声明readInterestOp为OP_READ。</li>\n<li>NioServerSocketChannel对应NioMessage, 当bossdui对应的NioEventLoop为新的连接建立NioSocketChannel时, 都会进入NioMessage.read()进行初始化。当NioSocketChannel对应着NioByteUnsafe, 当work对应的NioSocketchannel接收到数据时, 会进入NioByteUnsafe.read()只来接收数据。</li>\n</ul>\n<p>继续回到register()上,  channel与selector完成register之后:</p>\n<ol>\n<li>执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD-&gt;ServerBootstrapAcceptor-&gt;TAIL</li>\n<li>执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean wasActive = isActive();</div><div class=\"line\">           try &#123;</div><div class=\"line\">                //doBind0最终调用channel.bind方法对执行端口进行绑定</div><div class=\"line\">               doBind(localAddress);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">               safeSetFailure(promise, t);</div><div class=\"line\">               closeIfClosed();</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了</div><div class=\"line\">           if (!wasActive &amp;&amp; isActive()) &#123;</div><div class=\"line\">               invokeLater(new Runnable() &#123;</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void run() &#123;</div><div class=\"line\">                       //最终修改的是NioServerSocketChannel的可Accept属性</div><div class=\"line\">                       pipeline.fireChannelActive();</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>NioServerSocketChannel在初始化时只是将readInterestOp赋值为OP_ACCEPT, 而被注册感兴趣OP_ACCEPT是在这里, 真正调用了AbstractNioCHannel.doBeginRead来实现注册<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">    // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">    final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">    if (!selectionKey.isValid()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    readPending = true;</div><div class=\"line\"></div><div class=\"line\">    final int interestOps = selectionKey.interestOps();</div><div class=\"line\">    if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">        selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/PipeLine1.png\" height=\"300\" width=\"550\"><br>其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)</div></pre></td></tr></table></figure></p>\n<p>currentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。</p>\n"},{"title":"maven插件学习","date":"2019-07-06T05:32:36.000Z","_content":"","source":"_posts/maven插件学习.md","raw":"---\ntitle: maven插件学习\ndate: 2019-07-06 13:32:36\ntags:\n---\n","slug":"maven插件学习","published":1,"updated":"2019-07-06T05:32:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xp0017phu52rbo5u6c","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"gdb调试java基本用法","date":"2016-12-20T07:56:11.000Z","toc":true,"_content":"jvm进程崩溃时, 可以产生coredump文件, 该dump文件记录了崩溃时cpu、jvm当前线程、当前内存的使用情况, 学会分析该coredump对于我们排查问题十分重要, 本文将主要讲解如何通过gdb分析该coredump文件。\n## coredump产生\n第一步检查系统是否允许产生coredump文件\n操作系统默认禁止coredump文件的产生, 可以通过`ulimit -c`查看是否允许产生coredump文件, 若显示为0, 则禁止线程崩溃时产生该core文件, 可以通过`echo \"ulimit  -c unlimited\" >> /etc/profile`. 我们也可以通过cat /pro/$pid/limits 查看设置情况\n```\nLimit                     Soft Limit           Hard Limit           Units\nMax cpu time              unlimited            unlimited            seconds\nMax file size             unlimited            unlimited            bytes\nMax data size             unlimited            unlimited            bytes\nMax stack size            8388608              unlimited            bytes\nMax core file size        unlimited            unlimited            bytes\nMax resident set          unlimited            unlimited            bytes\nMax processes             23262                23262                processes\nMax open files            4096                 4096                 files\nMax locked memory         65536                65536                bytes\nMax address space         unlimited            unlimited            bytes\nMax file locks            unlimited            unlimited            locks\nMax pending signals       23262                23262                signals\nMax msgqueue size         819200               819200               bytes\nMax nice priority         0                    0\nMax realtime priority     0                    0\nMax realtime timeout      unlimited            unlimited            us\n```\n可以看到Max core file size设置为unlimited, 是运行产生core 文件的。\n第二步, 通过kill -6 pid 向进程发送abort信号产生core文件(默认文件名称)。\n## gdb基本使用\n\n|命令|简写|说明|\n|:-|:-|:-|\n|list|l|显示多行源代码|\n|break|b|设置断点,程序运行到断点的位置会停下来|\n|info|i|描述程序的状态|\n|run||r|开始运行程序\n|display|disp|跟踪查看某个变量,每次停下来都显示它的值|\n|step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句|\n|next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)|\n|print|p|打印内部变量值|\n|continue|c|继续程序的运行,直到遇到下一个断点|\n|set var name=v||设置变量的值|\n|start|st|开始执行程序,在main函数的第一条语句前面停下来|\n|file||装入需要调试的程序|\n|kill|k|终止正在调试的程序|\n|watch||监视变量值的变化|\n|backtrace|bt|产看函数调用信息(堆栈)|\n|frame|f|查看栈帧, 比如打印当前线程栈第5行详细信息: f 5|\n|quit|q|退出GDB环境|\n(参考<a href=\"https://blog.csdn.net/zdy0_2004/article/details/80102076\">gdb调试的基本使用</a>)\n\n## 分析coredump文件\n+ gdb java core\n调用如上命令加载core文件(这里的core指的是core文件名称)。\n1. 执行`info threads`\n```\n#0  0xb776b424 in __kernel_vsyscall ()\n(gdb) info threads\n  Id   Target Id         Frame\n  12   Thread 0xb6a84b40 (LWP 5553) 0xb776b424 in __kernel_vsyscall ()\n  11   Thread 0xad2ffb40 (LWP 5563) 0xb776b424 in __kernel_vsyscall ()\n  10   Thread 0xad350b40 (LWP 5562) 0xb776b424 in __kernel_vsyscall ()\n  9    Thread 0xad3d1b40 (LWP 5561) 0xb776b424 in __kernel_vsyscall ()\n  8    Thread 0xad422b40 (LWP 5560) 0xb776b424 in __kernel_vsyscall ()\n  7    Thread 0xad473b40 (LWP 5559) 0xb776b424 in __kernel_vsyscall ()\n  6    Thread 0xad6c4b40 (LWP 5558) 0xb776b424 in __kernel_vsyscall ()\n  5    Thread 0xad715b40 (LWP 5557) 0xb776b424 in __kernel_vsyscall ()\n  4    Thread 0xad796b40 (LWP 5556) 0xb776b424 in __kernel_vsyscall ()\n  3    Thread 0xadee6b40 (LWP 5555) 0xb776b424 in __kernel_vsyscall ()\n  2    Thread 0xb4817b40 (LWP 5554) 0xb776b424 in __kernel_vsyscall ()\n* 1    Thread 0xb756f700 (LWP 5552) 0xb776b424 in __kernel_vsyscall ()\n(gdb)\n```\n这里将展示目前已知的所有线程, *开头的代表当前处于调试的线程。这里可以通过输入info可以查看所有的命令。 切换当前调试线程可以通过`thread ID`方式, id取值上图第一列。其实我们查看每个线程在干什么, 也可以直接使用`pstack pid`即可\n2. 假如想查看id为1的线程当前栈调用情况, 那么执行继续`bt`\n```\n#0  0xb776b424 in __kernel_vsyscall ()\n(gdb) bt\n#0  0xb776b424 in __kernel_vsyscall ()\n#1  0xb7742178 in pthread_join (threadid=3064482624, thread_return=0xbfb1b944) at pthread_join.c:92\n#2  0xb772eeda in ContinueInNewThread0 () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#3  0xb772a266 in ContinueInNewThread () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#4  0xb772edab in JVMInit () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#5  0xb772d149 in JLI_Launch () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#6  0x0804858d in main ()\n```\n3. 查看每个register值\n```\n        0xfffffe00\t-512\necx            0x0\t0\nedx            0x25d5\t9685\nebx            0xb6a5dba8\t-1230644312\nesp            0xbfd1a6e0\t0xbfd1a6e0\nebp            0xb6a5db40\t0xb6a5db40\nesi            0x0\t0\nedi            0xb772c000\t-1217216512\neip            0xb7744424\t0xb7744424 <__kernel_vsyscall+16>\neflags         0x246\t[ PF ZF IF ]\n......\n```\n左边是寄存器名称, 中间是寄存器地址, 右边是寄存器值, 可以通过`print $ecx`验证寄存器值\n+ 查看反汇编语言\n```\n(gdb) disassemble\nDump of assembler code for function __kernel_vsyscall:\n   0xb7744414 <+0>:\tpush   %ecx\n   0xb7744415 <+1>:\tpush   %edx\n   0xb7744416 <+2>:\tpush   %ebp\n   0xb7744417 <+3>:\tmov    %esp,%ebp\n   0xb7744419 <+5>:\tsysenter\n   0xb774441b <+7>:\tnop\n   0xb774441c <+8>:\tnop\n   0xb774441d <+9>:\tnop\n   0xb774441e <+10>:\tnop\n   0xb774441f <+11>:\tnop\n   0xb7744420 <+12>:\tnop\n   0xb7744421 <+13>:\tnop\n   0xb7744422 <+14>:\tint    $0x80\n=> 0xb7744424 <+16>:\tpop    %ebp\n   0xb7744425 <+17>:\tpop    %edx\n   0xb7744426 <+18>:\tpop    %ecx\n   0xb7744427 <+19>:\tret\nEnd of assembler dump.\n```\n也可以反汇编一个函数`disass func_name`, 如下:\n```\n(gdb) disass main\nDump of assembler code for function main:\n   0x0000000000400620 <+0>:\tpush   %rbp\n   0x0000000000400621 <+1>:\tmov    %rsp,%rbp\n   0x0000000000400624 <+4>:\tsub    $0x40,%rsp\n   0x0000000000400628 <+8>:\tmov    0x200271(%rip),%rdx        # 0x6008a0 <const_launcher>\n   0x000000000040062f <+15>:\ttest   %rdx,%rdx\n   0x0000000000400632 <+18>:\tje     0x4006a0 <main+128>\n   0x0000000000400634 <+20>:\tmov    0x20026d(%rip),%rax        # 0x6008a8 <const_progname>\n   0x000000000040063b <+27>:\ttest   %rax,%rax\n   0x000000000040063e <+30>:\tje     0x4006b0 <main+144>\n   0x0000000000400640 <+32>:\tmov    %rax,0x10(%rsp)\n```\n+ 查看当前线程情况\n```\nxxxxxx@slave1:~$jstack /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core\nAttaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...\nDebugger attached successfully.\nClient compiler detected.\nJVM version is 25.121-b13\nDeadlock Detection:\n\nNo deadlocks found.\n\nThread 9692: (state = BLOCKED)\n\n\nThread 9691: (state = BLOCKED)\n\n\nThread 9690: (state = BLOCKED)\n - java.lang.Object.wait(long) @bci=0 (Interpreted frame)\n - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)\n - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)\n - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)\n......\n```\n注意java命令的路径不能省略, 否则会报如下异常:\n```\nAttaching to core core from executable java, please wait...\nError attaching to core file: cannot open binary file\nsun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\n\tat sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach0(Native Method)\n```\n+ 查看当前内存使用\n```\nxxxxx@slave1:~$ jmap /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core\nAttaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...\nDebugger attached successfully.\nClient compiler detected.\nJVM version is 25.121-b13\n0x08048000\t5K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java\n0xb7713000\t127K\t/lib/i386-linux-gnu/libpthread.so.0\n0xb76fd000\t93K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n0xb76f8000\t13K\t/lib/i386-linux-gnu/libdl.so.2\n0xb7549000\t1717K\t/lib/i386-linux-gnu/libc.so.6\n0xb7745000\t131K\t/lib/ld-linux.so.2\n0xb6aa4000\t8162K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/client/libjvm.so\n0xb6a5e000\t273K\t/lib/i386-linux-gnu/libm.so.6\n0xb6a04000\t29K\t/lib/i386-linux-gnu/librt.so.1\n0xb7736000\t54K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libverify.so\n0xb68db000\t187K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libjava.so\n0xb68bf000\t29K\t/lib/i386-linux-gnu/libnss_compat.so.2\n0xb68a6000\t89K\t/lib/i386-linux-gnu/libnsl.so.1\n0xb689a000\t41K\t/lib/i386-linux-gnu/libnss_nis.so.2\n0xb688d000\t45K\t/lib/i386-linux-gnu/libnss_files.so.2\n0xb6873000\t114K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libzip.so\n```\n\n+ 通过core文件产生heapdump文件\n`xxxxx@slave1:~$ jmap -dump:format=b,file=dump.hprof $JAVA_HOME/bin/java core`\n\n# dump内存区域\n\n\n# 参考\nhttps://blog.csdn.net/zdy0_2004/article/details/80102076\nhttps://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html","source":"_posts/gdb调试java基本用法.md","raw":"---\ntitle: gdb调试java基本用法\ndate: 2016-12-20 15:56:11\ntags: gdb\ntoc: true\n---\njvm进程崩溃时, 可以产生coredump文件, 该dump文件记录了崩溃时cpu、jvm当前线程、当前内存的使用情况, 学会分析该coredump对于我们排查问题十分重要, 本文将主要讲解如何通过gdb分析该coredump文件。\n## coredump产生\n第一步检查系统是否允许产生coredump文件\n操作系统默认禁止coredump文件的产生, 可以通过`ulimit -c`查看是否允许产生coredump文件, 若显示为0, 则禁止线程崩溃时产生该core文件, 可以通过`echo \"ulimit  -c unlimited\" >> /etc/profile`. 我们也可以通过cat /pro/$pid/limits 查看设置情况\n```\nLimit                     Soft Limit           Hard Limit           Units\nMax cpu time              unlimited            unlimited            seconds\nMax file size             unlimited            unlimited            bytes\nMax data size             unlimited            unlimited            bytes\nMax stack size            8388608              unlimited            bytes\nMax core file size        unlimited            unlimited            bytes\nMax resident set          unlimited            unlimited            bytes\nMax processes             23262                23262                processes\nMax open files            4096                 4096                 files\nMax locked memory         65536                65536                bytes\nMax address space         unlimited            unlimited            bytes\nMax file locks            unlimited            unlimited            locks\nMax pending signals       23262                23262                signals\nMax msgqueue size         819200               819200               bytes\nMax nice priority         0                    0\nMax realtime priority     0                    0\nMax realtime timeout      unlimited            unlimited            us\n```\n可以看到Max core file size设置为unlimited, 是运行产生core 文件的。\n第二步, 通过kill -6 pid 向进程发送abort信号产生core文件(默认文件名称)。\n## gdb基本使用\n\n|命令|简写|说明|\n|:-|:-|:-|\n|list|l|显示多行源代码|\n|break|b|设置断点,程序运行到断点的位置会停下来|\n|info|i|描述程序的状态|\n|run||r|开始运行程序\n|display|disp|跟踪查看某个变量,每次停下来都显示它的值|\n|step|s|执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句|\n|next|n|执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)|\n|print|p|打印内部变量值|\n|continue|c|继续程序的运行,直到遇到下一个断点|\n|set var name=v||设置变量的值|\n|start|st|开始执行程序,在main函数的第一条语句前面停下来|\n|file||装入需要调试的程序|\n|kill|k|终止正在调试的程序|\n|watch||监视变量值的变化|\n|backtrace|bt|产看函数调用信息(堆栈)|\n|frame|f|查看栈帧, 比如打印当前线程栈第5行详细信息: f 5|\n|quit|q|退出GDB环境|\n(参考<a href=\"https://blog.csdn.net/zdy0_2004/article/details/80102076\">gdb调试的基本使用</a>)\n\n## 分析coredump文件\n+ gdb java core\n调用如上命令加载core文件(这里的core指的是core文件名称)。\n1. 执行`info threads`\n```\n#0  0xb776b424 in __kernel_vsyscall ()\n(gdb) info threads\n  Id   Target Id         Frame\n  12   Thread 0xb6a84b40 (LWP 5553) 0xb776b424 in __kernel_vsyscall ()\n  11   Thread 0xad2ffb40 (LWP 5563) 0xb776b424 in __kernel_vsyscall ()\n  10   Thread 0xad350b40 (LWP 5562) 0xb776b424 in __kernel_vsyscall ()\n  9    Thread 0xad3d1b40 (LWP 5561) 0xb776b424 in __kernel_vsyscall ()\n  8    Thread 0xad422b40 (LWP 5560) 0xb776b424 in __kernel_vsyscall ()\n  7    Thread 0xad473b40 (LWP 5559) 0xb776b424 in __kernel_vsyscall ()\n  6    Thread 0xad6c4b40 (LWP 5558) 0xb776b424 in __kernel_vsyscall ()\n  5    Thread 0xad715b40 (LWP 5557) 0xb776b424 in __kernel_vsyscall ()\n  4    Thread 0xad796b40 (LWP 5556) 0xb776b424 in __kernel_vsyscall ()\n  3    Thread 0xadee6b40 (LWP 5555) 0xb776b424 in __kernel_vsyscall ()\n  2    Thread 0xb4817b40 (LWP 5554) 0xb776b424 in __kernel_vsyscall ()\n* 1    Thread 0xb756f700 (LWP 5552) 0xb776b424 in __kernel_vsyscall ()\n(gdb)\n```\n这里将展示目前已知的所有线程, *开头的代表当前处于调试的线程。这里可以通过输入info可以查看所有的命令。 切换当前调试线程可以通过`thread ID`方式, id取值上图第一列。其实我们查看每个线程在干什么, 也可以直接使用`pstack pid`即可\n2. 假如想查看id为1的线程当前栈调用情况, 那么执行继续`bt`\n```\n#0  0xb776b424 in __kernel_vsyscall ()\n(gdb) bt\n#0  0xb776b424 in __kernel_vsyscall ()\n#1  0xb7742178 in pthread_join (threadid=3064482624, thread_return=0xbfb1b944) at pthread_join.c:92\n#2  0xb772eeda in ContinueInNewThread0 () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#3  0xb772a266 in ContinueInNewThread () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#4  0xb772edab in JVMInit () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#5  0xb772d149 in JLI_Launch () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n#6  0x0804858d in main ()\n```\n3. 查看每个register值\n```\n        0xfffffe00\t-512\necx            0x0\t0\nedx            0x25d5\t9685\nebx            0xb6a5dba8\t-1230644312\nesp            0xbfd1a6e0\t0xbfd1a6e0\nebp            0xb6a5db40\t0xb6a5db40\nesi            0x0\t0\nedi            0xb772c000\t-1217216512\neip            0xb7744424\t0xb7744424 <__kernel_vsyscall+16>\neflags         0x246\t[ PF ZF IF ]\n......\n```\n左边是寄存器名称, 中间是寄存器地址, 右边是寄存器值, 可以通过`print $ecx`验证寄存器值\n+ 查看反汇编语言\n```\n(gdb) disassemble\nDump of assembler code for function __kernel_vsyscall:\n   0xb7744414 <+0>:\tpush   %ecx\n   0xb7744415 <+1>:\tpush   %edx\n   0xb7744416 <+2>:\tpush   %ebp\n   0xb7744417 <+3>:\tmov    %esp,%ebp\n   0xb7744419 <+5>:\tsysenter\n   0xb774441b <+7>:\tnop\n   0xb774441c <+8>:\tnop\n   0xb774441d <+9>:\tnop\n   0xb774441e <+10>:\tnop\n   0xb774441f <+11>:\tnop\n   0xb7744420 <+12>:\tnop\n   0xb7744421 <+13>:\tnop\n   0xb7744422 <+14>:\tint    $0x80\n=> 0xb7744424 <+16>:\tpop    %ebp\n   0xb7744425 <+17>:\tpop    %edx\n   0xb7744426 <+18>:\tpop    %ecx\n   0xb7744427 <+19>:\tret\nEnd of assembler dump.\n```\n也可以反汇编一个函数`disass func_name`, 如下:\n```\n(gdb) disass main\nDump of assembler code for function main:\n   0x0000000000400620 <+0>:\tpush   %rbp\n   0x0000000000400621 <+1>:\tmov    %rsp,%rbp\n   0x0000000000400624 <+4>:\tsub    $0x40,%rsp\n   0x0000000000400628 <+8>:\tmov    0x200271(%rip),%rdx        # 0x6008a0 <const_launcher>\n   0x000000000040062f <+15>:\ttest   %rdx,%rdx\n   0x0000000000400632 <+18>:\tje     0x4006a0 <main+128>\n   0x0000000000400634 <+20>:\tmov    0x20026d(%rip),%rax        # 0x6008a8 <const_progname>\n   0x000000000040063b <+27>:\ttest   %rax,%rax\n   0x000000000040063e <+30>:\tje     0x4006b0 <main+144>\n   0x0000000000400640 <+32>:\tmov    %rax,0x10(%rsp)\n```\n+ 查看当前线程情况\n```\nxxxxxx@slave1:~$jstack /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core\nAttaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...\nDebugger attached successfully.\nClient compiler detected.\nJVM version is 25.121-b13\nDeadlock Detection:\n\nNo deadlocks found.\n\nThread 9692: (state = BLOCKED)\n\n\nThread 9691: (state = BLOCKED)\n\n\nThread 9690: (state = BLOCKED)\n - java.lang.Object.wait(long) @bci=0 (Interpreted frame)\n - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)\n - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)\n - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)\n......\n```\n注意java命令的路径不能省略, 否则会报如下异常:\n```\nAttaching to core core from executable java, please wait...\nError attaching to core file: cannot open binary file\nsun.jvm.hotspot.debugger.DebuggerException: cannot open binary file\n\tat sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach0(Native Method)\n```\n+ 查看当前内存使用\n```\nxxxxx@slave1:~$ jmap /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core\nAttaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...\nDebugger attached successfully.\nClient compiler detected.\nJVM version is 25.121-b13\n0x08048000\t5K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java\n0xb7713000\t127K\t/lib/i386-linux-gnu/libpthread.so.0\n0xb76fd000\t93K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so\n0xb76f8000\t13K\t/lib/i386-linux-gnu/libdl.so.2\n0xb7549000\t1717K\t/lib/i386-linux-gnu/libc.so.6\n0xb7745000\t131K\t/lib/ld-linux.so.2\n0xb6aa4000\t8162K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/client/libjvm.so\n0xb6a5e000\t273K\t/lib/i386-linux-gnu/libm.so.6\n0xb6a04000\t29K\t/lib/i386-linux-gnu/librt.so.1\n0xb7736000\t54K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libverify.so\n0xb68db000\t187K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libjava.so\n0xb68bf000\t29K\t/lib/i386-linux-gnu/libnss_compat.so.2\n0xb68a6000\t89K\t/lib/i386-linux-gnu/libnsl.so.1\n0xb689a000\t41K\t/lib/i386-linux-gnu/libnss_nis.so.2\n0xb688d000\t45K\t/lib/i386-linux-gnu/libnss_files.so.2\n0xb6873000\t114K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libzip.so\n```\n\n+ 通过core文件产生heapdump文件\n`xxxxx@slave1:~$ jmap -dump:format=b,file=dump.hprof $JAVA_HOME/bin/java core`\n\n# dump内存区域\n\n\n# 参考\nhttps://blog.csdn.net/zdy0_2004/article/details/80102076\nhttps://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html","slug":"gdb调试java基本用法","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xr0019phu5p6wc2wl2","content":"<p>jvm进程崩溃时, 可以产生coredump文件, 该dump文件记录了崩溃时cpu、jvm当前线程、当前内存的使用情况, 学会分析该coredump对于我们排查问题十分重要, 本文将主要讲解如何通过gdb分析该coredump文件。</p>\n<h2 id=\"coredump产生\"><a href=\"#coredump产生\" class=\"headerlink\" title=\"coredump产生\"></a>coredump产生</h2><p>第一步检查系统是否允许产生coredump文件<br>操作系统默认禁止coredump文件的产生, 可以通过<code>ulimit -c</code>查看是否允许产生coredump文件, 若显示为0, 则禁止线程崩溃时产生该core文件, 可以通过<code>echo &quot;ulimit  -c unlimited&quot; &gt;&gt; /etc/profile</code>. 我们也可以通过cat /pro/$pid/limits 查看设置情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Limit                     Soft Limit           Hard Limit           Units</div><div class=\"line\">Max cpu time              unlimited            unlimited            seconds</div><div class=\"line\">Max file size             unlimited            unlimited            bytes</div><div class=\"line\">Max data size             unlimited            unlimited            bytes</div><div class=\"line\">Max stack size            8388608              unlimited            bytes</div><div class=\"line\">Max core file size        unlimited            unlimited            bytes</div><div class=\"line\">Max resident set          unlimited            unlimited            bytes</div><div class=\"line\">Max processes             23262                23262                processes</div><div class=\"line\">Max open files            4096                 4096                 files</div><div class=\"line\">Max locked memory         65536                65536                bytes</div><div class=\"line\">Max address space         unlimited            unlimited            bytes</div><div class=\"line\">Max file locks            unlimited            unlimited            locks</div><div class=\"line\">Max pending signals       23262                23262                signals</div><div class=\"line\">Max msgqueue size         819200               819200               bytes</div><div class=\"line\">Max nice priority         0                    0</div><div class=\"line\">Max realtime priority     0                    0</div><div class=\"line\">Max realtime timeout      unlimited            unlimited            us</div></pre></td></tr></table></figure></p>\n<p>可以看到Max core file size设置为unlimited, 是运行产生core 文件的。<br>第二步, 通过kill -6 pid 向进程发送abort信号产生core文件(默认文件名称)。</p>\n<h2 id=\"gdb基本使用\"><a href=\"#gdb基本使用\" class=\"headerlink\" title=\"gdb基本使用\"></a>gdb基本使用</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">简写</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">list</td>\n<td style=\"text-align:left\">l</td>\n<td style=\"text-align:left\">显示多行源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">break</td>\n<td style=\"text-align:left\">b</td>\n<td style=\"text-align:left\">设置断点,程序运行到断点的位置会停下来</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">info</td>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">描述程序的状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">run</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">r</td>\n<td>开始运行程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display</td>\n<td style=\"text-align:left\">disp</td>\n<td style=\"text-align:left\">跟踪查看某个变量,每次停下来都显示它的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">step</td>\n<td style=\"text-align:left\">s</td>\n<td style=\"text-align:left\">执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">n</td>\n<td style=\"text-align:left\">执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">print</td>\n<td style=\"text-align:left\">p</td>\n<td style=\"text-align:left\">打印内部变量值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">continue</td>\n<td style=\"text-align:left\">c</td>\n<td style=\"text-align:left\">继续程序的运行,直到遇到下一个断点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">set var name=v</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">设置变量的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">start</td>\n<td style=\"text-align:left\">st</td>\n<td style=\"text-align:left\">开始执行程序,在main函数的第一条语句前面停下来</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">file</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">装入需要调试的程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">kill</td>\n<td style=\"text-align:left\">k</td>\n<td style=\"text-align:left\">终止正在调试的程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">watch</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">监视变量值的变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">backtrace</td>\n<td style=\"text-align:left\">bt</td>\n<td style=\"text-align:left\">产看函数调用信息(堆栈)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">frame</td>\n<td style=\"text-align:left\">f</td>\n<td style=\"text-align:left\">查看栈帧, 比如打印当前线程栈第5行详细信息: f 5</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">quit</td>\n<td style=\"text-align:left\">q</td>\n<td style=\"text-align:left\">退出GDB环境</td>\n</tr>\n</tbody>\n</table>\n<p>(参考<a href=\"https://blog.csdn.net/zdy0_2004/article/details/80102076\" target=\"_blank\" rel=\"external\">gdb调试的基本使用</a>)</p>\n<h2 id=\"分析coredump文件\"><a href=\"#分析coredump文件\" class=\"headerlink\" title=\"分析coredump文件\"></a>分析coredump文件</h2><ul>\n<li>gdb java core<br>调用如上命令加载core文件(这里的core指的是core文件名称)。</li>\n</ul>\n<ol>\n<li>执行<code>info threads</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">#0  0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">(gdb) info threads</div><div class=\"line\">  Id   Target Id         Frame</div><div class=\"line\">  12   Thread 0xb6a84b40 (LWP 5553) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  11   Thread 0xad2ffb40 (LWP 5563) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  10   Thread 0xad350b40 (LWP 5562) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  9    Thread 0xad3d1b40 (LWP 5561) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  8    Thread 0xad422b40 (LWP 5560) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  7    Thread 0xad473b40 (LWP 5559) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  6    Thread 0xad6c4b40 (LWP 5558) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  5    Thread 0xad715b40 (LWP 5557) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  4    Thread 0xad796b40 (LWP 5556) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  3    Thread 0xadee6b40 (LWP 5555) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  2    Thread 0xb4817b40 (LWP 5554) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">* 1    Thread 0xb756f700 (LWP 5552) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">(gdb)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里将展示目前已知的所有线程, *开头的代表当前处于调试的线程。这里可以通过输入info可以查看所有的命令。 切换当前调试线程可以通过<code>thread ID</code>方式, id取值上图第一列。其实我们查看每个线程在干什么, 也可以直接使用<code>pstack pid</code>即可</p>\n<ol>\n<li><p>假如想查看id为1的线程当前栈调用情况, 那么执行继续<code>bt</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">#0  0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">(gdb) bt</div><div class=\"line\">#0  0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">#1  0xb7742178 in pthread_join (threadid=3064482624, thread_return=0xbfb1b944) at pthread_join.c:92</div><div class=\"line\">#2  0xb772eeda in ContinueInNewThread0 () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#3  0xb772a266 in ContinueInNewThread () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#4  0xb772edab in JVMInit () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#5  0xb772d149 in JLI_Launch () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#6  0x0804858d in main ()</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看每个register值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">        0xfffffe00\t-512</div><div class=\"line\">ecx            0x0\t0</div><div class=\"line\">edx            0x25d5\t9685</div><div class=\"line\">ebx            0xb6a5dba8\t-1230644312</div><div class=\"line\">esp            0xbfd1a6e0\t0xbfd1a6e0</div><div class=\"line\">ebp            0xb6a5db40\t0xb6a5db40</div><div class=\"line\">esi            0x0\t0</div><div class=\"line\">edi            0xb772c000\t-1217216512</div><div class=\"line\">eip            0xb7744424\t0xb7744424 &lt;__kernel_vsyscall+16&gt;</div><div class=\"line\">eflags         0x246\t[ PF ZF IF ]</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>左边是寄存器名称, 中间是寄存器地址, 右边是寄存器值, 可以通过<code>print $ecx</code>验证寄存器值</p>\n<ul>\n<li>查看反汇编语言<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) disassemble</div><div class=\"line\">Dump of assembler code for function __kernel_vsyscall:</div><div class=\"line\">   0xb7744414 &lt;+0&gt;:\tpush   %ecx</div><div class=\"line\">   0xb7744415 &lt;+1&gt;:\tpush   %edx</div><div class=\"line\">   0xb7744416 &lt;+2&gt;:\tpush   %ebp</div><div class=\"line\">   0xb7744417 &lt;+3&gt;:\tmov    %esp,%ebp</div><div class=\"line\">   0xb7744419 &lt;+5&gt;:\tsysenter</div><div class=\"line\">   0xb774441b &lt;+7&gt;:\tnop</div><div class=\"line\">   0xb774441c &lt;+8&gt;:\tnop</div><div class=\"line\">   0xb774441d &lt;+9&gt;:\tnop</div><div class=\"line\">   0xb774441e &lt;+10&gt;:\tnop</div><div class=\"line\">   0xb774441f &lt;+11&gt;:\tnop</div><div class=\"line\">   0xb7744420 &lt;+12&gt;:\tnop</div><div class=\"line\">   0xb7744421 &lt;+13&gt;:\tnop</div><div class=\"line\">   0xb7744422 &lt;+14&gt;:\tint    $0x80</div><div class=\"line\">=&gt; 0xb7744424 &lt;+16&gt;:\tpop    %ebp</div><div class=\"line\">   0xb7744425 &lt;+17&gt;:\tpop    %edx</div><div class=\"line\">   0xb7744426 &lt;+18&gt;:\tpop    %ecx</div><div class=\"line\">   0xb7744427 &lt;+19&gt;:\tret</div><div class=\"line\">End of assembler dump.</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>也可以反汇编一个函数<code>disass func_name</code>, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) disass main</div><div class=\"line\">Dump of assembler code for function main:</div><div class=\"line\">   0x0000000000400620 &lt;+0&gt;:\tpush   %rbp</div><div class=\"line\">   0x0000000000400621 &lt;+1&gt;:\tmov    %rsp,%rbp</div><div class=\"line\">   0x0000000000400624 &lt;+4&gt;:\tsub    $0x40,%rsp</div><div class=\"line\">   0x0000000000400628 &lt;+8&gt;:\tmov    0x200271(%rip),%rdx        # 0x6008a0 &lt;const_launcher&gt;</div><div class=\"line\">   0x000000000040062f &lt;+15&gt;:\ttest   %rdx,%rdx</div><div class=\"line\">   0x0000000000400632 &lt;+18&gt;:\tje     0x4006a0 &lt;main+128&gt;</div><div class=\"line\">   0x0000000000400634 &lt;+20&gt;:\tmov    0x20026d(%rip),%rax        # 0x6008a8 &lt;const_progname&gt;</div><div class=\"line\">   0x000000000040063b &lt;+27&gt;:\ttest   %rax,%rax</div><div class=\"line\">   0x000000000040063e &lt;+30&gt;:\tje     0x4006b0 &lt;main+144&gt;</div><div class=\"line\">   0x0000000000400640 &lt;+32&gt;:\tmov    %rax,0x10(%rsp)</div></pre></td></tr></table></figure></p>\n<ul>\n<li>查看当前线程情况<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">xxxxxx@slave1:~$jstack /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core</div><div class=\"line\">Attaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...</div><div class=\"line\">Debugger attached successfully.</div><div class=\"line\">Client compiler detected.</div><div class=\"line\">JVM version is 25.121-b13</div><div class=\"line\">Deadlock Detection:</div><div class=\"line\"></div><div class=\"line\">No deadlocks found.</div><div class=\"line\"></div><div class=\"line\">Thread 9692: (state = BLOCKED)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Thread 9691: (state = BLOCKED)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Thread 9690: (state = BLOCKED)</div><div class=\"line\"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</div><div class=\"line\"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</div><div class=\"line\"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</div><div class=\"line\"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意java命令的路径不能省略, 否则会报如下异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Attaching to core core from executable java, please wait...</div><div class=\"line\">Error attaching to core file: cannot open binary file</div><div class=\"line\">sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file</div><div class=\"line\">\tat sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach0(Native Method)</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>查看当前内存使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">xxxxx@slave1:~$ jmap /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core</div><div class=\"line\">Attaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...</div><div class=\"line\">Debugger attached successfully.</div><div class=\"line\">Client compiler detected.</div><div class=\"line\">JVM version is 25.121-b13</div><div class=\"line\">0x08048000\t5K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java</div><div class=\"line\">0xb7713000\t127K\t/lib/i386-linux-gnu/libpthread.so.0</div><div class=\"line\">0xb76fd000\t93K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">0xb76f8000\t13K\t/lib/i386-linux-gnu/libdl.so.2</div><div class=\"line\">0xb7549000\t1717K\t/lib/i386-linux-gnu/libc.so.6</div><div class=\"line\">0xb7745000\t131K\t/lib/ld-linux.so.2</div><div class=\"line\">0xb6aa4000\t8162K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/client/libjvm.so</div><div class=\"line\">0xb6a5e000\t273K\t/lib/i386-linux-gnu/libm.so.6</div><div class=\"line\">0xb6a04000\t29K\t/lib/i386-linux-gnu/librt.so.1</div><div class=\"line\">0xb7736000\t54K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libverify.so</div><div class=\"line\">0xb68db000\t187K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libjava.so</div><div class=\"line\">0xb68bf000\t29K\t/lib/i386-linux-gnu/libnss_compat.so.2</div><div class=\"line\">0xb68a6000\t89K\t/lib/i386-linux-gnu/libnsl.so.1</div><div class=\"line\">0xb689a000\t41K\t/lib/i386-linux-gnu/libnss_nis.so.2</div><div class=\"line\">0xb688d000\t45K\t/lib/i386-linux-gnu/libnss_files.so.2</div><div class=\"line\">0xb6873000\t114K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libzip.so</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过core文件产生heapdump文件<br><code>xxxxx@slave1:~$ jmap -dump:format=b,file=dump.hprof $JAVA_HOME/bin/java core</code></p>\n</li>\n</ul>\n<h1 id=\"dump内存区域\"><a href=\"#dump内存区域\" class=\"headerlink\" title=\"dump内存区域\"></a>dump内存区域</h1><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://blog.csdn.net/zdy0_2004/article/details/80102076\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/zdy0_2004/article/details/80102076</a><br><a href=\"https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>jvm进程崩溃时, 可以产生coredump文件, 该dump文件记录了崩溃时cpu、jvm当前线程、当前内存的使用情况, 学会分析该coredump对于我们排查问题十分重要, 本文将主要讲解如何通过gdb分析该coredump文件。</p>\n<h2 id=\"coredump产生\"><a href=\"#coredump产生\" class=\"headerlink\" title=\"coredump产生\"></a>coredump产生</h2><p>第一步检查系统是否允许产生coredump文件<br>操作系统默认禁止coredump文件的产生, 可以通过<code>ulimit -c</code>查看是否允许产生coredump文件, 若显示为0, 则禁止线程崩溃时产生该core文件, 可以通过<code>echo &quot;ulimit  -c unlimited&quot; &gt;&gt; /etc/profile</code>. 我们也可以通过cat /pro/$pid/limits 查看设置情况<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Limit                     Soft Limit           Hard Limit           Units</div><div class=\"line\">Max cpu time              unlimited            unlimited            seconds</div><div class=\"line\">Max file size             unlimited            unlimited            bytes</div><div class=\"line\">Max data size             unlimited            unlimited            bytes</div><div class=\"line\">Max stack size            8388608              unlimited            bytes</div><div class=\"line\">Max core file size        unlimited            unlimited            bytes</div><div class=\"line\">Max resident set          unlimited            unlimited            bytes</div><div class=\"line\">Max processes             23262                23262                processes</div><div class=\"line\">Max open files            4096                 4096                 files</div><div class=\"line\">Max locked memory         65536                65536                bytes</div><div class=\"line\">Max address space         unlimited            unlimited            bytes</div><div class=\"line\">Max file locks            unlimited            unlimited            locks</div><div class=\"line\">Max pending signals       23262                23262                signals</div><div class=\"line\">Max msgqueue size         819200               819200               bytes</div><div class=\"line\">Max nice priority         0                    0</div><div class=\"line\">Max realtime priority     0                    0</div><div class=\"line\">Max realtime timeout      unlimited            unlimited            us</div></pre></td></tr></table></figure></p>\n<p>可以看到Max core file size设置为unlimited, 是运行产生core 文件的。<br>第二步, 通过kill -6 pid 向进程发送abort信号产生core文件(默认文件名称)。</p>\n<h2 id=\"gdb基本使用\"><a href=\"#gdb基本使用\" class=\"headerlink\" title=\"gdb基本使用\"></a>gdb基本使用</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:left\">命令</th>\n<th style=\"text-align:left\">简写</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">list</td>\n<td style=\"text-align:left\">l</td>\n<td style=\"text-align:left\">显示多行源代码</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">break</td>\n<td style=\"text-align:left\">b</td>\n<td style=\"text-align:left\">设置断点,程序运行到断点的位置会停下来</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">info</td>\n<td style=\"text-align:left\">i</td>\n<td style=\"text-align:left\">描述程序的状态</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">run</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">r</td>\n<td>开始运行程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">display</td>\n<td style=\"text-align:left\">disp</td>\n<td style=\"text-align:left\">跟踪查看某个变量,每次停下来都显示它的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">step</td>\n<td style=\"text-align:left\">s</td>\n<td style=\"text-align:left\">执行下一条语句,如果该语句为函数调用,则进入函数执行其中的第一条语句</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">n</td>\n<td style=\"text-align:left\">执行下一条语句,如果该语句为函数调用,不会进入函数内部执行(即不会一步步地调试函数内部语句)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">print</td>\n<td style=\"text-align:left\">p</td>\n<td style=\"text-align:left\">打印内部变量值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">continue</td>\n<td style=\"text-align:left\">c</td>\n<td style=\"text-align:left\">继续程序的运行,直到遇到下一个断点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">set var name=v</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">设置变量的值</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">start</td>\n<td style=\"text-align:left\">st</td>\n<td style=\"text-align:left\">开始执行程序,在main函数的第一条语句前面停下来</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">file</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">装入需要调试的程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">kill</td>\n<td style=\"text-align:left\">k</td>\n<td style=\"text-align:left\">终止正在调试的程序</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">watch</td>\n<td style=\"text-align:left\"></td>\n<td style=\"text-align:left\">监视变量值的变化</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">backtrace</td>\n<td style=\"text-align:left\">bt</td>\n<td style=\"text-align:left\">产看函数调用信息(堆栈)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">frame</td>\n<td style=\"text-align:left\">f</td>\n<td style=\"text-align:left\">查看栈帧, 比如打印当前线程栈第5行详细信息: f 5</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">quit</td>\n<td style=\"text-align:left\">q</td>\n<td style=\"text-align:left\">退出GDB环境</td>\n</tr>\n</tbody>\n</table>\n<p>(参考<a href=\"https://blog.csdn.net/zdy0_2004/article/details/80102076\" target=\"_blank\" rel=\"external\">gdb调试的基本使用</a>)</p>\n<h2 id=\"分析coredump文件\"><a href=\"#分析coredump文件\" class=\"headerlink\" title=\"分析coredump文件\"></a>分析coredump文件</h2><ul>\n<li>gdb java core<br>调用如上命令加载core文件(这里的core指的是core文件名称)。</li>\n</ul>\n<ol>\n<li>执行<code>info threads</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">#0  0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">(gdb) info threads</div><div class=\"line\">  Id   Target Id         Frame</div><div class=\"line\">  12   Thread 0xb6a84b40 (LWP 5553) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  11   Thread 0xad2ffb40 (LWP 5563) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  10   Thread 0xad350b40 (LWP 5562) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  9    Thread 0xad3d1b40 (LWP 5561) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  8    Thread 0xad422b40 (LWP 5560) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  7    Thread 0xad473b40 (LWP 5559) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  6    Thread 0xad6c4b40 (LWP 5558) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  5    Thread 0xad715b40 (LWP 5557) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  4    Thread 0xad796b40 (LWP 5556) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  3    Thread 0xadee6b40 (LWP 5555) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">  2    Thread 0xb4817b40 (LWP 5554) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">* 1    Thread 0xb756f700 (LWP 5552) 0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">(gdb)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>这里将展示目前已知的所有线程, *开头的代表当前处于调试的线程。这里可以通过输入info可以查看所有的命令。 切换当前调试线程可以通过<code>thread ID</code>方式, id取值上图第一列。其实我们查看每个线程在干什么, 也可以直接使用<code>pstack pid</code>即可</p>\n<ol>\n<li><p>假如想查看id为1的线程当前栈调用情况, 那么执行继续<code>bt</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">#0  0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">(gdb) bt</div><div class=\"line\">#0  0xb776b424 in __kernel_vsyscall ()</div><div class=\"line\">#1  0xb7742178 in pthread_join (threadid=3064482624, thread_return=0xbfb1b944) at pthread_join.c:92</div><div class=\"line\">#2  0xb772eeda in ContinueInNewThread0 () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#3  0xb772a266 in ContinueInNewThread () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#4  0xb772edab in JVMInit () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#5  0xb772d149 in JLI_Launch () from /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">#6  0x0804858d in main ()</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看每个register值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">        0xfffffe00\t-512</div><div class=\"line\">ecx            0x0\t0</div><div class=\"line\">edx            0x25d5\t9685</div><div class=\"line\">ebx            0xb6a5dba8\t-1230644312</div><div class=\"line\">esp            0xbfd1a6e0\t0xbfd1a6e0</div><div class=\"line\">ebp            0xb6a5db40\t0xb6a5db40</div><div class=\"line\">esi            0x0\t0</div><div class=\"line\">edi            0xb772c000\t-1217216512</div><div class=\"line\">eip            0xb7744424\t0xb7744424 &lt;__kernel_vsyscall+16&gt;</div><div class=\"line\">eflags         0x246\t[ PF ZF IF ]</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>左边是寄存器名称, 中间是寄存器地址, 右边是寄存器值, 可以通过<code>print $ecx</code>验证寄存器值</p>\n<ul>\n<li>查看反汇编语言<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) disassemble</div><div class=\"line\">Dump of assembler code for function __kernel_vsyscall:</div><div class=\"line\">   0xb7744414 &lt;+0&gt;:\tpush   %ecx</div><div class=\"line\">   0xb7744415 &lt;+1&gt;:\tpush   %edx</div><div class=\"line\">   0xb7744416 &lt;+2&gt;:\tpush   %ebp</div><div class=\"line\">   0xb7744417 &lt;+3&gt;:\tmov    %esp,%ebp</div><div class=\"line\">   0xb7744419 &lt;+5&gt;:\tsysenter</div><div class=\"line\">   0xb774441b &lt;+7&gt;:\tnop</div><div class=\"line\">   0xb774441c &lt;+8&gt;:\tnop</div><div class=\"line\">   0xb774441d &lt;+9&gt;:\tnop</div><div class=\"line\">   0xb774441e &lt;+10&gt;:\tnop</div><div class=\"line\">   0xb774441f &lt;+11&gt;:\tnop</div><div class=\"line\">   0xb7744420 &lt;+12&gt;:\tnop</div><div class=\"line\">   0xb7744421 &lt;+13&gt;:\tnop</div><div class=\"line\">   0xb7744422 &lt;+14&gt;:\tint    $0x80</div><div class=\"line\">=&gt; 0xb7744424 &lt;+16&gt;:\tpop    %ebp</div><div class=\"line\">   0xb7744425 &lt;+17&gt;:\tpop    %edx</div><div class=\"line\">   0xb7744426 &lt;+18&gt;:\tpop    %ecx</div><div class=\"line\">   0xb7744427 &lt;+19&gt;:\tret</div><div class=\"line\">End of assembler dump.</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>也可以反汇编一个函数<code>disass func_name</code>, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">(gdb) disass main</div><div class=\"line\">Dump of assembler code for function main:</div><div class=\"line\">   0x0000000000400620 &lt;+0&gt;:\tpush   %rbp</div><div class=\"line\">   0x0000000000400621 &lt;+1&gt;:\tmov    %rsp,%rbp</div><div class=\"line\">   0x0000000000400624 &lt;+4&gt;:\tsub    $0x40,%rsp</div><div class=\"line\">   0x0000000000400628 &lt;+8&gt;:\tmov    0x200271(%rip),%rdx        # 0x6008a0 &lt;const_launcher&gt;</div><div class=\"line\">   0x000000000040062f &lt;+15&gt;:\ttest   %rdx,%rdx</div><div class=\"line\">   0x0000000000400632 &lt;+18&gt;:\tje     0x4006a0 &lt;main+128&gt;</div><div class=\"line\">   0x0000000000400634 &lt;+20&gt;:\tmov    0x20026d(%rip),%rax        # 0x6008a8 &lt;const_progname&gt;</div><div class=\"line\">   0x000000000040063b &lt;+27&gt;:\ttest   %rax,%rax</div><div class=\"line\">   0x000000000040063e &lt;+30&gt;:\tje     0x4006b0 &lt;main+144&gt;</div><div class=\"line\">   0x0000000000400640 &lt;+32&gt;:\tmov    %rax,0x10(%rsp)</div></pre></td></tr></table></figure></p>\n<ul>\n<li>查看当前线程情况<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">xxxxxx@slave1:~$jstack /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core</div><div class=\"line\">Attaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...</div><div class=\"line\">Debugger attached successfully.</div><div class=\"line\">Client compiler detected.</div><div class=\"line\">JVM version is 25.121-b13</div><div class=\"line\">Deadlock Detection:</div><div class=\"line\"></div><div class=\"line\">No deadlocks found.</div><div class=\"line\"></div><div class=\"line\">Thread 9692: (state = BLOCKED)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Thread 9691: (state = BLOCKED)</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Thread 9690: (state = BLOCKED)</div><div class=\"line\"> - java.lang.Object.wait(long) @bci=0 (Interpreted frame)</div><div class=\"line\"> - java.lang.ref.ReferenceQueue.remove(long) @bci=59, line=143 (Interpreted frame)</div><div class=\"line\"> - java.lang.ref.ReferenceQueue.remove() @bci=2, line=164 (Interpreted frame)</div><div class=\"line\"> - java.lang.ref.Finalizer$FinalizerThread.run() @bci=36, line=209 (Interpreted frame)</div><div class=\"line\">......</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意java命令的路径不能省略, 否则会报如下异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Attaching to core core from executable java, please wait...</div><div class=\"line\">Error attaching to core file: cannot open binary file</div><div class=\"line\">sun.jvm.hotspot.debugger.DebuggerException: cannot open binary file</div><div class=\"line\">\tat sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal.attach0(Native Method)</div></pre></td></tr></table></figure></p>\n<ul>\n<li><p>查看当前内存使用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">xxxxx@slave1:~$ jmap /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java core</div><div class=\"line\">Attaching to core core from executable /home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java, please wait...</div><div class=\"line\">Debugger attached successfully.</div><div class=\"line\">Client compiler detected.</div><div class=\"line\">JVM version is 25.121-b13</div><div class=\"line\">0x08048000\t5K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/java</div><div class=\"line\">0xb7713000\t127K\t/lib/i386-linux-gnu/libpthread.so.0</div><div class=\"line\">0xb76fd000\t93K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/bin/../lib/i386/jli/libjli.so</div><div class=\"line\">0xb76f8000\t13K\t/lib/i386-linux-gnu/libdl.so.2</div><div class=\"line\">0xb7549000\t1717K\t/lib/i386-linux-gnu/libc.so.6</div><div class=\"line\">0xb7745000\t131K\t/lib/ld-linux.so.2</div><div class=\"line\">0xb6aa4000\t8162K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/client/libjvm.so</div><div class=\"line\">0xb6a5e000\t273K\t/lib/i386-linux-gnu/libm.so.6</div><div class=\"line\">0xb6a04000\t29K\t/lib/i386-linux-gnu/librt.so.1</div><div class=\"line\">0xb7736000\t54K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libverify.so</div><div class=\"line\">0xb68db000\t187K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libjava.so</div><div class=\"line\">0xb68bf000\t29K\t/lib/i386-linux-gnu/libnss_compat.so.2</div><div class=\"line\">0xb68a6000\t89K\t/lib/i386-linux-gnu/libnsl.so.1</div><div class=\"line\">0xb689a000\t41K\t/lib/i386-linux-gnu/libnss_nis.so.2</div><div class=\"line\">0xb688d000\t45K\t/lib/i386-linux-gnu/libnss_files.so.2</div><div class=\"line\">0xb6873000\t114K\t/home/kewei/Downloads/work_soft/jdk1.8.0_121/jre/lib/i386/libzip.so</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过core文件产生heapdump文件<br><code>xxxxx@slave1:~$ jmap -dump:format=b,file=dump.hprof $JAVA_HOME/bin/java core</code></p>\n</li>\n</ul>\n<h1 id=\"dump内存区域\"><a href=\"#dump内存区域\" class=\"headerlink\" title=\"dump内存区域\"></a>dump内存区域</h1><h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://blog.csdn.net/zdy0_2004/article/details/80102076\" target=\"_blank\" rel=\"external\">https://blog.csdn.net/zdy0_2004/article/details/80102076</a><br><a href=\"https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/xuxm2007/archive/2011/04/01/2002162.html</a></p>\n"},{"title":"jvm内存泄露排查工具","date":"2016-12-15T13:12:10.000Z","toc":true,"_content":"本文介绍几个不常用的内存泄露排查工具:perftools、pmap、jcmd。\n\n## perftools\nperftools是一款比较好的分析堆外内存泄漏的工具, 原理: 通过使用自己实现的libtcmalloc.so来替换原有的内存分配函数, 来达到监控内存分配的目的\n\n#### 安装\nperftools安装需要依赖:libunwind, 首先安装libunwind:\n+ wget https://github.com/libunwind/libunwind/releases/download/v1.2.1/libunwind-1.2.1.tar.gz\n+ tar -xvf libunwind-1.2.1.tar.gz\n+ cd libunwind-1.2.1\n+ ./configure  --prefix=/home/target/libunwind\n+ make\n+ make install\n其次安装perftools:\n+ wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz\n+ tar -xvf gperftools-2.6.1.tar.gz\n+ cd gperftools-2.6.1\n+ ./configure --prefix=/home/target/gperftools\n+ make (安装时候, 可能会报g++: command not found, 切换到root: yum -y install gcc+ gcc-c++, 需要再次执行上一步, 否则会报异常)\n+ make install\n我们还需要设置一些环境变量:\nexport LD_PRELOAD=/home/target/gperftools/lib/libtcmalloc.so\n目的：在程序启动时自动链接libtcmalloc.so\nexport HEAPPROFILE=/you_directory/heap.hprof\n目的: 内存才能监控将产生很多.heap, 设置文件存放位置\nexport HEAP_PROFILE_ALLOCATION_INTERVAL=10000000\n目的: 内存使用多少, 会产生一个.heap文件。 默认每使用1G, 产生一个.bin文件。\n\n#### 使用\n+ 直接启动jvm进程, perftools会监控内存使用\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak.png\" height=\"250\" width=\"850\"/>\n+ 查看产生的heap.hprof.0001.heap文件\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak1.png\" height=\"450\" width=\"850\"/>\n其中对每列的介绍如下:\nThe first column contains the direct memory use in MB(当前函数目前使用的直接内存大小).\nThe fourth column contains memory use by the procedure and all of its callees(当前函数及其调用者使用的直接内存).\nThe second and fifth columns are just percentage representations of the numbers in the first and fifth columns.\nThe third column is a cumulative sum of the second column (i.e., the kth entry in the third column is the sum of the first k entries in the second column.)(目前占用的总堆外内存大小)\n\n## jcmd\njcm是一个多功能工具, 功能如下:\n```\n$user@host: /usr/local/java18/bin/jcmd 25266 help\n25266:\nThe following commands are available:\nJFR.stop\nJFR.start\nJFR.dump\nJFR.check\nVM.native_memory\nVM.check_commercial_features\nVM.unlock_commercial_features\nManagementAgent.stop\nManagementAgent.start_local\nManagementAgent.start\nGC.rotate_log\nThread.print         // 与jstack功能相同\nGC.class_stats\nGC.class_histogram    // 与jmap -histo功能相同\nGC.heap_dump         //与jmap -dump功能相同\nGC.run_finalization\nGC.run\nVM.uptime\nVM.flags                   //查看更完整的启动命令, 包括默认的参数, 比如垃圾回收器\nVM.system_properties      //查看系统参数\nVM.command_line          //查看启动命令\nVM.version\nhelp\n```\n我们将着重介绍VM.native_memory, 该参数可以支持我们追踪堆内内存的申请。 不过我们必须在进程启动时添加-XX:NativeMemoryTracking=detail参数才可用。 开启该参数将导致jvm进程5-10%性能损耗。\n其参数如下:\n\n|参数|介绍|\n|:-|:-|\n|summary|汇总的内存展示|\n|detail|详细的内存展示, 不仅包括summary, 还包括每个内存块地址及具体分配者|\n|baseline|当前线程拥有的内存块作为基准线, 与调用detail.diff summary.diff时刻的线程比较得出增量情况|\n|detail.diff|内存增量的详情|\n|summary.diff|内存增量的汇总情况|\n\nVM.native_memory显示的内存包含`堆内内存、Code区域、通过unsafe.allocateMemory(DirectByteBuffer实际也是由前者产生)，但是不包含其他Native Code（C代码）申请的堆外内存`。\n\n#### VM.native_memory\n用法: jcmd pid VM.native_memory detail\n```\n44387:\nNative Memory Tracking:\nTotal: reserved=1653891KB, committed=355703KB\n                  //同启动参数一致\n-                 Java Heap (reserved=102400KB, committed=102400KB)\n                            (mmap: reserved=102400KB, committed=102400KB)\n                   //类需要的内存\n-                 Class (reserved=1091740KB, committed=39836KB)\n                            (classes #426)\n                            (malloc=34972KB #267)\n                            (mmap: reserved=1056768KB, committed=4864KB)\n                  //thread #57，表示57个线程，分配的总内存有57807KB，平均一个线程是1MB。\n-                  Thread (reserved=57807KB, committed=57807KB)\n                            (thread #57)\n                            (stack: reserved=57568KB, committed=57568KB)\n                            (malloc=173KB #315)\n                            (arena=66KB #112)\n                   //JIT的代码缓存\n-                  Code (reserved=249648KB, committed=3560KB)\n                            (malloc=48KB #336)\n                            (mmap: reserved=249600KB, committed=3512KB)\n                   //GC需要的内存\n-                  GC (reserved=43020KB, committed=42824KB)\n                            (malloc=39208KB #204)\n                            (mmap: reserved=3812KB, committed=3616KB)\n                   //供编译器自身操作使用的\n-                  Compiler (reserved=135KB, committed=135KB)\n                            (malloc=4KB #41)\n                            (arena=131KB #3)\n                   //\n-                  Internal (reserved=107397KB, committed=107397KB)\n                            (malloc=107365KB #1972)\n                            (mmap: reserved=32KB, committed=32KB)\n                   //保留字符串（Interned String）的引用与符号表引用\n-                    Symbol (reserved=1374KB, committed=1374KB)\n                            (malloc=918KB #92)\n                            (arena=456KB #1)\n     //NMT本身也需要内存\n-    Native Memory Tracking (reserved=185KB, committed=185KB)\n                            (malloc=107KB #1646)\n                            (tracking overhead=78KB)\n\n-               Arena Chunk (reserved=186KB, committed=186KB)\n                            (malloc=186KB)\n\nVirtual memory map:\n//JVM heap内存大小100M, 地址范围0x00000000f9c00000-0x0000000100000000, 由ParallelScavengeHeap::initialize来申请的内存块\n[0x00000000f9c00000 - 0x0000000100000000] reserved 102400KB for Java Heap from\n    //下面这个怀疑是该函数在内存中的地址\n    [0x00007ff092b43bd2] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0xc2\n    [0x00007ff092b4452e] ReservedHeapSpace::ReservedHeapSpace(unsigned long, unsigned long, bool, char*)+0x6e\n    [0x00007ff092b1249b] Universe::reserve_heap(unsigned long, unsigned long)+0x8b\n    [0x00007ff0929cc5c4] ParallelScavengeHeap::initialize()+0x84\n\n        [0x00000000ffe80000 - 0x0000000100000000] committed 1536KB from\n            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53\n            [0x00007ff092a17a85] PSYoungGen::initialize_virtual_space(ReservedSpace, unsigned long)+0x75\n            [0x00007ff092a183ee] PSYoungGen::initialize(ReservedSpace, unsigned long)+0x3e\n            [0x00007ff09236fc85] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x345\n\n        [0x00000000f9c00000 - 0x00000000ffe80000] committed 100864KB from\n            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53\n            [0x00007ff092a06b77] PSOldGen::initialize(ReservedSpace, unsigned long, char const*, int)+0xb7\n            [0x00007ff09236fcda] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x39a\n            [0x00007ff0929cc716] ParallelScavengeHeap::initialize()+0x1d6\n    ......\n[0x00007ff093b40000 - 0x00007ff093c41000] reserved and committed 1028KB for Thread Stack from\n    [0x00007ff092af4fd6] Threads::create_vm(JavaVMInitArgs*, bool*)+0x1e6\n    [0x00007ff09275e244] JNI_CreateJavaVM+0x74\n    [0x00007ff09360245e] JavaMain+0x9e\n\n[0x00007ff093c49000 - 0x00007ff093c4b000] reserved 8KB for GC from\n    [0x00007ff092b43d66] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0x256\n    [0x00007ff092b43e0b] ReservedSpace::ReservedSpace(unsigned long, unsigned long, bool, char*, unsigned long)+0x1b\n    [0x00007ff092a0a1c2] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x92\n    [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178\n\n        [0x00007ff093c49000 - 0x00007ff093c4b000] committed 8KB from\n            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53\n            [0x00007ff092a0a274] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x144\n            [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178\n            [0x00007ff0929cc8c5] ParallelScavengeHeap::initialize()+0x385\nDetails:\n\n[0x00007ff092b1ad2b] Unsafe_AllocateMemory+0x1db\n[0x00007ff07d015994]\n                             //展示了DirectByteBuffer内存申请情况, 供92个内存块, 总共占用94MB大小\n                             (malloc=94208KB #92)\n\n[0x00007ff0923cca65] ArrayAllocator<unsigned long, (MemoryType)7>::allocate(unsigned long)+0x175\n[0x00007ff092a0092f] ParCompactionManager::initialize(ParMarkBitMap*)+0x28f\n[0x00007ff092a0a105] PSParallelCompact::post_initialize()+0xb5\n[0x00007ff0929cc535] ParallelScavengeHeap::post_initialize()+0x25\n                             (malloc=34816KB #34)\n\n[0x00007ff092a11d45] ArrayAllocator<StarTask, (MemoryType)1>::allocate(unsigned long)+0x175\n[0x00007ff092a10160] PSPromotionManager::PSPromotionManager()+0x1f0\n[0x00007ff092a106ad] PSPromotionManager::initialize()+0x13d\n[0x00007ff092b11f43] universe_post_init()+0x883\n                             (malloc=34816KB #34)\n```\n至于每个内存块存放的详情, 可以在pmap里查看。可见, 我们可以根据detail可以了解每块内存是由谁申请的。\n\n#### 内存增量diff\n执行顺序:\n+ /usr/local/java18/bin/jcmd 8202 VM.native_memory baseline 作为内存基准\n+ /usr/local/java18/bin/jcmd 8202 VM.native_memory detail.diff 根据内存基准来比较增量\n结果如下:\n```\nNative Memory Tracking:\nTotal: reserved=1617492KB +13331KB, committed=319304KB +13331KB\n-                 Java Heap (reserved=102400KB, committed=102400KB)\n                            (mmap: reserved=102400KB, committed=102400KB)\n                          ......\n                 Internal (reserved=70999KB +13312KB, committed=70999KB +13312KB)\n                            (malloc=70967KB +13312KB #1914 +13)\n                            (mmap: reserved=32KB, committed=32KB)\n\n-                    Symbol (reserved=1374KB, committed=1374KB)\n                            (malloc=918KB #92)\n                            (arena=456KB #1)\n\n-    Native Memory Tracking (reserved=183KB +19KB, committed=183KB +19KB)\n                            (malloc=106KB +15KB #1628 +212)\n                            (tracking overhead=77KB +4KB)\n\n-               Arena Chunk (reserved=186KB, committed=186KB)\n                            (malloc=186KB)\n\n[0x00007f5c46ed7d2b] Unsafe_AllocateMemory+0x1db\n[0x00007f5c31015994]\n                             (malloc=35840KB +13312KB #35 +13)\n\n[0x00007f5c46cc4883] MemBaseline::aggregate_virtual_memory_allocation_sites()+0x173\n[0x00007f5c46cc4b08] MemBaseline::baseline_allocation_sites()+0x1d8\n[0x00007f5c46cc5185] MemBaseline::baseline(bool)+0x635\n[0x00007f5c46d34188] NMTDCmd::execute(DCmdSource, Thread*)+0x178\n                             (malloc=1KB +1KB #17 +17)\n```\n如上图, 可以轻易发现Unsafe_AllocateMemory diff期间,增加了13次内存分配, 新增了13MB内存申请。\n\n## pmap\npmap可以查看进程使用的内存分布, 包括所有堆内和堆外内存。\n使用: pmap -x 9752 | sort -n -r -k 2, 并不需要root或者别的参数就可以执行, 查看进程的内存映射信息\n```\nmapped: 5341520K    writeable/private: 308668K    shared: 3836K\nAddress           Kbytes       Mode   Offset Device  Mapping\n0000000100080000 1048064       0       0 -----    [ anon ]\n00007fb789360000  242304       0       0 -----    [ anon ]\n00000000f9c00000  102912   23776   23776 rw---    [ anon ]\n00007fb6a216c000   96848      44       0 r----  locale-archive\n00007fb784021000   65404       0       0 -----    [ anon ]\n00007fb780021000   65404       0       0 -----    [ anon ]\n00007fb77c021000   65404       0       0 -----    [ anon ]\n00007fb778021000   65404       0       0 -----    [ anon ]\n00007fb774021000   65404       0       0 -----    [ anon ]\n00007fb770021000   65404       0       0 -----    [ anon ]\n00007fb76c021000   65404       0       0 -----    [ anon ]\n00007fb768021000   65404       0       0 -----    [ anon ]\n00007fb764021000   65404       0       0 -----    [ anon ]\n00007fb760021000   65404       0       0 -----    [ anon ]\n00007fb75c021000   65404       0       0 -----    [ anon ]\n00007fb758021000   65404       0       0 -----    [ anon ]\n00007fb750021000   65404       0       0 -----    [ anon ]\n00007fb74c021000   65404       0       0 -----    [ anon ]\n00007fb748021000   65404       0       0 -----    [ anon ]\n00007fb740021000   65404       0       0 -----    [ anon ]\n00007fb738021000   65404       0       0 -----    [ anon ]\n00007fb730021000   65404       0       0 -----    [ anon ]\n00007fb728021000   65404       0       0 -----    [ anon ]\n00007fb720021000   65404       0       0 -----    [ anon ]\n00007fb718021000   65404       0       0 -----    [ anon ]\n00007fb710021000   65404       0       0 -----    [ anon ]\n00007fb708021000   65404       0       0 -----    [ anon ]\n00007fb700021000   65404       0       0 -----    [ anon ]\n00007fb7a1802000    2048       0       0 -----  libpthread-2.12.so\n00007fb7a15ea000    2048       0       0 -----  libjli.so\n```\nAddress:  start address of map  映像起始地址, 就是真实内存地址\nKbytes:  size of map in kilobytes  映像大小\nRSS:  resident set size in kilobytes  驻留集大小\nDirty:  dirty pages (both shared and private) in kilobytes  脏页大小\nMode:  permissions on map 映像权限: r=read, w=write, x=execute, s=shared, p=private (copy on write)\nMapping:  file backing the map , or '[ anon ]' for allocated memory, or '[ stack ]' for the program stack.  映像支持文件,[anon]为已分配内存 [stack]为程序堆栈\nOffset:  offset into the file  文件偏移\nDevice:  device name (major:minor)  设备名\n第一行的值:\n+ mapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz\n+ writeable/private  表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小\n+ shared 表示进程和其他进程共享的内存大小\n根据此处的address和NMT可判断出该内存块属于哪个空间的。我们可以通过如下方式检查是否存在内存泄露\n`while true; do pmap -d  3066 | tail -1; sleep 1; done`\n```\nmapped: 5411424K    writeable/private: 378492K    shared: 3836K\nmapped: 5412452K    writeable/private: 379520K    shared: 3836K\nmapped: 5413480K    writeable/private: 380548K    shared: 3836K\nmapped: 5414508K    writeable/private: 381576K    shared: 3836K\nmapped: 5415536K    writeable/private: 382604K    shared: 3836K\n```\n# 参考\nhttp://goog-perftools.sourceforge.net/doc/heap_profiler.html\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html\nhttps://www.cnblogs.com/duanxz/archive/2012/08/09/2630284.html\nhttps://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html\nhttps://www.cnblogs.com/sidesky/p/10009241.html\nhttps://yq.aliyun.com/articles/227924\nhttps://www.cnblogs.com/ggjucheng/p/3348439.html","source":"_posts/jvm内存泄露排查工具.md","raw":"---\ntitle: jvm内存泄露排查工具\ndate: 2016-12-15 21:12:10\ntags: perftools、jcmd、pmap\ntoc: true\n---\n本文介绍几个不常用的内存泄露排查工具:perftools、pmap、jcmd。\n\n## perftools\nperftools是一款比较好的分析堆外内存泄漏的工具, 原理: 通过使用自己实现的libtcmalloc.so来替换原有的内存分配函数, 来达到监控内存分配的目的\n\n#### 安装\nperftools安装需要依赖:libunwind, 首先安装libunwind:\n+ wget https://github.com/libunwind/libunwind/releases/download/v1.2.1/libunwind-1.2.1.tar.gz\n+ tar -xvf libunwind-1.2.1.tar.gz\n+ cd libunwind-1.2.1\n+ ./configure  --prefix=/home/target/libunwind\n+ make\n+ make install\n其次安装perftools:\n+ wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz\n+ tar -xvf gperftools-2.6.1.tar.gz\n+ cd gperftools-2.6.1\n+ ./configure --prefix=/home/target/gperftools\n+ make (安装时候, 可能会报g++: command not found, 切换到root: yum -y install gcc+ gcc-c++, 需要再次执行上一步, 否则会报异常)\n+ make install\n我们还需要设置一些环境变量:\nexport LD_PRELOAD=/home/target/gperftools/lib/libtcmalloc.so\n目的：在程序启动时自动链接libtcmalloc.so\nexport HEAPPROFILE=/you_directory/heap.hprof\n目的: 内存才能监控将产生很多.heap, 设置文件存放位置\nexport HEAP_PROFILE_ALLOCATION_INTERVAL=10000000\n目的: 内存使用多少, 会产生一个.heap文件。 默认每使用1G, 产生一个.bin文件。\n\n#### 使用\n+ 直接启动jvm进程, perftools会监控内存使用\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak.png\" height=\"250\" width=\"850\"/>\n+ 查看产生的heap.hprof.0001.heap文件\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak1.png\" height=\"450\" width=\"850\"/>\n其中对每列的介绍如下:\nThe first column contains the direct memory use in MB(当前函数目前使用的直接内存大小).\nThe fourth column contains memory use by the procedure and all of its callees(当前函数及其调用者使用的直接内存).\nThe second and fifth columns are just percentage representations of the numbers in the first and fifth columns.\nThe third column is a cumulative sum of the second column (i.e., the kth entry in the third column is the sum of the first k entries in the second column.)(目前占用的总堆外内存大小)\n\n## jcmd\njcm是一个多功能工具, 功能如下:\n```\n$user@host: /usr/local/java18/bin/jcmd 25266 help\n25266:\nThe following commands are available:\nJFR.stop\nJFR.start\nJFR.dump\nJFR.check\nVM.native_memory\nVM.check_commercial_features\nVM.unlock_commercial_features\nManagementAgent.stop\nManagementAgent.start_local\nManagementAgent.start\nGC.rotate_log\nThread.print         // 与jstack功能相同\nGC.class_stats\nGC.class_histogram    // 与jmap -histo功能相同\nGC.heap_dump         //与jmap -dump功能相同\nGC.run_finalization\nGC.run\nVM.uptime\nVM.flags                   //查看更完整的启动命令, 包括默认的参数, 比如垃圾回收器\nVM.system_properties      //查看系统参数\nVM.command_line          //查看启动命令\nVM.version\nhelp\n```\n我们将着重介绍VM.native_memory, 该参数可以支持我们追踪堆内内存的申请。 不过我们必须在进程启动时添加-XX:NativeMemoryTracking=detail参数才可用。 开启该参数将导致jvm进程5-10%性能损耗。\n其参数如下:\n\n|参数|介绍|\n|:-|:-|\n|summary|汇总的内存展示|\n|detail|详细的内存展示, 不仅包括summary, 还包括每个内存块地址及具体分配者|\n|baseline|当前线程拥有的内存块作为基准线, 与调用detail.diff summary.diff时刻的线程比较得出增量情况|\n|detail.diff|内存增量的详情|\n|summary.diff|内存增量的汇总情况|\n\nVM.native_memory显示的内存包含`堆内内存、Code区域、通过unsafe.allocateMemory(DirectByteBuffer实际也是由前者产生)，但是不包含其他Native Code（C代码）申请的堆外内存`。\n\n#### VM.native_memory\n用法: jcmd pid VM.native_memory detail\n```\n44387:\nNative Memory Tracking:\nTotal: reserved=1653891KB, committed=355703KB\n                  //同启动参数一致\n-                 Java Heap (reserved=102400KB, committed=102400KB)\n                            (mmap: reserved=102400KB, committed=102400KB)\n                   //类需要的内存\n-                 Class (reserved=1091740KB, committed=39836KB)\n                            (classes #426)\n                            (malloc=34972KB #267)\n                            (mmap: reserved=1056768KB, committed=4864KB)\n                  //thread #57，表示57个线程，分配的总内存有57807KB，平均一个线程是1MB。\n-                  Thread (reserved=57807KB, committed=57807KB)\n                            (thread #57)\n                            (stack: reserved=57568KB, committed=57568KB)\n                            (malloc=173KB #315)\n                            (arena=66KB #112)\n                   //JIT的代码缓存\n-                  Code (reserved=249648KB, committed=3560KB)\n                            (malloc=48KB #336)\n                            (mmap: reserved=249600KB, committed=3512KB)\n                   //GC需要的内存\n-                  GC (reserved=43020KB, committed=42824KB)\n                            (malloc=39208KB #204)\n                            (mmap: reserved=3812KB, committed=3616KB)\n                   //供编译器自身操作使用的\n-                  Compiler (reserved=135KB, committed=135KB)\n                            (malloc=4KB #41)\n                            (arena=131KB #3)\n                   //\n-                  Internal (reserved=107397KB, committed=107397KB)\n                            (malloc=107365KB #1972)\n                            (mmap: reserved=32KB, committed=32KB)\n                   //保留字符串（Interned String）的引用与符号表引用\n-                    Symbol (reserved=1374KB, committed=1374KB)\n                            (malloc=918KB #92)\n                            (arena=456KB #1)\n     //NMT本身也需要内存\n-    Native Memory Tracking (reserved=185KB, committed=185KB)\n                            (malloc=107KB #1646)\n                            (tracking overhead=78KB)\n\n-               Arena Chunk (reserved=186KB, committed=186KB)\n                            (malloc=186KB)\n\nVirtual memory map:\n//JVM heap内存大小100M, 地址范围0x00000000f9c00000-0x0000000100000000, 由ParallelScavengeHeap::initialize来申请的内存块\n[0x00000000f9c00000 - 0x0000000100000000] reserved 102400KB for Java Heap from\n    //下面这个怀疑是该函数在内存中的地址\n    [0x00007ff092b43bd2] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0xc2\n    [0x00007ff092b4452e] ReservedHeapSpace::ReservedHeapSpace(unsigned long, unsigned long, bool, char*)+0x6e\n    [0x00007ff092b1249b] Universe::reserve_heap(unsigned long, unsigned long)+0x8b\n    [0x00007ff0929cc5c4] ParallelScavengeHeap::initialize()+0x84\n\n        [0x00000000ffe80000 - 0x0000000100000000] committed 1536KB from\n            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53\n            [0x00007ff092a17a85] PSYoungGen::initialize_virtual_space(ReservedSpace, unsigned long)+0x75\n            [0x00007ff092a183ee] PSYoungGen::initialize(ReservedSpace, unsigned long)+0x3e\n            [0x00007ff09236fc85] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x345\n\n        [0x00000000f9c00000 - 0x00000000ffe80000] committed 100864KB from\n            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53\n            [0x00007ff092a06b77] PSOldGen::initialize(ReservedSpace, unsigned long, char const*, int)+0xb7\n            [0x00007ff09236fcda] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x39a\n            [0x00007ff0929cc716] ParallelScavengeHeap::initialize()+0x1d6\n    ......\n[0x00007ff093b40000 - 0x00007ff093c41000] reserved and committed 1028KB for Thread Stack from\n    [0x00007ff092af4fd6] Threads::create_vm(JavaVMInitArgs*, bool*)+0x1e6\n    [0x00007ff09275e244] JNI_CreateJavaVM+0x74\n    [0x00007ff09360245e] JavaMain+0x9e\n\n[0x00007ff093c49000 - 0x00007ff093c4b000] reserved 8KB for GC from\n    [0x00007ff092b43d66] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0x256\n    [0x00007ff092b43e0b] ReservedSpace::ReservedSpace(unsigned long, unsigned long, bool, char*, unsigned long)+0x1b\n    [0x00007ff092a0a1c2] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x92\n    [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178\n\n        [0x00007ff093c49000 - 0x00007ff093c4b000] committed 8KB from\n            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53\n            [0x00007ff092a0a274] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x144\n            [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178\n            [0x00007ff0929cc8c5] ParallelScavengeHeap::initialize()+0x385\nDetails:\n\n[0x00007ff092b1ad2b] Unsafe_AllocateMemory+0x1db\n[0x00007ff07d015994]\n                             //展示了DirectByteBuffer内存申请情况, 供92个内存块, 总共占用94MB大小\n                             (malloc=94208KB #92)\n\n[0x00007ff0923cca65] ArrayAllocator<unsigned long, (MemoryType)7>::allocate(unsigned long)+0x175\n[0x00007ff092a0092f] ParCompactionManager::initialize(ParMarkBitMap*)+0x28f\n[0x00007ff092a0a105] PSParallelCompact::post_initialize()+0xb5\n[0x00007ff0929cc535] ParallelScavengeHeap::post_initialize()+0x25\n                             (malloc=34816KB #34)\n\n[0x00007ff092a11d45] ArrayAllocator<StarTask, (MemoryType)1>::allocate(unsigned long)+0x175\n[0x00007ff092a10160] PSPromotionManager::PSPromotionManager()+0x1f0\n[0x00007ff092a106ad] PSPromotionManager::initialize()+0x13d\n[0x00007ff092b11f43] universe_post_init()+0x883\n                             (malloc=34816KB #34)\n```\n至于每个内存块存放的详情, 可以在pmap里查看。可见, 我们可以根据detail可以了解每块内存是由谁申请的。\n\n#### 内存增量diff\n执行顺序:\n+ /usr/local/java18/bin/jcmd 8202 VM.native_memory baseline 作为内存基准\n+ /usr/local/java18/bin/jcmd 8202 VM.native_memory detail.diff 根据内存基准来比较增量\n结果如下:\n```\nNative Memory Tracking:\nTotal: reserved=1617492KB +13331KB, committed=319304KB +13331KB\n-                 Java Heap (reserved=102400KB, committed=102400KB)\n                            (mmap: reserved=102400KB, committed=102400KB)\n                          ......\n                 Internal (reserved=70999KB +13312KB, committed=70999KB +13312KB)\n                            (malloc=70967KB +13312KB #1914 +13)\n                            (mmap: reserved=32KB, committed=32KB)\n\n-                    Symbol (reserved=1374KB, committed=1374KB)\n                            (malloc=918KB #92)\n                            (arena=456KB #1)\n\n-    Native Memory Tracking (reserved=183KB +19KB, committed=183KB +19KB)\n                            (malloc=106KB +15KB #1628 +212)\n                            (tracking overhead=77KB +4KB)\n\n-               Arena Chunk (reserved=186KB, committed=186KB)\n                            (malloc=186KB)\n\n[0x00007f5c46ed7d2b] Unsafe_AllocateMemory+0x1db\n[0x00007f5c31015994]\n                             (malloc=35840KB +13312KB #35 +13)\n\n[0x00007f5c46cc4883] MemBaseline::aggregate_virtual_memory_allocation_sites()+0x173\n[0x00007f5c46cc4b08] MemBaseline::baseline_allocation_sites()+0x1d8\n[0x00007f5c46cc5185] MemBaseline::baseline(bool)+0x635\n[0x00007f5c46d34188] NMTDCmd::execute(DCmdSource, Thread*)+0x178\n                             (malloc=1KB +1KB #17 +17)\n```\n如上图, 可以轻易发现Unsafe_AllocateMemory diff期间,增加了13次内存分配, 新增了13MB内存申请。\n\n## pmap\npmap可以查看进程使用的内存分布, 包括所有堆内和堆外内存。\n使用: pmap -x 9752 | sort -n -r -k 2, 并不需要root或者别的参数就可以执行, 查看进程的内存映射信息\n```\nmapped: 5341520K    writeable/private: 308668K    shared: 3836K\nAddress           Kbytes       Mode   Offset Device  Mapping\n0000000100080000 1048064       0       0 -----    [ anon ]\n00007fb789360000  242304       0       0 -----    [ anon ]\n00000000f9c00000  102912   23776   23776 rw---    [ anon ]\n00007fb6a216c000   96848      44       0 r----  locale-archive\n00007fb784021000   65404       0       0 -----    [ anon ]\n00007fb780021000   65404       0       0 -----    [ anon ]\n00007fb77c021000   65404       0       0 -----    [ anon ]\n00007fb778021000   65404       0       0 -----    [ anon ]\n00007fb774021000   65404       0       0 -----    [ anon ]\n00007fb770021000   65404       0       0 -----    [ anon ]\n00007fb76c021000   65404       0       0 -----    [ anon ]\n00007fb768021000   65404       0       0 -----    [ anon ]\n00007fb764021000   65404       0       0 -----    [ anon ]\n00007fb760021000   65404       0       0 -----    [ anon ]\n00007fb75c021000   65404       0       0 -----    [ anon ]\n00007fb758021000   65404       0       0 -----    [ anon ]\n00007fb750021000   65404       0       0 -----    [ anon ]\n00007fb74c021000   65404       0       0 -----    [ anon ]\n00007fb748021000   65404       0       0 -----    [ anon ]\n00007fb740021000   65404       0       0 -----    [ anon ]\n00007fb738021000   65404       0       0 -----    [ anon ]\n00007fb730021000   65404       0       0 -----    [ anon ]\n00007fb728021000   65404       0       0 -----    [ anon ]\n00007fb720021000   65404       0       0 -----    [ anon ]\n00007fb718021000   65404       0       0 -----    [ anon ]\n00007fb710021000   65404       0       0 -----    [ anon ]\n00007fb708021000   65404       0       0 -----    [ anon ]\n00007fb700021000   65404       0       0 -----    [ anon ]\n00007fb7a1802000    2048       0       0 -----  libpthread-2.12.so\n00007fb7a15ea000    2048       0       0 -----  libjli.so\n```\nAddress:  start address of map  映像起始地址, 就是真实内存地址\nKbytes:  size of map in kilobytes  映像大小\nRSS:  resident set size in kilobytes  驻留集大小\nDirty:  dirty pages (both shared and private) in kilobytes  脏页大小\nMode:  permissions on map 映像权限: r=read, w=write, x=execute, s=shared, p=private (copy on write)\nMapping:  file backing the map , or '[ anon ]' for allocated memory, or '[ stack ]' for the program stack.  映像支持文件,[anon]为已分配内存 [stack]为程序堆栈\nOffset:  offset into the file  文件偏移\nDevice:  device name (major:minor)  设备名\n第一行的值:\n+ mapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz\n+ writeable/private  表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小\n+ shared 表示进程和其他进程共享的内存大小\n根据此处的address和NMT可判断出该内存块属于哪个空间的。我们可以通过如下方式检查是否存在内存泄露\n`while true; do pmap -d  3066 | tail -1; sleep 1; done`\n```\nmapped: 5411424K    writeable/private: 378492K    shared: 3836K\nmapped: 5412452K    writeable/private: 379520K    shared: 3836K\nmapped: 5413480K    writeable/private: 380548K    shared: 3836K\nmapped: 5414508K    writeable/private: 381576K    shared: 3836K\nmapped: 5415536K    writeable/private: 382604K    shared: 3836K\n```\n# 参考\nhttp://goog-perftools.sourceforge.net/doc/heap_profiler.html\nhttps://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html\nhttps://www.cnblogs.com/duanxz/archive/2012/08/09/2630284.html\nhttps://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html\nhttps://www.cnblogs.com/sidesky/p/10009241.html\nhttps://yq.aliyun.com/articles/227924\nhttps://www.cnblogs.com/ggjucheng/p/3348439.html","slug":"jvm内存泄露排查工具","published":1,"updated":"2019-06-05T16:24:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xu001bphu5q7oqn6ay","content":"<p>本文介绍几个不常用的内存泄露排查工具:perftools、pmap、jcmd。</p>\n<h2 id=\"perftools\"><a href=\"#perftools\" class=\"headerlink\" title=\"perftools\"></a>perftools</h2><p>perftools是一款比较好的分析堆外内存泄漏的工具, 原理: 通过使用自己实现的libtcmalloc.so来替换原有的内存分配函数, 来达到监控内存分配的目的</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>perftools安装需要依赖:libunwind, 首先安装libunwind:</p>\n<ul>\n<li>wget <a href=\"https://github.com/libunwind/libunwind/releases/download/v1.2.1/libunwind-1.2.1.tar.gz\" target=\"_blank\" rel=\"external\">https://github.com/libunwind/libunwind/releases/download/v1.2.1/libunwind-1.2.1.tar.gz</a></li>\n<li>tar -xvf libunwind-1.2.1.tar.gz</li>\n<li>cd libunwind-1.2.1</li>\n<li>./configure  –prefix=/home/target/libunwind</li>\n<li>make</li>\n<li>make install<br>其次安装perftools:</li>\n<li>wget <a href=\"https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz\" target=\"_blank\" rel=\"external\">https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</a></li>\n<li>tar -xvf gperftools-2.6.1.tar.gz</li>\n<li>cd gperftools-2.6.1</li>\n<li>./configure –prefix=/home/target/gperftools</li>\n<li>make (安装时候, 可能会报g++: command not found, 切换到root: yum -y install gcc+ gcc-c++, 需要再次执行上一步, 否则会报异常)</li>\n<li>make install<br>我们还需要设置一些环境变量:<br>export LD_PRELOAD=/home/target/gperftools/lib/libtcmalloc.so<br>目的：在程序启动时自动链接libtcmalloc.so<br>export HEAPPROFILE=/you_directory/heap.hprof<br>目的: 内存才能监控将产生很多.heap, 设置文件存放位置<br>export HEAP_PROFILE_ALLOCATION_INTERVAL=10000000<br>目的: 内存使用多少, 会产生一个.heap文件。 默认每使用1G, 产生一个.bin文件。</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><ul>\n<li>直接启动jvm进程, perftools会监控内存使用<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak.png\" height=\"250\" width=\"850\"></li>\n<li>查看产生的heap.hprof.0001.heap文件<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak1.png\" height=\"450\" width=\"850\"><br>其中对每列的介绍如下:<br>The first column contains the direct memory use in MB(当前函数目前使用的直接内存大小).<br>The fourth column contains memory use by the procedure and all of its callees(当前函数及其调用者使用的直接内存).<br>The second and fifth columns are just percentage representations of the numbers in the first and fifth columns.<br>The third column is a cumulative sum of the second column (i.e., the kth entry in the third column is the sum of the first k entries in the second column.)(目前占用的总堆外内存大小)</li>\n</ul>\n<h2 id=\"jcmd\"><a href=\"#jcmd\" class=\"headerlink\" title=\"jcmd\"></a>jcmd</h2><p>jcm是一个多功能工具, 功能如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">$user@host: /usr/local/java18/bin/jcmd 25266 help</div><div class=\"line\">25266:</div><div class=\"line\">The following commands are available:</div><div class=\"line\">JFR.stop</div><div class=\"line\">JFR.start</div><div class=\"line\">JFR.dump</div><div class=\"line\">JFR.check</div><div class=\"line\">VM.native_memory</div><div class=\"line\">VM.check_commercial_features</div><div class=\"line\">VM.unlock_commercial_features</div><div class=\"line\">ManagementAgent.stop</div><div class=\"line\">ManagementAgent.start_local</div><div class=\"line\">ManagementAgent.start</div><div class=\"line\">GC.rotate_log</div><div class=\"line\">Thread.print         // 与jstack功能相同</div><div class=\"line\">GC.class_stats</div><div class=\"line\">GC.class_histogram    // 与jmap -histo功能相同</div><div class=\"line\">GC.heap_dump         //与jmap -dump功能相同</div><div class=\"line\">GC.run_finalization</div><div class=\"line\">GC.run</div><div class=\"line\">VM.uptime</div><div class=\"line\">VM.flags                   //查看更完整的启动命令, 包括默认的参数, 比如垃圾回收器</div><div class=\"line\">VM.system_properties      //查看系统参数</div><div class=\"line\">VM.command_line          //查看启动命令</div><div class=\"line\">VM.version</div><div class=\"line\">help</div></pre></td></tr></table></figure></p>\n<p>我们将着重介绍VM.native_memory, 该参数可以支持我们追踪堆内内存的申请。 不过我们必须在进程启动时添加-XX:NativeMemoryTracking=detail参数才可用。 开启该参数将导致jvm进程5-10%性能损耗。<br>其参数如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">summary</td>\n<td style=\"text-align:left\">汇总的内存展示</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">detail</td>\n<td style=\"text-align:left\">详细的内存展示, 不仅包括summary, 还包括每个内存块地址及具体分配者</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">baseline</td>\n<td style=\"text-align:left\">当前线程拥有的内存块作为基准线, 与调用detail.diff summary.diff时刻的线程比较得出增量情况</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">detail.diff</td>\n<td style=\"text-align:left\">内存增量的详情</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">summary.diff</td>\n<td style=\"text-align:left\">内存增量的汇总情况</td>\n</tr>\n</tbody>\n</table>\n<p>VM.native_memory显示的内存包含<code>堆内内存、Code区域、通过unsafe.allocateMemory(DirectByteBuffer实际也是由前者产生)，但是不包含其他Native Code（C代码）申请的堆外内存</code>。</p>\n<h4 id=\"VM-native-memory\"><a href=\"#VM-native-memory\" class=\"headerlink\" title=\"VM.native_memory\"></a>VM.native_memory</h4><p>用法: jcmd pid VM.native_memory detail<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">44387:</div><div class=\"line\">Native Memory Tracking:</div><div class=\"line\">Total: reserved=1653891KB, committed=355703KB</div><div class=\"line\">                  //同启动参数一致</div><div class=\"line\">-                 Java Heap (reserved=102400KB, committed=102400KB)</div><div class=\"line\">                            (mmap: reserved=102400KB, committed=102400KB)</div><div class=\"line\">                   //类需要的内存</div><div class=\"line\">-                 Class (reserved=1091740KB, committed=39836KB)</div><div class=\"line\">                            (classes #426)</div><div class=\"line\">                            (malloc=34972KB #267)</div><div class=\"line\">                            (mmap: reserved=1056768KB, committed=4864KB)</div><div class=\"line\">                  //thread #57，表示57个线程，分配的总内存有57807KB，平均一个线程是1MB。</div><div class=\"line\">-                  Thread (reserved=57807KB, committed=57807KB)</div><div class=\"line\">                            (thread #57)</div><div class=\"line\">                            (stack: reserved=57568KB, committed=57568KB)</div><div class=\"line\">                            (malloc=173KB #315)</div><div class=\"line\">                            (arena=66KB #112)</div><div class=\"line\">                   //JIT的代码缓存</div><div class=\"line\">-                  Code (reserved=249648KB, committed=3560KB)</div><div class=\"line\">                            (malloc=48KB #336)</div><div class=\"line\">                            (mmap: reserved=249600KB, committed=3512KB)</div><div class=\"line\">                   //GC需要的内存</div><div class=\"line\">-                  GC (reserved=43020KB, committed=42824KB)</div><div class=\"line\">                            (malloc=39208KB #204)</div><div class=\"line\">                            (mmap: reserved=3812KB, committed=3616KB)</div><div class=\"line\">                   //供编译器自身操作使用的</div><div class=\"line\">-                  Compiler (reserved=135KB, committed=135KB)</div><div class=\"line\">                            (malloc=4KB #41)</div><div class=\"line\">                            (arena=131KB #3)</div><div class=\"line\">                   //</div><div class=\"line\">-                  Internal (reserved=107397KB, committed=107397KB)</div><div class=\"line\">                            (malloc=107365KB #1972)</div><div class=\"line\">                            (mmap: reserved=32KB, committed=32KB)</div><div class=\"line\">                   //保留字符串（Interned String）的引用与符号表引用</div><div class=\"line\">-                    Symbol (reserved=1374KB, committed=1374KB)</div><div class=\"line\">                            (malloc=918KB #92)</div><div class=\"line\">                            (arena=456KB #1)</div><div class=\"line\">     //NMT本身也需要内存</div><div class=\"line\">-    Native Memory Tracking (reserved=185KB, committed=185KB)</div><div class=\"line\">                            (malloc=107KB #1646)</div><div class=\"line\">                            (tracking overhead=78KB)</div><div class=\"line\"></div><div class=\"line\">-               Arena Chunk (reserved=186KB, committed=186KB)</div><div class=\"line\">                            (malloc=186KB)</div><div class=\"line\"></div><div class=\"line\">Virtual memory map:</div><div class=\"line\">//JVM heap内存大小100M, 地址范围0x00000000f9c00000-0x0000000100000000, 由ParallelScavengeHeap::initialize来申请的内存块</div><div class=\"line\">[0x00000000f9c00000 - 0x0000000100000000] reserved 102400KB for Java Heap from</div><div class=\"line\">    //下面这个怀疑是该函数在内存中的地址</div><div class=\"line\">    [0x00007ff092b43bd2] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0xc2</div><div class=\"line\">    [0x00007ff092b4452e] ReservedHeapSpace::ReservedHeapSpace(unsigned long, unsigned long, bool, char*)+0x6e</div><div class=\"line\">    [0x00007ff092b1249b] Universe::reserve_heap(unsigned long, unsigned long)+0x8b</div><div class=\"line\">    [0x00007ff0929cc5c4] ParallelScavengeHeap::initialize()+0x84</div><div class=\"line\"></div><div class=\"line\">        [0x00000000ffe80000 - 0x0000000100000000] committed 1536KB from</div><div class=\"line\">            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53</div><div class=\"line\">            [0x00007ff092a17a85] PSYoungGen::initialize_virtual_space(ReservedSpace, unsigned long)+0x75</div><div class=\"line\">            [0x00007ff092a183ee] PSYoungGen::initialize(ReservedSpace, unsigned long)+0x3e</div><div class=\"line\">            [0x00007ff09236fc85] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x345</div><div class=\"line\"></div><div class=\"line\">        [0x00000000f9c00000 - 0x00000000ffe80000] committed 100864KB from</div><div class=\"line\">            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53</div><div class=\"line\">            [0x00007ff092a06b77] PSOldGen::initialize(ReservedSpace, unsigned long, char const*, int)+0xb7</div><div class=\"line\">            [0x00007ff09236fcda] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x39a</div><div class=\"line\">            [0x00007ff0929cc716] ParallelScavengeHeap::initialize()+0x1d6</div><div class=\"line\">    ......</div><div class=\"line\">[0x00007ff093b40000 - 0x00007ff093c41000] reserved and committed 1028KB for Thread Stack from</div><div class=\"line\">    [0x00007ff092af4fd6] Threads::create_vm(JavaVMInitArgs*, bool*)+0x1e6</div><div class=\"line\">    [0x00007ff09275e244] JNI_CreateJavaVM+0x74</div><div class=\"line\">    [0x00007ff09360245e] JavaMain+0x9e</div><div class=\"line\"></div><div class=\"line\">[0x00007ff093c49000 - 0x00007ff093c4b000] reserved 8KB for GC from</div><div class=\"line\">    [0x00007ff092b43d66] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0x256</div><div class=\"line\">    [0x00007ff092b43e0b] ReservedSpace::ReservedSpace(unsigned long, unsigned long, bool, char*, unsigned long)+0x1b</div><div class=\"line\">    [0x00007ff092a0a1c2] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x92</div><div class=\"line\">    [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178</div><div class=\"line\"></div><div class=\"line\">        [0x00007ff093c49000 - 0x00007ff093c4b000] committed 8KB from</div><div class=\"line\">            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53</div><div class=\"line\">            [0x00007ff092a0a274] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x144</div><div class=\"line\">            [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178</div><div class=\"line\">            [0x00007ff0929cc8c5] ParallelScavengeHeap::initialize()+0x385</div><div class=\"line\">Details:</div><div class=\"line\"></div><div class=\"line\">[0x00007ff092b1ad2b] Unsafe_AllocateMemory+0x1db</div><div class=\"line\">[0x00007ff07d015994]</div><div class=\"line\">                             //展示了DirectByteBuffer内存申请情况, 供92个内存块, 总共占用94MB大小</div><div class=\"line\">                             (malloc=94208KB #92)</div><div class=\"line\"></div><div class=\"line\">[0x00007ff0923cca65] ArrayAllocator&lt;unsigned long, (MemoryType)7&gt;::allocate(unsigned long)+0x175</div><div class=\"line\">[0x00007ff092a0092f] ParCompactionManager::initialize(ParMarkBitMap*)+0x28f</div><div class=\"line\">[0x00007ff092a0a105] PSParallelCompact::post_initialize()+0xb5</div><div class=\"line\">[0x00007ff0929cc535] ParallelScavengeHeap::post_initialize()+0x25</div><div class=\"line\">                             (malloc=34816KB #34)</div><div class=\"line\"></div><div class=\"line\">[0x00007ff092a11d45] ArrayAllocator&lt;StarTask, (MemoryType)1&gt;::allocate(unsigned long)+0x175</div><div class=\"line\">[0x00007ff092a10160] PSPromotionManager::PSPromotionManager()+0x1f0</div><div class=\"line\">[0x00007ff092a106ad] PSPromotionManager::initialize()+0x13d</div><div class=\"line\">[0x00007ff092b11f43] universe_post_init()+0x883</div><div class=\"line\">                             (malloc=34816KB #34)</div></pre></td></tr></table></figure></p>\n<p>至于每个内存块存放的详情, 可以在pmap里查看。可见, 我们可以根据detail可以了解每块内存是由谁申请的。</p>\n<h4 id=\"内存增量diff\"><a href=\"#内存增量diff\" class=\"headerlink\" title=\"内存增量diff\"></a>内存增量diff</h4><p>执行顺序:</p>\n<ul>\n<li>/usr/local/java18/bin/jcmd 8202 VM.native_memory baseline 作为内存基准</li>\n<li>/usr/local/java18/bin/jcmd 8202 VM.native_memory detail.diff 根据内存基准来比较增量<br>结果如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">Native Memory Tracking:</div><div class=\"line\">Total: reserved=1617492KB +13331KB, committed=319304KB +13331KB</div><div class=\"line\">-                 Java Heap (reserved=102400KB, committed=102400KB)</div><div class=\"line\">                            (mmap: reserved=102400KB, committed=102400KB)</div><div class=\"line\">                          ......</div><div class=\"line\">                 Internal (reserved=70999KB +13312KB, committed=70999KB +13312KB)</div><div class=\"line\">                            (malloc=70967KB +13312KB #1914 +13)</div><div class=\"line\">                            (mmap: reserved=32KB, committed=32KB)</div><div class=\"line\"></div><div class=\"line\">-                    Symbol (reserved=1374KB, committed=1374KB)</div><div class=\"line\">                            (malloc=918KB #92)</div><div class=\"line\">                            (arena=456KB #1)</div><div class=\"line\"></div><div class=\"line\">-    Native Memory Tracking (reserved=183KB +19KB, committed=183KB +19KB)</div><div class=\"line\">                            (malloc=106KB +15KB #1628 +212)</div><div class=\"line\">                            (tracking overhead=77KB +4KB)</div><div class=\"line\"></div><div class=\"line\">-               Arena Chunk (reserved=186KB, committed=186KB)</div><div class=\"line\">                            (malloc=186KB)</div><div class=\"line\"></div><div class=\"line\">[0x00007f5c46ed7d2b] Unsafe_AllocateMemory+0x1db</div><div class=\"line\">[0x00007f5c31015994]</div><div class=\"line\">                             (malloc=35840KB +13312KB #35 +13)</div><div class=\"line\"></div><div class=\"line\">[0x00007f5c46cc4883] MemBaseline::aggregate_virtual_memory_allocation_sites()+0x173</div><div class=\"line\">[0x00007f5c46cc4b08] MemBaseline::baseline_allocation_sites()+0x1d8</div><div class=\"line\">[0x00007f5c46cc5185] MemBaseline::baseline(bool)+0x635</div><div class=\"line\">[0x00007f5c46d34188] NMTDCmd::execute(DCmdSource, Thread*)+0x178</div><div class=\"line\">                             (malloc=1KB +1KB #17 +17)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上图, 可以轻易发现Unsafe_AllocateMemory diff期间,增加了13次内存分配, 新增了13MB内存申请。</p>\n<h2 id=\"pmap\"><a href=\"#pmap\" class=\"headerlink\" title=\"pmap\"></a>pmap</h2><p>pmap可以查看进程使用的内存分布, 包括所有堆内和堆外内存。<br>使用: pmap -x 9752 | sort -n -r -k 2, 并不需要root或者别的参数就可以执行, 查看进程的内存映射信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">mapped: 5341520K    writeable/private: 308668K    shared: 3836K</div><div class=\"line\">Address           Kbytes       Mode   Offset Device  Mapping</div><div class=\"line\">0000000100080000 1048064       0       0 -----    [ anon ]</div><div class=\"line\">00007fb789360000  242304       0       0 -----    [ anon ]</div><div class=\"line\">00000000f9c00000  102912   23776   23776 rw---    [ anon ]</div><div class=\"line\">00007fb6a216c000   96848      44       0 r----  locale-archive</div><div class=\"line\">00007fb784021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb780021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb77c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb778021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb774021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb770021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb76c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb768021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb764021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb760021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb75c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb758021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb750021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb74c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb748021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb740021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb738021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb730021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb728021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb720021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb718021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb710021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb708021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb700021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb7a1802000    2048       0       0 -----  libpthread-2.12.so</div><div class=\"line\">00007fb7a15ea000    2048       0       0 -----  libjli.so</div></pre></td></tr></table></figure></p>\n<p>Address:  start address of map  映像起始地址, 就是真实内存地址<br>Kbytes:  size of map in kilobytes  映像大小<br>RSS:  resident set size in kilobytes  驻留集大小<br>Dirty:  dirty pages (both shared and private) in kilobytes  脏页大小<br>Mode:  permissions on map 映像权限: r=read, w=write, x=execute, s=shared, p=private (copy on write)<br>Mapping:  file backing the map , or ‘[ anon ]’ for allocated memory, or ‘[ stack ]’ for the program stack.  映像支持文件,[anon]为已分配内存 [stack]为程序堆栈<br>Offset:  offset into the file  文件偏移<br>Device:  device name (major:minor)  设备名<br>第一行的值:</p>\n<ul>\n<li>mapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz</li>\n<li>writeable/private  表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小</li>\n<li>shared 表示进程和其他进程共享的内存大小<br>根据此处的address和NMT可判断出该内存块属于哪个空间的。我们可以通过如下方式检查是否存在内存泄露<br><code>while true; do pmap -d  3066 | tail -1; sleep 1; done</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mapped: 5411424K    writeable/private: 378492K    shared: 3836K</div><div class=\"line\">mapped: 5412452K    writeable/private: 379520K    shared: 3836K</div><div class=\"line\">mapped: 5413480K    writeable/private: 380548K    shared: 3836K</div><div class=\"line\">mapped: 5414508K    writeable/private: 381576K    shared: 3836K</div><div class=\"line\">mapped: 5415536K    writeable/private: 382604K    shared: 3836K</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://goog-perftools.sourceforge.net/doc/heap_profiler.html\" target=\"_blank\" rel=\"external\">http://goog-perftools.sourceforge.net/doc/heap_profiler.html</a><br><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html\" target=\"_blank\" rel=\"external\">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html</a><br><a href=\"https://www.cnblogs.com/duanxz/archive/2012/08/09/2630284.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/duanxz/archive/2012/08/09/2630284.html</a><br><a href=\"https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html\" target=\"_blank\" rel=\"external\">https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html</a><br><a href=\"https://www.cnblogs.com/sidesky/p/10009241.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/sidesky/p/10009241.html</a><br><a href=\"https://yq.aliyun.com/articles/227924\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/articles/227924</a><br><a href=\"https://www.cnblogs.com/ggjucheng/p/3348439.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/ggjucheng/p/3348439.html</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍几个不常用的内存泄露排查工具:perftools、pmap、jcmd。</p>\n<h2 id=\"perftools\"><a href=\"#perftools\" class=\"headerlink\" title=\"perftools\"></a>perftools</h2><p>perftools是一款比较好的分析堆外内存泄漏的工具, 原理: 通过使用自己实现的libtcmalloc.so来替换原有的内存分配函数, 来达到监控内存分配的目的</p>\n<h4 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h4><p>perftools安装需要依赖:libunwind, 首先安装libunwind:</p>\n<ul>\n<li>wget <a href=\"https://github.com/libunwind/libunwind/releases/download/v1.2.1/libunwind-1.2.1.tar.gz\" target=\"_blank\" rel=\"external\">https://github.com/libunwind/libunwind/releases/download/v1.2.1/libunwind-1.2.1.tar.gz</a></li>\n<li>tar -xvf libunwind-1.2.1.tar.gz</li>\n<li>cd libunwind-1.2.1</li>\n<li>./configure  –prefix=/home/target/libunwind</li>\n<li>make</li>\n<li>make install<br>其次安装perftools:</li>\n<li>wget <a href=\"https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz\" target=\"_blank\" rel=\"external\">https://github.com/gperftools/gperftools/releases/download/gperftools-2.6.1/gperftools-2.6.1.tar.gz</a></li>\n<li>tar -xvf gperftools-2.6.1.tar.gz</li>\n<li>cd gperftools-2.6.1</li>\n<li>./configure –prefix=/home/target/gperftools</li>\n<li>make (安装时候, 可能会报g++: command not found, 切换到root: yum -y install gcc+ gcc-c++, 需要再次执行上一步, 否则会报异常)</li>\n<li>make install<br>我们还需要设置一些环境变量:<br>export LD_PRELOAD=/home/target/gperftools/lib/libtcmalloc.so<br>目的：在程序启动时自动链接libtcmalloc.so<br>export HEAPPROFILE=/you_directory/heap.hprof<br>目的: 内存才能监控将产生很多.heap, 设置文件存放位置<br>export HEAP_PROFILE_ALLOCATION_INTERVAL=10000000<br>目的: 内存使用多少, 会产生一个.heap文件。 默认每使用1G, 产生一个.bin文件。</li>\n</ul>\n<h4 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h4><ul>\n<li>直接启动jvm进程, perftools会监控内存使用<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak.png\" height=\"250\" width=\"850\"></li>\n<li>查看产生的heap.hprof.0001.heap文件<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/jvm_memory_leak1.png\" height=\"450\" width=\"850\"><br>其中对每列的介绍如下:<br>The first column contains the direct memory use in MB(当前函数目前使用的直接内存大小).<br>The fourth column contains memory use by the procedure and all of its callees(当前函数及其调用者使用的直接内存).<br>The second and fifth columns are just percentage representations of the numbers in the first and fifth columns.<br>The third column is a cumulative sum of the second column (i.e., the kth entry in the third column is the sum of the first k entries in the second column.)(目前占用的总堆外内存大小)</li>\n</ul>\n<h2 id=\"jcmd\"><a href=\"#jcmd\" class=\"headerlink\" title=\"jcmd\"></a>jcmd</h2><p>jcm是一个多功能工具, 功能如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">$user@host: /usr/local/java18/bin/jcmd 25266 help</div><div class=\"line\">25266:</div><div class=\"line\">The following commands are available:</div><div class=\"line\">JFR.stop</div><div class=\"line\">JFR.start</div><div class=\"line\">JFR.dump</div><div class=\"line\">JFR.check</div><div class=\"line\">VM.native_memory</div><div class=\"line\">VM.check_commercial_features</div><div class=\"line\">VM.unlock_commercial_features</div><div class=\"line\">ManagementAgent.stop</div><div class=\"line\">ManagementAgent.start_local</div><div class=\"line\">ManagementAgent.start</div><div class=\"line\">GC.rotate_log</div><div class=\"line\">Thread.print         // 与jstack功能相同</div><div class=\"line\">GC.class_stats</div><div class=\"line\">GC.class_histogram    // 与jmap -histo功能相同</div><div class=\"line\">GC.heap_dump         //与jmap -dump功能相同</div><div class=\"line\">GC.run_finalization</div><div class=\"line\">GC.run</div><div class=\"line\">VM.uptime</div><div class=\"line\">VM.flags                   //查看更完整的启动命令, 包括默认的参数, 比如垃圾回收器</div><div class=\"line\">VM.system_properties      //查看系统参数</div><div class=\"line\">VM.command_line          //查看启动命令</div><div class=\"line\">VM.version</div><div class=\"line\">help</div></pre></td></tr></table></figure></p>\n<p>我们将着重介绍VM.native_memory, 该参数可以支持我们追踪堆内内存的申请。 不过我们必须在进程启动时添加-XX:NativeMemoryTracking=detail参数才可用。 开启该参数将导致jvm进程5-10%性能损耗。<br>其参数如下:</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">参数</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">summary</td>\n<td style=\"text-align:left\">汇总的内存展示</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">detail</td>\n<td style=\"text-align:left\">详细的内存展示, 不仅包括summary, 还包括每个内存块地址及具体分配者</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">baseline</td>\n<td style=\"text-align:left\">当前线程拥有的内存块作为基准线, 与调用detail.diff summary.diff时刻的线程比较得出增量情况</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">detail.diff</td>\n<td style=\"text-align:left\">内存增量的详情</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">summary.diff</td>\n<td style=\"text-align:left\">内存增量的汇总情况</td>\n</tr>\n</tbody>\n</table>\n<p>VM.native_memory显示的内存包含<code>堆内内存、Code区域、通过unsafe.allocateMemory(DirectByteBuffer实际也是由前者产生)，但是不包含其他Native Code（C代码）申请的堆外内存</code>。</p>\n<h4 id=\"VM-native-memory\"><a href=\"#VM-native-memory\" class=\"headerlink\" title=\"VM.native_memory\"></a>VM.native_memory</h4><p>用法: jcmd pid VM.native_memory detail<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div></pre></td><td class=\"code\"><pre><div class=\"line\">44387:</div><div class=\"line\">Native Memory Tracking:</div><div class=\"line\">Total: reserved=1653891KB, committed=355703KB</div><div class=\"line\">                  //同启动参数一致</div><div class=\"line\">-                 Java Heap (reserved=102400KB, committed=102400KB)</div><div class=\"line\">                            (mmap: reserved=102400KB, committed=102400KB)</div><div class=\"line\">                   //类需要的内存</div><div class=\"line\">-                 Class (reserved=1091740KB, committed=39836KB)</div><div class=\"line\">                            (classes #426)</div><div class=\"line\">                            (malloc=34972KB #267)</div><div class=\"line\">                            (mmap: reserved=1056768KB, committed=4864KB)</div><div class=\"line\">                  //thread #57，表示57个线程，分配的总内存有57807KB，平均一个线程是1MB。</div><div class=\"line\">-                  Thread (reserved=57807KB, committed=57807KB)</div><div class=\"line\">                            (thread #57)</div><div class=\"line\">                            (stack: reserved=57568KB, committed=57568KB)</div><div class=\"line\">                            (malloc=173KB #315)</div><div class=\"line\">                            (arena=66KB #112)</div><div class=\"line\">                   //JIT的代码缓存</div><div class=\"line\">-                  Code (reserved=249648KB, committed=3560KB)</div><div class=\"line\">                            (malloc=48KB #336)</div><div class=\"line\">                            (mmap: reserved=249600KB, committed=3512KB)</div><div class=\"line\">                   //GC需要的内存</div><div class=\"line\">-                  GC (reserved=43020KB, committed=42824KB)</div><div class=\"line\">                            (malloc=39208KB #204)</div><div class=\"line\">                            (mmap: reserved=3812KB, committed=3616KB)</div><div class=\"line\">                   //供编译器自身操作使用的</div><div class=\"line\">-                  Compiler (reserved=135KB, committed=135KB)</div><div class=\"line\">                            (malloc=4KB #41)</div><div class=\"line\">                            (arena=131KB #3)</div><div class=\"line\">                   //</div><div class=\"line\">-                  Internal (reserved=107397KB, committed=107397KB)</div><div class=\"line\">                            (malloc=107365KB #1972)</div><div class=\"line\">                            (mmap: reserved=32KB, committed=32KB)</div><div class=\"line\">                   //保留字符串（Interned String）的引用与符号表引用</div><div class=\"line\">-                    Symbol (reserved=1374KB, committed=1374KB)</div><div class=\"line\">                            (malloc=918KB #92)</div><div class=\"line\">                            (arena=456KB #1)</div><div class=\"line\">     //NMT本身也需要内存</div><div class=\"line\">-    Native Memory Tracking (reserved=185KB, committed=185KB)</div><div class=\"line\">                            (malloc=107KB #1646)</div><div class=\"line\">                            (tracking overhead=78KB)</div><div class=\"line\"></div><div class=\"line\">-               Arena Chunk (reserved=186KB, committed=186KB)</div><div class=\"line\">                            (malloc=186KB)</div><div class=\"line\"></div><div class=\"line\">Virtual memory map:</div><div class=\"line\">//JVM heap内存大小100M, 地址范围0x00000000f9c00000-0x0000000100000000, 由ParallelScavengeHeap::initialize来申请的内存块</div><div class=\"line\">[0x00000000f9c00000 - 0x0000000100000000] reserved 102400KB for Java Heap from</div><div class=\"line\">    //下面这个怀疑是该函数在内存中的地址</div><div class=\"line\">    [0x00007ff092b43bd2] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0xc2</div><div class=\"line\">    [0x00007ff092b4452e] ReservedHeapSpace::ReservedHeapSpace(unsigned long, unsigned long, bool, char*)+0x6e</div><div class=\"line\">    [0x00007ff092b1249b] Universe::reserve_heap(unsigned long, unsigned long)+0x8b</div><div class=\"line\">    [0x00007ff0929cc5c4] ParallelScavengeHeap::initialize()+0x84</div><div class=\"line\"></div><div class=\"line\">        [0x00000000ffe80000 - 0x0000000100000000] committed 1536KB from</div><div class=\"line\">            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53</div><div class=\"line\">            [0x00007ff092a17a85] PSYoungGen::initialize_virtual_space(ReservedSpace, unsigned long)+0x75</div><div class=\"line\">            [0x00007ff092a183ee] PSYoungGen::initialize(ReservedSpace, unsigned long)+0x3e</div><div class=\"line\">            [0x00007ff09236fc85] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x345</div><div class=\"line\"></div><div class=\"line\">        [0x00000000f9c00000 - 0x00000000ffe80000] committed 100864KB from</div><div class=\"line\">            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53</div><div class=\"line\">            [0x00007ff092a06b77] PSOldGen::initialize(ReservedSpace, unsigned long, char const*, int)+0xb7</div><div class=\"line\">            [0x00007ff09236fcda] AdjoiningGenerations::AdjoiningGenerations(ReservedSpace, GenerationSizer*, unsigned long)+0x39a</div><div class=\"line\">            [0x00007ff0929cc716] ParallelScavengeHeap::initialize()+0x1d6</div><div class=\"line\">    ......</div><div class=\"line\">[0x00007ff093b40000 - 0x00007ff093c41000] reserved and committed 1028KB for Thread Stack from</div><div class=\"line\">    [0x00007ff092af4fd6] Threads::create_vm(JavaVMInitArgs*, bool*)+0x1e6</div><div class=\"line\">    [0x00007ff09275e244] JNI_CreateJavaVM+0x74</div><div class=\"line\">    [0x00007ff09360245e] JavaMain+0x9e</div><div class=\"line\"></div><div class=\"line\">[0x00007ff093c49000 - 0x00007ff093c4b000] reserved 8KB for GC from</div><div class=\"line\">    [0x00007ff092b43d66] ReservedSpace::initialize(unsigned long, unsigned long, bool, char*, unsigned long, bool)+0x256</div><div class=\"line\">    [0x00007ff092b43e0b] ReservedSpace::ReservedSpace(unsigned long, unsigned long, bool, char*, unsigned long)+0x1b</div><div class=\"line\">    [0x00007ff092a0a1c2] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x92</div><div class=\"line\">    [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178</div><div class=\"line\"></div><div class=\"line\">        [0x00007ff093c49000 - 0x00007ff093c4b000] committed 8KB from</div><div class=\"line\">            [0x00007ff092a16ac3] PSVirtualSpace::expand_by(unsigned long)+0x53</div><div class=\"line\">            [0x00007ff092a0a274] ParallelCompactData::create_vspace(unsigned long, unsigned long)+0x144</div><div class=\"line\">            [0x00007ff092a0c718] PSParallelCompact::initialize()+0x178</div><div class=\"line\">            [0x00007ff0929cc8c5] ParallelScavengeHeap::initialize()+0x385</div><div class=\"line\">Details:</div><div class=\"line\"></div><div class=\"line\">[0x00007ff092b1ad2b] Unsafe_AllocateMemory+0x1db</div><div class=\"line\">[0x00007ff07d015994]</div><div class=\"line\">                             //展示了DirectByteBuffer内存申请情况, 供92个内存块, 总共占用94MB大小</div><div class=\"line\">                             (malloc=94208KB #92)</div><div class=\"line\"></div><div class=\"line\">[0x00007ff0923cca65] ArrayAllocator&lt;unsigned long, (MemoryType)7&gt;::allocate(unsigned long)+0x175</div><div class=\"line\">[0x00007ff092a0092f] ParCompactionManager::initialize(ParMarkBitMap*)+0x28f</div><div class=\"line\">[0x00007ff092a0a105] PSParallelCompact::post_initialize()+0xb5</div><div class=\"line\">[0x00007ff0929cc535] ParallelScavengeHeap::post_initialize()+0x25</div><div class=\"line\">                             (malloc=34816KB #34)</div><div class=\"line\"></div><div class=\"line\">[0x00007ff092a11d45] ArrayAllocator&lt;StarTask, (MemoryType)1&gt;::allocate(unsigned long)+0x175</div><div class=\"line\">[0x00007ff092a10160] PSPromotionManager::PSPromotionManager()+0x1f0</div><div class=\"line\">[0x00007ff092a106ad] PSPromotionManager::initialize()+0x13d</div><div class=\"line\">[0x00007ff092b11f43] universe_post_init()+0x883</div><div class=\"line\">                             (malloc=34816KB #34)</div></pre></td></tr></table></figure></p>\n<p>至于每个内存块存放的详情, 可以在pmap里查看。可见, 我们可以根据detail可以了解每块内存是由谁申请的。</p>\n<h4 id=\"内存增量diff\"><a href=\"#内存增量diff\" class=\"headerlink\" title=\"内存增量diff\"></a>内存增量diff</h4><p>执行顺序:</p>\n<ul>\n<li>/usr/local/java18/bin/jcmd 8202 VM.native_memory baseline 作为内存基准</li>\n<li>/usr/local/java18/bin/jcmd 8202 VM.native_memory detail.diff 根据内存基准来比较增量<br>结果如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">Native Memory Tracking:</div><div class=\"line\">Total: reserved=1617492KB +13331KB, committed=319304KB +13331KB</div><div class=\"line\">-                 Java Heap (reserved=102400KB, committed=102400KB)</div><div class=\"line\">                            (mmap: reserved=102400KB, committed=102400KB)</div><div class=\"line\">                          ......</div><div class=\"line\">                 Internal (reserved=70999KB +13312KB, committed=70999KB +13312KB)</div><div class=\"line\">                            (malloc=70967KB +13312KB #1914 +13)</div><div class=\"line\">                            (mmap: reserved=32KB, committed=32KB)</div><div class=\"line\"></div><div class=\"line\">-                    Symbol (reserved=1374KB, committed=1374KB)</div><div class=\"line\">                            (malloc=918KB #92)</div><div class=\"line\">                            (arena=456KB #1)</div><div class=\"line\"></div><div class=\"line\">-    Native Memory Tracking (reserved=183KB +19KB, committed=183KB +19KB)</div><div class=\"line\">                            (malloc=106KB +15KB #1628 +212)</div><div class=\"line\">                            (tracking overhead=77KB +4KB)</div><div class=\"line\"></div><div class=\"line\">-               Arena Chunk (reserved=186KB, committed=186KB)</div><div class=\"line\">                            (malloc=186KB)</div><div class=\"line\"></div><div class=\"line\">[0x00007f5c46ed7d2b] Unsafe_AllocateMemory+0x1db</div><div class=\"line\">[0x00007f5c31015994]</div><div class=\"line\">                             (malloc=35840KB +13312KB #35 +13)</div><div class=\"line\"></div><div class=\"line\">[0x00007f5c46cc4883] MemBaseline::aggregate_virtual_memory_allocation_sites()+0x173</div><div class=\"line\">[0x00007f5c46cc4b08] MemBaseline::baseline_allocation_sites()+0x1d8</div><div class=\"line\">[0x00007f5c46cc5185] MemBaseline::baseline(bool)+0x635</div><div class=\"line\">[0x00007f5c46d34188] NMTDCmd::execute(DCmdSource, Thread*)+0x178</div><div class=\"line\">                             (malloc=1KB +1KB #17 +17)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>如上图, 可以轻易发现Unsafe_AllocateMemory diff期间,增加了13次内存分配, 新增了13MB内存申请。</p>\n<h2 id=\"pmap\"><a href=\"#pmap\" class=\"headerlink\" title=\"pmap\"></a>pmap</h2><p>pmap可以查看进程使用的内存分布, 包括所有堆内和堆外内存。<br>使用: pmap -x 9752 | sort -n -r -k 2, 并不需要root或者别的参数就可以执行, 查看进程的内存映射信息<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">mapped: 5341520K    writeable/private: 308668K    shared: 3836K</div><div class=\"line\">Address           Kbytes       Mode   Offset Device  Mapping</div><div class=\"line\">0000000100080000 1048064       0       0 -----    [ anon ]</div><div class=\"line\">00007fb789360000  242304       0       0 -----    [ anon ]</div><div class=\"line\">00000000f9c00000  102912   23776   23776 rw---    [ anon ]</div><div class=\"line\">00007fb6a216c000   96848      44       0 r----  locale-archive</div><div class=\"line\">00007fb784021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb780021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb77c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb778021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb774021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb770021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb76c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb768021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb764021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb760021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb75c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb758021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb750021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb74c021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb748021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb740021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb738021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb730021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb728021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb720021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb718021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb710021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb708021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb700021000   65404       0       0 -----    [ anon ]</div><div class=\"line\">00007fb7a1802000    2048       0       0 -----  libpthread-2.12.so</div><div class=\"line\">00007fb7a15ea000    2048       0       0 -----  libjli.so</div></pre></td></tr></table></figure></p>\n<p>Address:  start address of map  映像起始地址, 就是真实内存地址<br>Kbytes:  size of map in kilobytes  映像大小<br>RSS:  resident set size in kilobytes  驻留集大小<br>Dirty:  dirty pages (both shared and private) in kilobytes  脏页大小<br>Mode:  permissions on map 映像权限: r=read, w=write, x=execute, s=shared, p=private (copy on write)<br>Mapping:  file backing the map , or ‘[ anon ]’ for allocated memory, or ‘[ stack ]’ for the program stack.  映像支持文件,[anon]为已分配内存 [stack]为程序堆栈<br>Offset:  offset into the file  文件偏移<br>Device:  device name (major:minor)  设备名<br>第一行的值:</p>\n<ul>\n<li>mapped 表示该进程映射的虚拟地址空间大小，也就是该进程预先分配的虚拟内存大小，即ps出的vsz</li>\n<li>writeable/private  表示进程所占用的私有地址空间大小，也就是该进程实际使用的内存大小</li>\n<li>shared 表示进程和其他进程共享的内存大小<br>根据此处的address和NMT可判断出该内存块属于哪个空间的。我们可以通过如下方式检查是否存在内存泄露<br><code>while true; do pmap -d  3066 | tail -1; sleep 1; done</code><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">mapped: 5411424K    writeable/private: 378492K    shared: 3836K</div><div class=\"line\">mapped: 5412452K    writeable/private: 379520K    shared: 3836K</div><div class=\"line\">mapped: 5413480K    writeable/private: 380548K    shared: 3836K</div><div class=\"line\">mapped: 5414508K    writeable/private: 381576K    shared: 3836K</div><div class=\"line\">mapped: 5415536K    writeable/private: 382604K    shared: 3836K</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"http://goog-perftools.sourceforge.net/doc/heap_profiler.html\" target=\"_blank\" rel=\"external\">http://goog-perftools.sourceforge.net/doc/heap_profiler.html</a><br><a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html\" target=\"_blank\" rel=\"external\">https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html</a><br><a href=\"https://www.cnblogs.com/duanxz/archive/2012/08/09/2630284.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/duanxz/archive/2012/08/09/2630284.html</a><br><a href=\"https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html\" target=\"_blank\" rel=\"external\">https://tech.meituan.com/2019/01/03/spring-boot-native-memory-leak.html</a><br><a href=\"https://www.cnblogs.com/sidesky/p/10009241.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/sidesky/p/10009241.html</a><br><a href=\"https://yq.aliyun.com/articles/227924\" target=\"_blank\" rel=\"external\">https://yq.aliyun.com/articles/227924</a><br><a href=\"https://www.cnblogs.com/ggjucheng/p/3348439.html\" target=\"_blank\" rel=\"external\">https://www.cnblogs.com/ggjucheng/p/3348439.html</a></p>\n"},{"title":"git 基本命令学习心得-1","date":"2017-03-08T04:46:57.000Z","toc":true,"_content":"一般在公共分支上操作,不能修改分支的提交记录, 但是可以使用cherry-pick, revert这样的可以使用, 而rebase, reset这样的命令一般在私有分支上才可用。\n# rebase\ngit rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase3.png\" height=\"300\" width=\"550\"/>\n`git:(dev) git rebase master`, 此时处于G(最新提交)操作。变基是以共同祖先节点开始变的, 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D', 基于D'与F合并变成F', 基于F'和G合并变成G'。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。\n用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase --continue继续解决下一个冲突\n注意: 并没有要求修改comment, commit不变\n## 半路rebase\n以上示例是我们在dev分支的最新提交H上进行rebase的, 假如我们不在最新G上操作, 而是在F上进行rebase操作, 会出现什么结果呢?\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase2.png\" height=\"300\" width=\"550\"/>\n可以看到dev分支没有任何变化, 而是将EF提交分别与D提交合并, 使EF部分变基到master分支上。\n## rebase -i 参数\n-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。\n`git:(dev): git rebase -i master`之后, 将弹出这样的界面:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase5.png\" height=\"350\" width=\"450\"/>\n\n红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:\n+ 操作action\n+ commit hash值\n+ commit commit\n其中action介绍在红框2中, 主要分为这几种类型:\n1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。\ngit rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。\n2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)\ngit rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。\n3) e, edit = use commit, but stop for amending\ngit rebase -i master: 和p参数没啥区别, 能修改所有提交的comment\ngit rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用--continue才能继续\n4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。\n执行以下命令:`git:(dev): git rebase -i HEAD~3`, 并且修改action如下:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\n```\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase6.png\" height=\"350\" width=\"450\"/>\ngit log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。\ngit rebase -i master也能和描述也是一致的。\n5) f, fixup = like \"squash\", but discard this commit's log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。\ngit rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。\ngit rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。\n6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用\n7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)\n\n## i参数控制复制、删除、重置提交顺序等\nrebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\npick 159f932 d1\n```\n该提交将重复提交第一次提交, 提交结果如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase7.png\" height=\"350\" width=\"450\"/>\n本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push --force origin mybranch分支。 master一般不允许直接这么弄\n\n# cherry-pick\ncherry-pick主要是将一个分支单独的提交变化合并到另外一个分支上, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交改变合并到当前master分支上, 那么就执行:\n`git:(master D提交): git cherry-pick G`, 提交完成后, G提交出的变化代码就会和master分支D处全部代码合并, 产生提交D'。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D'和G毫无关联。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase10.png\" height=\"350\" width=\"450\"/>\ncherry-pick在提取G提交的变化时, 能将变化抽取出来的, 就将变化提取出来, 能合并就合并。变化合并到D时, 有冲突就解决冲突。\ncherry-pick与rebase使用上的区别:\nrebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。\ncherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。\n-m 参数\ngit cherry-pick G -m 1/2等\ngit show --pretty=raw xszdsdsdds\nhttps://stackoverflow.com/questions/12626754/git-cherry-pick-syntax-and-merge-branches/12628579#12628579\n\n# revert\nrevert的含义是撤销(丢弃)某次提交, 下图为例, 比如想撤销G提交: `git:(master D提交): git revert G`, 实际就是丢弃G的提交, 具体实现是将G提交变化从当前提交D中去掉, 然后产生新的提交D'。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_revert1.png\" height=\"350\" width=\"450\"/>\n同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D'与G提交没有任何关系。\n比如`git:(master D提交): git revert HEAD`, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert --continue来完成此次操作。\n\n# checkout\ncheckout主要是从`对象库中(仓库)`拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从`暂存区(索引)`中检出文件来重置工作区的文件, 使用示例如下:\n+ git:(master D提交): git checkout G\n将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致\n+ git:(master D提交): git checkout -- file1\n用`暂存区`的文件file1来重置`工作区`的file1, 而不是从本地代码仓库来恢复。\n+ git:(master D提交): git checkout G -- file1\n用G提交的代码`暂存区`的文件file1来重置`工作区`的file1。\ncheckout不会去修改提交记录, 仅仅是修改了HEAD。\n\n# reset\nreset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。\n+ 在切换到某一次提交时, 可使用 三个参数:\n---soft: 仅仅是将当前master、HEAD指针指向commit3\n---mixed: 在---soft的基础上, 用commit3的提交来重置暂存区。(默认)\n---hard: 在---hard的集群上, 用commit3的提交来重置暂存区、工作区。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_reset.png\" height=\"250\" width=\"700\"/>\n+ git:(master D提交): git reset HEAD file1\n用`本地代码仓库`的文件file1来重置`暂存区`(索引)的file1。\n","source":"_posts/git-基本命令学习心得.md","raw":"---\ntitle: git 基本命令学习心得-1\ndate: 2017-03-08 12:46:57\ntags: git, rebase, cherry-pick, reset, checkout\ntoc: true\n---\n一般在公共分支上操作,不能修改分支的提交记录, 但是可以使用cherry-pick, revert这样的可以使用, 而rebase, reset这样的命令一般在私有分支上才可用。\n# rebase\ngit rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase3.png\" height=\"300\" width=\"550\"/>\n`git:(dev) git rebase master`, 此时处于G(最新提交)操作。变基是以共同祖先节点开始变的, 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D', 基于D'与F合并变成F', 基于F'和G合并变成G'。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。\n用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase --continue继续解决下一个冲突\n注意: 并没有要求修改comment, commit不变\n## 半路rebase\n以上示例是我们在dev分支的最新提交H上进行rebase的, 假如我们不在最新G上操作, 而是在F上进行rebase操作, 会出现什么结果呢?\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase2.png\" height=\"300\" width=\"550\"/>\n可以看到dev分支没有任何变化, 而是将EF提交分别与D提交合并, 使EF部分变基到master分支上。\n## rebase -i 参数\n-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。\n`git:(dev): git rebase -i master`之后, 将弹出这样的界面:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase5.png\" height=\"350\" width=\"450\"/>\n\n红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:\n+ 操作action\n+ commit hash值\n+ commit commit\n其中action介绍在红框2中, 主要分为这几种类型:\n1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。\ngit rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。\n2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容\ngit rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)\ngit rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。\n3) e, edit = use commit, but stop for amending\ngit rebase -i master: 和p参数没啥区别, 能修改所有提交的comment\ngit rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用--continue才能继续\n4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。\n执行以下命令:`git:(dev): git rebase -i HEAD~3`, 并且修改action如下:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\n```\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase6.png\" height=\"350\" width=\"450\"/>\ngit log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。\ngit rebase -i master也能和描述也是一致的。\n5) f, fixup = like \"squash\", but discard this commit's log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。\ngit rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。\ngit rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。\n6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用\n7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)\n\n## i参数控制复制、删除、重置提交顺序等\nrebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:\n```\npick 159f932 d1\nsquash 4279e75 d2\npick 116755e d3\npick 159f932 d1\n```\n该提交将重复提交第一次提交, 提交结果如下:\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase7.png\" height=\"350\" width=\"450\"/>\n本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push --force origin mybranch分支。 master一般不允许直接这么弄\n\n# cherry-pick\ncherry-pick主要是将一个分支单独的提交变化合并到另外一个分支上, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交改变合并到当前master分支上, 那么就执行:\n`git:(master D提交): git cherry-pick G`, 提交完成后, G提交出的变化代码就会和master分支D处全部代码合并, 产生提交D'。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D'和G毫无关联。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase10.png\" height=\"350\" width=\"450\"/>\ncherry-pick在提取G提交的变化时, 能将变化抽取出来的, 就将变化提取出来, 能合并就合并。变化合并到D时, 有冲突就解决冲突。\ncherry-pick与rebase使用上的区别:\nrebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。\ncherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。\n-m 参数\ngit cherry-pick G -m 1/2等\ngit show --pretty=raw xszdsdsdds\nhttps://stackoverflow.com/questions/12626754/git-cherry-pick-syntax-and-merge-branches/12628579#12628579\n\n# revert\nrevert的含义是撤销(丢弃)某次提交, 下图为例, 比如想撤销G提交: `git:(master D提交): git revert G`, 实际就是丢弃G的提交, 具体实现是将G提交变化从当前提交D中去掉, 然后产生新的提交D'。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_revert1.png\" height=\"350\" width=\"450\"/>\n同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D'与G提交没有任何关系。\n比如`git:(master D提交): git revert HEAD`, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert --continue来完成此次操作。\n\n# checkout\ncheckout主要是从`对象库中(仓库)`拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从`暂存区(索引)`中检出文件来重置工作区的文件, 使用示例如下:\n+ git:(master D提交): git checkout G\n将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致\n+ git:(master D提交): git checkout -- file1\n用`暂存区`的文件file1来重置`工作区`的file1, 而不是从本地代码仓库来恢复。\n+ git:(master D提交): git checkout G -- file1\n用G提交的代码`暂存区`的文件file1来重置`工作区`的file1。\ncheckout不会去修改提交记录, 仅仅是修改了HEAD。\n\n# reset\nreset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。\n+ 在切换到某一次提交时, 可使用 三个参数:\n---soft: 仅仅是将当前master、HEAD指针指向commit3\n---mixed: 在---soft的基础上, 用commit3的提交来重置暂存区。(默认)\n---hard: 在---hard的集群上, 用commit3的提交来重置暂存区、工作区。\n<img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_reset.png\" height=\"250\" width=\"700\"/>\n+ git:(master D提交): git reset HEAD file1\n用`本地代码仓库`的文件file1来重置`暂存区`(索引)的file1。\n","slug":"git-基本命令学习心得","published":1,"updated":"2019-06-05T16:38:03.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjxr3d8xv001dphu5u1f6jft6","content":"<p>一般在公共分支上操作,不能修改分支的提交记录, 但是可以使用cherry-pick, revert这样的可以使用, 而rebase, reset这样的命令一般在私有分支上才可用。</p>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>git rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase3.png\" height=\"300\" width=\"550\"><br><code>git:(dev) git rebase master</code>, 此时处于G(最新提交)操作。变基是以共同祖先节点开始变的, 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D’, 基于D’与F合并变成F’, 基于F’和G合并变成G’。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。<br>用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase –continue继续解决下一个冲突<br>注意: 并没有要求修改comment, commit不变</p>\n<h2 id=\"半路rebase\"><a href=\"#半路rebase\" class=\"headerlink\" title=\"半路rebase\"></a>半路rebase</h2><p>以上示例是我们在dev分支的最新提交H上进行rebase的, 假如我们不在最新G上操作, 而是在F上进行rebase操作, 会出现什么结果呢?<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase2.png\" height=\"300\" width=\"550\"><br>可以看到dev分支没有任何变化, 而是将EF提交分别与D提交合并, 使EF部分变基到master分支上。</p>\n<h2 id=\"rebase-i-参数\"><a href=\"#rebase-i-参数\" class=\"headerlink\" title=\"rebase -i 参数\"></a>rebase -i 参数</h2><p>-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。<br><code>git:(dev): git rebase -i master</code>之后, 将弹出这样的界面:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase5.png\" height=\"350\" width=\"450\"></p>\n<p>红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:</p>\n<ul>\n<li>操作action</li>\n<li>commit hash值</li>\n<li>commit commit<br>其中action介绍在红框2中, 主要分为这几种类型:<br>1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。<br>git rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。<br>2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)<br>git rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。<br>3) e, edit = use commit, but stop for amending<br>git rebase -i master: 和p参数没啥区别, 能修改所有提交的comment<br>git rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用–continue才能继续<br>4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。<br>执行以下命令:<code>git:(dev): git rebase -i HEAD~3</code>, 并且修改action如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase6.png\" height=\"350\" width=\"450\"><br>git log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。<br>git rebase -i master也能和描述也是一致的。<br>5) f, fixup = like “squash”, but discard this commit’s log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。<br>git rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。<br>git rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。<br>6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用<br>7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)</p>\n<h2 id=\"i参数控制复制、删除、重置提交顺序等\"><a href=\"#i参数控制复制、删除、重置提交顺序等\" class=\"headerlink\" title=\"i参数控制复制、删除、重置提交顺序等\"></a>i参数控制复制、删除、重置提交顺序等</h2><p>rebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div><div class=\"line\">pick 159f932 d1</div></pre></td></tr></table></figure></p>\n<p>该提交将重复提交第一次提交, 提交结果如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase7.png\" height=\"350\" width=\"450\"><br>本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push –force origin mybranch分支。 master一般不允许直接这么弄</p>\n<h1 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h1><p>cherry-pick主要是将一个分支单独的提交变化合并到另外一个分支上, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交改变合并到当前master分支上, 那么就执行:<br><code>git:(master D提交): git cherry-pick G</code>, 提交完成后, G提交出的变化代码就会和master分支D处全部代码合并, 产生提交D’。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D’和G毫无关联。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase10.png\" height=\"350\" width=\"450\"><br>cherry-pick在提取G提交的变化时, 能将变化抽取出来的, 就将变化提取出来, 能合并就合并。变化合并到D时, 有冲突就解决冲突。<br>cherry-pick与rebase使用上的区别:<br>rebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。<br>cherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。<br>-m 参数<br>git cherry-pick G -m 1/2等<br>git show –pretty=raw xszdsdsdds<br><a href=\"https://stackoverflow.com/questions/12626754/git-cherry-pick-syntax-and-merge-branches/12628579#12628579\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/12626754/git-cherry-pick-syntax-and-merge-branches/12628579#12628579</a></p>\n<h1 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h1><p>revert的含义是撤销(丢弃)某次提交, 下图为例, 比如想撤销G提交: <code>git:(master D提交): git revert G</code>, 实际就是丢弃G的提交, 具体实现是将G提交变化从当前提交D中去掉, 然后产生新的提交D’。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_revert1.png\" height=\"350\" width=\"450\"><br>同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D’与G提交没有任何关系。<br>比如<code>git:(master D提交): git revert HEAD</code>, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert –continue来完成此次操作。</p>\n<h1 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h1><p>checkout主要是从<code>对象库中(仓库)</code>拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从<code>暂存区(索引)</code>中检出文件来重置工作区的文件, 使用示例如下:</p>\n<ul>\n<li>git:(master D提交): git checkout G<br>将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致</li>\n<li>git:(master D提交): git checkout – file1<br>用<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1, 而不是从本地代码仓库来恢复。</li>\n<li>git:(master D提交): git checkout G – file1<br>用G提交的代码<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1。<br>checkout不会去修改提交记录, 仅仅是修改了HEAD。</li>\n</ul>\n<h1 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h1><p>reset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。</p>\n<ul>\n<li>在切换到某一次提交时, 可使用 三个参数:<br>—soft: 仅仅是将当前master、HEAD指针指向commit3<br>—mixed: 在—soft的基础上, 用commit3的提交来重置暂存区。(默认)<br>—hard: 在—hard的集群上, 用commit3的提交来重置暂存区、工作区。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_reset.png\" height=\"250\" width=\"700\"></li>\n<li>git:(master D提交): git reset HEAD file1<br>用<code>本地代码仓库</code>的文件file1来重置<code>暂存区</code>(索引)的file1。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>一般在公共分支上操作,不能修改分支的提交记录, 但是可以使用cherry-pick, revert这样的可以使用, 而rebase, reset这样的命令一般在私有分支上才可用。</p>\n<h1 id=\"rebase\"><a href=\"#rebase\" class=\"headerlink\" title=\"rebase\"></a>rebase</h1><p>git rebase是用来更改提交的基, 通过重新在当前分支提交一连串的commit来实现的, 比如dev分支从master A提交产生的, 在master分支又进行了B、C、D提交, 在dev分支进行了E、F、G提交, 此时为了保证D能够合并到master最新的D提交上, 那么就使用rebase。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase3.png\" height=\"300\" width=\"550\"><br><code>git:(dev) git rebase master</code>, 此时处于G(最新提交)操作。变基是以共同祖先节点开始变的, 执行后就像放电影一样, 会将E、F、G的所有内容顺序与D合并。比如基于D与E合并后变成D’, 基于D’与F合并变成F’, 基于F’和G合并变成G’。箭头代表着基于哪些commit进行了merge。 完成rebase操作后, 提交链路被就改了。<br>用法:1.git rebase master 2. 通过vim解决冲突, 3.使用git add .保存 4.git rebase –continue继续解决下一个冲突<br>注意: 并没有要求修改comment, commit不变</p>\n<h2 id=\"半路rebase\"><a href=\"#半路rebase\" class=\"headerlink\" title=\"半路rebase\"></a>半路rebase</h2><p>以上示例是我们在dev分支的最新提交H上进行rebase的, 假如我们不在最新G上操作, 而是在F上进行rebase操作, 会出现什么结果呢?<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase2.png\" height=\"300\" width=\"550\"><br>可以看到dev分支没有任何变化, 而是将EF提交分别与D提交合并, 使EF部分变基到master分支上。</p>\n<h2 id=\"rebase-i-参数\"><a href=\"#rebase-i-参数\" class=\"headerlink\" title=\"rebase -i 参数\"></a>rebase -i 参数</h2><p>-i参数使rebase将于用户交互的形式完成merge, 根据这个参数, 用户可以完成多次提交顺序的复制、删除、编辑commit、修改提交顺序等一系列操作。<br><code>git:(dev): git rebase -i master</code>之后, 将弹出这样的界面:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase5.png\" height=\"350\" width=\"450\"></p>\n<p>红框1说明dev分支从master分支产生之后, 进行了三次提交, 这三次提交会和master最新的提交分别顺序进行合并。 红框1里面每行分为三部分:</p>\n<ul>\n<li>操作action</li>\n<li>commit hash值</li>\n<li>commit commit<br>其中action介绍在红框2中, 主要分为这几种类型:<br>1) p pick = use commit: 提交这次commit, 分别修改每次提交的comment内容。<br>git rebase -i master这种和别的分支进行rebase, 所有提交的comment是可以修改成功的。<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 但是最终没有生效。<br>2) r, reword = use commit, but edit the commit message: 提交这次commit, 同时修改这次comment的内容<br>git rebase -i HEAD~3 这种和本身历史提交进行rebase, 也提示需要修改comment, 同时修改这次comment的内容, 可以成功, 仅仅当前一次提交。(与说明相符)<br>git rebase -i master这种和别的分支进行rebase, 修改comment是可以修改成功的。 但是总是发生某些提交丢失的情况, 一般禁止使用。<br>3) e, edit = use commit, but stop for amending<br>git rebase -i master: 和p参数没啥区别, 能修改所有提交的comment<br>git rebase -i HEAD~3 : 可以停下来让你修改当前comment, 直到你调用–continue才能继续<br>4) s, squash = use commit, but meld into previous commit: 提交这次commit, 将本次提交和上次的提交合并(提交内容和提交comment都合并进去),使看起来是一次提交。<br>执行以下命令:<code>git:(dev): git rebase -i HEAD~3</code>, 并且修改action如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase6.png\" height=\"350\" width=\"450\"><br>git log展示如上, 可以看出第一个和第二次的提交合并了, 所有的提交comment都修改了。<br>git rebase -i master也能和描述也是一致的。<br>5) f, fixup = like “squash”, but discard this commit’s log message: 和squash效果一样, 和之前提交的commit会合并到一起, 本次提交的comment会直接丢弃。<br>git rebase -i master: 可以一起修改前缀的comment(也可以将#去掉,同一个comment分两行显示两个comment), 后续的提交还可以修改comment。<br>git rebase -i HEAD~3 : 这次提交的coment直接丢弃, 所有提交都不给改的机会。<br>6) x, exec = run command (the rest of the line) using shell :执行shell命令, 可以忽略使用<br>7) d, drop = remove commit 直接丢弃这次提交(包括提交内容与comment)</p>\n<h2 id=\"i参数控制复制、删除、重置提交顺序等\"><a href=\"#i参数控制复制、删除、重置提交顺序等\" class=\"headerlink\" title=\"i参数控制复制、删除、重置提交顺序等\"></a>i参数控制复制、删除、重置提交顺序等</h2><p>rebase -i参数可以通过重复上面的提交记录操作这些操作, 比如:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">pick 159f932 d1</div><div class=\"line\">squash 4279e75 d2</div><div class=\"line\">pick 116755e d3</div><div class=\"line\">pick 159f932 d1</div></pre></td></tr></table></figure></p>\n<p>该提交将重复提交第一次提交, 提交结果如下:<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase7.png\" height=\"350\" width=\"450\"><br>本地rebase之后再向远程推送, 可能会冲突, 这时确定没有人在基于那个分支分发的话, 可以通过git push –force origin mybranch分支。 master一般不允许直接这么弄</p>\n<h1 id=\"cherry-pick\"><a href=\"#cherry-pick\" class=\"headerlink\" title=\"cherry-pick\"></a>cherry-pick</h1><p>cherry-pick主要是将一个分支单独的提交变化合并到另外一个分支上, 以下图为例, 当前处于master的D提交上, 想让dev分支上的G提交改变合并到当前master分支上, 那么就执行:<br><code>git:(master D提交): git cherry-pick G</code>, 提交完成后, G提交出的变化代码就会和master分支D处全部代码合并, 产生提交D’。注意,这里虽然合并了, 但是并没有改变分支提交记录, 图中用虚线表达着从提交历史上看, D’和G毫无关联。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_rebase10.png\" height=\"350\" width=\"450\"><br>cherry-pick在提取G提交的变化时, 能将变化抽取出来的, 就将变化提取出来, 能合并就合并。变化合并到D时, 有冲突就解决冲突。<br>cherry-pick与rebase使用上的区别:<br>rebase: 修改提交历史, 改变的是整个分支的提交基, 将每次提交都与另外一个分支提交一一合并。<br>cherry-pick: 不会修改提交历史,仅仅产生一个新的提交。像挑选樱桃一样, 可以某个分支某次提交与另一个分支提交代码合并。<br>-m 参数<br>git cherry-pick G -m 1/2等<br>git show –pretty=raw xszdsdsdds<br><a href=\"https://stackoverflow.com/questions/12626754/git-cherry-pick-syntax-and-merge-branches/12628579#12628579\" target=\"_blank\" rel=\"external\">https://stackoverflow.com/questions/12626754/git-cherry-pick-syntax-and-merge-branches/12628579#12628579</a></p>\n<h1 id=\"revert\"><a href=\"#revert\" class=\"headerlink\" title=\"revert\"></a>revert</h1><p>revert的含义是撤销(丢弃)某次提交, 下图为例, 比如想撤销G提交: <code>git:(master D提交): git revert G</code>, 实际就是丢弃G的提交, 具体实现是将G提交变化从当前提交D中去掉, 然后产生新的提交D’。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_revert1.png\" height=\"350\" width=\"450\"><br>同cherry-pick一样, 并不改变历史提交记录, 仅仅将D和F(G的父提交)合并, 产生的新提交D’与G提交没有任何关系。<br>比如<code>git:(master D提交): git revert HEAD</code>, 撤销最近一次提交(也就提交D提交), 可能要产生冲突, 解决冲突后通过git add、git revert –continue来完成此次操作。</p>\n<h1 id=\"checkout\"><a href=\"#checkout\" class=\"headerlink\" title=\"checkout\"></a>checkout</h1><p>checkout主要是从<code>对象库中(仓库)</code>拿出一个提交, 然后放在工作目录中, HEAD会指向当前提交(前提是工作区、暂存区、本地仓库一致, 否则会冲突); 附带功能是从<code>暂存区(索引)</code>中检出文件来重置工作区的文件, 使用示例如下:</p>\n<ul>\n<li>git:(master D提交): git checkout G<br>将当前分支切换到G提交上面去, 此时工作区、暂存区、本地仓库代码将一致</li>\n<li>git:(master D提交): git checkout – file1<br>用<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1, 而不是从本地代码仓库来恢复。</li>\n<li>git:(master D提交): git checkout G – file1<br>用G提交的代码<code>暂存区</code>的文件file1来重置<code>工作区</code>的file1。<br>checkout不会去修改提交记录, 仅仅是修改了HEAD。</li>\n</ul>\n<h1 id=\"reset\"><a href=\"#reset\" class=\"headerlink\" title=\"reset\"></a>reset</h1><p>reset主要是将仓库中的某次提交拿出来, 然后放回到暂存区、工作目录中, HEAD, master会指向当前提交, 提交历史会被改变。</p>\n<ul>\n<li>在切换到某一次提交时, 可使用 三个参数:<br>—soft: 仅仅是将当前master、HEAD指针指向commit3<br>—mixed: 在—soft的基础上, 用commit3的提交来重置暂存区。(默认)<br>—hard: 在—hard的集群上, 用commit3的提交来重置暂存区、工作区。<br><img src=\"https://kkewwei.github.io/elasticsearch_learning/img/git_reset.png\" height=\"250\" width=\"700\"></li>\n<li>git:(master D提交): git reset HEAD file1<br>用<code>本地代码仓库</code>的文件file1来重置<code>暂存区</code>(索引)的file1。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjxr3d8w8000fphu5m7qov15i","tag_id":"cjxr3d8wa000hphu5c53jsq3f","_id":"cjxr3d8x1000mphu5or2xqn65"},{"post_id":"cjxr3d8wx000iphu5ftmbpgqb","tag_id":"cjxr3d8x1000lphu5q53p17t4","_id":"cjxr3d8x5000qphu5mipng6at"},{"post_id":"cjxr3d8x8000sphu5dzil1i7r","tag_id":"cjxr3d8xb000uphu59lrk9i1m","_id":"cjxr3d8xh000zphu5nijk7yas"},{"post_id":"cjxr3d8xa000tphu51vczjj5q","tag_id":"cjxr3d8xg000yphu5ts8swz94","_id":"cjxr3d8xm0014phu5jfvxwn2h"},{"post_id":"cjxr3d8xd000wphu502qg87fq","tag_id":"cjxr3d8xk0012phu5rntkfk6u","_id":"cjxr3d8xq0018phu5mv7ckdv4"},{"post_id":"cjxr3d8xe000xphu597mpfbfj","tag_id":"cjxr3d8xp0016phu5ifecw4lu","_id":"cjxr3d8xv001cphu57d34jyvn"},{"post_id":"cjxr3d8xm0015phu5hy1incvd","tag_id":"cjxr3d8xt001aphu5qf2a733w","_id":"cjxr3d8xx001fphu5n9gipeuw"},{"post_id":"cjxr3d8xr0019phu5p6wc2wl2","tag_id":"cjxr3d8xw001ephu59pnbt4ed","_id":"cjxr3d8xy001hphu5zjp9g3sc"},{"post_id":"cjxr3d8xu001bphu5q7oqn6ay","tag_id":"cjxr3d8xx001gphu54oq5je8g","_id":"cjxr3d8xy001jphu5lqzbh20r"},{"post_id":"cjxr3d8xv001dphu5u1f6jft6","tag_id":"cjxr3d8xy001iphu5p8z4yk09","_id":"cjxr3d8xy001kphu5b5pjeg25"}],"Tag":[{"name":"Flink、Slot分配、SubTask申请slot, SubTask部署","_id":"cjxr3d8wa000hphu5c53jsq3f"},{"name":"LockSupport","_id":"cjxr3d8x1000lphu5q53p17t4"},{"name":"PoolArena","_id":"cjxr3d8xb000uphu59lrk9i1m"},{"name":"Cycler","_id":"cjxr3d8xg000yphu5ts8swz94"},{"name":"NioEventLoop","_id":"cjxr3d8xk0012phu5rntkfk6u"},{"name":"ReentrantLock","_id":"cjxr3d8xp0016phu5ifecw4lu"},{"name":"netty4, ServerBootstrap, Initiale","_id":"cjxr3d8xt001aphu5qf2a733w"},{"name":"gdb","_id":"cjxr3d8xw001ephu59pnbt4ed"},{"name":"perftools、jcmd、pmap","_id":"cjxr3d8xx001gphu54oq5je8g"},{"name":"git, rebase, cherry-pick, reset, checkout","_id":"cjxr3d8xy001iphu5p8z4yk09"}]}}