{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/picture1.jpg","path":"picture1.jpg","modified":1,"renderable":0},{"_id":"source/img/picture.jpg","path":"img/picture.jpg","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":1,"renderable":1},{"_id":"source/img/1506269128432DX_IM_FILE_0.png","path":"img/1506269128432DX_IM_FILE_0.png","modified":1,"renderable":0},{"_id":"source/img/Netty概念.png","path":"img/Netty概念.png","modified":1,"renderable":0},{"_id":"source/img/ico.png","path":"img/ico.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":1,"renderable":1},{"_id":"source/img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","path":"img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/picture.jpg","path":"img/picture.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"f457a5ed7bb1870fd9a217757f21a72b53f64915","modified":1531645405000},{"_id":"themes/yilia/.DS_Store","hash":"fe4c6dc77d2c896f41c82d607eb8feeaf9fa50c5","modified":1525263651000},{"_id":"source/picture1.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263650000},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1525263651000},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1525263651000},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1525263651000},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1525263651000},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1525263651000},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1525263651000},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1525263651000},{"_id":"themes/yilia/_config.yml","hash":"ece60e044077530039d79b3cf34b03bf0b70ff9a","modified":1525263651000},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1525263651000},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1525263651000},{"_id":"source/_posts/.DS_Store","hash":"43922385a305959c6120d41bb09b0dd1d459b949","modified":1525263650000},{"_id":"source/_posts/AbstractOwnableSynchronizer学习.md","hash":"dd46d81504fdbf12449592f38514746d0da67253","modified":1525263650000},{"_id":"source/_posts/ES索引创建流程.md","hash":"ce9f0bdd339ed2db67081091ebf0e081cc16a8ec","modified":1525263650000},{"_id":"source/_posts/Netty-PoolThreadCache源码探究.md","hash":"4ee698022b71651e3a62f56841f745a5c41d5f31","modified":1531644089000},{"_id":"source/_posts/Netty-Http通信编码源码阅读.md","hash":"3039907661102036d3e06cb005dc8db0d4e62a21","modified":1527004390000},{"_id":"source/_posts/Netty内存学习.md","hash":"0b01d4be2720b79f3056a8d89a7cce0b8a93313b","modified":1531356007000},{"_id":"source/_posts/Netty-Http通信解码源码阅读.md","hash":"494b489738663809ca6a84671ce8b3d652871247","modified":1526221294000},{"_id":"source/_posts/Netty通信编解码源码解读.md","hash":"d5c323eafb17fda97c7046a3d15c9bb3438c8080","modified":1526212097000},{"_id":"source/_posts/NioEventLoop篇.md","hash":"03092a2c6a81e9e588a6fef0f5f9feb78dbf42b1","modified":1525263650000},{"_id":"source/_posts/ServerBootstrap初始篇.md","hash":"70b468e76b3cccd4fc7a9cfa97521da219bb3830","modified":1525263650000},{"_id":"source/img/.DS_Store","hash":"2d3cf28e2ce4a24156578d371cecdc5acd2d34bd","modified":1531645410000},{"_id":"source/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263650000},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1525263651000},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1525263651000},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1525263651000},{"_id":"themes/yilia/.git/index","hash":"17dc582f429cb43dfcbb8f3b60b9a96a4f89d907","modified":1525266725000},{"_id":"themes/yilia/.git/packed-refs","hash":"83644c3638dafa38c817265c9207f098dd8aeee6","modified":1525263651000},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1525263651000},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1525263651000},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1525263651000},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1525263651000},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1525263651000},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1525263651000},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1525263651000},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1525263651000},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1525263651000},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1525263651000},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1525263651000},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1525263651000},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1525263651000},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1525263651000},{"_id":"themes/yilia/source-src/.DS_Store","hash":"eb59082b0722091794ca7702b8f86389094ac262","modified":1525263651000},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1525263651000},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1525263651000},{"_id":"themes/yilia/source/.DS_Store","hash":"2e125b278324bee8e26c58283773ccf57ca50f62","modified":1525263651000},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1525263651000},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1525263651000},{"_id":"source/img/1506269128432DX_IM_FILE_0.png","hash":"ca117a42810f1564752b2622cd2485ae15e9e186","modified":1525263650000},{"_id":"source/img/Netty概念.png","hash":"99244a9371b8d5bf29d01cc103f79441ead35765","modified":1525263650000},{"_id":"source/img/ico.png","hash":"7c1d2489979dd24a7b221f4ad8eb1ef210c37cdc","modified":1531650619000},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1525263651000},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1525263651000},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1525263651000},{"_id":"source/img/BaseFuture_AbstractQueuedSynchronizer/.DS_Store","hash":"cb6d6e18a173ccc7da6187e4d994338cfd3121ea","modified":1525263650000},{"_id":"source/img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","hash":"912943a8eea0f8e4344511fd8088295787c39422","modified":1525263650000},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1525263651000},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1525263651000},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1525263651000},{"_id":"themes/yilia/.git/logs/HEAD","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"a27ce6989c2ee12931afb990a23f0720eaa7bc9c","modified":1526898191000},{"_id":"themes/yilia/layout/_partial/left-col.ejs_tmp","hash":"25ce2169f8516d90a9ddd6f268f2f6a71172916b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1525263651000},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1525263651000},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1525263651000},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1525263651000},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1525263651000},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1525263651000},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1525263651000},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1525263651000},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1525263651000},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1525263651000},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1525263651000},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1525263651000},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1525263651000},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1525263651000},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1525263651000},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1525263651000},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1525263651000},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1525263651000},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1525263651000},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1525263651000},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1525263651000},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1525263651000},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1525263651000},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1525263651000},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1525263651000},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1525263651000},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1525263651000},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1525263651000},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1525263651000},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1525263651000},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1525263651000},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1525263651000},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1525263651000},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1525263651000},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1525263651000},{"_id":"themes/yilia/source/img/.DS_Store","hash":"9a730f22af5f133f1235459006bbcf9661e6099b","modified":1525263651000},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1525263651000},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1525263651000},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1525263651000},{"_id":"themes/yilia/source/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1525263651000},{"_id":"themes/yilia/.git/objects/pack/pack-81482136cf6b522e44e787dc9c868acfcb7c25a6.idx","hash":"192241e09a6504ede0484bccfdb070cc40a2907a","modified":1525263651000},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1525263651000},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1525263651000},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1525263651000},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1525263651000},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1525263651000},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1525263651000},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"b0f91df7809cc4e8c9833c57860dbee3a82bf37b","modified":1525263651000},{"_id":"themes/yilia/.git/objects/pack/pack-81482136cf6b522e44e787dc9c868acfcb7c25a6.pack","hash":"a3546a4602f8b7a5a61f5bdc6ff14c6523cf6441","modified":1525263651000},{"_id":"public/content.json","hash":"3321dc8ecfb108e6cc47b5960fd3de8c53f55147","modified":1531650714145},{"_id":"public/2018/07/14/Netty-PoolThreadCache源码探究/index.html","hash":"5e786ef633aeacd1f343caab80c2a8ea37e0da59","modified":1531650714375},{"_id":"public/2018/05/23/Netty内存学习/index.html","hash":"eae643ac1a97799961682d6eaba871ce84bb8b71","modified":1531650714375},{"_id":"public/2018/05/04/Netty-Http通信编码源码阅读/index.html","hash":"ddcbbbe1f7185d43ac7dbd00aed96c5354ef7244","modified":1531650714375},{"_id":"public/2018/04/16/Netty-Http通信解码源码阅读/index.html","hash":"918fadb014971ec65d46cf0e529bfead41dfca5a","modified":1531650714375},{"_id":"public/2018/03/25/Netty通信编解码源码解读/index.html","hash":"a5de5a39591be817b431c51ef193af407e043f6f","modified":1531650714375},{"_id":"public/2018/01/22/NioEventLoop篇/index.html","hash":"b84bfd08f682994ee0657e6a3d2c18774a29fb55","modified":1531650714375},{"_id":"public/2018/01/14/ServerBootstrap初始篇/index.html","hash":"35a8e081466f56456e354c8e5237737861a301ed","modified":1531650714376},{"_id":"public/2017/12/17/ES索引创建流程/index.html","hash":"1a0b51e3b1fb5e83c00a1dc1be4fe5d6b6090639","modified":1531650714376},{"_id":"public/2017/12/17/AbstractOwnableSynchronizer学习/index.html","hash":"4dd508a5743a628b4811abf30871d23d04397fc5","modified":1531650714376},{"_id":"public/archives/index.html","hash":"f73d809216c84444834a429fe97e916156f147b6","modified":1531650714376},{"_id":"public/archives/2017/index.html","hash":"3dea2831741a6c0fa1e29a61d4b3b2e32bbf95f3","modified":1531650714376},{"_id":"public/archives/2017/12/index.html","hash":"b77a0be9d2ee115d89b0ddedccd2e9ea76ca05d6","modified":1531650714376},{"_id":"public/archives/2018/index.html","hash":"f4f5c32c086478c89ca752ce6c4b478547e68b76","modified":1531650714377},{"_id":"public/archives/2018/01/index.html","hash":"b668ed50689bba5d5148575992f127cd6285be43","modified":1531650714377},{"_id":"public/archives/2018/03/index.html","hash":"bc6201fe9a5625cc3476e917e18c7ca1c2005cd1","modified":1531650714377},{"_id":"public/archives/2018/04/index.html","hash":"f016335261e6ac57b11f28e06d62a26104bc77b5","modified":1531650714377},{"_id":"public/archives/2018/05/index.html","hash":"7c8fa15993ca0e21c493baa4c74e09e4f200320b","modified":1531650714377},{"_id":"public/archives/2018/07/index.html","hash":"e242761da8a1463a35e846924b3679a17629d972","modified":1531650714377},{"_id":"public/index.html","hash":"016b0ec5690e956a5386183a0a368a455461c335","modified":1531650714377},{"_id":"public/tags/AbstractQueuedSynchronizer-源码-BaseFuture/index.html","hash":"95d25306407b610269e6ef70f89a2b70e63f7474","modified":1531650714377},{"_id":"public/tags/netty4-ServerBootstrap-Initiale/index.html","hash":"2644c63627dbd65e841313f378a17fcba09c1104","modified":1531650714377},{"_id":"public/picture1.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1531650714382},{"_id":"public/img/picture.jpg","hash":"3f259b4b5460da1fae8cb02b35aed47398991ef6","modified":1531650714382},{"_id":"public/img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png","hash":"912943a8eea0f8e4344511fd8088295787c39422","modified":1531650714383},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1531650714383},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1531650714383},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1531650714383},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1531650714383},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1531650714383},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1531650714383},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1531650714383},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1531650714383},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1531650714383},{"_id":"public/img/1506269128432DX_IM_FILE_0.png","hash":"ca117a42810f1564752b2622cd2485ae15e9e186","modified":1531650714385},{"_id":"public/img/Netty概念.png","hash":"99244a9371b8d5bf29d01cc103f79441ead35765","modified":1531650714386},{"_id":"public/img/ico.png","hash":"7c1d2489979dd24a7b221f4ad8eb1ef210c37cdc","modified":1531650714388},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1531650714390},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1531650714390},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1531650714390},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1531650714390}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"BaseFuture及AbstractQueuedSynchronizer源码学习","date":"2017-12-16T19:54:43.000Z","_content":"## 简介\nAbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义`BaseFuture`。BaseFuture作为AbstractQueuedSynchronizer的实现类，赋予了锁的具体含义，定义了什么时候解锁及阻塞。\n### AbstractQueuedSynchronizer详解\n#### 属性                         \n`state`\nAbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义，在多线程针对state的操作，必须保证state状态的原子性，使用了`volatile`关键字，这里没使用Synchronized来保证原子性的原因:\n+ state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。\n+ Synchronized实现互斥的成本要比volatile很高。\n其他wiki中说的实现以下两种方法的原子性：\n+ AbstractQueuedSynchronizer.getState()\n+ AbstractQueuedSynchronizer.setState(int)\n也都是通过volatile来实现的。\n`Node`\nAbstractQueuedSynchronizer实现了FIFO队列，该队列代表着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：\n```\n{\n     volatile int waitStatus;\n     volatile Node prev;\n     volatile Node next;\n     volatile Thread thread;\n     Node nextWaiter;\n   \n}```\n\n|属性|介绍|\n|:-|:-|\n|waitStatus|当前节点的状态:<br>CANCELLED:当前线程取消执行，<br>SIGNAL:当前节点的后继节点的线程需要唤醒<br>CONDITION:当前节点在等待condition,也就处在condition队列中<br>PROPAGATE:<br>0:\n|prev|当前节点的前一个节点\n|next|当前节点的后继节点|\n|thread|当前节点所拥有的线程|\n|nextWaiter|链接指向下一个处于condition队列的节点\nFIFO队列如下如：[FIFO队列](../img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png)","source":"_posts/AbstractOwnableSynchronizer学习.md","raw":"---\ntitle: BaseFuture及AbstractQueuedSynchronizer源码学习\ndate: 2017-12-17 03:54:43\ntags: AbstractQueuedSynchronizer,源码,BaseFuture\n---\n## 简介\nAbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义`BaseFuture`。BaseFuture作为AbstractQueuedSynchronizer的实现类，赋予了锁的具体含义，定义了什么时候解锁及阻塞。\n### AbstractQueuedSynchronizer详解\n#### 属性                         \n`state`\nAbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义，在多线程针对state的操作，必须保证state状态的原子性，使用了`volatile`关键字，这里没使用Synchronized来保证原子性的原因:\n+ state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。\n+ Synchronized实现互斥的成本要比volatile很高。\n其他wiki中说的实现以下两种方法的原子性：\n+ AbstractQueuedSynchronizer.getState()\n+ AbstractQueuedSynchronizer.setState(int)\n也都是通过volatile来实现的。\n`Node`\nAbstractQueuedSynchronizer实现了FIFO队列，该队列代表着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：\n```\n{\n     volatile int waitStatus;\n     volatile Node prev;\n     volatile Node next;\n     volatile Thread thread;\n     Node nextWaiter;\n   \n}```\n\n|属性|介绍|\n|:-|:-|\n|waitStatus|当前节点的状态:<br>CANCELLED:当前线程取消执行，<br>SIGNAL:当前节点的后继节点的线程需要唤醒<br>CONDITION:当前节点在等待condition,也就处在condition队列中<br>PROPAGATE:<br>0:\n|prev|当前节点的前一个节点\n|next|当前节点的后继节点|\n|thread|当前节点所拥有的线程|\n|nextWaiter|链接指向下一个处于condition队列的节点\nFIFO队列如下如：[FIFO队列](../img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png)","slug":"AbstractOwnableSynchronizer学习","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadvt0000miu5h40zhw69","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>AbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义<code>BaseFuture</code>。BaseFuture作为AbstractQueuedSynchronizer的实现类，赋予了锁的具体含义，定义了什么时候解锁及阻塞。</p>\n<h3 id=\"AbstractQueuedSynchronizer详解\"><a href=\"#AbstractQueuedSynchronizer详解\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer详解\"></a>AbstractQueuedSynchronizer详解</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p><code>state</code><br>AbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义，在多线程针对state的操作，必须保证state状态的原子性，使用了<code>volatile</code>关键字，这里没使用Synchronized来保证原子性的原因:</p>\n<ul>\n<li>state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。</li>\n<li>Synchronized实现互斥的成本要比volatile很高。<br>其他wiki中说的实现以下两种方法的原子性：</li>\n<li>AbstractQueuedSynchronizer.getState()</li>\n<li>AbstractQueuedSynchronizer.setState(int)<br>也都是通过volatile来实现的。<br><code>Node</code><br>AbstractQueuedSynchronizer实现了FIFO队列，该队列代表着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     volatile int waitStatus;</div><div class=\"line\">     volatile Node prev;</div><div class=\"line\">     volatile Node next;</div><div class=\"line\">     volatile Thread thread;</div><div class=\"line\">     Node nextWaiter;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">waitStatus</td>\n<td style=\"text-align:left\">当前节点的状态:<br>CANCELLED:当前线程取消执行，<br>SIGNAL:当前节点的后继节点的线程需要唤醒<br>CONDITION:当前节点在等待condition,也就处在condition队列中<br>PROPAGATE:<br>0:</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prev</td>\n<td style=\"text-align:left\">当前节点的前一个节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">当前节点的后继节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">当前节点所拥有的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nextWaiter</td>\n<td style=\"text-align:left\">链接指向下一个处于condition队列的节点</td>\n</tr>\n</tbody>\n</table>\n<p>FIFO队列如下如：<a href=\"../img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png\">FIFO队列</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>AbstractQueuedSynchronizer，顾名思义，抽象队列同步器，作为抽象类，使用FIFO链，实现了锁的语义<code>BaseFuture</code>。BaseFuture作为AbstractQueuedSynchronizer的实现类，赋予了锁的具体含义，定义了什么时候解锁及阻塞。</p>\n<h3 id=\"AbstractQueuedSynchronizer详解\"><a href=\"#AbstractQueuedSynchronizer详解\" class=\"headerlink\" title=\"AbstractQueuedSynchronizer详解\"></a>AbstractQueuedSynchronizer详解</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p><code>state</code><br>AbstractQueuedSynchronizer主要针对属性state来实现锁的含义，用户通过针对state赋予不同的值，实现不同锁的含义，在多线程针对state的操作，必须保证state状态的原子性，使用了<code>volatile</code>关键字，这里没使用Synchronized来保证原子性的原因:</p>\n<ul>\n<li>state的状态修改不依赖历史的值，很适合volatile使用场景，设置了volatile后，也能保证state修改的可见性。</li>\n<li>Synchronized实现互斥的成本要比volatile很高。<br>其他wiki中说的实现以下两种方法的原子性：</li>\n<li>AbstractQueuedSynchronizer.getState()</li>\n<li>AbstractQueuedSynchronizer.setState(int)<br>也都是通过volatile来实现的。<br><code>Node</code><br>AbstractQueuedSynchronizer实现了FIFO队列，该队列代表着目前阻塞的线程，每个元素都是都由一个Node构成，Node结构如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">     volatile int waitStatus;</div><div class=\"line\">     volatile Node prev;</div><div class=\"line\">     volatile Node next;</div><div class=\"line\">     volatile Thread thread;</div><div class=\"line\">     Node nextWaiter;</div><div class=\"line\">   </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">属性</th>\n<th style=\"text-align:left\">介绍</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">waitStatus</td>\n<td style=\"text-align:left\">当前节点的状态:<br>CANCELLED:当前线程取消执行，<br>SIGNAL:当前节点的后继节点的线程需要唤醒<br>CONDITION:当前节点在等待condition,也就处在condition队列中<br>PROPAGATE:<br>0:</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">prev</td>\n<td style=\"text-align:left\">当前节点的前一个节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">next</td>\n<td style=\"text-align:left\">当前节点的后继节点</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">thread</td>\n<td style=\"text-align:left\">当前节点所拥有的线程</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">nextWaiter</td>\n<td style=\"text-align:left\">链接指向下一个处于condition队列的节点</td>\n</tr>\n</tbody>\n</table>\n<p>FIFO队列如下如：<a href=\"../img/BaseFuture_AbstractQueuedSynchronizer/1513529116336-image.png\">FIFO队列</a></p>\n"},{"title":"ES索引创建流程","date":"2017-12-17T15:25:54.000Z","_content":"","source":"_posts/ES索引创建流程.md","raw":"---\ntitle: ES索引创建流程\ndate: 2017-12-17 23:25:54\ntags:\n---\n","slug":"ES索引创建流程","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadvz0001miu5ss3y3vvx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Netty PoolThreadCache源码探究","date":"2018-07-14T11:04:06.000Z","_content":"NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。\n# PoolThreadCache\nNetty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的块。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\"/>\\\n图中只展示了small类型数组的大小, 为4, 而tiny、normal数组的大小分别分512、 12。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32>>4))的queue中。\n下面大致介绍下PoolThreadCache里面的属性作用\n```\n    final PoolArena<byte[]> heapArena;\n    final PoolArena<ByteBuffer> directArena;\n\n    // Hold the caches for the different size classes, which are tiny, small and normal.\n    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;//tiny内存缓存的个数。默认为512\n    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;//small内存缓存的个数,默认为256个\n    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;\n    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;\n    private final MemoryRegionCache<byte[]>[] normalHeapCaches;  //normalCacheSize缓存的个数，默认为64\n    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;  //Netty把大于pageSize小于chunkSize的空间成为normal内存\n\n\n    private final Thread deathWatchThread;\n    //线程消亡后，释放资源\n    private final Runnable freeTask;\n    //freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。\n    private int allocations;\n\n```\nheapArena与directArena作用一样, 根据用户使用direct内存还是heap内存Laur来确定使用哪个块。这里将directArena与PoolThreadCache绑定\n","source":"_posts/Netty-PoolThreadCache源码探究.md","raw":"---\ntitle: Netty PoolThreadCache源码探究\ndate: 2018-07-14 19:04:06\ntags:\n---\nNioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。\n# PoolThreadCache\nNetty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的块。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:\n<img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\"/>\\\n图中只展示了small类型数组的大小, 为4, 而tiny、normal数组的大小分别分512、 12。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32>>4))的queue中。\n下面大致介绍下PoolThreadCache里面的属性作用\n```\n    final PoolArena<byte[]> heapArena;\n    final PoolArena<ByteBuffer> directArena;\n\n    // Hold the caches for the different size classes, which are tiny, small and normal.\n    private final MemoryRegionCache<byte[]>[] tinySubPageHeapCaches;//tiny内存缓存的个数。默认为512\n    private final MemoryRegionCache<byte[]>[] smallSubPageHeapCaches;//small内存缓存的个数,默认为256个\n    private final MemoryRegionCache<ByteBuffer>[] tinySubPageDirectCaches;\n    private final MemoryRegionCache<ByteBuffer>[] smallSubPageDirectCaches;\n    private final MemoryRegionCache<byte[]>[] normalHeapCaches;  //normalCacheSize缓存的个数，默认为64\n    private final MemoryRegionCache<ByteBuffer>[] normalDirectCaches;  //Netty把大于pageSize小于chunkSize的空间成为normal内存\n\n\n    private final Thread deathWatchThread;\n    //线程消亡后，释放资源\n    private final Runnable freeTask;\n    //freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。\n    private int allocations;\n\n```\nheapArena与directArena作用一样, 根据用户使用direct内存还是heap内存Laur来确定使用哪个块。这里将directArena与PoolThreadCache绑定\n","slug":"Netty-PoolThreadCache源码探究","published":1,"updated":"2018-07-15T08:41:29.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadw50003miu50uc0ycqe","content":"<p>NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。</p>\n<h1 id=\"PoolThreadCache\"><a href=\"#PoolThreadCache\" class=\"headerlink\" title=\"PoolThreadCache\"></a>PoolThreadCache</h1><p>Netty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的块。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\">\\<br>图中只展示了small类型数组的大小, 为4, 而tiny、normal数组的大小分别分512、 12。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32&gt;&gt;4))的queue中。<br>下面大致介绍下PoolThreadCache里面的属性作用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">final PoolArena&lt;byte[]&gt; heapArena;</div><div class=\"line\">final PoolArena&lt;ByteBuffer&gt; directArena;</div><div class=\"line\"></div><div class=\"line\">// Hold the caches for the different size classes, which are tiny, small and normal.</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] tinySubPageHeapCaches;//tiny内存缓存的个数。默认为512</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] smallSubPageHeapCaches;//small内存缓存的个数,默认为256个</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] normalHeapCaches;  //normalCacheSize缓存的个数，默认为64</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;  //Netty把大于pageSize小于chunkSize的空间成为normal内存</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">private final Thread deathWatchThread;</div><div class=\"line\">//线程消亡后，释放资源</div><div class=\"line\">private final Runnable freeTask;</div><div class=\"line\">//freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。</div><div class=\"line\">private int allocations;</div></pre></td></tr></table></figure></p>\n<p>heapArena与directArena作用一样, 根据用户使用direct内存还是heap内存Laur来确定使用哪个块。这里将directArena与PoolThreadCache绑定</p>\n","site":{"data":{}},"excerpt":"","more":"<p>NioEventLoop在为数据分配存放的内存时, 会首先尝试从线程本地缓存中去申请, 只有当本地缓存中申请失败, 才会考虑从全局内存中申请, 本地缓存的管理者就是PoolThreadCache对象。 Netty自己实现了类似LocalThread的类来充当线程缓存: PoolThreadLocalCache, 本节将充分围绕这两个类的源代码进行描述。</p>\n<h1 id=\"PoolThreadCache\"><a href=\"#PoolThreadCache\" class=\"headerlink\" title=\"PoolThreadCache\"></a>PoolThreadCache</h1><p>Netty自己进行内存管理, 将内存主要分为Tiny, small, normal等size不等的块。 在PoolThreadCache中将缓存也按照size进行划分, 下图是PoolThreadCache的内部整体结构图:<br><img src=\"http://owsl7963b.bkt.clouddn.com/PoolThreadCache2.png\" height=\"400\" width=\"450\">\\<br>图中只展示了small类型数组的大小, 为4, 而tiny、normal数组的大小分别分512、 12。 每个数据元素代表着缓存不同类型大小的对象。 比如回收size为32B的对象, 将相应的内存块放在tiny类型数组、下标为1 (log(32&gt;&gt;4))的queue中。<br>下面大致介绍下PoolThreadCache里面的属性作用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">final PoolArena&lt;byte[]&gt; heapArena;</div><div class=\"line\">final PoolArena&lt;ByteBuffer&gt; directArena;</div><div class=\"line\"></div><div class=\"line\">// Hold the caches for the different size classes, which are tiny, small and normal.</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] tinySubPageHeapCaches;//tiny内存缓存的个数。默认为512</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] smallSubPageHeapCaches;//small内存缓存的个数,默认为256个</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] tinySubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] smallSubPageDirectCaches;</div><div class=\"line\">private final MemoryRegionCache&lt;byte[]&gt;[] normalHeapCaches;  //normalCacheSize缓存的个数，默认为64</div><div class=\"line\">private final MemoryRegionCache&lt;ByteBuffer&gt;[] normalDirectCaches;  //Netty把大于pageSize小于chunkSize的空间成为normal内存</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">private final Thread deathWatchThread;</div><div class=\"line\">//线程消亡后，释放资源</div><div class=\"line\">private final Runnable freeTask;</div><div class=\"line\">//freeSweepAllocationThreshold  在本地线程每分配freeSweepAllocationThreshold 次内存后，检测一下是否需要释放内存。</div><div class=\"line\">private int allocations;</div></pre></td></tr></table></figure></p>\n<p>heapArena与directArena作用一样, 根据用户使用direct内存还是heap内存Laur来确定使用哪个块。这里将directArena与PoolThreadCache绑定</p>\n"},{"title":"Netty PoolArea内存学习","date":"2018-05-23T14:31:13.000Z","_content":"# 简介\nNetty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。 堆外内存通过堆内对象进行操控, 堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它不像堆内内存一样由进程主动垃圾回收, 因此, netty主动创建了Pool和unpool的概念。\n### Pool和Unpool\n字面意思, 分别是池化内存和非池化内存。`池化内存`的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用。`非池化内存`就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数`Dio.netty.allocator.type`确定netty默认使用内存的方式, 目前neetty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了开发的难度。 所以在netty4时候, 默认使用pool方式。\n这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf, 也就是本文章要将的重点。\n\n\n\n","source":"_posts/Netty内存学习.md","raw":"---\ntitle: Netty PoolArea内存学习\ndate: 2018-05-23 22:31:13\ntags:\n---\n# 简介\nNetty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。 堆外内存通过堆内对象进行操控, 堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它不像堆内内存一样由进程主动垃圾回收, 因此, netty主动创建了Pool和unpool的概念。\n### Pool和Unpool\n字面意思, 分别是池化内存和非池化内存。`池化内存`的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用。`非池化内存`就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数`Dio.netty.allocator.type`确定netty默认使用内存的方式, 目前neetty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了开发的难度。 所以在netty4时候, 默认使用pool方式。\n这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf, 也就是本文章要将的重点。\n\n\n\n","slug":"Netty内存学习","published":1,"updated":"2018-07-12T00:40:07.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadw70004miu5kmetnwg5","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Netty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。 堆外内存通过堆内对象进行操控, 堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它不像堆内内存一样由进程主动垃圾回收, 因此, netty主动创建了Pool和unpool的概念。</p>\n<h3 id=\"Pool和Unpool\"><a href=\"#Pool和Unpool\" class=\"headerlink\" title=\"Pool和Unpool\"></a>Pool和Unpool</h3><p>字面意思, 分别是池化内存和非池化内存。<code>池化内存</code>的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用。<code>非池化内存</code>就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数<code>Dio.netty.allocator.type</code>确定netty默认使用内存的方式, 目前neetty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了开发的难度。 所以在netty4时候, 默认使用pool方式。<br>这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf, 也就是本文章要将的重点。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Netty内存主要分为两种: DirectByteBuf和HeapByteBuf, 实际上就是堆外内存和堆内内存。 堆外内存通过堆内对象进行操控, 堆外内存又称直接内存。 自从JDK1.4开始, 增加了NIO, 可以直接Native函数在堆外构建直接内存。Netty作为服务器架构技术, 拥有大量的网络数据传输, 当我们进行网络传输时, 必须将数据拷贝到直接内存, 合理利用好直接内存, 能够大量减少堆内数据和直接内存考虑, 显著地提高性能。 但是堆外内存也有一定的缺点, 它不像堆内内存一样由进程主动垃圾回收, 因此, netty主动创建了Pool和unpool的概念。</p>\n<h3 id=\"Pool和Unpool\"><a href=\"#Pool和Unpool\" class=\"headerlink\" title=\"Pool和Unpool\"></a>Pool和Unpool</h3><p>字面意思, 分别是池化内存和非池化内存。<code>池化内存</code>的管理方式是首先申请一大块内存, 然后再慢慢使用, 当使用完成释放后, 再将该部分内存放入池子中, 等待下一次的使用。<code>非池化内存</code>就是普通的内存使用, 需要时直接申请, 释放时直接释放。 可以通过参数<code>Dio.netty.allocator.type</code>确定netty默认使用内存的方式, 目前neetty针对pool做了大量的支持, 这样内存使用直接交给了netty管理, 减轻了开发的难度。 所以在netty4时候, 默认使用pool方式。<br>这样的话, 内存分为四种: PoolDireBuf、UnpoolDireBuf、PoolHeapBuf、UnpoolHeapBuf。netty底层默认使用的PoolDireBuf, 也就是本文章要将的重点。</p>\n"},{"title":"Netty Http通信源码二(编码)阅读","date":"2018-05-03T16:02:39.000Z","_content":"解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\" />\n涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。\n开始向外发送数据时, 如下:\n```\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context\n        final Object m = pipeline.touch(msg, next);\n        EventExecutor executor = next.executor();\n        if (executor.inEventLoop()) {\n            if (flush) {\n                next.invokeWriteAndFlush(m, promise);\n            } else {\n                next.invokeWrite(m, promise);\n            }\n        } else {\n            AbstractWriteTask task;\n            if (flush) {\n                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行\n            }  else {\n                task = WriteTask.newInstance(next, m, promise);\n            }\n            safeExecute(executor, task, promise, m);\n        }\n    }\n```\n当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:\n```\n        @Override\n        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n            super.write(ctx, msg, promise); //一般只是存放在缓存中\n            ctx.invokeFlush(); //真正的调用write,\n        }\n```\n可以看出, 写数据分为两个过程:write()和flush():\n+ write只是将数据放在了缓存ChannelOutboundBuffer中\n+ 通过调用channal.write()向网络发送数据。\n\n# HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\n我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。\n首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:\n```\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        CodecOutputList out = null;\n        try {\n            if (acceptOutboundMessage(msg)) {\n                out = CodecOutputList.newInstance();\n                I cast = (I) msg;\n                try {\n                    encode(ctx, cast, out);\n                } finally {\n                    ReferenceCountUtil.release(cast);\n                }\n                if (out.isEmpty()) {\n                    out.recycle();\n                    out = null;\n                    throw new EncoderException(\n                            StringUtil.simpleClassName(this) + \" must produce at least one message.\");\n                }\n            } else {\n                ctx.write(msg, promise);\n            }\n        }\n        } finally {\n            if (out != null) {\n                final int sizeMinusOne = out.size() - 1;\n                if (sizeMinusOne == 0) {\n                    ctx.write(out.get(0), promise);\n                } else if (sizeMinusOne > 0) {\n                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure\n                    // See https://github.com/netty/netty/issues/2525\n                    ChannelPromise voidPromise = ctx.voidPromise();\n                    boolean isVoidPromise = promise == voidPromise;\n                    for (int i = 0; i < sizeMinusOne; i ++) {//分开向下发送\n                        ChannelPromise p;\n                        if (isVoidPromise) {\n                            p = voidPromise;\n                        } else {\n                            p = ctx.newPromise();\n                        }\n                        ctx.write(out.getUnsafe(i), p);\n                    }\n                    ctx.write(out.getUnsafe(sizeMinusOne), promise);\n                }\n                out.recycle();\n            }\n        }\n    }\n```\n实现也很简单,主要做了如下两件事:\n1. 首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。\n2. 针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。\n\n## HttpContentEncoder的encode()函数\n首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: \"gzip,deflat,br\"为例。\n\nendoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分\n```\n@Override    //msg: DefaultFullHttpResponse\n    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;\n        switch (state) {\n            case AWAIT_HEADERS: {  //初始取值\n                ensureHeaders(msg);\n                assert encoder == null;\n\n                final HttpResponse res = (HttpResponse) msg;\n                 //根据返回结果确定是否需要编码\n                final int code = res.status().code();\n                final CharSequence acceptEncoding;\n                if (code == CONTINUE_CODE) { //continue_code\n                    // We need to not poll the encoding when response with CONTINUE as another response will follow\n                    // for the issued request. See https://github.com/netty/netty/issues/4079\n                    acceptEncoding = null;\n                } else {\n                    // Get the list of encodings accepted by the peer.\n                    acceptEncoding = acceptEncodingQueue.poll(); //\"gzip.default.br\"\n                    if (acceptEncoding == null) {\n                        throw new IllegalStateException(\"cannot send more responses than requests\");\n                    }\n                }\n                /*\n                 * per rfc2616 4.3 Message Body\n                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a\n                 * message-body. All other responses do include a message-body, although it MAY be of zero length.\n                 *\n                 * 9.4 HEAD\n                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body\n                 * in the response.\n                 *\n                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.\n                 *\n                 * See https://github.com/netty/netty/issues/5382\n                 */\n                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) { //是否接下来是没有body的\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n                if (isFull) {\n                    // Pass through the full response with empty content and continue waiting for the the next resp.\n                    if (!((ByteBufHolder) res).content().isReadable()) {\n                        out.add(ReferenceCountUtil.retain(res));\n                        break;\n                    }\n                }\n\n                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity\n                final Result result = beginEncode(res, acceptEncoding.toString());\n\n                // If unable to encode, pass through.\n                if (result == null) {\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n\n                encoder = result.contentEncoder(); //encoder = EmbeddedChannel\n\n                // Encode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip\n\n                // Output the rewritten response.\n                if (isFull) {\n                    // Convert full message into unfull one.\n                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());\n                    newRes.headers().set(res.headers());\n                    out.add(newRes);  //newRes里面还没有放数据\n\n                    ensureContent(res);\n                    encodeFullResponse(newRes, (HttpContent) res, out);\n                    break;\n                } else {\n                    // Make the response chunked to simplify content transformation.\n                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n\n                    out.add(res);\n                    state = State.AWAIT_CONTENT;\n                    if (!(msg instanceof HttpContent)) {\n                        // only break out the switch statement if we have not content to process\n                        // See https://github.com/netty/netty/issues/2006\n                        break;\n                    }\n                    // Fall through to encode the content\n                }\n            }\n            case AWAIT_CONTENT: {\n                ensureContent(msg);\n                if (encodeContent((HttpContent) msg, out)) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n            case PASS_THROUGH: {\n                ensureContent(msg);\n                out.add(ReferenceCountUtil.retain(msg));\n                // Passed through all following contents of the current response.\n                if (msg instanceof LastHttpContent) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n        }\n    }\n```\n该编码器encode主要做的事情:\n1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:\n+ 若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。\n+ 否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br\n2.根据规范`rfc2616 4.3 Message Body`, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。\n3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。\n4.在beginEncode中建立相应压缩管道EmbeddedChannel:\n```\n protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {\n        ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP\n        if (wrapper == null) {\n            return null;\n        }\n        String targetContentEncoding;\n        switch (wrapper) {\n        case GZIP:\n            targetContentEncoding = \"gzip\";\n            break;\n        case ZLIB:\n            targetContentEncoding = \"deflate\";\n            break;\n        default:\n            throw new Error();\n        }\n\n        return new Result(\n                targetContentEncoding,\n                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),\n                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(\n                        wrapper, compressionLevel, windowBits, memLevel)));\n    }\n```\n主要做了如下事情:\n+ 首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip>deflate\n+ 返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\" />\n对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。\n5.向返回值headler中添加 content-encoding:gzip\n6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.\n7.在encodeFullResponse中调用编码函数encodeContent()\n```\nprivate boolean encodeContent(HttpContent c, List<Object> out) {\n        ByteBuf content = c.content();\n        encode(content, out);\n        if (c instanceof LastHttpContent) {\n            finishEncode(out);\n            LastHttpContent last = (LastHttpContent) c;\n            // Generate an additional chunk if the decoder produced\n            // the last product on closure,\n            HttpHeaders headers = last.trailingHeaders();\n            if (headers.isEmpty()) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                out.add(new ComposedLastHttpContent(headers));\n            }\n            return true;\n        }\n        return false;\n    }\n```\n7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。\n+ 调用JdkZlibEncoder.encode()进行压缩。\n+ 将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。\n+ 在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。\n7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。\n这样整个输出帧的内容存放在out中, 拥有的对象如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\" />\n其中:\n+ DefaultHttpResponse: 存放的是Http/1.1 status, Header等\n+ 第一个DefaultHttpContent存放的是压缩的内容。\n+ 第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。\n+ LastHttpContent代表整个帧的结束, content部分为空。\n8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。\n## JdkZlibEncoder压缩\n我们可以了解下JdkZlibEncoder.encode()是怎么压缩的\n```\n    @Override\n    protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {\n        int len = uncompressed.readableBytes(); //总共刻度数据\n        int offset;\n        byte[] inAry;\n        if (uncompressed.hasArray()) {  //若有数组,直接获得数组\n            // if it is backed by an array we not need to to do a copy at all\n            inAry = uncompressed.array();\n            offset = uncompressed.arrayOffset() + uncompressed.readerIndex();\n            // skip all bytes as we will consume all of them\n            uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度\n        } else {\n            inAry = new byte[len];\n            uncompressed.readBytes(inAry);//将数据读取到这个byte数组中\n            offset = 0;\n        }\n        if (writeHeader) { //将数组写进去， 最开始编码，需要写\n            writeHeader = false;\n            if (wrapper == ZlibWrapper.GZIP) {\n                out.writeBytes(gzipHeader);//首先写进去头\n            }\n        }\n        if (wrapper == ZlibWrapper.GZIP) {\n            crc.update(inAry, offset, len);\n        }\n        //向压缩器中传递带压缩的数组\n        deflater.setInput(inAry, offset, len);\n        while (!deflater.needsInput()) {\n            deflate(out); //进行真正的压缩\n        }\n    }\n```\n可以看到:\n+ 首先获得bytebuf的byte数组\n+ 向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];\n其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;\n+ 直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。\n\n\n## DefalueChannalHadlerContext.write()\nDefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。\n接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:\n```\n         ByteBuf buf = null;\n        if (msg instanceof HttpMessage) {  //如果是头部，则先编码头部\n            if (state != ST_INIT) {\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n            }\n            H m = (H) msg;\n            buf = ctx.alloc().buffer();//直接内存分配的地址\n            // Encode the message.\n            encodeInitialLine(buf, m); //先是编码initial部分\n            encodeHeaders(m.headers(), buf);//再编码header部分\n            buf.writeBytes(CRLF);\n            state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK\n                    HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;\n        }\n        if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {\n            out.add(EMPTY_BUFFER);\n            return;\n        }\n        //如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse\n        if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\n            switch (state) {\n                case ST_INIT:\n                    throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n                case ST_CONTENT_NON_CHUNK: //st_content_non_chunk\n                    final long contentLength = contentLength(msg);\n                    if (contentLength > 0) {//可写的空间够，直接放到直接内存buf中\n                        if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {//必须是content类型的\n                            // merge into other buffer for performance reasons\n                            buf.writeBytes(((HttpContent) msg).content());\n                            out.add(buf);\n                        } else {\n                            if (buf != null) {\n                                out.add(buf); //先把直接内存放进去\n                            }\n                            out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去\n                        }\n\n                        if (msg instanceof LastHttpContent) {\n                            state = ST_INIT; //编码完成后，直接复位\n                        }\n                        break;\n                    }\n                    // fall-through!\n                case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里\n\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    } else {\n                        // Need to produce some output otherwise an\n                        // IllegalStateException will be thrown\n                        out.add(EMPTY_BUFFER);\n                    }\n\n                    break;\n                case ST_CONTENT_CHUNK:\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    }\n                    encodeChunkedContent(ctx, msg, contentLength(msg), out);\n                    break;\n                default:\n                    throw new Error();\n            }\n            if (msg instanceof LastHttpContent) { //解码完成，再置位\n                state = ST_INIT;\n            }\n        } else if (buf != null) {\n            out.add(buf);\n        }\n```\nstate初始值为ST_INIT, 该函数主要做了如下操作:\n1. 首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。\n+ 通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)\n```\n         response.protocolVersion().encode(buf); //首先存放version编码\n        buf.writeByte(SP); //存放byte:32水平空格\n        response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=\"200 ok\"\n        buf.writeBytes(CRLF); //  { CR, LF }回车换行\n```\n+ 通过encodeHeaders编码header部分, 每个header属性编码如下:\n```\n         final int nameLen = name.length();\n        final int valueLen = value.length();\n        final int entryLen = nameLen + valueLen + 4;\n        buf.ensureWritable(entryLen);  //检查buf的最小长度\n        int offset = buf.writerIndex();\n        writeAscii(buf, offset, name); // 使用US_ASCII编码\n        offset += nameLen;\n        buf.setByte(offset ++, ':');//:\n        buf.setByte(offset ++, ' ');//空格\n        writeAscii(buf, offset, value);\n        offset += valueLen;\n        buf.setByte(offset ++, '\\r');//\n        buf.setByte(offset ++, '\\n');\n        buf.writerIndex(offset);\n```\n1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格\n2) 通过CharsetUtil.US_ASCII编码key和value\n+ 再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\" />\n\n然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。\n2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。\n+ 会直接将整个DefaltHttpContent放入out向外写\n+ 当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。\n\n\n# Netty水位\n\n向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:\n```\n   @Override\n        public final void write(Object msg, ChannelPromise promise) {\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位\n            int size;\n            try {\n                msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap\n                size = pipeline.estimatorHandle().size(msg);\n                if (size < 0) {\n                    size = 0;\n                }\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                ReferenceCountUtil.release(msg);\n                return;\n            }\n            outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer\n        }\n```\n+ 在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。\n+ 通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。\n我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\" />\nflushEntry 表示即将刷新的位置\nunflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。\ntailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。\n当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:\n```\n        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息\n        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法\n            setUnwritable(invokeLater);\n        }\n```\n所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?\n在netty启动时, 只需要添加如下参数即可:\n```\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);\n```\n代表:\n+ 当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。\n+ 当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.\n## setUnwritable设置不可写\n\n```\n        for (;;) {\n            final int oldValue = unwritable;\n            final int newValue = oldValue | 1;\n            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态\n                if (oldValue == 0 && newValue != 0) {\n                    fireChannelWritabilityChanged(invokeLater);//\n                }//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。\n                break;\n            }\n        }\n```\n这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写->不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。\n在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。\n\n# Flush\n数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:\n```\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            unsafe.flush();\n        }\n```\n这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():\n```\n        @Override\n        public final void flush() {\n            assertEventLoop();\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null) {\n                return;\n            }\n            outboundBuffer.addFlush();\n            flush0();//写完了\n        }\n```\n主要做了如下事情:\n+ outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;\n+ 调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():\n## 内部flush0\n```\n        @SuppressWarnings(\"deprecation\")\n        protected void flush0() {\n            if (inFlush0) { //有正在写（真正的调用write写）\n                // Avoid re-entrance\n                return;\n            }\n            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n                return;\n            }\n            inFlush0 = true; //标记正在写\n            // Mark all pending write requests as failure if the channel is inactive.\n            if (!isActive()) {\n                try {\n                    if (isOpen()) {\n                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);\n                    } else {\n                        // Do not trigger channelWritabilityChanged because the channel is closed already.\n                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);\n                    }\n                } finally {\n                    inFlush0 = false;\n                }\n                return;\n            }\n            try {\n                doWrite(outboundBuffer);\n            } catch (Throwable t) {\n               ......\n            } finally {\n                inFlush0 = false;\n            }\n        }\n```\n该代码主要做了如下事情:\n1. 检查是否有正在flush,  如是的话, 直接退出。\n2. 标志正在flush\n3.调用doWrite继续刷:\n```\nprotected void doWrite(ChannelOutboundBuffer in) throws Exception {\n        for (;;) {\n            int size = in.size(); //所有的都写完了\n            if (size == 0) {\n                // All written so clear OP_WRITE\n                clearOpWrite();\n                break;\n            }\n            long writtenBytes = 0;\n            boolean done = false;\n            boolean setOpWrite = false;\n            // Ensure the pending writes are made of ByteBufs only.\n            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个\n            int nioBufferCnt = in.nioBufferCount();\n            long expectedWrittenBytes = in.nioBufferSize();\n            SocketChannel ch = javaChannel();\n            // Always us nioBuffers() to workaround data-corruption.\n            // See https://github.com/netty/netty/issues/2761\n            switch (nioBufferCnt) {\n                case 0:\n                    // We have something else beside ByteBuffers to write so fallback to normal writes.\n                    super.doWrite(in);\n                    return;\n                case 1:\n                    // Only one ByteBuf so use non-gathering write\n                    ByteBuffer nioBuffer = nioBuffers[0];\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {\n                        final int localWrittenBytes = ch.write(nioBuffer);\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {//循环16次, 可能一次写不完\n                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            // Release the fully written buffers, and update the indexes of the partially written buffer.\n            in.removeBytes(writtenBytes); //记录可丢弃的数据\n            if (!done) {//若没有写完\n                // Did not write all buffers completely.\n                incompleteWrite(setOpWrite);\n                break;\n            }\n        }\n    }\n```\n该函数主要做了如下事情:\n1. 通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]\n2. 当content个数>=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。\n\n至此, write到缓存、flush到网络部分全部讲完了。\n","source":"_posts/Netty-Http通信编码源码阅读.md","raw":"---\ntitle: Netty Http通信源码二(编码)阅读\ndate: 2018-05-04 00:02:39\ntags:\n---\n解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\" />\n涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。\n开始向外发送数据时, 如下:\n```\nprivate void write(Object msg, boolean flush, ChannelPromise promise) {\n        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context\n        final Object m = pipeline.touch(msg, next);\n        EventExecutor executor = next.executor();\n        if (executor.inEventLoop()) {\n            if (flush) {\n                next.invokeWriteAndFlush(m, promise);\n            } else {\n                next.invokeWrite(m, promise);\n            }\n        } else {\n            AbstractWriteTask task;\n            if (flush) {\n                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行\n            }  else {\n                task = WriteTask.newInstance(next, m, promise);\n            }\n            safeExecute(executor, task, promise, m);\n        }\n    }\n```\n当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:\n```\n        @Override\n        public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) {\n            super.write(ctx, msg, promise); //一般只是存放在缓存中\n            ctx.invokeFlush(); //真正的调用write,\n        }\n```\n可以看出, 写数据分为两个过程:write()和flush():\n+ write只是将数据放在了缓存ChannelOutboundBuffer中\n+ 通过调用channal.write()向网络发送数据。\n\n# HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\n我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。\n首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:\n```\n    @Override\n    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n        CodecOutputList out = null;\n        try {\n            if (acceptOutboundMessage(msg)) {\n                out = CodecOutputList.newInstance();\n                I cast = (I) msg;\n                try {\n                    encode(ctx, cast, out);\n                } finally {\n                    ReferenceCountUtil.release(cast);\n                }\n                if (out.isEmpty()) {\n                    out.recycle();\n                    out = null;\n                    throw new EncoderException(\n                            StringUtil.simpleClassName(this) + \" must produce at least one message.\");\n                }\n            } else {\n                ctx.write(msg, promise);\n            }\n        }\n        } finally {\n            if (out != null) {\n                final int sizeMinusOne = out.size() - 1;\n                if (sizeMinusOne == 0) {\n                    ctx.write(out.get(0), promise);\n                } else if (sizeMinusOne > 0) {\n                    // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure\n                    // See https://github.com/netty/netty/issues/2525\n                    ChannelPromise voidPromise = ctx.voidPromise();\n                    boolean isVoidPromise = promise == voidPromise;\n                    for (int i = 0; i < sizeMinusOne; i ++) {//分开向下发送\n                        ChannelPromise p;\n                        if (isVoidPromise) {\n                            p = voidPromise;\n                        } else {\n                            p = ctx.newPromise();\n                        }\n                        ctx.write(out.getUnsafe(i), p);\n                    }\n                    ctx.write(out.getUnsafe(sizeMinusOne), promise);\n                }\n                out.recycle();\n            }\n        }\n    }\n```\n实现也很简单,主要做了如下两件事:\n1. 首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。\n2. 针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。\n\n## HttpContentEncoder的encode()函数\n首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: \"gzip,deflat,br\"为例。\n\nendoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分\n```\n@Override    //msg: DefaultFullHttpResponse\n    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List<Object> out) throws Exception {\n        final boolean isFull = msg instanceof HttpResponse && msg instanceof LastHttpContent;\n        switch (state) {\n            case AWAIT_HEADERS: {  //初始取值\n                ensureHeaders(msg);\n                assert encoder == null;\n\n                final HttpResponse res = (HttpResponse) msg;\n                 //根据返回结果确定是否需要编码\n                final int code = res.status().code();\n                final CharSequence acceptEncoding;\n                if (code == CONTINUE_CODE) { //continue_code\n                    // We need to not poll the encoding when response with CONTINUE as another response will follow\n                    // for the issued request. See https://github.com/netty/netty/issues/4079\n                    acceptEncoding = null;\n                } else {\n                    // Get the list of encodings accepted by the peer.\n                    acceptEncoding = acceptEncodingQueue.poll(); //\"gzip.default.br\"\n                    if (acceptEncoding == null) {\n                        throw new IllegalStateException(\"cannot send more responses than requests\");\n                    }\n                }\n                /*\n                 * per rfc2616 4.3 Message Body\n                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a\n                 * message-body. All other responses do include a message-body, although it MAY be of zero length.\n                 *\n                 * 9.4 HEAD\n                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body\n                 * in the response.\n                 *\n                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.\n                 *\n                 * See https://github.com/netty/netty/issues/5382\n                 */\n                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) { //是否接下来是没有body的\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n                if (isFull) {\n                    // Pass through the full response with empty content and continue waiting for the the next resp.\n                    if (!((ByteBufHolder) res).content().isReadable()) {\n                        out.add(ReferenceCountUtil.retain(res));\n                        break;\n                    }\n                }\n\n                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity\n                final Result result = beginEncode(res, acceptEncoding.toString());\n\n                // If unable to encode, pass through.\n                if (result == null) {\n                    if (isFull) {\n                        out.add(ReferenceCountUtil.retain(res));\n                    } else {\n                        out.add(res);\n                        // Pass through all following contents.\n                        state = State.PASS_THROUGH;\n                    }\n                    break;\n                }\n\n                encoder = result.contentEncoder(); //encoder = EmbeddedChannel\n\n                // Encode the content and remove or replace the existing headers\n                // so that the message looks like a decoded message.\n                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip\n\n                // Output the rewritten response.\n                if (isFull) {\n                    // Convert full message into unfull one.\n                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());\n                    newRes.headers().set(res.headers());\n                    out.add(newRes);  //newRes里面还没有放数据\n\n                    ensureContent(res);\n                    encodeFullResponse(newRes, (HttpContent) res, out);\n                    break;\n                } else {\n                    // Make the response chunked to simplify content transformation.\n                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);\n                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);\n\n                    out.add(res);\n                    state = State.AWAIT_CONTENT;\n                    if (!(msg instanceof HttpContent)) {\n                        // only break out the switch statement if we have not content to process\n                        // See https://github.com/netty/netty/issues/2006\n                        break;\n                    }\n                    // Fall through to encode the content\n                }\n            }\n            case AWAIT_CONTENT: {\n                ensureContent(msg);\n                if (encodeContent((HttpContent) msg, out)) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n            case PASS_THROUGH: {\n                ensureContent(msg);\n                out.add(ReferenceCountUtil.retain(msg));\n                // Passed through all following contents of the current response.\n                if (msg instanceof LastHttpContent) {\n                    state = State.AWAIT_HEADERS;\n                }\n                break;\n            }\n        }\n    }\n```\n该编码器encode主要做的事情:\n1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:\n+ 若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。\n+ 否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br\n2.根据规范`rfc2616 4.3 Message Body`, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。\n3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。\n4.在beginEncode中建立相应压缩管道EmbeddedChannel:\n```\n protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception {\n        ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP\n        if (wrapper == null) {\n            return null;\n        }\n        String targetContentEncoding;\n        switch (wrapper) {\n        case GZIP:\n            targetContentEncoding = \"gzip\";\n            break;\n        case ZLIB:\n            targetContentEncoding = \"deflate\";\n            break;\n        default:\n            throw new Error();\n        }\n\n        return new Result(\n                targetContentEncoding,\n                new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),\n                        ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(\n                        wrapper, compressionLevel, windowBits, memLevel)));\n    }\n```\n主要做了如下事情:\n+ 首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip>deflate\n+ 返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\" />\n对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。\n5.向返回值headler中添加 content-encoding:gzip\n6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.\n7.在encodeFullResponse中调用编码函数encodeContent()\n```\nprivate boolean encodeContent(HttpContent c, List<Object> out) {\n        ByteBuf content = c.content();\n        encode(content, out);\n        if (c instanceof LastHttpContent) {\n            finishEncode(out);\n            LastHttpContent last = (LastHttpContent) c;\n            // Generate an additional chunk if the decoder produced\n            // the last product on closure,\n            HttpHeaders headers = last.trailingHeaders();\n            if (headers.isEmpty()) {\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);\n            } else {\n                out.add(new ComposedLastHttpContent(headers));\n            }\n            return true;\n        }\n        return false;\n    }\n```\n7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。\n+ 调用JdkZlibEncoder.encode()进行压缩。\n+ 将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。\n+ 在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。\n7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。\n这样整个输出帧的内容存放在out中, 拥有的对象如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\" />\n其中:\n+ DefaultHttpResponse: 存放的是Http/1.1 status, Header等\n+ 第一个DefaultHttpContent存放的是压缩的内容。\n+ 第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。\n+ LastHttpContent代表整个帧的结束, content部分为空。\n8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。\n## JdkZlibEncoder压缩\n我们可以了解下JdkZlibEncoder.encode()是怎么压缩的\n```\n    @Override\n    protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception {\n        int len = uncompressed.readableBytes(); //总共刻度数据\n        int offset;\n        byte[] inAry;\n        if (uncompressed.hasArray()) {  //若有数组,直接获得数组\n            // if it is backed by an array we not need to to do a copy at all\n            inAry = uncompressed.array();\n            offset = uncompressed.arrayOffset() + uncompressed.readerIndex();\n            // skip all bytes as we will consume all of them\n            uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度\n        } else {\n            inAry = new byte[len];\n            uncompressed.readBytes(inAry);//将数据读取到这个byte数组中\n            offset = 0;\n        }\n        if (writeHeader) { //将数组写进去， 最开始编码，需要写\n            writeHeader = false;\n            if (wrapper == ZlibWrapper.GZIP) {\n                out.writeBytes(gzipHeader);//首先写进去头\n            }\n        }\n        if (wrapper == ZlibWrapper.GZIP) {\n            crc.update(inAry, offset, len);\n        }\n        //向压缩器中传递带压缩的数组\n        deflater.setInput(inAry, offset, len);\n        while (!deflater.needsInput()) {\n            deflate(out); //进行真正的压缩\n        }\n    }\n```\n可以看到:\n+ 首先获得bytebuf的byte数组\n+ 向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];\n其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;\n+ 直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。\n\n\n## DefalueChannalHadlerContext.write()\nDefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。\n接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:\n```\n         ByteBuf buf = null;\n        if (msg instanceof HttpMessage) {  //如果是头部，则先编码头部\n            if (state != ST_INIT) {\n                throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n            }\n            H m = (H) msg;\n            buf = ctx.alloc().buffer();//直接内存分配的地址\n            // Encode the message.\n            encodeInitialLine(buf, m); //先是编码initial部分\n            encodeHeaders(m.headers(), buf);//再编码header部分\n            buf.writeBytes(CRLF);\n            state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK\n                    HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;\n        }\n        if (msg instanceof ByteBuf && !((ByteBuf) msg).isReadable()) {\n            out.add(EMPTY_BUFFER);\n            return;\n        }\n        //如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse\n        if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) {\n            switch (state) {\n                case ST_INIT:\n                    throw new IllegalStateException(\"unexpected message type: \" + StringUtil.simpleClassName(msg));\n                case ST_CONTENT_NON_CHUNK: //st_content_non_chunk\n                    final long contentLength = contentLength(msg);\n                    if (contentLength > 0) {//可写的空间够，直接放到直接内存buf中\n                        if (buf != null && buf.writableBytes() >= contentLength && msg instanceof HttpContent) {//必须是content类型的\n                            // merge into other buffer for performance reasons\n                            buf.writeBytes(((HttpContent) msg).content());\n                            out.add(buf);\n                        } else {\n                            if (buf != null) {\n                                out.add(buf); //先把直接内存放进去\n                            }\n                            out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去\n                        }\n\n                        if (msg instanceof LastHttpContent) {\n                            state = ST_INIT; //编码完成后，直接复位\n                        }\n                        break;\n                    }\n                    // fall-through!\n                case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里\n\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    } else {\n                        // Need to produce some output otherwise an\n                        // IllegalStateException will be thrown\n                        out.add(EMPTY_BUFFER);\n                    }\n\n                    break;\n                case ST_CONTENT_CHUNK:\n                    if (buf != null) {\n                        // We allocated a buffer so add it now.\n                        out.add(buf);\n                    }\n                    encodeChunkedContent(ctx, msg, contentLength(msg), out);\n                    break;\n                default:\n                    throw new Error();\n            }\n            if (msg instanceof LastHttpContent) { //解码完成，再置位\n                state = ST_INIT;\n            }\n        } else if (buf != null) {\n            out.add(buf);\n        }\n```\nstate初始值为ST_INIT, 该函数主要做了如下操作:\n1. 首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。\n+ 通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)\n```\n         response.protocolVersion().encode(buf); //首先存放version编码\n        buf.writeByte(SP); //存放byte:32水平空格\n        response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=\"200 ok\"\n        buf.writeBytes(CRLF); //  { CR, LF }回车换行\n```\n+ 通过encodeHeaders编码header部分, 每个header属性编码如下:\n```\n         final int nameLen = name.length();\n        final int valueLen = value.length();\n        final int entryLen = nameLen + valueLen + 4;\n        buf.ensureWritable(entryLen);  //检查buf的最小长度\n        int offset = buf.writerIndex();\n        writeAscii(buf, offset, name); // 使用US_ASCII编码\n        offset += nameLen;\n        buf.setByte(offset ++, ':');//:\n        buf.setByte(offset ++, ' ');//空格\n        writeAscii(buf, offset, value);\n        offset += valueLen;\n        buf.setByte(offset ++, '\\r');//\n        buf.setByte(offset ++, '\\n');\n        buf.writerIndex(offset);\n```\n1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格\n2) 通过CharsetUtil.US_ASCII编码key和value\n+ 再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\" />\n\n然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。\n2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。\n+ 会直接将整个DefaltHttpContent放入out向外写\n+ 当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。\n\n\n# Netty水位\n\n向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:\n```\n   @Override\n        public final void write(Object msg, ChannelPromise promise) {\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位\n            int size;\n            try {\n                msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap\n                size = pipeline.estimatorHandle().size(msg);\n                if (size < 0) {\n                    size = 0;\n                }\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                ReferenceCountUtil.release(msg);\n                return;\n            }\n            outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer\n        }\n```\n+ 在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。\n+ 通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。\n我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:\n<img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\" />\nflushEntry 表示即将刷新的位置\nunflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。\ntailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。\n当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:\n```\n        long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息\n        if (newWriteBufferSize > channel.config().getWriteBufferHighWaterMark()) {//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法\n            setUnwritable(invokeLater);\n        }\n```\n所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?\n在netty启动时, 只需要添加如下参数即可:\n```\nServerBootstrap bootstrap = new ServerBootstrap();\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);\nbootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);\n```\n代表:\n+ 当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。\n+ 当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.\n## setUnwritable设置不可写\n\n```\n        for (;;) {\n            final int oldValue = unwritable;\n            final int newValue = oldValue | 1;\n            if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) {//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态\n                if (oldValue == 0 && newValue != 0) {\n                    fireChannelWritabilityChanged(invokeLater);//\n                }//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。\n                break;\n            }\n        }\n```\n这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写->不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。\n在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。\n\n# Flush\n数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:\n```\n        public void flush(ChannelHandlerContext ctx) throws Exception {\n            unsafe.flush();\n        }\n```\n这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():\n```\n        @Override\n        public final void flush() {\n            assertEventLoop();\n            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null) {\n                return;\n            }\n            outboundBuffer.addFlush();\n            flush0();//写完了\n        }\n```\n主要做了如下事情:\n+ outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;\n+ 调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():\n## 内部flush0\n```\n        @SuppressWarnings(\"deprecation\")\n        protected void flush0() {\n            if (inFlush0) { //有正在写（真正的调用write写）\n                // Avoid re-entrance\n                return;\n            }\n            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;\n            if (outboundBuffer == null || outboundBuffer.isEmpty()) {\n                return;\n            }\n            inFlush0 = true; //标记正在写\n            // Mark all pending write requests as failure if the channel is inactive.\n            if (!isActive()) {\n                try {\n                    if (isOpen()) {\n                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);\n                    } else {\n                        // Do not trigger channelWritabilityChanged because the channel is closed already.\n                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);\n                    }\n                } finally {\n                    inFlush0 = false;\n                }\n                return;\n            }\n            try {\n                doWrite(outboundBuffer);\n            } catch (Throwable t) {\n               ......\n            } finally {\n                inFlush0 = false;\n            }\n        }\n```\n该代码主要做了如下事情:\n1. 检查是否有正在flush,  如是的话, 直接退出。\n2. 标志正在flush\n3.调用doWrite继续刷:\n```\nprotected void doWrite(ChannelOutboundBuffer in) throws Exception {\n        for (;;) {\n            int size = in.size(); //所有的都写完了\n            if (size == 0) {\n                // All written so clear OP_WRITE\n                clearOpWrite();\n                break;\n            }\n            long writtenBytes = 0;\n            boolean done = false;\n            boolean setOpWrite = false;\n            // Ensure the pending writes are made of ByteBufs only.\n            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个\n            int nioBufferCnt = in.nioBufferCount();\n            long expectedWrittenBytes = in.nioBufferSize();\n            SocketChannel ch = javaChannel();\n            // Always us nioBuffers() to workaround data-corruption.\n            // See https://github.com/netty/netty/issues/2761\n            switch (nioBufferCnt) {\n                case 0:\n                    // We have something else beside ByteBuffers to write so fallback to normal writes.\n                    super.doWrite(in);\n                    return;\n                case 1:\n                    // Only one ByteBuf so use non-gathering write\n                    ByteBuffer nioBuffer = nioBuffers[0];\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {\n                        final int localWrittenBytes = ch.write(nioBuffer);\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n                default:\n                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {//循环16次, 可能一次写不完\n                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出\n                        if (localWrittenBytes == 0) {\n                            setOpWrite = true;\n                            break;\n                        }\n                        expectedWrittenBytes -= localWrittenBytes;\n                        writtenBytes += localWrittenBytes;\n                        if (expectedWrittenBytes == 0) {\n                            done = true;\n                            break;\n                        }\n                    }\n                    break;\n            }\n            // Release the fully written buffers, and update the indexes of the partially written buffer.\n            in.removeBytes(writtenBytes); //记录可丢弃的数据\n            if (!done) {//若没有写完\n                // Did not write all buffers completely.\n                incompleteWrite(setOpWrite);\n                break;\n            }\n        }\n    }\n```\n该函数主要做了如下事情:\n1. 通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]\n2. 当content个数>=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。\n\n至此, write到缓存、flush到网络部分全部讲完了。\n","slug":"Netty-Http通信编码源码阅读","published":1,"updated":"2018-05-22T15:53:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadw90005miu5d4buakmm","content":"<p>解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\"><br>涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。<br>开始向外发送数据时, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</div><div class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context</div><div class=\"line\">        final Object m = pipeline.touch(msg, next);</div><div class=\"line\">        EventExecutor executor = next.executor();</div><div class=\"line\">        if (executor.inEventLoop()) &#123;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                next.invokeWriteAndFlush(m, promise);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                next.invokeWrite(m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            AbstractWriteTask task;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行</div><div class=\"line\">            &#125;  else &#123;</div><div class=\"line\">                task = WriteTask.newInstance(next, m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            safeExecute(executor, task, promise, m);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">    super.write(ctx, msg, promise); //一般只是存放在缓存中</div><div class=\"line\">    ctx.invokeFlush(); //真正的调用write,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 写数据分为两个过程:write()和flush():</p>\n<ul>\n<li>write只是将数据放在了缓存ChannelOutboundBuffer中</li>\n<li>通过调用channal.write()向网络发送数据。</li>\n</ul>\n<h1 id=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"><a href=\"#HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\" class=\"headerlink\" title=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"></a>HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec</h1><p>我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。<br>首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class=\"line\">    CodecOutputList out = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (acceptOutboundMessage(msg)) &#123;</div><div class=\"line\">            out = CodecOutputList.newInstance();</div><div class=\"line\">            I cast = (I) msg;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                encode(ctx, cast, out);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                ReferenceCountUtil.release(cast);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (out.isEmpty()) &#123;</div><div class=\"line\">                out.recycle();</div><div class=\"line\">                out = null;</div><div class=\"line\">                throw new EncoderException(</div><div class=\"line\">                        StringUtil.simpleClassName(this) + &quot; must produce at least one message.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.write(msg, promise);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            final int sizeMinusOne = out.size() - 1;</div><div class=\"line\">            if (sizeMinusOne == 0) &#123;</div><div class=\"line\">                ctx.write(out.get(0), promise);</div><div class=\"line\">            &#125; else if (sizeMinusOne &gt; 0) &#123;</div><div class=\"line\">                // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2525</div><div class=\"line\">                ChannelPromise voidPromise = ctx.voidPromise();</div><div class=\"line\">                boolean isVoidPromise = promise == voidPromise;</div><div class=\"line\">                for (int i = 0; i &lt; sizeMinusOne; i ++) &#123;//分开向下发送</div><div class=\"line\">                    ChannelPromise p;</div><div class=\"line\">                    if (isVoidPromise) &#123;</div><div class=\"line\">                        p = voidPromise;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        p = ctx.newPromise();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    ctx.write(out.getUnsafe(i), p);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ctx.write(out.getUnsafe(sizeMinusOne), promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现也很简单,主要做了如下两件事:</p>\n<ol>\n<li>首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。</li>\n<li>针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。</li>\n</ol>\n<h2 id=\"HttpContentEncoder的encode-函数\"><a href=\"#HttpContentEncoder的encode-函数\" class=\"headerlink\" title=\"HttpContentEncoder的encode()函数\"></a>HttpContentEncoder的encode()函数</h2><p>首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: “gzip,deflat,br”为例。</p>\n<p>endoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override    //msg: DefaultFullHttpResponse</div><div class=\"line\">    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        final boolean isFull = msg instanceof HttpResponse &amp;&amp; msg instanceof LastHttpContent;</div><div class=\"line\">        switch (state) &#123;</div><div class=\"line\">            case AWAIT_HEADERS: &#123;  //初始取值</div><div class=\"line\">                ensureHeaders(msg);</div><div class=\"line\">                assert encoder == null;</div><div class=\"line\"></div><div class=\"line\">                final HttpResponse res = (HttpResponse) msg;</div><div class=\"line\">                 //根据返回结果确定是否需要编码</div><div class=\"line\">                final int code = res.status().code();</div><div class=\"line\">                final CharSequence acceptEncoding;</div><div class=\"line\">                if (code == CONTINUE_CODE) &#123; //continue_code</div><div class=\"line\">                    // We need to not poll the encoding when response with CONTINUE as another response will follow</div><div class=\"line\">                    // for the issued request. See https://github.com/netty/netty/issues/4079</div><div class=\"line\">                    acceptEncoding = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Get the list of encodings accepted by the peer.</div><div class=\"line\">                    acceptEncoding = acceptEncodingQueue.poll(); //&quot;gzip.default.br&quot;</div><div class=\"line\">                    if (acceptEncoding == null) &#123;</div><div class=\"line\">                        throw new IllegalStateException(&quot;cannot send more responses than requests&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                /*</div><div class=\"line\">                 * per rfc2616 4.3 Message Body</div><div class=\"line\">                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a</div><div class=\"line\">                 * message-body. All other responses do include a message-body, although it MAY be of zero length.</div><div class=\"line\">                 *</div><div class=\"line\">                 * 9.4 HEAD</div><div class=\"line\">                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body</div><div class=\"line\">                 * in the response.</div><div class=\"line\">                 *</div><div class=\"line\">                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.</div><div class=\"line\">                 *</div><div class=\"line\">                 * See https://github.com/netty/netty/issues/5382</div><div class=\"line\">                 */</div><div class=\"line\">                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) &#123; //是否接下来是没有body的</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Pass through the full response with empty content and continue waiting for the the next resp.</div><div class=\"line\">                    if (!((ByteBufHolder) res).content().isReadable()) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity</div><div class=\"line\">                final Result result = beginEncode(res, acceptEncoding.toString());</div><div class=\"line\"></div><div class=\"line\">                // If unable to encode, pass through.</div><div class=\"line\">                if (result == null) &#123;</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                encoder = result.contentEncoder(); //encoder = EmbeddedChannel</div><div class=\"line\"></div><div class=\"line\">                // Encode the content and remove or replace the existing headers</div><div class=\"line\">                // so that the message looks like a decoded message.</div><div class=\"line\">                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip</div><div class=\"line\"></div><div class=\"line\">                // Output the rewritten response.</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Convert full message into unfull one.</div><div class=\"line\">                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());</div><div class=\"line\">                    newRes.headers().set(res.headers());</div><div class=\"line\">                    out.add(newRes);  //newRes里面还没有放数据</div><div class=\"line\"></div><div class=\"line\">                    ensureContent(res);</div><div class=\"line\">                    encodeFullResponse(newRes, (HttpContent) res, out);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Make the response chunked to simplify content transformation.</div><div class=\"line\">                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);</div><div class=\"line\">                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);</div><div class=\"line\"></div><div class=\"line\">                    out.add(res);</div><div class=\"line\">                    state = State.AWAIT_CONTENT;</div><div class=\"line\">                    if (!(msg instanceof HttpContent)) &#123;</div><div class=\"line\">                        // only break out the switch statement if we have not content to process</div><div class=\"line\">                        // See https://github.com/netty/netty/issues/2006</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Fall through to encode the content</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case AWAIT_CONTENT: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                if (encodeContent((HttpContent) msg, out)) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case PASS_THROUGH: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                out.add(ReferenceCountUtil.retain(msg));</div><div class=\"line\">                // Passed through all following contents of the current response.</div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>该编码器encode主要做的事情:<br>1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:</p>\n<ul>\n<li>若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。</li>\n<li>否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br<br>2.根据规范<code>rfc2616 4.3 Message Body</code>, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。<br>3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。<br>4.在beginEncode中建立相应压缩管道EmbeddedChannel:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception &#123;</div><div class=\"line\">       ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP</div><div class=\"line\">       if (wrapper == null) &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">       String targetContentEncoding;</div><div class=\"line\">       switch (wrapper) &#123;</div><div class=\"line\">       case GZIP:</div><div class=\"line\">           targetContentEncoding = &quot;gzip&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       case ZLIB:</div><div class=\"line\">           targetContentEncoding = &quot;deflate&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       default:</div><div class=\"line\">           throw new Error();</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return new Result(</div><div class=\"line\">               targetContentEncoding,</div><div class=\"line\">               new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),</div><div class=\"line\">                       ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(</div><div class=\"line\">                       wrapper, compressionLevel, windowBits, memLevel)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip&gt;deflate</li>\n<li>返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\"><br>对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。<br>5.向返回值headler中添加 content-encoding:gzip<br>6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.<br>7.在encodeFullResponse中调用编码函数encodeContent()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean encodeContent(HttpContent c, List&lt;Object&gt; out) &#123;</div><div class=\"line\">        ByteBuf content = c.content();</div><div class=\"line\">        encode(content, out);</div><div class=\"line\">        if (c instanceof LastHttpContent) &#123;</div><div class=\"line\">            finishEncode(out);</div><div class=\"line\">            LastHttpContent last = (LastHttpContent) c;</div><div class=\"line\">            // Generate an additional chunk if the decoder produced</div><div class=\"line\">            // the last product on closure,</div><div class=\"line\">            HttpHeaders headers = last.trailingHeaders();</div><div class=\"line\">            if (headers.isEmpty()) &#123;</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new ComposedLastHttpContent(headers));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。</p>\n<ul>\n<li>调用JdkZlibEncoder.encode()进行压缩。</li>\n<li>将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。</li>\n<li>在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。<br>7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。<br>这样整个输出帧的内容存放在out中, 拥有的对象如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\"><br>其中:</li>\n<li>DefaultHttpResponse: 存放的是Http/1.1 status, Header等</li>\n<li>第一个DefaultHttpContent存放的是压缩的内容。</li>\n<li>第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。</li>\n<li>LastHttpContent代表整个帧的结束, content部分为空。<br>8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。<h2 id=\"JdkZlibEncoder压缩\"><a href=\"#JdkZlibEncoder压缩\" class=\"headerlink\" title=\"JdkZlibEncoder压缩\"></a>JdkZlibEncoder压缩</h2>我们可以了解下JdkZlibEncoder.encode()是怎么压缩的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception &#123;</div><div class=\"line\">    int len = uncompressed.readableBytes(); //总共刻度数据</div><div class=\"line\">    int offset;</div><div class=\"line\">    byte[] inAry;</div><div class=\"line\">    if (uncompressed.hasArray()) &#123;  //若有数组,直接获得数组</div><div class=\"line\">        // if it is backed by an array we not need to to do a copy at all</div><div class=\"line\">        inAry = uncompressed.array();</div><div class=\"line\">        offset = uncompressed.arrayOffset() + uncompressed.readerIndex();</div><div class=\"line\">        // skip all bytes as we will consume all of them</div><div class=\"line\">        uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        inAry = new byte[len];</div><div class=\"line\">        uncompressed.readBytes(inAry);//将数据读取到这个byte数组中</div><div class=\"line\">        offset = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (writeHeader) &#123; //将数组写进去， 最开始编码，需要写</div><div class=\"line\">        writeHeader = false;</div><div class=\"line\">        if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">            out.writeBytes(gzipHeader);//首先写进去头</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">        crc.update(inAry, offset, len);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //向压缩器中传递带压缩的数组</div><div class=\"line\">    deflater.setInput(inAry, offset, len);</div><div class=\"line\">    while (!deflater.needsInput()) &#123;</div><div class=\"line\">        deflate(out); //进行真正的压缩</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先获得bytebuf的byte数组</li>\n<li>向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];<br>其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;</li>\n<li>直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。</li>\n</ul>\n<h2 id=\"DefalueChannalHadlerContext-write\"><a href=\"#DefalueChannalHadlerContext-write\" class=\"headerlink\" title=\"DefalueChannalHadlerContext.write()\"></a>DefalueChannalHadlerContext.write()</h2><p>DefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。<br>接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ByteBuf buf = null;</div><div class=\"line\">if (msg instanceof HttpMessage) &#123;  //如果是头部，则先编码头部</div><div class=\"line\">    if (state != ST_INIT) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">    &#125;</div><div class=\"line\">    H m = (H) msg;</div><div class=\"line\">    buf = ctx.alloc().buffer();//直接内存分配的地址</div><div class=\"line\">    // Encode the message.</div><div class=\"line\">    encodeInitialLine(buf, m); //先是编码initial部分</div><div class=\"line\">    encodeHeaders(m.headers(), buf);//再编码header部分</div><div class=\"line\">    buf.writeBytes(CRLF);</div><div class=\"line\">    state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK</div><div class=\"line\">            HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg instanceof ByteBuf &amp;&amp; !((ByteBuf) msg).isReadable()) &#123;</div><div class=\"line\">    out.add(EMPTY_BUFFER);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse</div><div class=\"line\">if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) &#123;</div><div class=\"line\">    switch (state) &#123;</div><div class=\"line\">        case ST_INIT:</div><div class=\"line\">            throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">        case ST_CONTENT_NON_CHUNK: //st_content_non_chunk</div><div class=\"line\">            final long contentLength = contentLength(msg);</div><div class=\"line\">            if (contentLength &gt; 0) &#123;//可写的空间够，直接放到直接内存buf中</div><div class=\"line\">                if (buf != null &amp;&amp; buf.writableBytes() &gt;= contentLength &amp;&amp; msg instanceof HttpContent) &#123;//必须是content类型的</div><div class=\"line\">                    // merge into other buffer for performance reasons</div><div class=\"line\">                    buf.writeBytes(((HttpContent) msg).content());</div><div class=\"line\">                    out.add(buf);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (buf != null) &#123;</div><div class=\"line\">                        out.add(buf); //先把直接内存放进去</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = ST_INIT; //编码完成后，直接复位</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // fall-through!</div><div class=\"line\">        case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里</div><div class=\"line\"></div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Need to produce some output otherwise an</div><div class=\"line\">                // IllegalStateException will be thrown</div><div class=\"line\">                out.add(EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            break;</div><div class=\"line\">        case ST_CONTENT_CHUNK:</div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125;</div><div class=\"line\">            encodeChunkedContent(ctx, msg, contentLength(msg), out);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            throw new Error();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg instanceof LastHttpContent) &#123; //解码完成，再置位</div><div class=\"line\">        state = ST_INIT;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (buf != null) &#123;</div><div class=\"line\">    out.add(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>state初始值为ST_INIT, 该函数主要做了如下操作:</p>\n<ol>\n<li>首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。</li>\n</ol>\n<ul>\n<li><p>通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> response.protocolVersion().encode(buf); //首先存放version编码</div><div class=\"line\">buf.writeByte(SP); //存放byte:32水平空格</div><div class=\"line\">response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=&quot;200 ok&quot;</div><div class=\"line\">buf.writeBytes(CRLF); //  &#123; CR, LF &#125;回车换行</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过encodeHeaders编码header部分, 每个header属性编码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> final int nameLen = name.length();</div><div class=\"line\">final int valueLen = value.length();</div><div class=\"line\">final int entryLen = nameLen + valueLen + 4;</div><div class=\"line\">buf.ensureWritable(entryLen);  //检查buf的最小长度</div><div class=\"line\">int offset = buf.writerIndex();</div><div class=\"line\">writeAscii(buf, offset, name); // 使用US_ASCII编码</div><div class=\"line\">offset += nameLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;:&apos;);//:</div><div class=\"line\">buf.setByte(offset ++, &apos; &apos;);//空格</div><div class=\"line\">writeAscii(buf, offset, value);</div><div class=\"line\">offset += valueLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;\\r&apos;);//</div><div class=\"line\">buf.setByte(offset ++, &apos;\\n&apos;);</div><div class=\"line\">buf.writerIndex(offset);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格<br>2) 通过CharsetUtil.US_ASCII编码key和value</p>\n<ul>\n<li>再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\"></li>\n</ul>\n<p>然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。<br>2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。</p>\n<ul>\n<li>会直接将整个DefaltHttpContent放入out向外写</li>\n<li>当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。</li>\n</ul>\n<h1 id=\"Netty水位\"><a href=\"#Netty水位\" class=\"headerlink\" title=\"Netty水位\"></a>Netty水位</h1><p>向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">     public final void write(Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位</div><div class=\"line\">         int size;</div><div class=\"line\">         try &#123;</div><div class=\"line\">             msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap</div><div class=\"line\">             size = pipeline.estimatorHandle().size(msg);</div><div class=\"line\">             if (size &lt; 0) &#123;</div><div class=\"line\">                 size = 0;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; catch (Throwable t) &#123;</div><div class=\"line\">             safeSetFailure(promise, t);</div><div class=\"line\">             ReferenceCountUtil.release(msg);</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。</li>\n<li>通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。<br>我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\"><br>flushEntry 表示即将刷新的位置<br>unflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。<br>tailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。<br>当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息</div><div class=\"line\">if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法</div><div class=\"line\">    setUnwritable(invokeLater);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?<br>在netty启动时, 只需要添加如下参数即可:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);</div></pre></td></tr></table></figure></p>\n<p>代表:</p>\n<ul>\n<li>当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。</li>\n<li>当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.<h2 id=\"setUnwritable设置不可写\"><a href=\"#setUnwritable设置不可写\" class=\"headerlink\" title=\"setUnwritable设置不可写\"></a>setUnwritable设置不可写</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    final int oldValue = unwritable;</div><div class=\"line\">    final int newValue = oldValue | 1;</div><div class=\"line\">    if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) &#123;//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态</div><div class=\"line\">        if (oldValue == 0 &amp;&amp; newValue != 0) &#123;</div><div class=\"line\">            fireChannelWritabilityChanged(invokeLater);//</div><div class=\"line\">        &#125;//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写-&gt;不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。<br>在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。</p>\n<h1 id=\"Flush\"><a href=\"#Flush\" class=\"headerlink\" title=\"Flush\"></a>Flush</h1><p>数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">    unsafe.flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public final void flush() &#123;</div><div class=\"line\">    assertEventLoop();</div><div class=\"line\">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    outboundBuffer.addFlush();</div><div class=\"line\">    flush0();//写完了</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;</li>\n<li>调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():<h2 id=\"内部flush0\"><a href=\"#内部flush0\" class=\"headerlink\" title=\"内部flush0\"></a>内部flush0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">protected void flush0() &#123;</div><div class=\"line\">    if (inFlush0) &#123; //有正在写（真正的调用write写）</div><div class=\"line\">        // Avoid re-entrance</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    inFlush0 = true; //标记正在写</div><div class=\"line\">    // Mark all pending write requests as failure if the channel is inactive.</div><div class=\"line\">    if (!isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (isOpen()) &#123;</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Do not trigger channelWritabilityChanged because the channel is closed already.</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            inFlush0 = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        doWrite(outboundBuffer);</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">       ......</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        inFlush0 = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该代码主要做了如下事情:</p>\n<ol>\n<li>检查是否有正在flush,  如是的话, 直接退出。</li>\n<li>标志正在flush<br>3.调用doWrite继续刷:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            int size = in.size(); //所有的都写完了</div><div class=\"line\">            if (size == 0) &#123;</div><div class=\"line\">                // All written so clear OP_WRITE</div><div class=\"line\">                clearOpWrite();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            long writtenBytes = 0;</div><div class=\"line\">            boolean done = false;</div><div class=\"line\">            boolean setOpWrite = false;</div><div class=\"line\">            // Ensure the pending writes are made of ByteBufs only.</div><div class=\"line\">            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个</div><div class=\"line\">            int nioBufferCnt = in.nioBufferCount();</div><div class=\"line\">            long expectedWrittenBytes = in.nioBufferSize();</div><div class=\"line\">            SocketChannel ch = javaChannel();</div><div class=\"line\">            // Always us nioBuffers() to workaround data-corruption.</div><div class=\"line\">            // See https://github.com/netty/netty/issues/2761</div><div class=\"line\">            switch (nioBufferCnt) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                    // We have something else beside ByteBuffers to write so fallback to normal writes.</div><div class=\"line\">                    super.doWrite(in);</div><div class=\"line\">                    return;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    // Only one ByteBuf so use non-gathering write</div><div class=\"line\">                    ByteBuffer nioBuffer = nioBuffers[0];</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;</div><div class=\"line\">                        final int localWrittenBytes = ch.write(nioBuffer);</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;//循环16次, 可能一次写不完</div><div class=\"line\">                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">            in.removeBytes(writtenBytes); //记录可丢弃的数据</div><div class=\"line\">            if (!done) &#123;//若没有写完</div><div class=\"line\">                // Did not write all buffers completely.</div><div class=\"line\">                incompleteWrite(setOpWrite);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]</li>\n<li>当content个数&gt;=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。</li>\n</ol>\n<p>至此, write到缓存、flush到网络部分全部讲完了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>解码过程仍以<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/04/16/Netty-Http%E9%80%9A%E4%BF%A1%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/\">Netty Http通信源码一(解码)阅读</a>提供的示例为例, 编码发送的主体DefaultFullHttpResponse如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/DefaultFullHttpResponse.png\"><br>涉及到的ChannelOutboundHandler类有:HttpContentCompressor、HttpObjectEncoder, 及其父类。 本wiki仍然以数据的流向作为引导线。<br>开始向外发送数据时, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void write(Object msg, boolean flush, ChannelPromise promise) &#123;</div><div class=\"line\">        AbstractChannelHandlerContext next = findContextOutbound(); //向外发送，找到一个拥有out的context</div><div class=\"line\">        final Object m = pipeline.touch(msg, next);</div><div class=\"line\">        EventExecutor executor = next.executor();</div><div class=\"line\">        if (executor.inEventLoop()) &#123;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                next.invokeWriteAndFlush(m, promise);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                next.invokeWrite(m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            AbstractWriteTask task;</div><div class=\"line\">            if (flush) &#123;</div><div class=\"line\">                task = WriteAndFlushTask.newInstance(next, m, promise); //这个task是一个Runnable, 只需要向里面放， 后期自然会执行</div><div class=\"line\">            &#125;  else &#123;</div><div class=\"line\">                task = WriteTask.newInstance(next, m, promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            safeExecute(executor, task, promise, m);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>当自定义handler向外发送数据时, 走的是else部分; 若我们调用了flush()方法, 此时, 会产生WriteAndFlushTask对象,  其为Runnable类, 在run函数中, 会直接调用write(), write定义如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(AbstractChannelHandlerContext ctx, Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">    super.write(ctx, msg, promise); //一般只是存放在缓存中</div><div class=\"line\">    ctx.invokeFlush(); //真正的调用write,</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出, 写数据分为两个过程:write()和flush():</p>\n<ul>\n<li>write只是将数据放在了缓存ChannelOutboundBuffer中</li>\n<li>通过调用channal.write()向网络发送数据。</li>\n</ul>\n<h1 id=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"><a href=\"#HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\" class=\"headerlink\" title=\"HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec\"></a>HttpContentCompressor及父类HttpContentEncoder、MessageToMessageCodec</h1><p>我们需要知道: MessageToMessageCodec该类是一个ChannelDuplexHandler类型的, 可以同时在IN, OUT场景下使用。<br>首先进入的是MessageToMessageCodec的write()函数, 通过该函数的encoder.write(ctx, msg, promise)跳转到MessageToMessageEncoder的write()函数中, 实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception &#123;</div><div class=\"line\">    CodecOutputList out = null;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        if (acceptOutboundMessage(msg)) &#123;</div><div class=\"line\">            out = CodecOutputList.newInstance();</div><div class=\"line\">            I cast = (I) msg;</div><div class=\"line\">            try &#123;</div><div class=\"line\">                encode(ctx, cast, out);</div><div class=\"line\">            &#125; finally &#123;</div><div class=\"line\">                ReferenceCountUtil.release(cast);</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (out.isEmpty()) &#123;</div><div class=\"line\">                out.recycle();</div><div class=\"line\">                out = null;</div><div class=\"line\">                throw new EncoderException(</div><div class=\"line\">                        StringUtil.simpleClassName(this) + &quot; must produce at least one message.&quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.write(msg, promise);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        if (out != null) &#123;</div><div class=\"line\">            final int sizeMinusOne = out.size() - 1;</div><div class=\"line\">            if (sizeMinusOne == 0) &#123;</div><div class=\"line\">                ctx.write(out.get(0), promise);</div><div class=\"line\">            &#125; else if (sizeMinusOne &gt; 0) &#123;</div><div class=\"line\">                // Check if we can use a voidPromise for our extra writes to reduce GC-Pressure</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2525</div><div class=\"line\">                ChannelPromise voidPromise = ctx.voidPromise();</div><div class=\"line\">                boolean isVoidPromise = promise == voidPromise;</div><div class=\"line\">                for (int i = 0; i &lt; sizeMinusOne; i ++) &#123;//分开向下发送</div><div class=\"line\">                    ChannelPromise p;</div><div class=\"line\">                    if (isVoidPromise) &#123;</div><div class=\"line\">                        p = voidPromise;</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        p = ctx.newPromise();</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    ctx.write(out.getUnsafe(i), p);</div><div class=\"line\">                &#125;</div><div class=\"line\">                ctx.write(out.getUnsafe(sizeMinusOne), promise);</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.recycle();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>实现也很简单,主要做了如下两件事:</p>\n<ol>\n<li>首先通过encode()进行编码, encode()是在HttpContentEncoder中实现的: 若out没有编码输出, 则直接抛出异常;最终通过msg.release()释放response.content占用的空间。</li>\n<li>针对编码输出out, 循环遍历out中每一个compoment, 通过DefalueChannalHadlerContext.write()向外写出数据。</li>\n</ol>\n<h2 id=\"HttpContentEncoder的encode-函数\"><a href=\"#HttpContentEncoder的encode-函数\" class=\"headerlink\" title=\"HttpContentEncoder的encode()函数\"></a>HttpContentEncoder的encode()函数</h2><p>首先需要了解HttpContentEncoder的decode(), 在写入的时候, 将header里面的accept-encoding属性取值赋给acceptEncodingQueue, 这样服务器端返回数据压缩的时候就知道需要使用什么编码器了, 本文章以客户端发送的编码器: “gzip,deflat,br”为例。</p>\n<p>endoce函数如下, 其中msg为DefaultFullHttpResponse, 包含了header和content部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override    //msg: DefaultFullHttpResponse</div><div class=\"line\">    protected void encode(ChannelHandlerContext ctx, HttpObject msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        final boolean isFull = msg instanceof HttpResponse &amp;&amp; msg instanceof LastHttpContent;</div><div class=\"line\">        switch (state) &#123;</div><div class=\"line\">            case AWAIT_HEADERS: &#123;  //初始取值</div><div class=\"line\">                ensureHeaders(msg);</div><div class=\"line\">                assert encoder == null;</div><div class=\"line\"></div><div class=\"line\">                final HttpResponse res = (HttpResponse) msg;</div><div class=\"line\">                 //根据返回结果确定是否需要编码</div><div class=\"line\">                final int code = res.status().code();</div><div class=\"line\">                final CharSequence acceptEncoding;</div><div class=\"line\">                if (code == CONTINUE_CODE) &#123; //continue_code</div><div class=\"line\">                    // We need to not poll the encoding when response with CONTINUE as another response will follow</div><div class=\"line\">                    // for the issued request. See https://github.com/netty/netty/issues/4079</div><div class=\"line\">                    acceptEncoding = null;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Get the list of encodings accepted by the peer.</div><div class=\"line\">                    acceptEncoding = acceptEncodingQueue.poll(); //&quot;gzip.default.br&quot;</div><div class=\"line\">                    if (acceptEncoding == null) &#123;</div><div class=\"line\">                        throw new IllegalStateException(&quot;cannot send more responses than requests&quot;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">                /*</div><div class=\"line\">                 * per rfc2616 4.3 Message Body</div><div class=\"line\">                 * All 1xx (informational), 204 (no content), and 304 (not modified) responses MUST NOT include a</div><div class=\"line\">                 * message-body. All other responses do include a message-body, although it MAY be of zero length.</div><div class=\"line\">                 *</div><div class=\"line\">                 * 9.4 HEAD</div><div class=\"line\">                 * The HEAD method is identical to GET except that the server MUST NOT return a message-body</div><div class=\"line\">                 * in the response.</div><div class=\"line\">                 *</div><div class=\"line\">                 * Also we should pass through HTTP/1.0 as transfer-encoding: chunked is not supported.</div><div class=\"line\">                 *</div><div class=\"line\">                 * See https://github.com/netty/netty/issues/5382</div><div class=\"line\">                 */</div><div class=\"line\">                if (isPassthru(res.protocolVersion(), code, acceptEncoding)) &#123; //是否接下来是没有body的</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Pass through the full response with empty content and continue waiting for the the next resp.</div><div class=\"line\">                    if (!((ByteBufHolder) res).content().isReadable()) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                // Prepare to encode the content.   通过curl 发送的请求中是没有压缩的，为identity</div><div class=\"line\">                final Result result = beginEncode(res, acceptEncoding.toString());</div><div class=\"line\"></div><div class=\"line\">                // If unable to encode, pass through.</div><div class=\"line\">                if (result == null) &#123;</div><div class=\"line\">                    if (isFull) &#123;</div><div class=\"line\">                        out.add(ReferenceCountUtil.retain(res));</div><div class=\"line\">                    &#125; else &#123;</div><div class=\"line\">                        out.add(res);</div><div class=\"line\">                        // Pass through all following contents.</div><div class=\"line\">                        state = State.PASS_THROUGH;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                encoder = result.contentEncoder(); //encoder = EmbeddedChannel</div><div class=\"line\"></div><div class=\"line\">                // Encode the content and remove or replace the existing headers</div><div class=\"line\">                // so that the message looks like a decoded message.</div><div class=\"line\">                res.headers().set(HttpHeaderNames.CONTENT_ENCODING, result.targetContentEncoding()); //gzip</div><div class=\"line\"></div><div class=\"line\">                // Output the rewritten response.</div><div class=\"line\">                if (isFull) &#123;</div><div class=\"line\">                    // Convert full message into unfull one.</div><div class=\"line\">                    HttpResponse newRes = new DefaultHttpResponse(res.protocolVersion(), res.status());</div><div class=\"line\">                    newRes.headers().set(res.headers());</div><div class=\"line\">                    out.add(newRes);  //newRes里面还没有放数据</div><div class=\"line\"></div><div class=\"line\">                    ensureContent(res);</div><div class=\"line\">                    encodeFullResponse(newRes, (HttpContent) res, out);</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    // Make the response chunked to simplify content transformation.</div><div class=\"line\">                    res.headers().remove(HttpHeaderNames.CONTENT_LENGTH);</div><div class=\"line\">                    res.headers().set(HttpHeaderNames.TRANSFER_ENCODING, HttpHeaderValues.CHUNKED);</div><div class=\"line\"></div><div class=\"line\">                    out.add(res);</div><div class=\"line\">                    state = State.AWAIT_CONTENT;</div><div class=\"line\">                    if (!(msg instanceof HttpContent)) &#123;</div><div class=\"line\">                        // only break out the switch statement if we have not content to process</div><div class=\"line\">                        // See https://github.com/netty/netty/issues/2006</div><div class=\"line\">                        break;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    // Fall through to encode the content</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case AWAIT_CONTENT: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                if (encodeContent((HttpContent) msg, out)) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            case PASS_THROUGH: &#123;</div><div class=\"line\">                ensureContent(msg);</div><div class=\"line\">                out.add(ReferenceCountUtil.retain(msg));</div><div class=\"line\">                // Passed through all following contents of the current response.</div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = State.AWAIT_HEADERS;</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>该编码器encode主要做的事情:<br>1.根据state初始值AWAIT_HEADERS(默认)首先AWAIT_HEADERS分支, 获取result_code:</p>\n<ul>\n<li>若为100, 说明之时一个continue信号, acceptEncoding赋值为空, 告诉后面不用压缩直接返回。</li>\n<li>否则, 根据获取decode()时设置的压缩格式:accept-encoding: gzip,deflat,br<br>2.根据规范<code>rfc2616 4.3 Message Body</code>, code返回值若为All 1xx (informational), 204 (no content), and 304 (not modified)时, response一定不能包含message-body部分。此时检查result_code, 若是该类code, 直接执行将out.add(res)而退出, 而不用考虑对content部分进行压缩。<br>3.检查response的contet是否有可读数据, content没值的话直接放入out.add(res)返回。<br>4.在beginEncode中建立相应压缩管道EmbeddedChannel:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected Result beginEncode(HttpResponse headers, String acceptEncoding) throws Exception &#123;</div><div class=\"line\">       ZlibWrapper wrapper = determineWrapper(acceptEncoding);//GZIP</div><div class=\"line\">       if (wrapper == null) &#123;</div><div class=\"line\">           return null;</div><div class=\"line\">       &#125;</div><div class=\"line\">       String targetContentEncoding;</div><div class=\"line\">       switch (wrapper) &#123;</div><div class=\"line\">       case GZIP:</div><div class=\"line\">           targetContentEncoding = &quot;gzip&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       case ZLIB:</div><div class=\"line\">           targetContentEncoding = &quot;deflate&quot;;</div><div class=\"line\">           break;</div><div class=\"line\">       default:</div><div class=\"line\">           throw new Error();</div><div class=\"line\">       &#125;</div><div class=\"line\"></div><div class=\"line\">       return new Result(</div><div class=\"line\">               targetContentEncoding,</div><div class=\"line\">               new EmbeddedChannel(ctx.channel().id(), ctx.channel().metadata().hasDisconnect(),</div><div class=\"line\">                       ctx.channel().config(), ZlibCodecFactory.newZlibEncoder(</div><div class=\"line\">                       wrapper, compressionLevel, windowBits, memLevel)));</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要做了如下事情:</p>\n<ul>\n<li>首先在determineWrapper判断使用哪种压缩编码, 使用优先级gzip&gt;deflate</li>\n<li>返回EmbeddedChannel, 我们需要注意该channel里面通过ZlibCodecFactory.newZlibEncoder()方式添加了一个handler, 该返回EmbeddedChannel的pipeline结构如下:<img src=\"http://owsl7963b.bkt.clouddn.com/GzipPipline.png\"><br>对gzip编码感兴趣的话, 可以看下JdkZlibEncoder.encode关于编码的细节。<br>5.向返回值headler中添加 content-encoding:gzip<br>6.封装header, result_code, http_version, 产生一个DefaultHttpResponse, 放入out.<br>7.在encodeFullResponse中调用编码函数encodeContent()<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">private boolean encodeContent(HttpContent c, List&lt;Object&gt; out) &#123;</div><div class=\"line\">        ByteBuf content = c.content();</div><div class=\"line\">        encode(content, out);</div><div class=\"line\">        if (c instanceof LastHttpContent) &#123;</div><div class=\"line\">            finishEncode(out);</div><div class=\"line\">            LastHttpContent last = (LastHttpContent) c;</div><div class=\"line\">            // Generate an additional chunk if the decoder produced</div><div class=\"line\">            // the last product on closure,</div><div class=\"line\">            HttpHeaders headers = last.trailingHeaders();</div><div class=\"line\">            if (headers.isEmpty()) &#123;</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new ComposedLastHttpContent(headers));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return true;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return false;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>7.1.注意这里的encode部分, 调用的是 encoder.writeOutbound(in.retain()), 而encoder就是前面描述的EmbeddedChannel, 进去后, 发现调用的是EmbeddedChannel.write(m),  依次处理的handler见上图EmbeddedChannel的pipeline。</p>\n<ul>\n<li>调用JdkZlibEncoder.encode()进行压缩。</li>\n<li>将数据写入ChannelOutboundBuffer对象并刷新, 写入的时候也会受限制于高水位,但是实际并不起什么作用, 后面在真正发送数据的时候会详细讲解这部分。</li>\n<li>在finishEncode()中会产生DefaultHttpContent, 里面存放的是gzip压缩的footer(可读才10 byte), 具体byte见JdkZlibEncoder.finishEncode里面描述。<br>7.2.向out中写入LastHttpContent.EMPTY_LAST_CONTENT, 代表这个帧内容结束。<br>这样整个输出帧的内容存放在out中, 拥有的对象如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpOutPutResponse.png\"><br>其中:</li>\n<li>DefaultHttpResponse: 存放的是Http/1.1 status, Header等</li>\n<li>第一个DefaultHttpContent存放的是压缩的内容。</li>\n<li>第二个DefaultHttpContent存放的是压缩器gzip的尾部标识部分。</li>\n<li>LastHttpContent代表整个帧的结束, content部分为空。<br>8.在encodeFullResponse中, 向header部分添加整个帧的长度content-length属性。<h2 id=\"JdkZlibEncoder压缩\"><a href=\"#JdkZlibEncoder压缩\" class=\"headerlink\" title=\"JdkZlibEncoder压缩\"></a>JdkZlibEncoder压缩</h2>我们可以了解下JdkZlibEncoder.encode()是怎么压缩的<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void encode(ChannelHandlerContext ctx, ByteBuf uncompressed, ByteBuf out) throws Exception &#123;</div><div class=\"line\">    int len = uncompressed.readableBytes(); //总共刻度数据</div><div class=\"line\">    int offset;</div><div class=\"line\">    byte[] inAry;</div><div class=\"line\">    if (uncompressed.hasArray()) &#123;  //若有数组,直接获得数组</div><div class=\"line\">        // if it is backed by an array we not need to to do a copy at all</div><div class=\"line\">        inAry = uncompressed.array();</div><div class=\"line\">        offset = uncompressed.arrayOffset() + uncompressed.readerIndex();</div><div class=\"line\">        // skip all bytes as we will consume all of them</div><div class=\"line\">        uncompressed.skipBytes(len); //读取的数据， 直接跳过数组的长度</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        inAry = new byte[len];</div><div class=\"line\">        uncompressed.readBytes(inAry);//将数据读取到这个byte数组中</div><div class=\"line\">        offset = 0;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (writeHeader) &#123; //将数组写进去， 最开始编码，需要写</div><div class=\"line\">        writeHeader = false;</div><div class=\"line\">        if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">            out.writeBytes(gzipHeader);//首先写进去头</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (wrapper == ZlibWrapper.GZIP) &#123;</div><div class=\"line\">        crc.update(inAry, offset, len);</div><div class=\"line\">    &#125;</div><div class=\"line\">    //向压缩器中传递带压缩的数组</div><div class=\"line\">    deflater.setInput(inAry, offset, len);</div><div class=\"line\">    while (!deflater.needsInput()) &#123;</div><div class=\"line\">        deflate(out); //进行真正的压缩</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到:</p>\n<ul>\n<li>首先获得bytebuf的byte数组</li>\n<li>向最终存放压缩数据的out(PooledUnsafeDirectByteBuf)中写入gzip压缩标志的头部gzipHeader: [0x1f, (byte) 0x8b, Deflater.DEFLATED, 0, 0, 0, 0, 0, 0, 0];<br>其中out长度 =  (int) Math.ceil(msg.readableBytes() * 1.001) + 12 + gzipHeader.len(), 看来极端情况下压缩后可能和压缩前长度差不多;</li>\n<li>直接调用gzip的压缩算法, 将byte压缩后写入out中. 至于具体的压缩算法, 感兴趣的同学可以自行查看源代码。</li>\n</ul>\n<h2 id=\"DefalueChannalHadlerContext-write\"><a href=\"#DefalueChannalHadlerContext-write\" class=\"headerlink\" title=\"DefalueChannalHadlerContext.write()\"></a>DefalueChannalHadlerContext.write()</h2><p>DefalueChannalHadlerContext.write()函数之前的工作主要是编码部分、组成帧。 这里开始将压缩后最终的帧继续向外传递write。<br>接下来OutHanlder为HttpResponseEncoder, 实际调用的是其父类MessageToMessageEncoder.write(), 该函数已经在最开始介绍了; 其中调用了HttpObjectEncoder.encode(), 函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"> ByteBuf buf = null;</div><div class=\"line\">if (msg instanceof HttpMessage) &#123;  //如果是头部，则先编码头部</div><div class=\"line\">    if (state != ST_INIT) &#123;</div><div class=\"line\">        throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">    &#125;</div><div class=\"line\">    H m = (H) msg;</div><div class=\"line\">    buf = ctx.alloc().buffer();//直接内存分配的地址</div><div class=\"line\">    // Encode the message.</div><div class=\"line\">    encodeInitialLine(buf, m); //先是编码initial部分</div><div class=\"line\">    encodeHeaders(m.headers(), buf);//再编码header部分</div><div class=\"line\">    buf.writeBytes(CRLF);</div><div class=\"line\">    state = isContentAlwaysEmpty(m) ? ST_CONTENT_ALWAYS_EMPTY ://一般都是ST_CONTENT_NON_CHUNK</div><div class=\"line\">            HttpUtil.isTransferEncodingChunked(m) ? ST_CONTENT_CHUNK : ST_CONTENT_NON_CHUNK;</div><div class=\"line\">&#125;</div><div class=\"line\">if (msg instanceof ByteBuf &amp;&amp; !((ByteBuf) msg).isReadable()) &#123;</div><div class=\"line\">    out.add(EMPTY_BUFFER);</div><div class=\"line\">    return;</div><div class=\"line\">&#125;</div><div class=\"line\">//如果是数据部分，则编码数据部分， 若是DefaultFullHttpResponse</div><div class=\"line\">if (msg instanceof HttpContent || msg instanceof ByteBuf || msg instanceof FileRegion) &#123;</div><div class=\"line\">    switch (state) &#123;</div><div class=\"line\">        case ST_INIT:</div><div class=\"line\">            throw new IllegalStateException(&quot;unexpected message type: &quot; + StringUtil.simpleClassName(msg));</div><div class=\"line\">        case ST_CONTENT_NON_CHUNK: //st_content_non_chunk</div><div class=\"line\">            final long contentLength = contentLength(msg);</div><div class=\"line\">            if (contentLength &gt; 0) &#123;//可写的空间够，直接放到直接内存buf中</div><div class=\"line\">                if (buf != null &amp;&amp; buf.writableBytes() &gt;= contentLength &amp;&amp; msg instanceof HttpContent) &#123;//必须是content类型的</div><div class=\"line\">                    // merge into other buffer for performance reasons</div><div class=\"line\">                    buf.writeBytes(((HttpContent) msg).content());</div><div class=\"line\">                    out.add(buf);</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (buf != null) &#123;</div><div class=\"line\">                        out.add(buf); //先把直接内存放进去</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    out.add(encodeAndRetain(msg));//放进去的是CompositeByteBuf, 可以看出分了两部分放进去</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                if (msg instanceof LastHttpContent) &#123;</div><div class=\"line\">                    state = ST_INIT; //编码完成后，直接复位</div><div class=\"line\">                &#125;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // fall-through!</div><div class=\"line\">        case ST_CONTENT_ALWAYS_EMPTY: //内容为空, 最后一个帧将跳到这里</div><div class=\"line\"></div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Need to produce some output otherwise an</div><div class=\"line\">                // IllegalStateException will be thrown</div><div class=\"line\">                out.add(EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            break;</div><div class=\"line\">        case ST_CONTENT_CHUNK:</div><div class=\"line\">            if (buf != null) &#123;</div><div class=\"line\">                // We allocated a buffer so add it now.</div><div class=\"line\">                out.add(buf);</div><div class=\"line\">            &#125;</div><div class=\"line\">            encodeChunkedContent(ctx, msg, contentLength(msg), out);</div><div class=\"line\">            break;</div><div class=\"line\">        default:</div><div class=\"line\">            throw new Error();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (msg instanceof LastHttpContent) &#123; //解码完成，再置位</div><div class=\"line\">        state = ST_INIT;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; else if (buf != null) &#123;</div><div class=\"line\">    out.add(buf);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>state初始值为ST_INIT, 该函数主要做了如下操作:</p>\n<ol>\n<li>首先检查是否是HttpMessage, Http Response 结构如上所示, 最开始是DefaultHttpResponse。</li>\n</ol>\n<ul>\n<li><p>通过encodeInitialLine编码initial部分(HHttpResponseEncoder中定义)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> response.protocolVersion().encode(buf); //首先存放version编码</div><div class=\"line\">buf.writeByte(SP); //存放byte:32水平空格</div><div class=\"line\">response.status().encode(buf); //存放status, 比如[50 48 48 32 79 79]=&quot;200 ok&quot;</div><div class=\"line\">buf.writeBytes(CRLF); //  &#123; CR, LF &#125;回车换行</div></pre></td></tr></table></figure>\n</li>\n<li><p>通过encodeHeaders编码header部分, 每个header属性编码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> final int nameLen = name.length();</div><div class=\"line\">final int valueLen = value.length();</div><div class=\"line\">final int entryLen = nameLen + valueLen + 4;</div><div class=\"line\">buf.ensureWritable(entryLen);  //检查buf的最小长度</div><div class=\"line\">int offset = buf.writerIndex();</div><div class=\"line\">writeAscii(buf, offset, name); // 使用US_ASCII编码</div><div class=\"line\">offset += nameLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;:&apos;);//:</div><div class=\"line\">buf.setByte(offset ++, &apos; &apos;);//空格</div><div class=\"line\">writeAscii(buf, offset, value);</div><div class=\"line\">offset += valueLen;</div><div class=\"line\">buf.setByte(offset ++, &apos;\\r&apos;);//</div><div class=\"line\">buf.setByte(offset ++, &apos;\\n&apos;);</div><div class=\"line\">buf.writerIndex(offset);</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>1) 可以看出实际编码后存放的是 key: value\\r\\n; 注意冒号后面是空格<br>2) 通过CharsetUtil.US_ASCII编码key和value</p>\n<ul>\n<li>再接着写入[CRLF]。 其实可以看出, http response byte每部分内容都是以[CRLF]作为分隔符, 格式如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/HttpResponse_Byte.png\"></li>\n</ul>\n<p>然后根据header部分来改变state状态, 一般state会被置为ST_CONTENT_NON_CHUNK。根据MessageToMessageEncoder.write()可知, 编码完DefaultHttpResponse, 就调用DefalueChannalHadlerContext.write继续向外写, 后面会详细讲些该部分。<br>2.第二、三次、四次传递过来的是DefaltHttpContent, 将进入ST_CONTENT_NON_CHUNK部分。</p>\n<ul>\n<li>会直接将整个DefaltHttpContent放入out向外写</li>\n<li>当发现传递过来的Content为末尾标识符LastHttpContent时, contentLength为0, 此时将直接跳到ST_CONTENT_ALWAYS_EMPTY部分执行, out会添加EMPTY_BUFFER, 最终state=ST_INIT置位, 表示该帧处理完成, 等待下一个帧传递过来。</li>\n</ul>\n<h1 id=\"Netty水位\"><a href=\"#Netty水位\" class=\"headerlink\" title=\"Netty水位\"></a>Netty水位</h1><p>向外写的最外层为HeadContext, 其write直接调用unsafe.write(msg, promise), 实际调用的是AbstractChannel$AbstractSafeUnSafe.write(), 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">     public final void write(Object msg, ChannelPromise promise) &#123;</div><div class=\"line\">         ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;//每个管道都有一个高水位和低水位</div><div class=\"line\">         int size;</div><div class=\"line\">         try &#123;</div><div class=\"line\">             msg = filterOutboundMessage(msg); //自定义, 在真正写出的时候, msg必须转变为直接内存heap</div><div class=\"line\">             size = pipeline.estimatorHandle().size(msg);</div><div class=\"line\">             if (size &lt; 0) &#123;</div><div class=\"line\">                 size = 0;</div><div class=\"line\">             &#125;</div><div class=\"line\">         &#125; catch (Throwable t) &#123;</div><div class=\"line\">             safeSetFailure(promise, t);</div><div class=\"line\">             ReferenceCountUtil.release(msg);</div><div class=\"line\">             return;</div><div class=\"line\">         &#125;</div><div class=\"line\">         outboundBuffer.addMessage(msg, size, promise);//ChannelOutboundBuffer</div><div class=\"line\">     &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>在这个函数中, 我们需要了解的是: 若直接是最外层发送, 那么filterOutboundMessage将会把msg转变为直接内存buf。</li>\n<li>通过ChannelOutboundBuffer.addMessage(msg, size, promise), 将输出结果暂时缓存起来, 形成一个链再批量发送。<br>我们需要了解下ChannelOutboundBuffer这个类, 它作为输出内容暂时缓存的地方, 维护着输出数据组成的链, 结构如下:<br><img src=\"http://owsl7963b.bkt.clouddn.com/ChannelOutboundBuffer.png\"><br>flushEntry 表示即将刷新的位置<br>unflushEntry: 每次调用addFlush()将unflushEntry赋值给flushEntry, 才算真正开始flush数据了。<br>tailEntry: 当前缓存message时, 新增message都是尾部追加。 我们需要知道, 尾部追加并没有限制, 也就是说, netty本身并不会为我们做限制写入, 它只是负责通知我们达到内存使用水位上限了。 我们需要自己在函数中控制写入数据, 比如在发送数据时, 当且仅当channel.isWritable()为true才继续发送数据。<br>当把message通过尾部追加添加到输出list之后, 会同时调用incrementPendingOutboundBytes(), 记录当前已缓存的数据量:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">long newWriteBufferSize = TOTAL_PENDING_SIZE_UPDATER.addAndGet(this, size);////原子更新一下当前的水位，并获取最新的水位信息</div><div class=\"line\">if (newWriteBufferSize &gt; channel.config().getWriteBufferHighWaterMark()) &#123;//如果当前的水位高于配置的高水位，那么就要调用setUnwriteable方法</div><div class=\"line\">    setUnwritable(invokeLater);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>所以向ChannelOutboundBuffer添加content不能太快了, 否则若来不及发送的话, 都是堆积在直接内存中, 容易造成内存OOM, 这里是如何限处理存数据大小的呢?<br>在netty启动时, 只需要添加如下参数即可:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">ServerBootstrap bootstrap = new ServerBootstrap();</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, 64 * 1024);</div><div class=\"line\">bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, 32 * 1024);</div></pre></td></tr></table></figure></p>\n<p>代表:</p>\n<ul>\n<li>当每个channel使用写出缓存超过高水位64kb(默认值)时候, 就会调用fireChannelWritabilityChanged函数, 让上游感知, 同时Channel.isWritable()返回false。</li>\n<li>当每个channel使用写出缓存超过高水位之后, 又通过发送到网络后回落到低水位时, Channel.isWritable() 将会返回true.<h2 id=\"setUnwritable设置不可写\"><a href=\"#setUnwritable设置不可写\" class=\"headerlink\" title=\"setUnwritable设置不可写\"></a>setUnwritable设置不可写</h2></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    final int oldValue = unwritable;</div><div class=\"line\">    final int newValue = oldValue | 1;</div><div class=\"line\">    if (UNWRITABLE_UPDATER.compareAndSet(this, oldValue, newValue)) &#123;//高水位的时候就会可以通知到业务handler中的WritabilityChanged方法，并且修改buffer的状态</div><div class=\"line\">        if (oldValue == 0 &amp;&amp; newValue != 0) &#123;</div><div class=\"line\">            fireChannelWritabilityChanged(invokeLater);//</div><div class=\"line\">        &#125;//事实上，达到高水位之后，Netty仅仅会发送一个Channle状态位变更事件通知，并不会阻止用户继续发送消息.发现的确如此。</div><div class=\"line\">        break;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里可以看出使用for循环, 直到将unwritable属性有0变为1(可写-&gt;不可写), 然后调用fireChannelWritabilityChanged向上层handler发送信号。<br>在自定义handler时, 可以覆盖该函数, 并通过channelWritable()判断是达到水位上限还是恢复可写了。</p>\n<h1 id=\"Flush\"><a href=\"#Flush\" class=\"headerlink\" title=\"Flush\"></a>Flush</h1><p>数据发送到缓存之后, 就开始调用ctx.invokeFlush(),  开始从HttpPipeliningHandler.flush开始调用,  一直到HeadContext.flush(), HeadContext.flush()调用如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void flush(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">    unsafe.flush();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这样的代码结构是不是很熟悉, 和write部分最终调用时一样的。 调用AbstractChannel$AbstractSafeUnSafe.flush():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">public final void flush() &#123;</div><div class=\"line\">    assertEventLoop();</div><div class=\"line\">    ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    outboundBuffer.addFlush();</div><div class=\"line\">    flush0();//写完了</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下事情:</p>\n<ul>\n<li>outboundBuffer.addFlush() 仅仅将flushEntry指向缓存连第一个节点, 并将unflushedEntry置为空;</li>\n<li>调用flush0开始真正的flush, 会跳到AbstractChannel$AbstractUnsafe.flush0():<h2 id=\"内部flush0\"><a href=\"#内部flush0\" class=\"headerlink\" title=\"内部flush0\"></a>内部flush0</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;deprecation&quot;)</div><div class=\"line\">protected void flush0() &#123;</div><div class=\"line\">    if (inFlush0) &#123; //有正在写（真正的调用write写）</div><div class=\"line\">        // Avoid re-entrance</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;</div><div class=\"line\">    if (outboundBuffer == null || outboundBuffer.isEmpty()) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    inFlush0 = true; //标记正在写</div><div class=\"line\">    // Mark all pending write requests as failure if the channel is inactive.</div><div class=\"line\">    if (!isActive()) &#123;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            if (isOpen()) &#123;</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                // Do not trigger channelWritabilityChanged because the channel is closed already.</div><div class=\"line\">                outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            inFlush0 = false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        doWrite(outboundBuffer);</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">       ......</div><div class=\"line\">    &#125; finally &#123;</div><div class=\"line\">        inFlush0 = false;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>该代码主要做了如下事情:</p>\n<ol>\n<li>检查是否有正在flush,  如是的话, 直接退出。</li>\n<li>标志正在flush<br>3.调用doWrite继续刷:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void doWrite(ChannelOutboundBuffer in) throws Exception &#123;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            int size = in.size(); //所有的都写完了</div><div class=\"line\">            if (size == 0) &#123;</div><div class=\"line\">                // All written so clear OP_WRITE</div><div class=\"line\">                clearOpWrite();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            long writtenBytes = 0;</div><div class=\"line\">            boolean done = false;</div><div class=\"line\">            boolean setOpWrite = false;</div><div class=\"line\">            // Ensure the pending writes are made of ByteBufs only.</div><div class=\"line\">            ByteBuffer[] nioBuffers = in.nioBuffers(); //获取的是DirectByteBuf[] 共三个</div><div class=\"line\">            int nioBufferCnt = in.nioBufferCount();</div><div class=\"line\">            long expectedWrittenBytes = in.nioBufferSize();</div><div class=\"line\">            SocketChannel ch = javaChannel();</div><div class=\"line\">            // Always us nioBuffers() to workaround data-corruption.</div><div class=\"line\">            // See https://github.com/netty/netty/issues/2761</div><div class=\"line\">            switch (nioBufferCnt) &#123;</div><div class=\"line\">                case 0:</div><div class=\"line\">                    // We have something else beside ByteBuffers to write so fallback to normal writes.</div><div class=\"line\">                    super.doWrite(in);</div><div class=\"line\">                    return;</div><div class=\"line\">                case 1:</div><div class=\"line\">                    // Only one ByteBuf so use non-gathering write</div><div class=\"line\">                    ByteBuffer nioBuffer = nioBuffers[0];</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;</div><div class=\"line\">                        final int localWrittenBytes = ch.write(nioBuffer);</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                default:</div><div class=\"line\">                    for (int i = config().getWriteSpinCount() - 1; i &gt;= 0; i --) &#123;//循环16次, 可能一次写不完</div><div class=\"line\">                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt); //真正的写出</div><div class=\"line\">                        if (localWrittenBytes == 0) &#123;</div><div class=\"line\">                            setOpWrite = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                        expectedWrittenBytes -= localWrittenBytes;</div><div class=\"line\">                        writtenBytes += localWrittenBytes;</div><div class=\"line\">                        if (expectedWrittenBytes == 0) &#123;</div><div class=\"line\">                            done = true;</div><div class=\"line\">                            break;</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Release the fully written buffers, and update the indexes of the partially written buffer.</div><div class=\"line\">            in.removeBytes(writtenBytes); //记录可丢弃的数据</div><div class=\"line\">            if (!done) &#123;//若没有写完</div><div class=\"line\">                // Did not write all buffers completely.</div><div class=\"line\">                incompleteWrite(setOpWrite);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>该函数主要做了如下事情:</p>\n<ol>\n<li>通过in.nioBuffers() 获取content的直接内存DirectByteBuf[]</li>\n<li>当content个数&gt;=1时, 通过for 循环发送config().getWriteSpinCount()次, 为什么这样做? 是以免一次数据量太大了, 发送一次发送不完, 默认可以连续发送16次。ch.write()这个函数是不是又很常见了。</li>\n</ol>\n<p>至此, write到缓存、flush到网络部分全部讲完了。</p>\n"},{"title":"Netty Http通信源码一(解码)阅读","date":"2018-04-15T16:06:17.000Z","_content":"首先给出一个http server pipiLine里面的处理器的组成结构的示例:\n```\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);\n            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个\n            ch.pipeline().addLast(\"decoder\", decoder);\n            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n            final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));\n            ch.pipeline().addLast(\"aggregator\", aggregator);  //包的聚合\n            ch.pipeline().addLast(\"encoder_compress\", new HttpContentCompressor(transport.compressionLevel));\n            ch.pipeline().addLast(\"pipelining\", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));\n            ch.pipeline().addLast(\"handler\", requestHandler);\n        }\n```\n其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。\nhttp处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。\n这里有一个问题:\n`为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?`\n# HttpObjectDecoder和HttpRequestDecoder\n首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:\n+ HttpRequest: 主要存放inital, head等。\n+ HttpContent: 传输的数据部分\nHttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成`HttpRequest`,实际就是将`ChannelBuffer`转变为多个`HttpChunk`对象。\nHttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。\nHttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。\ndecode函数实现如下:\n```\nprotected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) { //没有break\n        case SKIP_CONTROL_CHARS: { //skip_control_chars\n            if (!skipControlCharacters(buffer)) {\n                return;\n            }\n            currentState = State.READ_INITIAL;   //read_initail\n        }\n        case READ_INITIAL: try {  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1\n            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line); //{Method, URL, HTTPVersion\n            if (initialLine.length < 3) { //无效的请求， 忽略。\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars\n                return;\n            }\n            message = createMessage(initialLine);  //DefaultHttpRequest\n            currentState = State.READ_HEADER;  //read_header\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {    //read_header\n            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:   //skip_control_char\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE: //read_chunk_size\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:  //或者读取变量类型长度或者定长\n                long contentLength = contentLength();//没有长度相关变量就是-1\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content\n                    resetNow();\n                    return;\n                }\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content\n                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {  //read_fixed_lengt_content\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength; // 注意这两个直接赋值一样\n                }\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {  //read_variable_length_content\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {  //read_fixed_length_content\n            int readLimit = buffer.readableBytes();\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create a HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面\n            chunkSize -= toRead; //content = PooledSlicedByteBuf\n            if (chunkSize == 0) {  //要是定长的话，就直接content就是DefaultLastHttpContent，\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow(); //解析完了就该返回了\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {//read_chunk_size\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: { //read_chunked_content\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n            out.add(chunk);\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {//read_chunked_delimiter\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {//read_chunked_foooter\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {  //bad_message\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {//upgraded\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n```\n注意这里的case并没有break, decode主要做了如下逻辑:\n1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。\n```\nprivate static boolean skipControlCharacters(ByteBuf buffer) {\n        boolean skiped = false;\n        final int wIdx = buffer.writerIndex();\n        int rIdx = buffer.readerIndex();\n        while (wIdx > rIdx) {\n            int c = buffer.getUnsignedByte(rIdx++);\n            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等\n                rIdx--;\n                skiped = true;\n                break;\n            }\n        }\n        buffer.readerIndex(rIdx);\n        return skiped;\n    }\n```\n首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。\n2) 读取INITIAL部分\n从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:`GET /_cat/indices HTTP/1.1`, 创建对象:DefaultHttpRequest, 其中\n```\nhttpVersion: HTTP/1.1\nmethod: GET\nuri: /_cat/indices\n```\n这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。\n3) 读取Headers部分\n```\nprivate State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;  //DefaultHttpRequest\n        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders\n        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while{}为循环\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do { //这是个while循环，以换行符来进行分割\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n                line = headerParser.parse(buffer);   //\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {   //解析出最后一个header\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {  //header是否为空\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始\n        } else if (HttpUtil.isTransferEncodingChunked(message)) { // 是否包含 transfer-encoding: chunked\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {   //Content-Length: 80\n            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值\n        } else { //没有Content-Length和chunked相关的，就是读取变量类型长度\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n        }\n```\n主要做的事:\n+ 读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:\n```\n\"Accept\" -> \"*/*\"\n\"User-Agent\" -> \"curl/7/43/0\"\n\"Host\" -> \"127.0.0.1:9200\"\n\"Content-Length\" -> \"66735\"\n\"Content-Encoding\" -> \"gzip\"\n\"Content-Type\" -> \"application/x-www-form-urlencoded\"\n\"Expect\" -> \"100-continue\"\n\"null\" -> \"null\"\n```\n我们需要了解一个参数:Expect: 100-continue\n\n> <a href=\"https://blog.csdn.net/MitKey/article/details/52042537\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。<p>客户端策略:\n如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}\n如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。\n并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。\n有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。<p>服务端策略:\n正确情况下，收到请求后，返回 100 或错误码。\n如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。\n\n这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度>=1025时, 客户端发送的header里面才会有这个参数。\n+ 如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。\n这里会设置状态为READ_FIXED_LENGTH_CONTENT\n4)  读取内容\n因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<Math.min(readableLength, maxChunkSize), 每读取maxChunkSize长度的值就向后传递, 同时修改chunkSize的值。读取第二个chunked的动作在MessageToMessageDecoder中发出(该content的readableBytes>0)。\n这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。\n# HttpObjectAggregator和 MessageAggregator\nHttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。\nMessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:\n```\n    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {\n        if (isStartMessage(msg)) {//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行\n            handlingOversizedMessage = false;\n            if (currentMessage != null) {\n                currentMessage.release();\n                currentMessage = null;\n                throw new MessageAggregationException();\n            }\n            @SuppressWarnings(\"unchecked\")\n            S m = (S) msg; //DefaultHttpRequest\n            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)\n            // Check before content length. Failing an expectation may result in a different response being sent.\n            Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse\n            if (continueResponse != null) { //向客户端返回100-continue, 告诉客户端可以发送content了\n                // Cache the write listener for reuse.\n                ChannelFutureListener listener = continueResponseWriteListener;\n                if (listener == null) {\n                    continueResponseWriteListener = listener = new ChannelFutureListener() {\n                        @Override\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                ctx.fireExceptionCaught(future.cause());\n                            }\n                        }\n                    };\n                }\n                // Make sure to call this before writing, otherwise reference counts may be invalid.\n                boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);\n                handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);\n\n                final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);\n\n                if (closeAfterWrite) {\n                    future.addListener(ChannelFutureListener.CLOSE);\n                    return;\n                }\n                if (handlingOversizedMessage) {\n                    return;\n                }\n            } else if (isContentLengthInvalid(m, maxContentLength)) { //检查length是否有效，\n                // if content length is set, preemptively close if it's too large\n                invokeHandleOversizedMessage(ctx, m);\n                return;\n            }\n\n            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {\n                O aggregated;\n                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {\n                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());\n                } else {\n                    aggregated = beginAggregation(m, EMPTY_BUFFER);\n                }\n                finishAggregation(aggregated);\n                out.add(aggregated);\n                return;\n            }\n             //同时生成好Compent\n            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.\n            CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可\n            if (m instanceof ByteBufHolder) {\n                appendPartialContent(content, ((ByteBufHolder) m).content());\n            }\n            currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest\n        } else if (isContentMessage(msg)) { //解析内容部分\n            if (currentMessage == null) {\n                // it is possible that a TooLongFrameException was already thrown but we can still discard data\n                // until the begging of the next request/response.\n                return;\n            }\n\n            // Merge the received chunk into the content of the current message.\n            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();\n\n            @SuppressWarnings(\"unchecked\")\n            final C m = (C) msg; //可能是DefaultLastHttpContent\n            // Handle oversized message.\n            if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {\n                // By convention, full message type extends first message type.\n                @SuppressWarnings(\"unchecked\")\n                S s = (S) currentMessage;\n                invokeHandleOversizedMessage(ctx, s);\n                return;\n            }\n            // Append the content of the chunk.\n            appendPartialContent(content, m.content()); //把产生的数据添加到末尾\n            //\n            // Give the subtypes a chance to merge additional information such as trailing headers.\n            aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest\n\n            final boolean last;\n            if (m instanceof DecoderResultProvider) {\n                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();\n                if (!decoderResult.isSuccess()) {\n                    if (currentMessage instanceof DecoderResultProvider) {\n                        ((DecoderResultProvider) currentMessage).setDecoderResult(\n                                DecoderResult.failure(decoderResult.cause()));\n                    }\n                    last = true;\n                } else {\n                    last = isLastContentMessage(m);\n                }\n            } else {\n                last = isLastContentMessage(m);\n            }\n\n            if (last) {  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，\n                finishAggregation(currentMessage);\n\n                // All done\n                out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。\n                currentMessage = null;\n            }\n        } else {\n            throw new MessageAggregationException();\n        }\n    }\n```\ndecode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。\n1) 若请求是HttpRequest\n说明该部分是request最开始的那一部分。\n+ 首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。\n+ 生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。\n需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性`List<Component> components`构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。\n\n2) 若请求是HttpContent部分\n+ 将content添加进CompositeByteBuf中\n通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:\n```\n     private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {\n            .....\n            if (cIndex == components.size()) {\n                wasAdded = components.add(c);\n                if (cIndex == 0) {\n                    c.endOffset = readableBytes;\n                } else {\n                    Component prev = components.get(cIndex - 1);\n                    c.offset = prev.endOffset;\n                    c.endOffset = c.offset + readableBytes;\n                }\n            }\n            .....\n            if (increaseWriterIndex) {\n                writerIndex(writerIndex() + buffer.readableBytes());\n            }\n            return cIndex;\n        }\n    }\n```\n每个Component结构如下:\n```\n        ByteBuf buf;  //该Component实际存储\n        final int length;\n        int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。\n        int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。\n```\n在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。\n\n+ 等待所有的content发送过来\n1. 轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。\n2. 直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。\n\n至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\" />\n# 附\n如何将Composite转换为一个连续的堆内buf呢?\n通过Unpooled.copiedBuffer(request.content())方法即可。\n","source":"_posts/Netty-Http通信解码源码阅读.md","raw":"---\ntitle: Netty Http通信源码一(解码)阅读\ndate: 2018-04-16 00:06:17\ntags:\n---\n首先给出一个http server pipiLine里面的处理器的组成结构的示例:\n```\n        @Override\n        protected void initChannel(Channel ch) throws Exception {\n            final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);\n            decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个\n            ch.pipeline().addLast(\"decoder\", decoder);\n            ch.pipeline().addLast(\"encoder\", new HttpResponseEncoder());\n            final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));\n            ch.pipeline().addLast(\"aggregator\", aggregator);  //包的聚合\n            ch.pipeline().addLast(\"encoder_compress\", new HttpContentCompressor(transport.compressionLevel));\n            ch.pipeline().addLast(\"pipelining\", new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));\n            ch.pipeline().addLast(\"handler\", requestHandler);\n        }\n```\n其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。\nhttp处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。\n这里有一个问题:\n`为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?`\n# HttpObjectDecoder和HttpRequestDecoder\n首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:\n+ HttpRequest: 主要存放inital, head等。\n+ HttpContent: 传输的数据部分\nHttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成`HttpRequest`,实际就是将`ChannelBuffer`转变为多个`HttpChunk`对象。\nHttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。\nHttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。\ndecode函数实现如下:\n```\nprotected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n        if (resetRequested) {\n            resetNow();\n        }\n\n        switch (currentState) { //没有break\n        case SKIP_CONTROL_CHARS: { //skip_control_chars\n            if (!skipControlCharacters(buffer)) {\n                return;\n            }\n            currentState = State.READ_INITIAL;   //read_initail\n        }\n        case READ_INITIAL: try {  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1\n            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse\n            if (line == null) {\n                return;\n            }\n            String[] initialLine = splitInitialLine(line); //{Method, URL, HTTPVersion\n            if (initialLine.length < 3) { //无效的请求， 忽略。\n                // Invalid initial line - ignore.\n                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars\n                return;\n            }\n            message = createMessage(initialLine);  //DefaultHttpRequest\n            currentState = State.READ_HEADER;  //read_header\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_HEADER: try {    //read_header\n            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式\n            if (nextState == null) {\n                return;\n            }\n            currentState = nextState;\n            switch (nextState) {\n            case SKIP_CONTROL_CHARS:   //skip_control_char\n                out.add(message);\n                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content\n                resetNow();\n                return;\n            case READ_CHUNK_SIZE: //read_chunk_size\n                if (!chunkedSupported) {\n                    throw new IllegalArgumentException(\"Chunked messages not supported\");\n                }\n                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.\n                out.add(message);\n                return;\n            default:  //或者读取变量类型长度或者定长\n                long contentLength = contentLength();//没有长度相关变量就是-1\n                if (contentLength == 0 || contentLength == -1 && isDecodingRequest()) {\n                    out.add(message);\n                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content\n                    resetNow();\n                    return;\n                }\n                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content\n                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content\n                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分\n                if (nextState == State.READ_FIXED_LENGTH_CONTENT) {  //read_fixed_lengt_content\n                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.\n                    chunkSize = contentLength; // 注意这两个直接赋值一样\n                }\n                // We return here, this forces decode to be called again where we will decode the content\n                return;\n            }\n        } catch (Exception e) {\n            out.add(invalidMessage(buffer, e));\n            return;\n        }\n        case READ_VARIABLE_LENGTH_CONTENT: {  //read_variable_length_content\n            // Keep reading data as a chunk until the end of connection is reached.\n            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);\n            if (toRead > 0) {\n                ByteBuf content = buffer.readRetainedSlice(toRead);\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        case READ_FIXED_LENGTH_CONTENT: {  //read_fixed_length_content\n            int readLimit = buffer.readableBytes();\n            // Check if the buffer is readable first as we use the readable byte count\n            // to create the HttpChunk. This is needed as otherwise we may end up with\n            // create a HttpChunk instance that contains an empty buffer and so is\n            // handled like it is the last HttpChunk.\n            //\n            // See https://github.com/netty/netty/issues/433\n            if (readLimit == 0) {\n                return;\n            }\n            int toRead = Math.min(readLimit, maxChunkSize);\n            if (toRead > chunkSize) {\n                toRead = (int) chunkSize;\n            }\n            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面\n            chunkSize -= toRead; //content = PooledSlicedByteBuf\n            if (chunkSize == 0) {  //要是定长的话，就直接content就是DefaultLastHttpContent，\n                // Read all content.\n                out.add(new DefaultLastHttpContent(content, validateHeaders));\n                resetNow(); //解析完了就该返回了\n            } else {\n                out.add(new DefaultHttpContent(content));\n            }\n            return;\n        }\n        /**\n         * everything else after this point takes care of reading chunked content. basically, read chunk size,\n         * read chunk, read and ignore the CRLF and repeat until 0\n         */\n        case READ_CHUNK_SIZE: try {//read_chunk_size\n            AppendableCharSequence line = lineParser.parse(buffer);\n            if (line == null) {\n                return;\n            }\n            int chunkSize = getChunkSize(line.toString());\n            this.chunkSize = chunkSize;\n            if (chunkSize == 0) {\n                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer\n                return;\n            }\n            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content\n            // fall-through\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case READ_CHUNKED_CONTENT: { //read_chunked_content\n            assert chunkSize <= Integer.MAX_VALUE;\n            int toRead = Math.min((int) chunkSize, maxChunkSize);\n            toRead = Math.min(toRead, buffer.readableBytes());\n            if (toRead == 0) {\n                return;\n            }\n            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));\n            chunkSize -= toRead;\n            out.add(chunk);\n            if (chunkSize != 0) {\n                return;\n            }\n            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter\n            // fall-through\n        }\n        case READ_CHUNK_DELIMITER: {//read_chunked_delimiter\n            final int wIdx = buffer.writerIndex();\n            int rIdx = buffer.readerIndex();\n            while (wIdx > rIdx) {\n                byte next = buffer.getByte(rIdx++);\n                if (next == HttpConstants.LF) {\n                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size\n                    break;\n                }\n            }\n            buffer.readerIndex(rIdx);\n            return;\n        }\n        case READ_CHUNK_FOOTER: try {//read_chunked_foooter\n            LastHttpContent trailer = readTrailingHeaders(buffer);\n            if (trailer == null) {\n                return;\n            }\n            out.add(trailer);\n            resetNow();\n            return;\n        } catch (Exception e) {\n            out.add(invalidChunk(buffer, e));\n            return;\n        }\n        case BAD_MESSAGE: {  //bad_message\n            // Keep discarding until disconnection.\n            buffer.skipBytes(buffer.readableBytes());\n            break;\n        }\n        case UPGRADED: {//upgraded\n            int readableBytes = buffer.readableBytes();\n            if (readableBytes > 0) {\n                // Keep on consuming as otherwise we may trigger an DecoderException,\n                // other handler will replace this codec with the upgraded protocol codec to\n                // take the traffic over at some point then.\n                // See https://github.com/netty/netty/issues/2173\n                out.add(buffer.readBytes(readableBytes));\n            }\n            break;\n        }\n        }\n    }\n```\n注意这里的case并没有break, decode主要做了如下逻辑:\n1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。\n```\nprivate static boolean skipControlCharacters(ByteBuf buffer) {\n        boolean skiped = false;\n        final int wIdx = buffer.writerIndex();\n        int rIdx = buffer.readerIndex();\n        while (wIdx > rIdx) {\n            int c = buffer.getUnsignedByte(rIdx++);\n            if (!Character.isISOControl(c) && !Character.isWhitespace(c)) {//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等\n                rIdx--;\n                skiped = true;\n                break;\n            }\n        }\n        buffer.readerIndex(rIdx);\n        return skiped;\n    }\n```\n首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。\n2) 读取INITIAL部分\n从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:`GET /_cat/indices HTTP/1.1`, 创建对象:DefaultHttpRequest, 其中\n```\nhttpVersion: HTTP/1.1\nmethod: GET\nuri: /_cat/indices\n```\n这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。\n3) 读取Headers部分\n```\nprivate State readHeaders(ByteBuf buffer) {\n        final HttpMessage message = this.message;  //DefaultHttpRequest\n        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders\n        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while{}为循环\n        if (line == null) {\n            return null;\n        }\n        if (line.length() > 0) {\n            do { //这是个while循环，以换行符来进行分割\n                char firstChar = line.charAt(0);\n                if (name != null && (firstChar == ' ' || firstChar == '\\t')) {\n                    String trimmedLine = line.toString().trim();\n                    String valueStr = String.valueOf(value);\n                    value = valueStr + ' ' + trimmedLine;\n                } else {\n                    if (name != null) {\n                        headers.add(name, value);\n                    }\n                    splitHeader(line);\n                }\n                line = headerParser.parse(buffer);   //\n                if (line == null) {\n                    return null;\n                }\n            } while (line.length() > 0);\n        }\n\n        // Add the last header.\n        if (name != null) {   //解析出最后一个header\n            headers.add(name, value);\n        }\n        // reset name and value fields\n        name = null;\n        value = null;\n\n        State nextState;\n\n        if (isContentAlwaysEmpty(message)) {  //header是否为空\n            HttpUtil.setTransferEncodingChunked(message, false);\n            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始\n        } else if (HttpUtil.isTransferEncodingChunked(message)) { // 是否包含 transfer-encoding: chunked\n            nextState = State.READ_CHUNK_SIZE;\n        } else if (contentLength() >= 0) {   //Content-Length: 80\n            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值\n        } else { //没有Content-Length和chunked相关的，就是读取变量类型长度\n            nextState = State.READ_VARIABLE_LENGTH_CONTENT;\n        }\n        return nextState;\n        }\n```\n主要做的事:\n+ 读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:\n```\n\"Accept\" -> \"*/*\"\n\"User-Agent\" -> \"curl/7/43/0\"\n\"Host\" -> \"127.0.0.1:9200\"\n\"Content-Length\" -> \"66735\"\n\"Content-Encoding\" -> \"gzip\"\n\"Content-Type\" -> \"application/x-www-form-urlencoded\"\n\"Expect\" -> \"100-continue\"\n\"null\" -> \"null\"\n```\n我们需要了解一个参数:Expect: 100-continue\n\n> <a href=\"https://blog.csdn.net/MitKey/article/details/52042537\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。<p>客户端策略:\n如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}\n如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。\n并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。\n有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。<p>服务端策略:\n正确情况下，收到请求后，返回 100 或错误码。\n如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。\n\n这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度>=1025时, 客户端发送的header里面才会有这个参数。\n+ 如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。\n这里会设置状态为READ_FIXED_LENGTH_CONTENT\n4)  读取内容\n因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<Math.min(readableLength, maxChunkSize), 每读取maxChunkSize长度的值就向后传递, 同时修改chunkSize的值。读取第二个chunked的动作在MessageToMessageDecoder中发出(该content的readableBytes>0)。\n这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。\n# HttpObjectAggregator和 MessageAggregator\nHttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。\nMessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:\n```\n    protected void decode(final ChannelHandlerContext ctx, I msg, List<Object> out) throws Exception {\n        if (isStartMessage(msg)) {//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行\n            handlingOversizedMessage = false;\n            if (currentMessage != null) {\n                currentMessage.release();\n                currentMessage = null;\n                throw new MessageAggregationException();\n            }\n            @SuppressWarnings(\"unchecked\")\n            S m = (S) msg; //DefaultHttpRequest\n            // Send the continue response if necessary (e.g. 'Expect: 100-continue' header)\n            // Check before content length. Failing an expectation may result in a different response being sent.\n            Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse\n            if (continueResponse != null) { //向客户端返回100-continue, 告诉客户端可以发送content了\n                // Cache the write listener for reuse.\n                ChannelFutureListener listener = continueResponseWriteListener;\n                if (listener == null) {\n                    continueResponseWriteListener = listener = new ChannelFutureListener() {\n                        @Override\n                        public void operationComplete(ChannelFuture future) throws Exception {\n                            if (!future.isSuccess()) {\n                                ctx.fireExceptionCaught(future.cause());\n                            }\n                        }\n                    };\n                }\n                // Make sure to call this before writing, otherwise reference counts may be invalid.\n                boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);\n                handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);\n\n                final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);\n\n                if (closeAfterWrite) {\n                    future.addListener(ChannelFutureListener.CLOSE);\n                    return;\n                }\n                if (handlingOversizedMessage) {\n                    return;\n                }\n            } else if (isContentLengthInvalid(m, maxContentLength)) { //检查length是否有效，\n                // if content length is set, preemptively close if it's too large\n                invokeHandleOversizedMessage(ctx, m);\n                return;\n            }\n\n            if (m instanceof DecoderResultProvider && !((DecoderResultProvider) m).decoderResult().isSuccess()) {\n                O aggregated;\n                if (m instanceof ByteBufHolder && ((ByteBufHolder) m).content().isReadable()) {\n                    aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());\n                } else {\n                    aggregated = beginAggregation(m, EMPTY_BUFFER);\n                }\n                finishAggregation(aggregated);\n                out.add(aggregated);\n                return;\n            }\n             //同时生成好Compent\n            // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.\n            CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可\n            if (m instanceof ByteBufHolder) {\n                appendPartialContent(content, ((ByteBufHolder) m).content());\n            }\n            currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest\n        } else if (isContentMessage(msg)) { //解析内容部分\n            if (currentMessage == null) {\n                // it is possible that a TooLongFrameException was already thrown but we can still discard data\n                // until the begging of the next request/response.\n                return;\n            }\n\n            // Merge the received chunk into the content of the current message.\n            CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();\n\n            @SuppressWarnings(\"unchecked\")\n            final C m = (C) msg; //可能是DefaultLastHttpContent\n            // Handle oversized message.\n            if (content.readableBytes() > maxContentLength - m.content().readableBytes()) {\n                // By convention, full message type extends first message type.\n                @SuppressWarnings(\"unchecked\")\n                S s = (S) currentMessage;\n                invokeHandleOversizedMessage(ctx, s);\n                return;\n            }\n            // Append the content of the chunk.\n            appendPartialContent(content, m.content()); //把产生的数据添加到末尾\n            //\n            // Give the subtypes a chance to merge additional information such as trailing headers.\n            aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest\n\n            final boolean last;\n            if (m instanceof DecoderResultProvider) {\n                DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();\n                if (!decoderResult.isSuccess()) {\n                    if (currentMessage instanceof DecoderResultProvider) {\n                        ((DecoderResultProvider) currentMessage).setDecoderResult(\n                                DecoderResult.failure(decoderResult.cause()));\n                    }\n                    last = true;\n                } else {\n                    last = isLastContentMessage(m);\n                }\n            } else {\n                last = isLastContentMessage(m);\n            }\n\n            if (last) {  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，\n                finishAggregation(currentMessage);\n\n                // All done\n                out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。\n                currentMessage = null;\n            }\n        } else {\n            throw new MessageAggregationException();\n        }\n    }\n```\ndecode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。\n1) 若请求是HttpRequest\n说明该部分是request最开始的那一部分。\n+ 首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。\n+ 生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。\n需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性`List<Component> components`构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。\n\n2) 若请求是HttpContent部分\n+ 将content添加进CompositeByteBuf中\n通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:\n```\n     private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) {\n            .....\n            if (cIndex == components.size()) {\n                wasAdded = components.add(c);\n                if (cIndex == 0) {\n                    c.endOffset = readableBytes;\n                } else {\n                    Component prev = components.get(cIndex - 1);\n                    c.offset = prev.endOffset;\n                    c.endOffset = c.offset + readableBytes;\n                }\n            }\n            .....\n            if (increaseWriterIndex) {\n                writerIndex(writerIndex() + buffer.readableBytes());\n            }\n            return cIndex;\n        }\n    }\n```\n每个Component结构如下:\n```\n        ByteBuf buf;  //该Component实际存储\n        final int length;\n        int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。\n        int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。\n```\n在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。\n\n+ 等待所有的content发送过来\n1. 轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。\n2. 直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。\n\n至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\" />\n# 附\n如何将Composite转换为一个连续的堆内buf呢?\n通过Unpooled.copiedBuffer(request.content())方法即可。\n","slug":"Netty-Http通信解码源码阅读","published":1,"updated":"2018-05-13T14:21:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadwb0007miu50hm74z0r","content":"<p>首先给出一个http server pipiLine里面的处理器的组成结构的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void initChannel(Channel ch) throws Exception &#123;</div><div class=\"line\">    final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);</div><div class=\"line\">    decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个</div><div class=\"line\">    ch.pipeline().addLast(&quot;decoder&quot;, decoder);</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder&quot;, new HttpResponseEncoder());</div><div class=\"line\">    final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));</div><div class=\"line\">    ch.pipeline().addLast(&quot;aggregator&quot;, aggregator);  //包的聚合</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder_compress&quot;, new HttpContentCompressor(transport.compressionLevel));</div><div class=\"line\">    ch.pipeline().addLast(&quot;pipelining&quot;, new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));</div><div class=\"line\">    ch.pipeline().addLast(&quot;handler&quot;, requestHandler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。<br>http处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。<br>这里有一个问题:<br><code>为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?</code></p>\n<h1 id=\"HttpObjectDecoder和HttpRequestDecoder\"><a href=\"#HttpObjectDecoder和HttpRequestDecoder\" class=\"headerlink\" title=\"HttpObjectDecoder和HttpRequestDecoder\"></a>HttpObjectDecoder和HttpRequestDecoder</h1><p>首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:</p>\n<ul>\n<li>HttpRequest: 主要存放inital, head等。</li>\n<li>HttpContent: 传输的数据部分<br>HttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成<code>HttpRequest</code>,实际就是将<code>ChannelBuffer</code>转变为多个<code>HttpChunk</code>对象。<br>HttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。<br>HttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。<br>decode函数实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        if (resetRequested) &#123;</div><div class=\"line\">            resetNow();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        switch (currentState) &#123; //没有break</div><div class=\"line\">        case SKIP_CONTROL_CHARS: &#123; //skip_control_chars</div><div class=\"line\">            if (!skipControlCharacters(buffer)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_INITIAL;   //read_initail</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_INITIAL: try &#123;  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String[] initialLine = splitInitialLine(line); //&#123;Method, URL, HTTPVersion</div><div class=\"line\">            if (initialLine.length &lt; 3) &#123; //无效的请求， 忽略。</div><div class=\"line\">                // Invalid initial line - ignore.</div><div class=\"line\">                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            message = createMessage(initialLine);  //DefaultHttpRequest</div><div class=\"line\">            currentState = State.READ_HEADER;  //read_header</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_HEADER: try &#123;    //read_header</div><div class=\"line\">            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式</div><div class=\"line\">            if (nextState == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = nextState;</div><div class=\"line\">            switch (nextState) &#123;</div><div class=\"line\">            case SKIP_CONTROL_CHARS:   //skip_control_char</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content</div><div class=\"line\">                resetNow();</div><div class=\"line\">                return;</div><div class=\"line\">            case READ_CHUNK_SIZE: //read_chunk_size</div><div class=\"line\">                if (!chunkedSupported) &#123;</div><div class=\"line\">                    throw new IllegalArgumentException(&quot;Chunked messages not supported&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                return;</div><div class=\"line\">            default:  //或者读取变量类型长度或者定长</div><div class=\"line\">                long contentLength = contentLength();//没有长度相关变量就是-1</div><div class=\"line\">                if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) &#123;</div><div class=\"line\">                    out.add(message);</div><div class=\"line\">                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content</div><div class=\"line\">                    resetNow();</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content</div><div class=\"line\">                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content</div><div class=\"line\">                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分</div><div class=\"line\">                if (nextState == State.READ_FIXED_LENGTH_CONTENT) &#123;  //read_fixed_lengt_content</div><div class=\"line\">                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.</div><div class=\"line\">                    chunkSize = contentLength; // 注意这两个直接赋值一样</div><div class=\"line\">                &#125;</div><div class=\"line\">                // We return here, this forces decode to be called again where we will decode the content</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_VARIABLE_LENGTH_CONTENT: &#123;  //read_variable_length_content</div><div class=\"line\">            // Keep reading data as a chunk until the end of connection is reached.</div><div class=\"line\">            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);</div><div class=\"line\">            if (toRead &gt; 0) &#123;</div><div class=\"line\">                ByteBuf content = buffer.readRetainedSlice(toRead);</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_FIXED_LENGTH_CONTENT: &#123;  //read_fixed_length_content</div><div class=\"line\">            int readLimit = buffer.readableBytes();</div><div class=\"line\">            // Check if the buffer is readable first as we use the readable byte count</div><div class=\"line\">            // to create the HttpChunk. This is needed as otherwise we may end up with</div><div class=\"line\">            // create a HttpChunk instance that contains an empty buffer and so is</div><div class=\"line\">            // handled like it is the last HttpChunk.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/433</div><div class=\"line\">            if (readLimit == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int toRead = Math.min(readLimit, maxChunkSize);</div><div class=\"line\">            if (toRead &gt; chunkSize) &#123;</div><div class=\"line\">                toRead = (int) chunkSize;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面</div><div class=\"line\">            chunkSize -= toRead; //content = PooledSlicedByteBuf</div><div class=\"line\">            if (chunkSize == 0) &#123;  //要是定长的话，就直接content就是DefaultLastHttpContent，</div><div class=\"line\">                // Read all content.</div><div class=\"line\">                out.add(new DefaultLastHttpContent(content, validateHeaders));</div><div class=\"line\">                resetNow(); //解析完了就该返回了</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        /**</div><div class=\"line\">         * everything else after this point takes care of reading chunked content. basically, read chunk size,</div><div class=\"line\">         * read chunk, read and ignore the CRLF and repeat until 0</div><div class=\"line\">         */</div><div class=\"line\">        case READ_CHUNK_SIZE: try &#123;//read_chunk_size</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer);</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int chunkSize = getChunkSize(line.toString());</div><div class=\"line\">            this.chunkSize = chunkSize;</div><div class=\"line\">            if (chunkSize == 0) &#123;</div><div class=\"line\">                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNKED_CONTENT: &#123; //read_chunked_content</div><div class=\"line\">            assert chunkSize &lt;= Integer.MAX_VALUE;</div><div class=\"line\">            int toRead = Math.min((int) chunkSize, maxChunkSize);</div><div class=\"line\">            toRead = Math.min(toRead, buffer.readableBytes());</div><div class=\"line\">            if (toRead == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));</div><div class=\"line\">            chunkSize -= toRead;</div><div class=\"line\">            out.add(chunk);</div><div class=\"line\">            if (chunkSize != 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_DELIMITER: &#123;//read_chunked_delimiter</div><div class=\"line\">            final int wIdx = buffer.writerIndex();</div><div class=\"line\">            int rIdx = buffer.readerIndex();</div><div class=\"line\">            while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">                byte next = buffer.getByte(rIdx++);</div><div class=\"line\">                if (next == HttpConstants.LF) &#123;</div><div class=\"line\">                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            buffer.readerIndex(rIdx);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_FOOTER: try &#123;//read_chunked_foooter</div><div class=\"line\">            LastHttpContent trailer = readTrailingHeaders(buffer);</div><div class=\"line\">            if (trailer == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.add(trailer);</div><div class=\"line\">            resetNow();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case BAD_MESSAGE: &#123;  //bad_message</div><div class=\"line\">            // Keep discarding until disconnection.</div><div class=\"line\">            buffer.skipBytes(buffer.readableBytes());</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case UPGRADED: &#123;//upgraded</div><div class=\"line\">            int readableBytes = buffer.readableBytes();</div><div class=\"line\">            if (readableBytes &gt; 0) &#123;</div><div class=\"line\">                // Keep on consuming as otherwise we may trigger an DecoderException,</div><div class=\"line\">                // other handler will replace this codec with the upgraded protocol codec to</div><div class=\"line\">                // take the traffic over at some point then.</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2173</div><div class=\"line\">                out.add(buffer.readBytes(readableBytes));</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意这里的case并没有break, decode主要做了如下逻辑:<br>1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean skipControlCharacters(ByteBuf buffer) &#123;</div><div class=\"line\">        boolean skiped = false;</div><div class=\"line\">        final int wIdx = buffer.writerIndex();</div><div class=\"line\">        int rIdx = buffer.readerIndex();</div><div class=\"line\">        while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">            int c = buffer.getUnsignedByte(rIdx++);</div><div class=\"line\">            if (!Character.isISOControl(c) &amp;&amp; !Character.isWhitespace(c)) &#123;//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等</div><div class=\"line\">                rIdx--;</div><div class=\"line\">                skiped = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        buffer.readerIndex(rIdx);</div><div class=\"line\">        return skiped;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。<br>2) 读取INITIAL部分<br>从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:<code>GET /_cat/indices HTTP/1.1</code>, 创建对象:DefaultHttpRequest, 其中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpVersion: HTTP/1.1</div><div class=\"line\">method: GET</div><div class=\"line\">uri: /_cat/indices</div></pre></td></tr></table></figure></p>\n<p>这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。<br>3) 读取Headers部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">private State readHeaders(ByteBuf buffer) &#123;</div><div class=\"line\">        final HttpMessage message = this.message;  //DefaultHttpRequest</div><div class=\"line\">        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders</div><div class=\"line\">        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while&#123;&#125;为循环</div><div class=\"line\">        if (line == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (line.length() &gt; 0) &#123;</div><div class=\"line\">            do &#123; //这是个while循环，以换行符来进行分割</div><div class=\"line\">                char firstChar = line.charAt(0);</div><div class=\"line\">                if (name != null &amp;&amp; (firstChar == &apos; &apos; || firstChar == &apos;\\t&apos;)) &#123;</div><div class=\"line\">                    String trimmedLine = line.toString().trim();</div><div class=\"line\">                    String valueStr = String.valueOf(value);</div><div class=\"line\">                    value = valueStr + &apos; &apos; + trimmedLine;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (name != null) &#123;</div><div class=\"line\">                        headers.add(name, value);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    splitHeader(line);</div><div class=\"line\">                &#125;</div><div class=\"line\">                line = headerParser.parse(buffer);   //</div><div class=\"line\">                if (line == null) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; while (line.length() &gt; 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Add the last header.</div><div class=\"line\">        if (name != null) &#123;   //解析出最后一个header</div><div class=\"line\">            headers.add(name, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        // reset name and value fields</div><div class=\"line\">        name = null;</div><div class=\"line\">        value = null;</div><div class=\"line\"></div><div class=\"line\">        State nextState;</div><div class=\"line\"></div><div class=\"line\">        if (isContentAlwaysEmpty(message)) &#123;  //header是否为空</div><div class=\"line\">            HttpUtil.setTransferEncodingChunked(message, false);</div><div class=\"line\">            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始</div><div class=\"line\">        &#125; else if (HttpUtil.isTransferEncodingChunked(message)) &#123; // 是否包含 transfer-encoding: chunked</div><div class=\"line\">            nextState = State.READ_CHUNK_SIZE;</div><div class=\"line\">        &#125; else if (contentLength() &gt;= 0) &#123;   //Content-Length: 80</div><div class=\"line\">            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值</div><div class=\"line\">        &#125; else &#123; //没有Content-Length和chunked相关的，就是读取变量类型长度</div><div class=\"line\">            nextState = State.READ_VARIABLE_LENGTH_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return nextState;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;Accept&quot; -&gt; &quot;*/*&quot;</div><div class=\"line\">&quot;User-Agent&quot; -&gt; &quot;curl/7/43/0&quot;</div><div class=\"line\">&quot;Host&quot; -&gt; &quot;127.0.0.1:9200&quot;</div><div class=\"line\">&quot;Content-Length&quot; -&gt; &quot;66735&quot;</div><div class=\"line\">&quot;Content-Encoding&quot; -&gt; &quot;gzip&quot;</div><div class=\"line\">&quot;Content-Type&quot; -&gt; &quot;application/x-www-form-urlencoded&quot;</div><div class=\"line\">&quot;Expect&quot; -&gt; &quot;100-continue&quot;</div><div class=\"line\">&quot;null&quot; -&gt; &quot;null&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们需要了解一个参数:Expect: 100-continue</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/MitKey/article/details/52042537\" target=\"_blank\" rel=\"external\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。</p><p>客户端策略:<br>如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}<br>如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。<br>并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。<br>有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。</p><p>服务端策略:<br>正确情况下，收到请求后，返回 100 或错误码。<br>如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。</p>\n</blockquote>\n<p>这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度&gt;=1025时, 客户端发送的header里面才会有这个参数。</p>\n<ul>\n<li>如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。<br>这里会设置状态为READ_FIXED_LENGTH_CONTENT<br>4)  读取内容<br>因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<math.min(readablelength, maxchunksize),=\"\" 每读取maxchunksize长度的值就向后传递,=\"\" 同时修改chunksize的值。读取第二个chunked的动作在messagetomessagedecoder中发出(该content的readablebytes=\"\">0)。<br>这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。<h1 id=\"HttpObjectAggregator和-MessageAggregator\"><a href=\"#HttpObjectAggregator和-MessageAggregator\" class=\"headerlink\" title=\"HttpObjectAggregator和 MessageAggregator\"></a>HttpObjectAggregator和 MessageAggregator</h1>HttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。<br>MessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">    if (isStartMessage(msg)) &#123;//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行</div><div class=\"line\">        handlingOversizedMessage = false;</div><div class=\"line\">        if (currentMessage != null) &#123;</div><div class=\"line\">            currentMessage.release();</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">            throw new MessageAggregationException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        S m = (S) msg; //DefaultHttpRequest</div><div class=\"line\">        // Send the continue response if necessary (e.g. &apos;Expect: 100-continue&apos; header)</div><div class=\"line\">        // Check before content length. Failing an expectation may result in a different response being sent.</div><div class=\"line\">        Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse</div><div class=\"line\">        if (continueResponse != null) &#123; //向客户端返回100-continue, 告诉客户端可以发送content了</div><div class=\"line\">            // Cache the write listener for reuse.</div><div class=\"line\">            ChannelFutureListener listener = continueResponseWriteListener;</div><div class=\"line\">            if (listener == null) &#123;</div><div class=\"line\">                continueResponseWriteListener = listener = new ChannelFutureListener() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                        if (!future.isSuccess()) &#123;</div><div class=\"line\">                            ctx.fireExceptionCaught(future.cause());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Make sure to call this before writing, otherwise reference counts may be invalid.</div><div class=\"line\">            boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);</div><div class=\"line\">            handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);</div><div class=\"line\"></div><div class=\"line\">            final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);</div><div class=\"line\"></div><div class=\"line\">            if (closeAfterWrite) &#123;</div><div class=\"line\">                future.addListener(ChannelFutureListener.CLOSE);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (handlingOversizedMessage) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; //检查length是否有效，</div><div class=\"line\">            // if content length is set, preemptively close if it&apos;s too large</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, m);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123;</div><div class=\"line\">            O aggregated;</div><div class=\"line\">            if (m instanceof ByteBufHolder &amp;&amp; ((ByteBufHolder) m).content().isReadable()) &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\">            finishAggregation(aggregated);</div><div class=\"line\">            out.add(aggregated);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //同时生成好Compent</div><div class=\"line\">        // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.</div><div class=\"line\">        CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可</div><div class=\"line\">        if (m instanceof ByteBufHolder) &#123;</div><div class=\"line\">            appendPartialContent(content, ((ByteBufHolder) m).content());</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest</div><div class=\"line\">    &#125; else if (isContentMessage(msg)) &#123; //解析内容部分</div><div class=\"line\">        if (currentMessage == null) &#123;</div><div class=\"line\">            // it is possible that a TooLongFrameException was already thrown but we can still discard data</div><div class=\"line\">            // until the begging of the next request/response.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Merge the received chunk into the content of the current message.</div><div class=\"line\">        CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();</div><div class=\"line\"></div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        final C m = (C) msg; //可能是DefaultLastHttpContent</div><div class=\"line\">        // Handle oversized message.</div><div class=\"line\">        if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123;</div><div class=\"line\">            // By convention, full message type extends first message type.</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            S s = (S) currentMessage;</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, s);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // Append the content of the chunk.</div><div class=\"line\">        appendPartialContent(content, m.content()); //把产生的数据添加到末尾</div><div class=\"line\">        //</div><div class=\"line\">        // Give the subtypes a chance to merge additional information such as trailing headers.</div><div class=\"line\">        aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest</div><div class=\"line\"></div><div class=\"line\">        final boolean last;</div><div class=\"line\">        if (m instanceof DecoderResultProvider) &#123;</div><div class=\"line\">            DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();</div><div class=\"line\">            if (!decoderResult.isSuccess()) &#123;</div><div class=\"line\">                if (currentMessage instanceof DecoderResultProvider) &#123;</div><div class=\"line\">                    ((DecoderResultProvider) currentMessage).setDecoderResult(</div><div class=\"line\">                            DecoderResult.failure(decoderResult.cause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">                last = true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                last = isLastContentMessage(m);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            last = isLastContentMessage(m);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (last) &#123;  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，</div><div class=\"line\">            finishAggregation(currentMessage);</div><div class=\"line\"></div><div class=\"line\">            // All done</div><div class=\"line\">            out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new MessageAggregationException();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</math.min(readablelength,></li>\n</ul>\n<p>decode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。<br>1) 若请求是HttpRequest<br>说明该部分是request最开始的那一部分。</p>\n<ul>\n<li>首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。</li>\n<li>生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。<br>需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性<code>List&lt;Component&gt; components</code>构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。</li>\n</ul>\n<p>2) 若请求是HttpContent部分</p>\n<ul>\n<li>将content添加进CompositeByteBuf中<br>通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) &#123;</div><div class=\"line\">        .....</div><div class=\"line\">        if (cIndex == components.size()) &#123;</div><div class=\"line\">            wasAdded = components.add(c);</div><div class=\"line\">            if (cIndex == 0) &#123;</div><div class=\"line\">                c.endOffset = readableBytes;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Component prev = components.get(cIndex - 1);</div><div class=\"line\">                c.offset = prev.endOffset;</div><div class=\"line\">                c.endOffset = c.offset + readableBytes;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .....</div><div class=\"line\">        if (increaseWriterIndex) &#123;</div><div class=\"line\">            writerIndex(writerIndex() + buffer.readableBytes());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个Component结构如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf buf;  //该Component实际存储</div><div class=\"line\">final int length;</div><div class=\"line\">int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。</div><div class=\"line\">int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。</div></pre></td></tr></table></figure></p>\n<p>在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。</p>\n<ul>\n<li>等待所有的content发送过来</li>\n</ul>\n<ol>\n<li>轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。</li>\n<li>直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。</li>\n</ol>\n<p>至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\"></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>如何将Composite转换为一个连续的堆内buf呢?<br>通过Unpooled.copiedBuffer(request.content())方法即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>首先给出一个http server pipiLine里面的处理器的组成结构的示例:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void initChannel(Channel ch) throws Exception &#123;</div><div class=\"line\">    final HttpRequestDecoder decoder = new HttpRequestDecoder(4096, 8192, 8192);</div><div class=\"line\">    decoder.setCumulator(ByteToMessageDecoder.COMPOSITE_CUMULATOR);  //默认是另一个</div><div class=\"line\">    ch.pipeline().addLast(&quot;decoder&quot;, decoder);</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder&quot;, new HttpResponseEncoder());</div><div class=\"line\">    final HttpObjectAggregator aggregator = new HttpObjectAggregator(Math.toIntExact(transport.maxContentLength.getBytes()));</div><div class=\"line\">    ch.pipeline().addLast(&quot;aggregator&quot;, aggregator);  //包的聚合</div><div class=\"line\">    ch.pipeline().addLast(&quot;encoder_compress&quot;, new HttpContentCompressor(transport.compressionLevel));</div><div class=\"line\">    ch.pipeline().addLast(&quot;pipelining&quot;, new HttpPipeliningHandler(transport.logger, transport.pipeliningMaxEvents));</div><div class=\"line\">    ch.pipeline().addLast(&quot;handler&quot;, requestHandler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中只有HttpRequestDecoder属于ByteToMessageDecoder类型, 主要作用是从byte中拼接处每一个帧, 其余处理器大部分是根据自定义的语义对这个帧转化, 本文将以示例中的重要的handler为处理器, 以POST请求解析过程为串分析下去。<br>http处理方式是每次将缓冲池放满(默认65536个), 然后将65536个字符按照虚拟的chunk分片(默认一个HttpChunk 8192个字符),通过handler, 最后在HttpObjectAggregator聚合, 然后发向后面。<br>这里有一个问题:<br><code>为什么不将65536个字符一下发送到最终handler, 而需要先分解成虚拟的chunked, 一个一个发送到后面再聚合起来?</code></p>\n<h1 id=\"HttpObjectDecoder和HttpRequestDecoder\"><a href=\"#HttpObjectDecoder和HttpRequestDecoder\" class=\"headerlink\" title=\"HttpObjectDecoder和HttpRequestDecoder\"></a>HttpObjectDecoder和HttpRequestDecoder</h1><p>首先需要知道, Rquest请求由FullHttpRequest构成, 主要分为两部分:</p>\n<ul>\n<li>HttpRequest: 主要存放inital, head等。</li>\n<li>HttpContent: 传输的数据部分<br>HttpRequestDecoder类继承自HttpObjectDecoder, 主要实现了decode函数, 主要负责把数据流解析成<code>HttpRequest</code>,实际就是将<code>ChannelBuffer</code>转变为多个<code>HttpChunk</code>对象。<br>HttpObjectDecoder继承自ByteToMessageDecoder类, 这个类是不是很熟悉, 详见<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/03/25/Netty%E9%80%9A%E4%BF%A1%E7%BC%96%E8%A7%A3%E7%A0%81%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/\">Netty通信编解码源码解读</a>。<br>HttpObjectDecoder主要根据当前保存的状态位currentState(不要被定义的状态位吓到, 根据名称就能大致了解其作用)来决定即将完成的动作, 默认初始值为:State.SKIP_CONTROL_CHARS。<br>decode函数实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div><div class=\"line\">168</div><div class=\"line\">169</div><div class=\"line\">170</div><div class=\"line\">171</div><div class=\"line\">172</div><div class=\"line\">173</div><div class=\"line\">174</div><div class=\"line\">175</div><div class=\"line\">176</div><div class=\"line\">177</div><div class=\"line\">178</div><div class=\"line\">179</div><div class=\"line\">180</div><div class=\"line\">181</div><div class=\"line\">182</div><div class=\"line\">183</div><div class=\"line\">184</div><div class=\"line\">185</div><div class=\"line\">186</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">        if (resetRequested) &#123;</div><div class=\"line\">            resetNow();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        switch (currentState) &#123; //没有break</div><div class=\"line\">        case SKIP_CONTROL_CHARS: &#123; //skip_control_chars</div><div class=\"line\">            if (!skipControlCharacters(buffer)) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_INITIAL;   //read_initail</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_INITIAL: try &#123;  //read_initial   请求换行符(line)  比如解析出来GET /_cat/indices HTTP/1.1</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer); //lineParser: LineParser继承自HeaderParser，调用的还是HeaderParser.parse</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            String[] initialLine = splitInitialLine(line); //&#123;Method, URL, HTTPVersion</div><div class=\"line\">            if (initialLine.length &lt; 3) &#123; //无效的请求， 忽略。</div><div class=\"line\">                // Invalid initial line - ignore.</div><div class=\"line\">                currentState = State.SKIP_CONTROL_CHARS;  //skip_control_chars</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            message = createMessage(initialLine);  //DefaultHttpRequest</div><div class=\"line\">            currentState = State.READ_HEADER;  //read_header</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_HEADER: try &#123;    //read_header</div><div class=\"line\">            State nextState = readHeaders(buffer); //读取完header部分，同时根据header部分修改了nextState的值，告诉了读取content的方式</div><div class=\"line\">            if (nextState == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = nextState;</div><div class=\"line\">            switch (nextState) &#123;</div><div class=\"line\">            case SKIP_CONTROL_CHARS:   //skip_control_char</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //empty_last_content</div><div class=\"line\">                resetNow();</div><div class=\"line\">                return;</div><div class=\"line\">            case READ_CHUNK_SIZE: //read_chunk_size</div><div class=\"line\">                if (!chunkedSupported) &#123;</div><div class=\"line\">                    throw new IllegalArgumentException(&quot;Chunked messages not supported&quot;);</div><div class=\"line\">                &#125;</div><div class=\"line\">                // Chunked encoding - generate HttpMessage first.  HttpChunks will follow.</div><div class=\"line\">                out.add(message);</div><div class=\"line\">                return;</div><div class=\"line\">            default:  //或者读取变量类型长度或者定长</div><div class=\"line\">                long contentLength = contentLength();//没有长度相关变量就是-1</div><div class=\"line\">                if (contentLength == 0 || contentLength == -1 &amp;&amp; isDecodingRequest()) &#123;</div><div class=\"line\">                    out.add(message);</div><div class=\"line\">                    out.add(LastHttpContent.EMPTY_LAST_CONTENT);  //enpty_last_content</div><div class=\"line\">                    resetNow();</div><div class=\"line\">                    return;</div><div class=\"line\">                &#125;</div><div class=\"line\">                assert nextState == State.READ_FIXED_LENGTH_CONTENT ||  //read_fixed_length_content</div><div class=\"line\">                        nextState == State.READ_VARIABLE_LENGTH_CONTENT; //read_variable_length_content</div><div class=\"line\">                out.add(message); //目前message=DefaultHttpRequest, 放进去了line和header部分</div><div class=\"line\">                if (nextState == State.READ_FIXED_LENGTH_CONTENT) &#123;  //read_fixed_lengt_content</div><div class=\"line\">                    // chunkSize will be decreased as the READ_FIXED_LENGTH_CONTENT state reads data chunk by chunk.</div><div class=\"line\">                    chunkSize = contentLength; // 注意这两个直接赋值一样</div><div class=\"line\">                &#125;</div><div class=\"line\">                // We return here, this forces decode to be called again where we will decode the content</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidMessage(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_VARIABLE_LENGTH_CONTENT: &#123;  //read_variable_length_content</div><div class=\"line\">            // Keep reading data as a chunk until the end of connection is reached.</div><div class=\"line\">            int toRead = Math.min(buffer.readableBytes(), maxChunkSize);</div><div class=\"line\">            if (toRead &gt; 0) &#123;</div><div class=\"line\">                ByteBuf content = buffer.readRetainedSlice(toRead);</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_FIXED_LENGTH_CONTENT: &#123;  //read_fixed_length_content</div><div class=\"line\">            int readLimit = buffer.readableBytes();</div><div class=\"line\">            // Check if the buffer is readable first as we use the readable byte count</div><div class=\"line\">            // to create the HttpChunk. This is needed as otherwise we may end up with</div><div class=\"line\">            // create a HttpChunk instance that contains an empty buffer and so is</div><div class=\"line\">            // handled like it is the last HttpChunk.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/433</div><div class=\"line\">            if (readLimit == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int toRead = Math.min(readLimit, maxChunkSize);</div><div class=\"line\">            if (toRead &gt; chunkSize) &#123;</div><div class=\"line\">                toRead = (int) chunkSize;</div><div class=\"line\">            &#125;</div><div class=\"line\">            ByteBuf content = buffer.readRetainedSlice(toRead);  //buffer = PooledUnsafeDirectByteBuf, 实际会跑到AbstractByteBuf.readRetainedSlice()里面</div><div class=\"line\">            chunkSize -= toRead; //content = PooledSlicedByteBuf</div><div class=\"line\">            if (chunkSize == 0) &#123;  //要是定长的话，就直接content就是DefaultLastHttpContent，</div><div class=\"line\">                // Read all content.</div><div class=\"line\">                out.add(new DefaultLastHttpContent(content, validateHeaders));</div><div class=\"line\">                resetNow(); //解析完了就该返回了</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                out.add(new DefaultHttpContent(content));</div><div class=\"line\">            &#125;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        /**</div><div class=\"line\">         * everything else after this point takes care of reading chunked content. basically, read chunk size,</div><div class=\"line\">         * read chunk, read and ignore the CRLF and repeat until 0</div><div class=\"line\">         */</div><div class=\"line\">        case READ_CHUNK_SIZE: try &#123;//read_chunk_size</div><div class=\"line\">            AppendableCharSequence line = lineParser.parse(buffer);</div><div class=\"line\">            if (line == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            int chunkSize = getChunkSize(line.toString());</div><div class=\"line\">            this.chunkSize = chunkSize;</div><div class=\"line\">            if (chunkSize == 0) &#123;</div><div class=\"line\">                currentState = State.READ_CHUNK_FOOTER;//read_chunk_footer</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNKED_CONTENT;//read_chunked_content</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNKED_CONTENT: &#123; //read_chunked_content</div><div class=\"line\">            assert chunkSize &lt;= Integer.MAX_VALUE;</div><div class=\"line\">            int toRead = Math.min((int) chunkSize, maxChunkSize);</div><div class=\"line\">            toRead = Math.min(toRead, buffer.readableBytes());</div><div class=\"line\">            if (toRead == 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            HttpContent chunk = new DefaultHttpContent(buffer.readRetainedSlice(toRead));</div><div class=\"line\">            chunkSize -= toRead;</div><div class=\"line\">            out.add(chunk);</div><div class=\"line\">            if (chunkSize != 0) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            currentState = State.READ_CHUNK_DELIMITER;//read_chunked_delimiter</div><div class=\"line\">            // fall-through</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_DELIMITER: &#123;//read_chunked_delimiter</div><div class=\"line\">            final int wIdx = buffer.writerIndex();</div><div class=\"line\">            int rIdx = buffer.readerIndex();</div><div class=\"line\">            while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">                byte next = buffer.getByte(rIdx++);</div><div class=\"line\">                if (next == HttpConstants.LF) &#123;</div><div class=\"line\">                    currentState = State.READ_CHUNK_SIZE;//read_chunked_size</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            buffer.readerIndex(rIdx);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case READ_CHUNK_FOOTER: try &#123;//read_chunked_foooter</div><div class=\"line\">            LastHttpContent trailer = readTrailingHeaders(buffer);</div><div class=\"line\">            if (trailer == null) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            out.add(trailer);</div><div class=\"line\">            resetNow();</div><div class=\"line\">            return;</div><div class=\"line\">        &#125; catch (Exception e) &#123;</div><div class=\"line\">            out.add(invalidChunk(buffer, e));</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case BAD_MESSAGE: &#123;  //bad_message</div><div class=\"line\">            // Keep discarding until disconnection.</div><div class=\"line\">            buffer.skipBytes(buffer.readableBytes());</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        case UPGRADED: &#123;//upgraded</div><div class=\"line\">            int readableBytes = buffer.readableBytes();</div><div class=\"line\">            if (readableBytes &gt; 0) &#123;</div><div class=\"line\">                // Keep on consuming as otherwise we may trigger an DecoderException,</div><div class=\"line\">                // other handler will replace this codec with the upgraded protocol codec to</div><div class=\"line\">                // take the traffic over at some point then.</div><div class=\"line\">                // See https://github.com/netty/netty/issues/2173</div><div class=\"line\">                out.add(buffer.readBytes(readableBytes));</div><div class=\"line\">            &#125;</div><div class=\"line\">            break;</div><div class=\"line\">        &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>注意这里的case并没有break, decode主要做了如下逻辑:<br>1)  首先检查byte, 要跳过最开始的控制符或者空格, 部分控制符就是ascii编码为31之前的字符。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean skipControlCharacters(ByteBuf buffer) &#123;</div><div class=\"line\">        boolean skiped = false;</div><div class=\"line\">        final int wIdx = buffer.writerIndex();</div><div class=\"line\">        int rIdx = buffer.readerIndex();</div><div class=\"line\">        while (wIdx &gt; rIdx) &#123;</div><div class=\"line\">            int c = buffer.getUnsignedByte(rIdx++);</div><div class=\"line\">            if (!Character.isISOControl(c) &amp;&amp; !Character.isWhitespace(c)) &#123;//0～31及127(共33个)是控制字符或通信专用字符（其余为可显示字符），如控制符：LF（换行）、CR（回车）、FF（换页）、DEL（删除）、BS（退格)、BEL（响铃）等</div><div class=\"line\">                rIdx--;</div><div class=\"line\">                skiped = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        buffer.readerIndex(rIdx);</div><div class=\"line\">        return skiped;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>首先读取当前字母, 若发现符合要求, 再复位当前读指针。 并将动作设置为READ_INITIAL, 表示接下来将要读取initial部分。<br>2) 读取INITIAL部分<br>从当前节点开始读取字符,直到读取分割符号为HttpConstants.LF(换行符), 该部分将解析出如下信息:<code>GET /_cat/indices HTTP/1.1</code>, 创建对象:DefaultHttpRequest, 其中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">httpVersion: HTTP/1.1</div><div class=\"line\">method: GET</div><div class=\"line\">uri: /_cat/indices</div></pre></td></tr></table></figure></p>\n<p>这个DefaultHttpRequest在HttpObjectDecoder中生成, 作为最终的这个请求的头部分。然后将状态位置为READ_HEADER, 表示即将读取header部分。<br>3) 读取Headers部分<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\">private State readHeaders(ByteBuf buffer) &#123;</div><div class=\"line\">        final HttpMessage message = this.message;  //DefaultHttpRequest</div><div class=\"line\">        final HttpHeaders headers = message.headers();  //headers = DefaultHttpHeaders</div><div class=\"line\">        AppendableCharSequence line = headerParser.parse(buffer);//不停地解析header， 下面是个do()while&#123;&#125;为循环</div><div class=\"line\">        if (line == null) &#123;</div><div class=\"line\">            return null;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (line.length() &gt; 0) &#123;</div><div class=\"line\">            do &#123; //这是个while循环，以换行符来进行分割</div><div class=\"line\">                char firstChar = line.charAt(0);</div><div class=\"line\">                if (name != null &amp;&amp; (firstChar == &apos; &apos; || firstChar == &apos;\\t&apos;)) &#123;</div><div class=\"line\">                    String trimmedLine = line.toString().trim();</div><div class=\"line\">                    String valueStr = String.valueOf(value);</div><div class=\"line\">                    value = valueStr + &apos; &apos; + trimmedLine;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    if (name != null) &#123;</div><div class=\"line\">                        headers.add(name, value);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    splitHeader(line);</div><div class=\"line\">                &#125;</div><div class=\"line\">                line = headerParser.parse(buffer);   //</div><div class=\"line\">                if (line == null) &#123;</div><div class=\"line\">                    return null;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; while (line.length() &gt; 0);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Add the last header.</div><div class=\"line\">        if (name != null) &#123;   //解析出最后一个header</div><div class=\"line\">            headers.add(name, value);</div><div class=\"line\">        &#125;</div><div class=\"line\">        // reset name and value fields</div><div class=\"line\">        name = null;</div><div class=\"line\">        value = null;</div><div class=\"line\"></div><div class=\"line\">        State nextState;</div><div class=\"line\"></div><div class=\"line\">        if (isContentAlwaysEmpty(message)) &#123;  //header是否为空</div><div class=\"line\">            HttpUtil.setTransferEncodingChunked(message, false);</div><div class=\"line\">            nextState = State.SKIP_CONTROL_CHARS;  // 哪里有问题，又是重头开始</div><div class=\"line\">        &#125; else if (HttpUtil.isTransferEncodingChunked(message)) &#123; // 是否包含 transfer-encoding: chunked</div><div class=\"line\">            nextState = State.READ_CHUNK_SIZE;</div><div class=\"line\">        &#125; else if (contentLength() &gt;= 0) &#123;   //Content-Length: 80</div><div class=\"line\">            nextState = State.READ_FIXED_LENGTH_CONTENT;  //下一个读取Content值</div><div class=\"line\">        &#125; else &#123; //没有Content-Length和chunked相关的，就是读取变量类型长度</div><div class=\"line\">            nextState = State.READ_VARIABLE_LENGTH_CONTENT;</div><div class=\"line\">        &#125;</div><div class=\"line\">        return nextState;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>读取header部分和读取inital部分一样, 也是根据HttpConstants.LF(换行符)循环读取每一行, 并且解读出key-value出来, 获取到所有的header内容, 同时也放入DefaultHttpRequest中, header内容示例如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;Accept&quot; -&gt; &quot;*/*&quot;</div><div class=\"line\">&quot;User-Agent&quot; -&gt; &quot;curl/7/43/0&quot;</div><div class=\"line\">&quot;Host&quot; -&gt; &quot;127.0.0.1:9200&quot;</div><div class=\"line\">&quot;Content-Length&quot; -&gt; &quot;66735&quot;</div><div class=\"line\">&quot;Content-Encoding&quot; -&gt; &quot;gzip&quot;</div><div class=\"line\">&quot;Content-Type&quot; -&gt; &quot;application/x-www-form-urlencoded&quot;</div><div class=\"line\">&quot;Expect&quot; -&gt; &quot;100-continue&quot;</div><div class=\"line\">&quot;null&quot; -&gt; &quot;null&quot;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们需要了解一个参数:Expect: 100-continue</p>\n<blockquote>\n<p><a href=\"https://blog.csdn.net/MitKey/article/details/52042537\" target=\"_blank\" rel=\"external\">参考</a>100-continue 是用于客户端在发送 post 数据给服务器时，征询服务器情况，看服务器是否处理 post 的数据，如果不处理，客户端则不上传 post 是数据，反之则上传。在实际应用中，通过 post 上传大数据时，才会使用到 100-continue 协议。</p><p>客户端策略:<br>如果客户端有 post 数据要上传，可以考虑使用 100-continue 协议。在请求头中加入 {“Expect”:”100-continue”}<br>如果没有 post 数据，不能使用 100-continue 协议，因为这会让服务端造成误解。<br>并不是所有的 Server 都会正确实现 100-continue 协议，如果 Client 发送 Expect:100-continue 消息后，在 timeout 时间内无响应，Client 需要立马上传 post 数据。<br>有些 Server 会错误实现 100-continue 协议，在不需要此协议时返回 100，此时客户端应该忽略。</p><p>服务端策略:<br>正确情况下，收到请求后，返回 100 或错误码。<br>如果在发送 100-continue 前收到了 post 数据（客户端提前发送 post 数据），则不发送 100 响应码(略去)。</p>\n</blockquote>\n<p>这个参数也不是必须有的, 当content部分长度超过, 客户端才会向服务器端发送这个参数。 在terminal下面通过curl发送包含数据请求, 当数据部分长度&gt;=1025时, 客户端发送的header里面才会有这个参数。</p>\n<ul>\n<li>如上因为header中包含Content-Length, 说明接下来需要读取定长为66735的一个帧。<br>这里会设置状态为READ_FIXED_LENGTH_CONTENT<br>4)  读取内容<br>因为header读取完成之后, 将nextState设置成了READ_FIXED_LENGTH_CONTENT, 那么会连续接收并读取chunkSize长度的byte。这里有个设置, 我们设置了maxChunkSize, 意味着每次读取的chunked的长度必须<math.min(readablelength, maxchunksize),=\"\" 每读取maxchunksize长度的值就向后传递,=\"\" 同时修改chunksize的值。读取第二个chunked的动作在messagetomessagedecoder中发出(该content的readablebytes=\"\">0)。<br>这里对于maxChunkSize的限制不甚理解, 既然已经读取到readableLength长度的值, 为啥还需要再次分割每个chunked为maxChunkSize。<h1 id=\"HttpObjectAggregator和-MessageAggregator\"><a href=\"#HttpObjectAggregator和-MessageAggregator\" class=\"headerlink\" title=\"HttpObjectAggregator和 MessageAggregator\"></a>HttpObjectAggregator和 MessageAggregator</h1>HttpObjectAggregator主要是将HttpRequest和HttpContent合并成FullHttpRequest, 继承自MessageAggregator。<br>MessageAggregator实现了decode()函数, 继承了MessageToMessageDecoder(很熟悉), 主要实现如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void decode(final ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out) throws Exception &#123;</div><div class=\"line\">    if (isStartMessage(msg)) &#123;//会跑到HttpObjectAggregator里面，只要是HttpMessage类型就行</div><div class=\"line\">        handlingOversizedMessage = false;</div><div class=\"line\">        if (currentMessage != null) &#123;</div><div class=\"line\">            currentMessage.release();</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">            throw new MessageAggregationException();</div><div class=\"line\">        &#125;</div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        S m = (S) msg; //DefaultHttpRequest</div><div class=\"line\">        // Send the continue response if necessary (e.g. &apos;Expect: 100-continue&apos; header)</div><div class=\"line\">        // Check before content length. Failing an expectation may result in a different response being sent.</div><div class=\"line\">        Object continueResponse = newContinueResponse(m, maxContentLength, ctx.pipeline());//跑到HttpObjectAggregator里面，第一次返回DefaultFullHttpResponse</div><div class=\"line\">        if (continueResponse != null) &#123; //向客户端返回100-continue, 告诉客户端可以发送content了</div><div class=\"line\">            // Cache the write listener for reuse.</div><div class=\"line\">            ChannelFutureListener listener = continueResponseWriteListener;</div><div class=\"line\">            if (listener == null) &#123;</div><div class=\"line\">                continueResponseWriteListener = listener = new ChannelFutureListener() &#123;</div><div class=\"line\">                    @Override</div><div class=\"line\">                    public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                        if (!future.isSuccess()) &#123;</div><div class=\"line\">                            ctx.fireExceptionCaught(future.cause());</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;</div><div class=\"line\">            // Make sure to call this before writing, otherwise reference counts may be invalid.</div><div class=\"line\">            boolean closeAfterWrite = closeAfterContinueResponse(continueResponse);</div><div class=\"line\">            handlingOversizedMessage = ignoreContentAfterContinueResponse(continueResponse);</div><div class=\"line\"></div><div class=\"line\">            final ChannelFuture future = ctx.writeAndFlush(continueResponse).addListener(listener);</div><div class=\"line\"></div><div class=\"line\">            if (closeAfterWrite) &#123;</div><div class=\"line\">                future.addListener(ChannelFutureListener.CLOSE);</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (handlingOversizedMessage) &#123;</div><div class=\"line\">                return;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else if (isContentLengthInvalid(m, maxContentLength)) &#123; //检查length是否有效，</div><div class=\"line\">            // if content length is set, preemptively close if it&apos;s too large</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, m);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (m instanceof DecoderResultProvider &amp;&amp; !((DecoderResultProvider) m).decoderResult().isSuccess()) &#123;</div><div class=\"line\">            O aggregated;</div><div class=\"line\">            if (m instanceof ByteBufHolder &amp;&amp; ((ByteBufHolder) m).content().isReadable()) &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, ((ByteBufHolder) m).content().retain());</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                aggregated = beginAggregation(m, EMPTY_BUFFER);</div><div class=\"line\">            &#125;</div><div class=\"line\">            finishAggregation(aggregated);</div><div class=\"line\">            out.add(aggregated);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">         //同时生成好Compent</div><div class=\"line\">        // A streamed message - initialize the cumulative buffer, and wait for incoming chunks.</div><div class=\"line\">        CompositeByteBuf content = ctx.alloc().compositeBuffer(maxCumulationBufferComponents);//只有start类型数值才能生成CompositeByteBuf，后面内容部分只管向里面添加即可</div><div class=\"line\">        if (m instanceof ByteBufHolder) &#123;</div><div class=\"line\">            appendPartialContent(content, ((ByteBufHolder) m).content());</div><div class=\"line\">        &#125;</div><div class=\"line\">        currentMessage = beginAggregation(m, content); //currentMessage = AggregatedFullHttpRequest</div><div class=\"line\">    &#125; else if (isContentMessage(msg)) &#123; //解析内容部分</div><div class=\"line\">        if (currentMessage == null) &#123;</div><div class=\"line\">            // it is possible that a TooLongFrameException was already thrown but we can still discard data</div><div class=\"line\">            // until the begging of the next request/response.</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Merge the received chunk into the content of the current message.</div><div class=\"line\">        CompositeByteBuf content = (CompositeByteBuf) currentMessage.content();</div><div class=\"line\"></div><div class=\"line\">        @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">        final C m = (C) msg; //可能是DefaultLastHttpContent</div><div class=\"line\">        // Handle oversized message.</div><div class=\"line\">        if (content.readableBytes() &gt; maxContentLength - m.content().readableBytes()) &#123;</div><div class=\"line\">            // By convention, full message type extends first message type.</div><div class=\"line\">            @SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">            S s = (S) currentMessage;</div><div class=\"line\">            invokeHandleOversizedMessage(ctx, s);</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // Append the content of the chunk.</div><div class=\"line\">        appendPartialContent(content, m.content()); //把产生的数据添加到末尾</div><div class=\"line\">        //</div><div class=\"line\">        // Give the subtypes a chance to merge additional information such as trailing headers.</div><div class=\"line\">        aggregate(currentMessage, m);  //HttpObjectAggregator.aggregate()    currentMessage=AggregatedFullHttpRequest</div><div class=\"line\"></div><div class=\"line\">        final boolean last;</div><div class=\"line\">        if (m instanceof DecoderResultProvider) &#123;</div><div class=\"line\">            DecoderResult decoderResult = ((DecoderResultProvider) m).decoderResult();</div><div class=\"line\">            if (!decoderResult.isSuccess()) &#123;</div><div class=\"line\">                if (currentMessage instanceof DecoderResultProvider) &#123;</div><div class=\"line\">                    ((DecoderResultProvider) currentMessage).setDecoderResult(</div><div class=\"line\">                            DecoderResult.failure(decoderResult.cause()));</div><div class=\"line\">                &#125;</div><div class=\"line\">                last = true;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                last = isLastContentMessage(m);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            last = isLastContentMessage(m);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        if (last) &#123;  //如果Content是最后一个，那么就开始组合了，向out添加结果后就可以继续发送，否则就直接退出了，</div><div class=\"line\">            finishAggregation(currentMessage);</div><div class=\"line\"></div><div class=\"line\">            // All done</div><div class=\"line\">            out.add(currentMessage); //把结果放进来意味着继续向下一个处理器发送，否则就直接接收下一个chunked。</div><div class=\"line\">            currentMessage = null;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        throw new MessageAggregationException();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</math.min(readablelength,></li>\n</ul>\n<p>decode函数主要检查该解析请求是否是HttpRequest或者HttpContent, 否则直接返回异常。<br>1) 若请求是HttpRequest<br>说明该部分是request最开始的那一部分。</p>\n<ul>\n<li>首先检查是否请求中是否包含Expect: 100-continue(在newContinueResponse中检查): 若包含有, 服务器需要向客户端发送可以发送content的response, response中content为空; 反之, 说明不用向客户端发送continue的回复。</li>\n<li>生成CompositeByteBuf, 准备存放即将到来的HttpChunk; 生成AggregatedFullHttpRequest, 将CompositeByteBuf和DefaultHttpRequest包含其中。<br>需要简单介绍下CompositeByteBuf, 通过名字也可以看出, 他是一个复合型的ByteBuf, 它并不是真实的, 它主要由属性<code>List&lt;Component&gt; components</code>构成, 每新来一个ByteBuf, 都会添加到components中。 CompositeByteBuf也有自己的writerIndex和readIndex, 表示整个CompositeByteBuf最大可读和最大可写偏移量。</li>\n</ul>\n<p>2) 若请求是HttpContent部分</p>\n<ul>\n<li>将content添加进CompositeByteBuf中<br>通过appendPartialContent()添加, conponent添加进CompositeByteBuf的过程如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"> private int addComponent0(boolean increaseWriterIndex, int cIndex, ByteBuf buffer) &#123;</div><div class=\"line\">        .....</div><div class=\"line\">        if (cIndex == components.size()) &#123;</div><div class=\"line\">            wasAdded = components.add(c);</div><div class=\"line\">            if (cIndex == 0) &#123;</div><div class=\"line\">                c.endOffset = readableBytes;</div><div class=\"line\">            &#125; else &#123;</div><div class=\"line\">                Component prev = components.get(cIndex - 1);</div><div class=\"line\">                c.offset = prev.endOffset;</div><div class=\"line\">                c.endOffset = c.offset + readableBytes;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        .....</div><div class=\"line\">        if (increaseWriterIndex) &#123;</div><div class=\"line\">            writerIndex(writerIndex() + buffer.readableBytes());</div><div class=\"line\">        &#125;</div><div class=\"line\">        return cIndex;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每个Component结构如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf buf;  //该Component实际存储</div><div class=\"line\">final int length;</div><div class=\"line\">int offset; 标记该Component占CompositeByte所有Component byte的起始偏移位置。</div><div class=\"line\">int endOffset;  //标记该Component占CompositeByte所有Component byte的最终偏移位置。</div></pre></td></tr></table></figure></p>\n<p>在添加的时候, curr.offset = pre.endOffset,curr.endOffset = pre.offset+ readLength, 这样每个Component offset和endOffset指针首位相连。</p>\n<ul>\n<li>等待所有的content发送过来</li>\n</ul>\n<ol>\n<li>轮训等待所有的部分content发送过来, 封装成Component放进CompositeByte中。</li>\n<li>直到检测到content为最后一个content(类型为LastHttpContent), 则将CompositeByte放入out中继续向里面传递。</li>\n</ol>\n<p>至此,一个完整地AggregatedFullHttpRequest已经解析出来了,组成如下:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/DefaultLastHttpContent.png\"></p>\n<h1 id=\"附\"><a href=\"#附\" class=\"headerlink\" title=\"附\"></a>附</h1><p>如何将Composite转换为一个连续的堆内buf呢?<br>通过Unpooled.copiedBuffer(request.content())方法即可。</p>\n"},{"title":"Netty Thrift方式通信编解码源码解读","date":"2018-03-25T03:11:12.000Z","_content":"# 介绍\n## 零拷贝\nNetty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\">参考</a>)：\n1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。\n3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\n\n## 编解码处理器\n编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例\n解码处理器目前接触比较多的两种:\n+ ByteToMessageDecoder\nByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。\n+ MessageToMessageDecoder\nMessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。\n\n## 代码引入\n需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):\n```\n        public final void read() {\n            final ChannelConfig config = config();\n            final ChannelPipeline pipeline = pipeline();\n            final ByteBufAllocator allocator = config.getAllocator();\n            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取\n            allocHandle.reset(config);\n            ByteBuf byteBuf = null;\n            boolean close = false;\n            try {\n                do {\n                    byteBuf = allocHandle.allocate(allocator);\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                    if (allocHandle.lastBytesRead() <= 0) { // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接\n                        // nothing was read. release the buffer.\n                        byteBuf.release();\n                        byteBuf = null;\n                        close = allocHandle.lastBytesRead() < 0;\n                        break;\n                    }\n                    allocHandle.incMessagesRead(1);\n                    readPending = false;\n                    pipeline.fireChannelRead(byteBuf);\n                    byteBuf = null;\n                } while (allocHandle.continueReading());\n                allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）\n                pipeline.fireChannelReadComplete();// 本轮数据读取完毕\n                if (close) {// 如果读取的时候发生错误则关闭连接\n                    closeOnRead(pipeline);\n                }\n            } catch (Throwable t) {\n                handleReadException(pipeline, byteBuf, t, close, allocHandle);\n            } finally {\n\n            }\n        }\n    }\n ```\n这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。\n# ByteToMessageDecoder\n属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。\n回到代码里, 需要关注channelRead:\n```\n@Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ByteBuf) {    //PoolUnsafeDirectByteBuf\n            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合\n            try {\n                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf\n                first = cumulation == null;\n                if (first) {\n                    cumulation = data;\n                } else {\n                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR\n                }\n                callDecode(ctx, cumulation, out);\n            } catch (DecoderException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw new DecoderException(t);\n            } finally {//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)\n                if (cumulation != null && !cumulation.isReadable()) {\n                    numReads = 0;\n                    cumulation.release();\n                    cumulation = null;\n                } else if (++ numReads >= discardAfterReads) {\n                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.\n                    // See https://github.com/netty/netty/issues/4275\n                    numReads = 0;\n                    discardSomeReadBytes();\n                }\n\n                int size = out.size();\n                decodeWasNull = !out.insertSinceRecycled();\n                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message\n                out.recycle();\n            }\n        } else {\n            ctx.fireChannelRead(msg);\n        }\n    }\n```\n主要做的事情:\n1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。\n2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。\n```\n @Override\n        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf\n            final ByteBuf buffer;\n            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()\n                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {\n                // Expand cumulation (by replace it) when either there is not more room in the buffer\n                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or\n                // duplicate().retain() or if its read-only.\n                //\n                // See:\n                // - https://github.com/netty/netty/issues/2327\n                // - https://github.com/netty/netty/issues/1764\n                buffer = expandCumulation(alloc, cumulation, in.readableBytes());\n            } else {\n                buffer = cumulation;\n            }\n            buffer.writeBytes(in); //将新的数据，写入这个cumulation\n            in.release();  //释放资源\n            return buffer;\n        }\n```\n+ 首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation\n```\n   ByteBuf oldCumulation = cumulation;\n        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据\n        cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据\n        oldCumulation.release(); //释放旧的缓冲区\n        return cumulation;\n```\ncumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。\n3) 解码callDecode\n```\n             while (in.isReadable()) {\n                int outSize = out.size();\n                if (outSize > 0) { //out为经过转码形成帧的的数据\n                    fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个\n                    out.clear();\n                    outSize = 0;\n                }\n                int oldInputLength = in.readableBytes();  //24\n                decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode\n                if (outSize == out.size()) { //decode没有解析出东西\n                    if (oldInputLength == in.readableBytes()) { //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐\n                        break;\n                    } else { //还是向前消费了许多东西，可能读到了坏的帧，丢弃了\n                        continue;\n                    }\n                }\n                if (oldInputLength == in.readableBytes()) {  //说明outSize < out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题\n                    throw new DecoderException(\n                            StringUtil.simpleClassName(getClass()) +\n                                    \".decode() did not read anything but decoded a message.\");\n                }\n              }\n```\n+ 首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。\n+ 开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在`LengthFieldBasedFrameDecoder`里实现。\n+ 对这轮解析结果进行分析:\n     若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。\n     若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。\n     若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。\n4) 检查是否还有帧可以继续向上传递。\n```\n static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {\n        if (msgs instanceof CodecOutputList) {   //都单个单个的发送\n            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                ctx.fireChannelRead(msgs.get(i));\n            }\n        }\n    }\n```\n可以看出实际也是每个帧单独向上发送的。\n\n# LengthFieldBasedFrameDecoder\nLengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)即可: 从原始byte in中解析出一个帧, 放入out中。\n我们需要理解几个属性的函数:\n+ maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。\n+ lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。\n+ lengthFieldLength: 定义帧长度的字段本身的长度。\n+ lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉\n+ initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分\n+ failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。\n+ discardingTooLongFrame: 当帧解析出来的帧内容长度 > maxFrameLength时,并且剩余缓存可读字段 < 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。\n+ tooLongFrameLength: 超过长度限制maxFrameLength的帧长度\n+ bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容\n关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"/>\n也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\"> 参考/a>\n其中:\n+ head1和head2可以由用户自定义语义。\n+ 有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength\n解码函数如下:\n```\n       if (discardingTooLongFrame) {//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢\n            long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度\n            int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数\n            in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度\n            bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度\n            this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度\n            failIfNecessary(false);\n        }\n        //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回\n        if (in.readableBytes() < lengthFieldEndOffset) {//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码\n            return null; //当前帧没有value\n        }\n       // 拿到长度字段的起始偏移量index\n        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置\n        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度\n        if (frameLength < 0) {\n            in.skipBytes(lengthFieldEndOffset);\n            throw new CorruptedFrameException(\n                    \"negative pre-adjustment length field: \" + frameLength);\n        }\n        // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)\n        frameLength += lengthAdjustment + lengthFieldEndOffset;\n        if (frameLength < lengthFieldEndOffset) {\n            in.skipBytes(lengthFieldEndOffset);//当前帧忽略过\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than lengthFieldEndOffset: \" + lengthFieldEndOffset);\n        }\n        // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。\n        if (frameLength > maxFrameLength) {\n            long discard = frameLength - in.readableBytes();//前面\n            tooLongFrameLength = frameLength;\n            // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n            if (discard < 0) {// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n                // buffer contains more bytes then the frameLength so we can discard all now\n                in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面\n            } else {\n                // Enter the discard mode and discard everything received so far.\n                discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧\n                bytesToDiscard = discard;\n                in.skipBytes(in.readableBytes());//丢弃整个帧\n            }\n            failIfNecessary(true);\n            return null;\n        }\n        // never overflows because it's less than maxFrameLength\n        int frameLengthInt = (int) frameLength;\n        if (in.readableBytes() < frameLengthInt) {  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环\n            return null;\n        }\n        if (initialBytesToStrip > frameLengthInt) {\n            in.skipBytes(frameLengthInt);\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than initialBytesToStrip: \" + initialBytesToStrip);\n        }\n        in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content\n        // extract frame\n        int readerIndex = in.readerIndex();\n        int actualFrameLength = frameLengthInt - initialBytesToStrip;\n        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);\n        in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置\n        return frame;\n```\n主要操作如下:\n1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:\n```\nprivate void failIfNecessary(boolean firstDetectionOfTooLongFrame) {\n        if (bytesToDiscard == 0) { //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态\n            // Reset to the initial state and tell the handlers that\n            // the frame was too large.\n            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度\n            this.tooLongFrameLength = 0; //主要是复位\n            discardingTooLongFrame = false;\n            if (!failFast || firstDetectionOfTooLongFrame) {// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理\n                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃\n            }\n        } else {  //第一次遇到，发现当前帧长度太长了\n            // Keep discarding and notify handlers if necessary.\n            if (failFast && firstDetectionOfTooLongFrame) {\n                fail(tooLongFrameLength); //是第一次遇到，直接丢失\n            }\n        }\n    }\n```\n+ 当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。\n+ 反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。\n2) 若当前缓存可读byte < 长度偏移量, 直接退出继续, 数据仍然放在了缓存。\n3) 计算出帧整体的长度,包括了length + head2 + content:\n```\nframeLength += lengthAdjustment + lengthFieldEndOffset;\n```\n4) 检查帧frameLength是否超过的阈值,若超过了:\n+ 检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度\n+ 否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。\n并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。\n5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。\n6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。\n","source":"_posts/Netty通信编解码源码解读.md","raw":"---\ntitle: Netty Thrift方式通信编解码源码解读\ndate: 2018-03-25 11:11:12\ntags:\n---\n# 介绍\n## 零拷贝\nNetty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\">参考</a>)：\n1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。\n2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。\n3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。\n4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。\n\n## 编解码处理器\n编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例\n解码处理器目前接触比较多的两种:\n+ ByteToMessageDecoder\nByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。\n+ MessageToMessageDecoder\nMessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。\n\n## 代码引入\n需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):\n```\n        public final void read() {\n            final ChannelConfig config = config();\n            final ChannelPipeline pipeline = pipeline();\n            final ByteBufAllocator allocator = config.getAllocator();\n            final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取\n            allocHandle.reset(config);\n            ByteBuf byteBuf = null;\n            boolean close = false;\n            try {\n                do {\n                    byteBuf = allocHandle.allocate(allocator);\n                    allocHandle.lastBytesRead(doReadBytes(byteBuf));\n                    if (allocHandle.lastBytesRead() <= 0) { // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接\n                        // nothing was read. release the buffer.\n                        byteBuf.release();\n                        byteBuf = null;\n                        close = allocHandle.lastBytesRead() < 0;\n                        break;\n                    }\n                    allocHandle.incMessagesRead(1);\n                    readPending = false;\n                    pipeline.fireChannelRead(byteBuf);\n                    byteBuf = null;\n                } while (allocHandle.continueReading());\n                allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）\n                pipeline.fireChannelReadComplete();// 本轮数据读取完毕\n                if (close) {// 如果读取的时候发生错误则关闭连接\n                    closeOnRead(pipeline);\n                }\n            } catch (Throwable t) {\n                handleReadException(pipeline, byteBuf, t, close, allocHandle);\n            } finally {\n\n            }\n        }\n    }\n ```\n这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。\n# ByteToMessageDecoder\n属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。\n回到代码里, 需要关注channelRead:\n```\n@Override\n    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n        if (msg instanceof ByteBuf) {    //PoolUnsafeDirectByteBuf\n            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合\n            try {\n                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf\n                first = cumulation == null;\n                if (first) {\n                    cumulation = data;\n                } else {\n                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR\n                }\n                callDecode(ctx, cumulation, out);\n            } catch (DecoderException e) {\n                throw e;\n            } catch (Throwable t) {\n                throw new DecoderException(t);\n            } finally {//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)\n                if (cumulation != null && !cumulation.isReadable()) {\n                    numReads = 0;\n                    cumulation.release();\n                    cumulation = null;\n                } else if (++ numReads >= discardAfterReads) {\n                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.\n                    // See https://github.com/netty/netty/issues/4275\n                    numReads = 0;\n                    discardSomeReadBytes();\n                }\n\n                int size = out.size();\n                decodeWasNull = !out.insertSinceRecycled();\n                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message\n                out.recycle();\n            }\n        } else {\n            ctx.fireChannelRead(msg);\n        }\n    }\n```\n主要做的事情:\n1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。\n2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。\n```\n @Override\n        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf\n            final ByteBuf buffer;\n            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()\n                    || cumulation.refCnt() > 1 || cumulation.isReadOnly()) {\n                // Expand cumulation (by replace it) when either there is not more room in the buffer\n                // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or\n                // duplicate().retain() or if its read-only.\n                //\n                // See:\n                // - https://github.com/netty/netty/issues/2327\n                // - https://github.com/netty/netty/issues/1764\n                buffer = expandCumulation(alloc, cumulation, in.readableBytes());\n            } else {\n                buffer = cumulation;\n            }\n            buffer.writeBytes(in); //将新的数据，写入这个cumulation\n            in.release();  //释放资源\n            return buffer;\n        }\n```\n+ 首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation\n```\n   ByteBuf oldCumulation = cumulation;\n        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据\n        cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据\n        oldCumulation.release(); //释放旧的缓冲区\n        return cumulation;\n```\ncumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。\n3) 解码callDecode\n```\n             while (in.isReadable()) {\n                int outSize = out.size();\n                if (outSize > 0) { //out为经过转码形成帧的的数据\n                    fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个\n                    out.clear();\n                    outSize = 0;\n                }\n                int oldInputLength = in.readableBytes();  //24\n                decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode\n                if (outSize == out.size()) { //decode没有解析出东西\n                    if (oldInputLength == in.readableBytes()) { //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐\n                        break;\n                    } else { //还是向前消费了许多东西，可能读到了坏的帧，丢弃了\n                        continue;\n                    }\n                }\n                if (oldInputLength == in.readableBytes()) {  //说明outSize < out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题\n                    throw new DecoderException(\n                            StringUtil.simpleClassName(getClass()) +\n                                    \".decode() did not read anything but decoded a message.\");\n                }\n              }\n```\n+ 首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。\n+ 开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在`LengthFieldBasedFrameDecoder`里实现。\n+ 对这轮解析结果进行分析:\n     若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。\n     若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。\n     若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。\n4) 检查是否还有帧可以继续向上传递。\n```\n static void fireChannelRead(ChannelHandlerContext ctx, List<Object> msgs, int numElements) {\n        if (msgs instanceof CodecOutputList) {   //都单个单个的发送\n            fireChannelRead(ctx, (CodecOutputList) msgs, numElements);\n        } else {\n            for (int i = 0; i < numElements; i++) {\n                ctx.fireChannelRead(msgs.get(i));\n            }\n        }\n    }\n```\n可以看出实际也是每个帧单独向上发送的。\n\n# LengthFieldBasedFrameDecoder\nLengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)即可: 从原始byte in中解析出一个帧, 放入out中。\n我们需要理解几个属性的函数:\n+ maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。\n+ lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。\n+ lengthFieldLength: 定义帧长度的字段本身的长度。\n+ lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉\n+ initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分\n+ failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。\n+ discardingTooLongFrame: 当帧解析出来的帧内容长度 > maxFrameLength时,并且剩余缓存可读字段 < 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。\n+ tooLongFrameLength: 超过长度限制maxFrameLength的帧长度\n+ bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容\n关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"/>\n也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\"> 参考/a>\n其中:\n+ head1和head2可以由用户自定义语义。\n+ 有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength\n解码函数如下:\n```\n       if (discardingTooLongFrame) {//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢\n            long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度\n            int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数\n            in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度\n            bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度\n            this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度\n            failIfNecessary(false);\n        }\n        //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回\n        if (in.readableBytes() < lengthFieldEndOffset) {//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码\n            return null; //当前帧没有value\n        }\n       // 拿到长度字段的起始偏移量index\n        int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置\n        long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度\n        if (frameLength < 0) {\n            in.skipBytes(lengthFieldEndOffset);\n            throw new CorruptedFrameException(\n                    \"negative pre-adjustment length field: \" + frameLength);\n        }\n        // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)\n        frameLength += lengthAdjustment + lengthFieldEndOffset;\n        if (frameLength < lengthFieldEndOffset) {\n            in.skipBytes(lengthFieldEndOffset);//当前帧忽略过\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than lengthFieldEndOffset: \" + lengthFieldEndOffset);\n        }\n        // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。\n        if (frameLength > maxFrameLength) {\n            long discard = frameLength - in.readableBytes();//前面\n            tooLongFrameLength = frameLength;\n            // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n            if (discard < 0) {// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包\n                // buffer contains more bytes then the frameLength so we can discard all now\n                in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面\n            } else {\n                // Enter the discard mode and discard everything received so far.\n                discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧\n                bytesToDiscard = discard;\n                in.skipBytes(in.readableBytes());//丢弃整个帧\n            }\n            failIfNecessary(true);\n            return null;\n        }\n        // never overflows because it's less than maxFrameLength\n        int frameLengthInt = (int) frameLength;\n        if (in.readableBytes() < frameLengthInt) {  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环\n            return null;\n        }\n        if (initialBytesToStrip > frameLengthInt) {\n            in.skipBytes(frameLengthInt);\n            throw new CorruptedFrameException(\n                    \"Adjusted frame length (\" + frameLength + \") is less \" +\n                    \"than initialBytesToStrip: \" + initialBytesToStrip);\n        }\n        in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content\n        // extract frame\n        int readerIndex = in.readerIndex();\n        int actualFrameLength = frameLengthInt - initialBytesToStrip;\n        ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);\n        in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置\n        return frame;\n```\n主要操作如下:\n1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:\n```\nprivate void failIfNecessary(boolean firstDetectionOfTooLongFrame) {\n        if (bytesToDiscard == 0) { //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态\n            // Reset to the initial state and tell the handlers that\n            // the frame was too large.\n            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度\n            this.tooLongFrameLength = 0; //主要是复位\n            discardingTooLongFrame = false;\n            if (!failFast || firstDetectionOfTooLongFrame) {// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理\n                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃\n            }\n        } else {  //第一次遇到，发现当前帧长度太长了\n            // Keep discarding and notify handlers if necessary.\n            if (failFast && firstDetectionOfTooLongFrame) {\n                fail(tooLongFrameLength); //是第一次遇到，直接丢失\n            }\n        }\n    }\n```\n+ 当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。\n+ 反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。\n2) 若当前缓存可读byte < 长度偏移量, 直接退出继续, 数据仍然放在了缓存。\n3) 计算出帧整体的长度,包括了length + head2 + content:\n```\nframeLength += lengthAdjustment + lengthFieldEndOffset;\n```\n4) 检查帧frameLength是否超过的阈值,若超过了:\n+ 检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度\n+ 否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。\n并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。\n5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。\n6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。\n","slug":"Netty通信编解码源码解读","published":1,"updated":"2018-05-13T11:48:17.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadwd0008miu5amjwhppy","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>Netty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\" target=\"_blank\" rel=\"external\">参考</a>)：<br>1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p>\n<h2 id=\"编解码处理器\"><a href=\"#编解码处理器\" class=\"headerlink\" title=\"编解码处理器\"></a>编解码处理器</h2><p>编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例<br>解码处理器目前接触比较多的两种:</p>\n<ul>\n<li>ByteToMessageDecoder<br>ByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。</li>\n<li>MessageToMessageDecoder<br>MessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。</li>\n</ul>\n<h2 id=\"代码引入\"><a href=\"#代码引入\" class=\"headerlink\" title=\"代码引入\"></a>代码引入</h2><p>需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    public final void read() &#123;</div><div class=\"line\">        final ChannelConfig config = config();</div><div class=\"line\">        final ChannelPipeline pipeline = pipeline();</div><div class=\"line\">        final ByteBufAllocator allocator = config.getAllocator();</div><div class=\"line\">        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取</div><div class=\"line\">        allocHandle.reset(config);</div><div class=\"line\">        ByteBuf byteBuf = null;</div><div class=\"line\">        boolean close = false;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                byteBuf = allocHandle.allocate(allocator);</div><div class=\"line\">                allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class=\"line\">                if (allocHandle.lastBytesRead() &lt;= 0) &#123; // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接</div><div class=\"line\">                    // nothing was read. release the buffer.</div><div class=\"line\">                    byteBuf.release();</div><div class=\"line\">                    byteBuf = null;</div><div class=\"line\">                    close = allocHandle.lastBytesRead() &lt; 0;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                allocHandle.incMessagesRead(1);</div><div class=\"line\">                readPending = false;</div><div class=\"line\">                pipeline.fireChannelRead(byteBuf);</div><div class=\"line\">                byteBuf = null;</div><div class=\"line\">            &#125; while (allocHandle.continueReading());</div><div class=\"line\">            allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）</div><div class=\"line\">            pipeline.fireChannelReadComplete();// 本轮数据读取完毕</div><div class=\"line\">            if (close) &#123;// 如果读取的时候发生错误则关闭连接</div><div class=\"line\">                closeOnRead(pipeline);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable t) &#123;</div><div class=\"line\">            handleReadException(pipeline, byteBuf, t, close, allocHandle);</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。</p>\n<h1 id=\"ByteToMessageDecoder\"><a href=\"#ByteToMessageDecoder\" class=\"headerlink\" title=\"ByteToMessageDecoder\"></a>ByteToMessageDecoder</h1><p>属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。<br>回到代码里, 需要关注channelRead:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class=\"line\">        if (msg instanceof ByteBuf) &#123;    //PoolUnsafeDirectByteBuf</div><div class=\"line\">            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf</div><div class=\"line\">                first = cumulation == null;</div><div class=\"line\">                if (first) &#123;</div><div class=\"line\">                    cumulation = data;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR</div><div class=\"line\">                &#125;</div><div class=\"line\">                callDecode(ctx, cumulation, out);</div><div class=\"line\">            &#125; catch (DecoderException e) &#123;</div><div class=\"line\">                throw e;</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                throw new DecoderException(t);</div><div class=\"line\">            &#125; finally &#123;//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)</div><div class=\"line\">                if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    cumulation.release();</div><div class=\"line\">                    cumulation = null;</div><div class=\"line\">                &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</div><div class=\"line\">                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/4275</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    discardSomeReadBytes();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                int size = out.size();</div><div class=\"line\">                decodeWasNull = !out.insertSinceRecycled();</div><div class=\"line\">                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message</div><div class=\"line\">                out.recycle();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.fireChannelRead(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事情:<br>1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。<br>2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">       public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) &#123;  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf</div><div class=\"line\">           final ByteBuf buffer;</div><div class=\"line\">           if (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</div><div class=\"line\">                   || cumulation.refCnt() &gt; 1 || cumulation.isReadOnly()) &#123;</div><div class=\"line\">               // Expand cumulation (by replace it) when either there is not more room in the buffer</div><div class=\"line\">               // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</div><div class=\"line\">               // duplicate().retain() or if its read-only.</div><div class=\"line\">               //</div><div class=\"line\">               // See:</div><div class=\"line\">               // - https://github.com/netty/netty/issues/2327</div><div class=\"line\">               // - https://github.com/netty/netty/issues/1764</div><div class=\"line\">               buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               buffer = cumulation;</div><div class=\"line\">           &#125;</div><div class=\"line\">           buffer.writeBytes(in); //将新的数据，写入这个cumulation</div><div class=\"line\">           in.release();  //释放资源</div><div class=\"line\">           return buffer;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf oldCumulation = cumulation;</div><div class=\"line\">     cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据</div><div class=\"line\">     cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据</div><div class=\"line\">     oldCumulation.release(); //释放旧的缓冲区</div><div class=\"line\">     return cumulation;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>cumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。<br>3) 解码callDecode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (in.isReadable()) &#123;</div><div class=\"line\">   int outSize = out.size();</div><div class=\"line\">   if (outSize &gt; 0) &#123; //out为经过转码形成帧的的数据</div><div class=\"line\">       fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个</div><div class=\"line\">       out.clear();</div><div class=\"line\">       outSize = 0;</div><div class=\"line\">   &#125;</div><div class=\"line\">   int oldInputLength = in.readableBytes();  //24</div><div class=\"line\">   decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode</div><div class=\"line\">   if (outSize == out.size()) &#123; //decode没有解析出东西</div><div class=\"line\">       if (oldInputLength == in.readableBytes()) &#123; //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐</div><div class=\"line\">           break;</div><div class=\"line\">       &#125; else &#123; //还是向前消费了许多东西，可能读到了坏的帧，丢弃了</div><div class=\"line\">           continue;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   if (oldInputLength == in.readableBytes()) &#123;  //说明outSize &lt; out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题</div><div class=\"line\">       throw new DecoderException(</div><div class=\"line\">               StringUtil.simpleClassName(getClass()) +</div><div class=\"line\">                       &quot;.decode() did not read anything but decoded a message.&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。</li>\n<li>开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在<code>LengthFieldBasedFrameDecoder</code>里实现。</li>\n<li>对这轮解析结果进行分析:<br>   若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。<br>   若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。<br>   若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。<br>4) 检查是否还有帧可以继续向上传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements) &#123;</div><div class=\"line\">       if (msgs instanceof CodecOutputList) &#123;   //都单个单个的发送</div><div class=\"line\">           fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           for (int i = 0; i &lt; numElements; i++) &#123;</div><div class=\"line\">               ctx.fireChannelRead(msgs.get(i));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出实际也是每个帧单独向上发送的。</p>\n<h1 id=\"LengthFieldBasedFrameDecoder\"><a href=\"#LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"LengthFieldBasedFrameDecoder\"></a>LengthFieldBasedFrameDecoder</h1><p>LengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<object> out)即可: 从原始byte in中解析出一个帧, 放入out中。<br>我们需要理解几个属性的函数:</object></p>\n<ul>\n<li>maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。</li>\n<li>lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。</li>\n<li>lengthFieldLength: 定义帧长度的字段本身的长度。</li>\n<li>lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉</li>\n<li>initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分</li>\n<li>failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。</li>\n<li>discardingTooLongFrame: 当帧解析出来的帧内容长度 &gt; maxFrameLength时,并且剩余缓存可读字段 &lt; 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。</li>\n<li>tooLongFrameLength: 超过长度限制maxFrameLength的帧长度</li>\n<li>bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容<br>关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"><br>也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\" target=\"_blank\" rel=\"external\"> 参考/a&gt;<br>其中:</a></li>\n<li>head1和head2可以由用户自定义语义。</li>\n<li>有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength<br>解码函数如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (discardingTooLongFrame) &#123;//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢</div><div class=\"line\">     long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度</div><div class=\"line\">     int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数</div><div class=\"line\">     in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度</div><div class=\"line\">     bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度</div><div class=\"line\">     this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度</div><div class=\"line\">     failIfNecessary(false);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回</div><div class=\"line\"> if (in.readableBytes() &lt; lengthFieldEndOffset) &#123;//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码</div><div class=\"line\">     return null; //当前帧没有value</div><div class=\"line\"> &#125;</div><div class=\"line\">// 拿到长度字段的起始偏移量index</div><div class=\"line\"> int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置</div><div class=\"line\"> long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度</div><div class=\"line\"> if (frameLength &lt; 0) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;negative pre-adjustment length field: &quot; + frameLength);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)</div><div class=\"line\"> frameLength += lengthAdjustment + lengthFieldEndOffset;</div><div class=\"line\"> if (frameLength &lt; lengthFieldEndOffset) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);//当前帧忽略过</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than lengthFieldEndOffset: &quot; + lengthFieldEndOffset);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。</div><div class=\"line\"> if (frameLength &gt; maxFrameLength) &#123;</div><div class=\"line\">     long discard = frameLength - in.readableBytes();//前面</div><div class=\"line\">     tooLongFrameLength = frameLength;</div><div class=\"line\">     // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">     if (discard &lt; 0) &#123;// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">         // buffer contains more bytes then the frameLength so we can discard all now</div><div class=\"line\">         in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Enter the discard mode and discard everything received so far.</div><div class=\"line\">         discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧</div><div class=\"line\">         bytesToDiscard = discard;</div><div class=\"line\">         in.skipBytes(in.readableBytes());//丢弃整个帧</div><div class=\"line\">     &#125;</div><div class=\"line\">     failIfNecessary(true);</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> // never overflows because it&apos;s less than maxFrameLength</div><div class=\"line\"> int frameLengthInt = (int) frameLength;</div><div class=\"line\"> if (in.readableBytes() &lt; frameLengthInt) &#123;  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> if (initialBytesToStrip &gt; frameLengthInt) &#123;</div><div class=\"line\">     in.skipBytes(frameLengthInt);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than initialBytesToStrip: &quot; + initialBytesToStrip);</div><div class=\"line\"> &#125;</div><div class=\"line\"> in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content</div><div class=\"line\"> // extract frame</div><div class=\"line\"> int readerIndex = in.readerIndex();</div><div class=\"line\"> int actualFrameLength = frameLengthInt - initialBytesToStrip;</div><div class=\"line\"> ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);</div><div class=\"line\"> in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置</div><div class=\"line\"> return frame;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要操作如下:<br>1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void failIfNecessary(boolean firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">        if (bytesToDiscard == 0) &#123; //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态</div><div class=\"line\">            // Reset to the initial state and tell the handlers that</div><div class=\"line\">            // the frame was too large.</div><div class=\"line\">            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度</div><div class=\"line\">            this.tooLongFrameLength = 0; //主要是复位</div><div class=\"line\">            discardingTooLongFrame = false;</div><div class=\"line\">            if (!failFast || firstDetectionOfTooLongFrame) &#123;// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理</div><div class=\"line\">                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;  //第一次遇到，发现当前帧长度太长了</div><div class=\"line\">            // Keep discarding and notify handlers if necessary.</div><div class=\"line\">            if (failFast &amp;&amp; firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">                fail(tooLongFrameLength); //是第一次遇到，直接丢失</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。</li>\n<li>反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。<br>2) 若当前缓存可读byte &lt; 长度偏移量, 直接退出继续, 数据仍然放在了缓存。<br>3) 计算出帧整体的长度,包括了length + head2 + content:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameLength += lengthAdjustment + lengthFieldEndOffset;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>4) 检查帧frameLength是否超过的阈值,若超过了:</p>\n<ul>\n<li>检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度</li>\n<li>否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。<br>并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。<br>5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。<br>6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"零拷贝\"><a href=\"#零拷贝\" class=\"headerlink\" title=\"零拷贝\"></a>零拷贝</h2><p>Netty的“零拷贝”主要体现以下几个方面(<a href=\"http://www.infoq.com/cn/articles/netty-high-performance?utm_source=infoq&utm_medium=popular_links...\" target=\"_blank\" rel=\"external\">参考</a>)：<br>1.Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中(内存拷贝)，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。<br>2.Netty 提供了 CompositeByteBuf 类, 它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf, 避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。<br>3.通过 FileRegion 包装的FileChannel.tranferTo方法 实现文件传输, 可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环write方式导致的内存拷贝问题。<br>4.通过 wrap 操作, 我们可以将 byte[] 数组、ByteBuf、ByteBuffer等包装成一个 Netty ByteBuf 对象, 进而避免了拷贝操作。</p>\n<h2 id=\"编解码处理器\"><a href=\"#编解码处理器\" class=\"headerlink\" title=\"编解码处理器\"></a>编解码处理器</h2><p>编码与解码器原理相同, 只是做的工作相反, 这里以分析解码器ChannelInboundHandlerAdapter为例<br>解码处理器目前接触比较多的两种:</p>\n<ul>\n<li>ByteToMessageDecoder<br>ByteToMessageDecoder解码器主要将接收的byte位按照定义的帧的结构从原始byte中解析出来, 成为一个个独立的Message(帧/数据报), 常见的比如LengthFieldBasedFrameDecoder。</li>\n<li>MessageToMessageDecoder<br>MessageToMessageDecoder解码器主要将一个个独立的独立的Message, 根据定义的解码规则, 赋予具体的寓意, 比如将整个byte解析成string类型(StringDecoder)等。</li>\n</ul>\n<h2 id=\"代码引入\"><a href=\"#代码引入\" class=\"headerlink\" title=\"代码引入\"></a>代码引入</h2><p>需要再次强调的是, 此时pipeline链上的处理上下文: HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.<br>在<a href=\"https://kkewwei.github.io/elasticsearch_learning/2018/01/22/NioEventLoop%E7%AF%87/\">NioEventLoop篇</a>说到, 关于IO SelectionKey.OP_READ类型的任务, 当接收到了数据, 会从unsafe.read()进入到如下代码中(实际调用NioByteUnsafe.read()):<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">    public final void read() &#123;</div><div class=\"line\">        final ChannelConfig config = config();</div><div class=\"line\">        final ChannelPipeline pipeline = pipeline();</div><div class=\"line\">        final ByteBufAllocator allocator = config.getAllocator();</div><div class=\"line\">        final RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();//// allocHandle主要用于预估本次ByteBuf的初始大小，避免分配太多导致浪费或者分配过小放不下单次读取的数据而需要多次读取</div><div class=\"line\">        allocHandle.reset(config);</div><div class=\"line\">        ByteBuf byteBuf = null;</div><div class=\"line\">        boolean close = false;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            do &#123;</div><div class=\"line\">                byteBuf = allocHandle.allocate(allocator);</div><div class=\"line\">                allocHandle.lastBytesRead(doReadBytes(byteBuf));</div><div class=\"line\">                if (allocHandle.lastBytesRead() &lt;= 0) &#123; // 未读取到数据则直接释放该ByteBuf,如果返回-1表示读取出错，后面会关闭该连接</div><div class=\"line\">                    // nothing was read. release the buffer.</div><div class=\"line\">                    byteBuf.release();</div><div class=\"line\">                    byteBuf = null;</div><div class=\"line\">                    close = allocHandle.lastBytesRead() &lt; 0;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                allocHandle.incMessagesRead(1);</div><div class=\"line\">                readPending = false;</div><div class=\"line\">                pipeline.fireChannelRead(byteBuf);</div><div class=\"line\">                byteBuf = null;</div><div class=\"line\">            &#125; while (allocHandle.continueReading());</div><div class=\"line\">            allocHandle.readComplete();//记录本次读取到的数据长度（用于计算下次分配ByteBuf时的初始化大小）</div><div class=\"line\">            pipeline.fireChannelReadComplete();// 本轮数据读取完毕</div><div class=\"line\">            if (close) &#123;// 如果读取的时候发生错误则关闭连接</div><div class=\"line\">                closeOnRead(pipeline);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; catch (Throwable t) &#123;</div><div class=\"line\">            handleReadException(pipeline, byteBuf, t, close, allocHandle);</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里分配的内存是直接内存。当读取完一次数据后, 通过pipeline.fireChannelReadComplete()向下传递, HeadContext做的事仅仅是找到下一个属性为IN的Context(EncoderContext). 一般对应的handler为ByteToMessageDecoder类解码器, 本文以LengthFieldBasedFrameDecoder来分析。</p>\n<h1 id=\"ByteToMessageDecoder\"><a href=\"#ByteToMessageDecoder\" class=\"headerlink\" title=\"ByteToMessageDecoder\"></a>ByteToMessageDecoder</h1><p>属性cumulation存放的是之前没有解析完成的数据, 作为缓存和下次接收的数据一起解析。<br>回到代码里, 需要关注channelRead:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</div><div class=\"line\">        if (msg instanceof ByteBuf) &#123;    //PoolUnsafeDirectByteBuf</div><div class=\"line\">            CodecOutputList out = CodecOutputList.newInstance();//创建解码消息List存放集合</div><div class=\"line\">            try &#123;</div><div class=\"line\">                ByteBuf data = (ByteBuf) msg;  //data = PoolUnsafeDirectByteBuf</div><div class=\"line\">                first = cumulation == null;</div><div class=\"line\">                if (first) &#123;</div><div class=\"line\">                    cumulation = data;</div><div class=\"line\">                &#125; else &#123;</div><div class=\"line\">                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data); // cumulator = MERGE_CUMULATOR</div><div class=\"line\">                &#125;</div><div class=\"line\">                callDecode(ctx, cumulation, out);</div><div class=\"line\">            &#125; catch (DecoderException e) &#123;</div><div class=\"line\">                throw e;</div><div class=\"line\">            &#125; catch (Throwable t) &#123;</div><div class=\"line\">                throw new DecoderException(t);</div><div class=\"line\">            &#125; finally &#123;//如果累积对象中没有数据了(因为所有发送的数据刚刚好n个msg)</div><div class=\"line\">                if (cumulation != null &amp;&amp; !cumulation.isReadable()) &#123;</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    cumulation.release();</div><div class=\"line\">                    cumulation = null;</div><div class=\"line\">                &#125; else if (++ numReads &gt;= discardAfterReads) &#123;</div><div class=\"line\">                    // We did enough reads already try to discard some bytes so we not risk to see a OOME.</div><div class=\"line\">                    // See https://github.com/netty/netty/issues/4275</div><div class=\"line\">                    numReads = 0;</div><div class=\"line\">                    discardSomeReadBytes();</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">                int size = out.size();</div><div class=\"line\">                decodeWasNull = !out.insertSinceRecycled();</div><div class=\"line\">                fireChannelRead(ctx, out, size); //针对解析后的out结果，逐个调用message</div><div class=\"line\">                out.recycle();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            ctx.fireChannelRead(msg);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事情:<br>1) 首先判断msg是否为ByteBuf: 若不是, 则说明此轮传递的不是数据解码, 继续向外传递。<br>2) 如果cumulation为空, 说明之前解析的帧与数据长度恰好吻合, 没有剩余数据需要下次拼接解析的, 否则, 需要将上次剩余的cumulation与新接收的ByteBuf合成一个新的ByteBuf继续解析。合成器默认为MERGE_CUMULATOR。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">       public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) &#123;  //alloc: PooledByteBufAllocator(directe:true) , cumulation = PooledUnsafeDirectByteBuf</div><div class=\"line\">           final ByteBuf buffer;</div><div class=\"line\">           if (cumulation.writerIndex() &gt; cumulation.maxCapacity() - in.readableBytes()</div><div class=\"line\">                   || cumulation.refCnt() &gt; 1 || cumulation.isReadOnly()) &#123;</div><div class=\"line\">               // Expand cumulation (by replace it) when either there is not more room in the buffer</div><div class=\"line\">               // or if the refCnt is greater then 1 which may happen when the user use slice().retain() or</div><div class=\"line\">               // duplicate().retain() or if its read-only.</div><div class=\"line\">               //</div><div class=\"line\">               // See:</div><div class=\"line\">               // - https://github.com/netty/netty/issues/2327</div><div class=\"line\">               // - https://github.com/netty/netty/issues/1764</div><div class=\"line\">               buffer = expandCumulation(alloc, cumulation, in.readableBytes());</div><div class=\"line\">           &#125; else &#123;</div><div class=\"line\">               buffer = cumulation;</div><div class=\"line\">           &#125;</div><div class=\"line\">           buffer.writeBytes(in); //将新的数据，写入这个cumulation</div><div class=\"line\">           in.release();  //释放资源</div><div class=\"line\">           return buffer;</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先判断目前的cumulation最大容器能否装的下即将合成的缓存, 实际上cumulation.maxCapacity()的取值非常大(2147483647), 如果装不下的, 需要申请新的缓存区域:expandCumulation<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ByteBuf oldCumulation = cumulation;</div><div class=\"line\">     cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);//重新生成一个新的缓存区， 注意这里的参数是长度，而没有数据的数据</div><div class=\"line\">     cumulation.writeBytes(oldCumulation);  //会跑到AbstractByteBuf.writeBytes()里面，向新的cumulation写回旧的数据</div><div class=\"line\">     oldCumulation.release(); //释放旧的缓冲区</div><div class=\"line\">     return cumulation;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>cumulation = alloc.buffer(size)可以看出是新生成的缓存与之前缓存区域毫不相关(根据size申请的), 会将新旧缓存放入同一个最新的缓存cumulation。<br>3) 解码callDecode<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">while (in.isReadable()) &#123;</div><div class=\"line\">   int outSize = out.size();</div><div class=\"line\">   if (outSize &gt; 0) &#123; //out为经过转码形成帧的的数据</div><div class=\"line\">       fireChannelRead(ctx, out, outSize);//每当读取到帧了，就会立刻向上发送解析好的帧，看情况解析出来一个，发送一个</div><div class=\"line\">       out.clear();</div><div class=\"line\">       outSize = 0;</div><div class=\"line\">   &#125;</div><div class=\"line\">   int oldInputLength = in.readableBytes();  //24</div><div class=\"line\">   decodeRemovalReentryProtection(ctx, in, out);  //这里会循环的调用解码decode</div><div class=\"line\">   if (outSize == out.size()) &#123; //decode没有解析出东西</div><div class=\"line\">       if (oldInputLength == in.readableBytes()) &#123; //没有读取到任何东西，可能帧显示的长度大于实际的位数，没有数据了, 需要下次接受的数据补齐</div><div class=\"line\">           break;</div><div class=\"line\">       &#125; else &#123; //还是向前消费了许多东西，可能读到了坏的帧，丢弃了</div><div class=\"line\">           continue;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div><div class=\"line\">   if (oldInputLength == in.readableBytes()) &#123;  //说明outSize &lt; out.size(),读取到新的帧了，但是指针还没有向前进，哪里有问题</div><div class=\"line\">       throw new DecoderException(</div><div class=\"line\">               StringUtil.simpleClassName(getClass()) +</div><div class=\"line\">                       &quot;.decode() did not read anything but decoded a message.&quot;);</div><div class=\"line\">   &#125;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>首先查看是否解析出来了数据报(帧), 若解析出来了, 则通过fireChannelRead向上传递。</li>\n<li>开始这轮真正的数据解析工作, decodeRemovalReentryProtection里面需要注意decode函数, 在<code>LengthFieldBasedFrameDecoder</code>里实现。</li>\n<li>对这轮解析结果进行分析:<br>   若没有解析出数据, 说明缓存区域没有消费数据, 显示的帧长度大于实际拥有的数据量, 此时会将数据缓存起来放入cumulation, 等待下次接收到数据后一起解析。<br>   若没有解析出数据, 说明可能存在损坏的帧, 解码时候把废弃的帧给丢弃了。<br>   若解析出来的数据, 但是却没有消费数据, 说明出现了问题, 向外抛出异常。<br>4) 检查是否还有帧可以继续向上传递。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">static void fireChannelRead(ChannelHandlerContext ctx, List&lt;Object&gt; msgs, int numElements) &#123;</div><div class=\"line\">       if (msgs instanceof CodecOutputList) &#123;   //都单个单个的发送</div><div class=\"line\">           fireChannelRead(ctx, (CodecOutputList) msgs, numElements);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           for (int i = 0; i &lt; numElements; i++) &#123;</div><div class=\"line\">               ctx.fireChannelRead(msgs.get(i));</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看出实际也是每个帧单独向上发送的。</p>\n<h1 id=\"LengthFieldBasedFrameDecoder\"><a href=\"#LengthFieldBasedFrameDecoder\" class=\"headerlink\" title=\"LengthFieldBasedFrameDecoder\"></a>LengthFieldBasedFrameDecoder</h1><p>LengthFieldBasedFrameDecoder作为ByteToMessageDecoder的父类, 它只用定义具体的规则, 如何拆分byte成为每一个个数据报(帧), 也就是只用实现protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<object> out)即可: 从原始byte in中解析出一个帧, 放入out中。<br>我们需要理解几个属性的函数:</object></p>\n<ul>\n<li>maxFrameLength: 定义了每个帧的最大长度, 超过此长度的帧将作为废弃数据直接丢弃掉。</li>\n<li>lengthFieldOffset:  帧长度位置的偏移量(起始位置), 情况:帧的第一个部分不是长度字段。</li>\n<li>lengthFieldLength: 定义帧长度的字段本身的长度。</li>\n<li>lengthAdjustment:  数据内容长度需需要调整的长度, 情况: 帧的长度还可能包含了部分不属于帧内容字段长度, 需要把这部分长度给去掉</li>\n<li>initialBytesToStrip:  解析时候, 需要跳过的长度, 以进入到帧的数据部分</li>\n<li>failFast: 当解析出的帧内容长度大于阈值, 是否立即抛出异常,默认为false, 建议不要修改。 当设置为true后, 把该帧全部内容丢弃后再抛出异常。</li>\n<li>discardingTooLongFrame: 当帧解析出来的帧内容长度 &gt; maxFrameLength时,并且剩余缓存可读字段 &lt; 解析的帧长度, 需要discardingTooLongFrame置位true,  意味着下次接收的帧需要继续丢弃,当前帧处于丢弃模式。</li>\n<li>tooLongFrameLength: 超过长度限制maxFrameLength的帧长度</li>\n<li>bytesToDiscard: 对于下次接收的数据中需要继续丢弃的byte长度。 当接收的帧长度大于阈值, 会丢弃该帧及内容<br>关系如下:<img src=\"http://owsl7963b.bkt.clouddn.com/Thrift%E5%B8%A7.png\"><br>也可<a href=\"https://blog.csdn.net/u010853261/article/details/55803933\" target=\"_blank\" rel=\"external\"> 参考/a&gt;<br>其中:</a></li>\n<li>head1和head2可以由用户自定义语义。</li>\n<li>有的人会想, initialBytesToStrip、lengthFieldOffset、lengthFieldLength这三个属性有一定的关系, 还为啥会当把三个参数都传递进来, 我想设计者是为了给使用者更大的灵活性,比如 lengthFieldLength后面专门空几个byte啥都不干放着也是行的, 一般initialBytesToStrip = lengthFieldOffset+lengthFieldLength<br>解码函数如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (discardingTooLongFrame) &#123;//如果当前的编码器处于丢弃超长帧的状态，上一个包最后一个帧还有东西要丢弃，要对当前包接着丢</div><div class=\"line\">     long bytesToDiscard = this.bytesToDiscard; //获取需要丢弃的长度</div><div class=\"line\">     int localBytesToDiscard = (int) Math.min(bytesToDiscard, in.readableBytes());//丢弃的长度不能超过当前缓冲区可读的字节数</div><div class=\"line\">     in.skipBytes(localBytesToDiscard);//跳过需要忽略的字节长度</div><div class=\"line\">     bytesToDiscard -= localBytesToDiscard;////bytesToDiscard减去已经忽略的字节长度</div><div class=\"line\">     this.bytesToDiscard = bytesToDiscard; //下轮还需要忽略的长度</div><div class=\"line\">     failIfNecessary(false);</div><div class=\"line\"> &#125;</div><div class=\"line\"> //对当前缓冲区中可读字节数和长度偏移量进行对比，如果小于偏移量，谁明缓冲区数据报内容没有，直接返回</div><div class=\"line\"> if (in.readableBytes() &lt; lengthFieldEndOffset) &#123;//数据报内数据不够，返回null，由IO线程继续读取数据，此轮不解码</div><div class=\"line\">     return null; //当前帧没有value</div><div class=\"line\"> &#125;</div><div class=\"line\">// 拿到长度字段的起始偏移量index</div><div class=\"line\"> int actualLengthFieldOffset = in.readerIndex() + lengthFieldOffset;  //长度域终点位置</div><div class=\"line\"> long frameLength = getUnadjustedFrameLength(in, actualLengthFieldOffset, lengthFieldLength, byteOrder);/// 拿到实际的未调整过的内容长度</div><div class=\"line\"> if (frameLength &lt; 0) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;negative pre-adjustment length field: &quot; + frameLength);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // frameLength = (head1_length+length_length)(lengthFieldEndOffset)+head2_length(lengthAdjustment)+content_length(frameLength)</div><div class=\"line\"> frameLength += lengthAdjustment + lengthFieldEndOffset;</div><div class=\"line\"> if (frameLength &lt; lengthFieldEndOffset) &#123;</div><div class=\"line\">     in.skipBytes(lengthFieldEndOffset);//当前帧忽略过</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than lengthFieldEndOffset: &quot; + lengthFieldEndOffset);</div><div class=\"line\"> &#125;</div><div class=\"line\"> // 数据帧长长度超出最大帧长度，说明这个帧当前帧不合法， 需要丢弃当前帧，跳到包里下一个帧里面。</div><div class=\"line\"> if (frameLength &gt; maxFrameLength) &#123;</div><div class=\"line\">     long discard = frameLength - in.readableBytes();//前面</div><div class=\"line\">     tooLongFrameLength = frameLength;</div><div class=\"line\">     // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">     if (discard &lt; 0) &#123;// // 当前可读字节已达到frameLength，直接跳过frameLength个字节，丢弃之后，后面有可能就是一个合法的数据包</div><div class=\"line\">         // buffer contains more bytes then the frameLength so we can discard all now</div><div class=\"line\">         in.skipBytes((int) frameLength);//丢弃当前不合法帧，直接跳到包里下一个帧里面</div><div class=\"line\">     &#125; else &#123;</div><div class=\"line\">         // Enter the discard mode and discard everything received so far.</div><div class=\"line\">         discardingTooLongFrame = true;//下个报接着丢上一个报最后一个帧</div><div class=\"line\">         bytesToDiscard = discard;</div><div class=\"line\">         in.skipBytes(in.readableBytes());//丢弃整个帧</div><div class=\"line\">     &#125;</div><div class=\"line\">     failIfNecessary(true);</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> // never overflows because it&apos;s less than maxFrameLength</div><div class=\"line\"> int frameLengthInt = (int) frameLength;</div><div class=\"line\"> if (in.readableBytes() &lt; frameLengthInt) &#123;  //什么都没有读取到，而且in指针也没有向前去，后面将退出，不会在继续循环</div><div class=\"line\">     return null;</div><div class=\"line\"> &#125;</div><div class=\"line\"> if (initialBytesToStrip &gt; frameLengthInt) &#123;</div><div class=\"line\">     in.skipBytes(frameLengthInt);</div><div class=\"line\">     throw new CorruptedFrameException(</div><div class=\"line\">             &quot;Adjusted frame length (&quot; + frameLength + &quot;) is less &quot; +</div><div class=\"line\">             &quot;than initialBytesToStrip: &quot; + initialBytesToStrip);</div><div class=\"line\"> &#125;</div><div class=\"line\"> in.skipBytes(initialBytesToStrip); //这段值已经读取出来了（长度），后续都是head2+content</div><div class=\"line\"> // extract frame</div><div class=\"line\"> int readerIndex = in.readerIndex();</div><div class=\"line\"> int actualFrameLength = frameLengthInt - initialBytesToStrip;</div><div class=\"line\"> ByteBuf frame = extractFrame(ctx, in, readerIndex, actualFrameLength);</div><div class=\"line\"> in.readerIndex(readerIndex + actualFrameLength);  //设置可读位置</div><div class=\"line\"> return frame;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要操作如下:<br>1) 如果当前处于丢弃模式(discardingTooLongFrame), 若是,那么继续丢弃还需要丢弃的byte, 并且检查是否该抛出异常:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void failIfNecessary(boolean firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">        if (bytesToDiscard == 0) &#123; //不是第一次遇到，就是说下次编码的时候不需要丢弃了，说明这个超长帧读取完毕，那么将这个编码器的状态设置为非丢弃超长帧状态</div><div class=\"line\">            // Reset to the initial state and tell the handlers that</div><div class=\"line\">            // the frame was too large.</div><div class=\"line\">            long tooLongFrameLength = this.tooLongFrameLength; //超过限制的帧长度</div><div class=\"line\">            this.tooLongFrameLength = 0; //主要是复位</div><div class=\"line\">            discardingTooLongFrame = false;</div><div class=\"line\">            if (!failFast || firstDetectionOfTooLongFrame) &#123;// 如果没有设置快速失败，或者设置了快速失败并且是第一次检测到大包错误，抛出异常，让handler去处理</div><div class=\"line\">                fail(tooLongFrameLength); //bytesToDiscard，最起码不是第一次，bytesToDiscard为0.直接丢弃</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; else &#123;  //第一次遇到，发现当前帧长度太长了</div><div class=\"line\">            // Keep discarding and notify handlers if necessary.</div><div class=\"line\">            if (failFast &amp;&amp; firstDetectionOfTooLongFrame) &#123;</div><div class=\"line\">                fail(tooLongFrameLength); //是第一次遇到，直接丢失</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>当上一个帧需要丢弃content全部丢弃完了, 那么就直接抛出异常。failFast肯定为false,因为bytesToDiscard, 就说明此次不是最开始遇见超过阈值长度的帧。</li>\n<li>反之, 说明是首次发现帧太长了, 需要丢弃。failFast肯定为true。<br>2) 若当前缓存可读byte &lt; 长度偏移量, 直接退出继续, 数据仍然放在了缓存。<br>3) 计算出帧整体的长度,包括了length + head2 + content:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">frameLength += lengthAdjustment + lengthFieldEndOffset;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>4) 检查帧frameLength是否超过的阈值,若超过了:</p>\n<ul>\n<li>检查当前缓存可读数据是否够length长度丢弃, 若够的话, 缓存可读区域向前移动frameLength长度</li>\n<li>否则, 进入丢弃模式: discardingTooLongFrame设置为true、记录下次需要丢弃的长度。<br>并运行failIfNecessary, 检查是现在立刻抛出异常, 还是等下轮丢弃完再抛。<br>5) 检查当前缓存可读长度是否超过frameLength, 若没有的话, 说明当前帧长度超过了发送的长度限制(默认1024bit), 当前帧被多次发送了, 这里解析函数就直接退出。下次接收的数据会自动累加到当前可读数据上,等待下次再解析出这个帧。<br>6) 跳过initialBytesToStrip, 并开始读取相应的帧内容, 并向上传递该帧内容。</li>\n</ul>\n"},{"title":"NioEventLoop篇","date":"2018-01-22T00:53:40.000Z","_content":"# 介绍\n在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:\n```\n            ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {...}\n            });\n```\n调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:\n```\n public void execute(Runnable task) {\n        boolean inEventLoop = inEventLoop();\n        if (inEventLoop) {\n            addTask(task);\n        } else {\n            startThread();\n            addTask(task);\n            if (isShutdown() && removeTask(task)) {\n                reject();\n            }\n        }\n        if (!addTaskWakesUp && wakesUpForTask(task)) {\n            wakeup(inEventLoop);\n        }\n    }\n```\n首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。\n## startThread\nstartThread用来启动NioEventLoop里面的执行线程,代码如下:\n```\n  executor.execute(new Runnable() { //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动\n            @Override\n            public void run() {\n                thread = Thread.currentThread(); //获取当前这个线程\n                if (interrupted) {\n                    thread.interrupt();\n                }\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环\n                    success = true;\n                } catch (Throwable t) {\n                }\n```\nexecutor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。\n\n\n# NioEventLoop\ntask分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。\n+ 非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头`ch.eventLoop().execute`)\n+ IO型: Accetp、Write、read等从远程节点发送过来的请求。\n\n为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:\n+ 若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。\n+ 若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。\n\nNioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:\n\n```\n  @Override\n    protected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n                        // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                        // before calling 'selector.wakeup()' to reduce the wake-up\n                        // overhead. (Selector.wakeup() is an expensive operation.)\n                        //\n                        // However, there is a race condition in this approach.\n                        // The race condition is triggered when 'wakenUp' is set to\n                        // true too early.\n                        //\n                        // 'wakenUp' is set to true too early if:\n                        // 1) Selector is waken up between 'wakenUp.set(false)' and\n                        //    'selector.select(...)'. (BAD)\n                        // 2) Selector is waken up between 'selector.select(...)' and\n                        //    'if (wakenUp.get()) { ... }'. (OK)\n                        //\n                        // In the first case, 'wakenUp' is set to true and the\n                        // following 'selector.select(...)' will wake up immediately.\n                        // Until 'wakenUp' is set to false again in the next round,\n                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                        // any attempt to wake up the Selector will fail, too, causing\n                        // the following 'selector.select(...)' call to block\n                        // unnecessarily.\n                        //\n                        // To fix this problem, we wake up the selector again if wakenUp\n                        // is true immediately after selector.select(...).\n                        // It is inefficient in that it wakes up the selector for both\n                        // the first case (BAD - wake-up required) and the second case\n                        // (OK - no wake-up required).\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                        // fallthrough\n                }\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\nselector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()\nNioEventLoop.run()部分的逻辑还是比较清楚:\n(1) 检查是否累计有task:\n```\n@Override\n    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {\n        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要\n    }\n```\n进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:\n```\nint selectNow() throws IOException {//相当于复写了NIO的select函数\n        try {\n            return selector.selectNow(); //返回的0, 直接跳出switch循环\n        } finally {\n            // restore wakeup state if needed\n            if (wakenUp.get()) {\n                selector.wakeup();\n            }\n        }\n    }\n```\n若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。\n(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。\nwakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:\n```\nprivate void select(boolean oldWakenUp) throws IOException {\n        Selector selector = this.selector;\n        try {\n            int selectCnt = 0;\n            long currentTimeNanos = System.nanoTime();\n            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间\n            for (;;) {  //timeoutMillis下次等待需要的时间\n                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns\n                if (timeoutMillis <= 0) {//距离第一个执行计划开始时间已经过了（1ms）\n                    if (selectCnt == 0) { //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()\n                        selector.selectNow();\n                        selectCnt = 1;\n                    }\n                    break;\n                }\n                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call\n                // Selector#wakeup. So we need to check task queue again before executing select operation.\n                // If we don't, the task might be pended until select operation was timed out.\n                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.\n                if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                int selectedKeys = selector.select(timeoutMillis);\n                selectCnt ++;\n                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环\n                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                    // - Selected something,\n                    // - waken up by user, or\n                    // - the task queue has a pending task.\n                    // - a scheduled task is ready for processing\n                    break;\n                }\n                long time = System.nanoTime();//selector.select(timeoutMillis);\n                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                    // timeoutMillis elapsed without anything selected.\n                    selectCnt = 1;\n                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                        selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。\n                    // The selector returned prematurely many times in a row.\n                    // Rebuild the selector to work around the problem.\n                    rebuildSelector();\n                    selector = this.selector;\n                    // Select again to populate selectedKeys.\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                currentTimeNanos = time;\n            }\n\n        } catch (CancelledKeyException e) {\n        }\n    }\n\n```\n可以看出代码做了如下事情:\n2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时\n如果当前时间 > 截止时间 + 0.5ms的话,就立刻退出执行task。\n2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。\n+ 此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。\n+ 若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。\n别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:\n ```\nprotected void wakeup(boolean inEventLoop) { //inEventLoop说的是NioEventLoop还没有启动\n        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n            selector.wakeup();\n        }\n    }\n ```\n 当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。\n2.3 执行selector.select(timeoutMillis)\n+ 若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。\n+ 若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。\n+ 若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。\n\n2.4 检查是否需要跳出循环:\n+ 有IO task了\n+ 上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。\n+ 此轮有task处于penging.\n+ 有schedule task截止时间已经到了。\nselect(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。\n这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:\n```\nivate void rebuildSelector0() {\n        newSelectorTuple = openSelector();//打开一个新的Selector\n        // Register all channels to the new Selector.\n        int nChannels = 0;\n        for (SelectionKey key: oldSelector.keys()) {////SelectionKey无效或者已经注册上了则跳过\n            Object a = key.attachment();\n            try {\n                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {\n                    continue;\n                }\n                int interestOps = key.interestOps();\n                key.cancel();//取消SelectionKey\n                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);\n            }\n        }\n        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector\n        unwrappedSelector = newSelectorTuple.unwrappedSelector;\n```\n主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。\n如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过`SELECTOR_AUTO_REBUILD_THRESHOLD`则说明触发了, 默认为512次。\n\nselect(wakenUp.getAndSet(false))完成后,会有这段代码\n```\nif (wakenUp.get()) {\n        selector.wakeup(); //下次\n }\n```\n参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。\n假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:\n```\nif (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n```\n那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -> 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)\n```\n     if (hasTasks() && wakenUp.compareAndSet(false, true)) {//若果当前有task，并且是可以叫醒的，则中断selector.select\n                    selector.selectNow();//selectNow()返回，否则会耽误任务执行\n                    selectCnt = 1;   //\n                    break;\n                }\n```\n\n只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。\n所以说, 那部分代码是没有没有意义的。\n\n(3) 开始执行IO task和非IO task\n前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。\n## IO任务执行processSelectedKeysPlain\nprocessSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:\n```\n        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n        eventLoop = ch.eventLoop();\n        try {\n            int readyOps = k.readyOps();\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n                unsafe.finishConnect();\n            }\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) { //如果是写\n                ch.unsafe().forceFlush();\n            }\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read(); //这里很重要，NioMessageUnsafe\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n```\n这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)\n ###  SelectionKey.OP_ACCEPT部分\n 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面\n```\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config(); //NioServerSocketChannelConf\n            final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline\n            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n            allocHandle.reset(config);\n\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    do { //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法\n                        int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        allocHandle.incMessagesRead(localRead);\n                    } while (allocHandle.continueReading()); //当前连接是否该继续\n                } catch (Throwable t) {\n                    exception = t;\n                }\n\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n                    readPending = false;//// 对每个连接调用pipeline的fireChannelRead\n                    pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面\n                }\n                readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf\n                allocHandle.readComplete();\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    inputShutdown = true;\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                // Check if there is a readPending which was not processed yet.\n                // This could be for two reasons:\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n                //\n                // See https://github.com/netty/netty/issues/2254\n                if (!readPending && !config.isAutoRead()) {\n                    removeReadOp();\n                }\n            }\n```\n1. 循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:\n```\n         SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，\n        try {\n            if (ch != null) {\n                buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel\n                return 1;\n            }\n        } catch (Throwable t) {\n        }\n\n        return 0;\n```\n同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个\nSocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。\nNioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:\n```\n         this.parent = parent; //NioServerSocketChannel\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。\n```\n\n2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。\n初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:\n ```\npublic final ChannelPipeline fireChannelRead(Object msg) { //msg是新建立的SocketChannel\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了\n        return this;\n    }\n```\n读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以`static`注释的。\n```\n static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { ////msg是新建立的NioSocketChannel\n        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next); //pipe是同一个，\n        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为\n        if (executor.inEventLoop()) { //本线程是否是EventLoop线程\n            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类\n        } else {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    next.invokeChannelRead(m);\n                }\n            });\n        }\n    }\n````\n2.1 会以根据HeadContext开始讲起:\n+ 首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。\n```\n public EventExecutor executor() {  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop\n        if (executor == null) {\n            return channel().eventLoop();\n        } else {\n            return executor;\n        }\n    }\n\n```\n+ 确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的`static void invokeChannelRead`\nstatic void invokeChannelRead\n```\n private AbstractChannelHandlerContext findContextInbound() { //从Head当前位置找，直到向后找到一个inbound的，就退出\n        AbstractChannelHandlerContext ctx = this;\n        do {\n            ctx = ctx.next;//直接找下一个\n        } while (!ctx.inbound);\n        return ctx;\n    }\n```\n到第二个Context, 其中会执行`((ChannelInboundHandler) handler()).channelRead(this, msg)`, 即ServerBootstrapAcceptor.channelRead(), 如下所示:\n```\n public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            final Channel child = (Channel) msg; //// child = NioSocketChannel\n            child.pipeline().addLast(childHandler);\n            setChannelOptions(child, childOptions, logger);\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n            try {  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接\n                childGroup.register(child).addListener(new ChannelFutureListener() {   ///这里使用的是childGroup\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) { //如果有连接完成，但是失败的情况下\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n            }\n```\n主要做的事:\n+ 其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.\n+ 从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。\n+ 当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。\n\n其中第二步骤, 注册的代码在`ServerBootStrap初始篇`中已经展示, 为了讲解方便在此再次罗列:\n```\n                 boolean firstRegistration = neverRegistered;\n                doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中\n                neverRegistered = false;\n                registered = true;// register状态设置为true，\n\n                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n                // user may already fire events through the pipeline in the ChannelFutureListener.\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0->accept\n                pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n```\n其中需要注意的是:\n+ invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:\nHeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n+ 会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:\n```\n public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireChannelActive();\n\n            readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性\n        }\n```\nctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin\n```\n@Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。\n### SelectionKey.OP_READ\n 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在`Netty通信编解码源码解读`讲解。\n\n## 执行非IO Task.\n进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:\n```\nprotected boolean runAllTasks(long timeoutNanos) {//处理非I/O任务。\n        fetchFromScheduledTaskQueue();\n        Runnable task = pollTask();//从\n        if (task == null) {\n            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()\n            return false;\n        }\n        //截止时间=ScheduledFutureTask当前相对时间+ 超时\n        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;\n        long runTasks = 0;\n        long lastExecutionTime;\n        for (;;) {\n            safeExecute(task);  //顺序执行所有task\n\n            runTasks ++;\n\n            // Check timeout every 64 tasks because nanoTime() is relatively expensive.\n            // XXX: Hard-coded value - will make it configurable if it is really a problem.\n            if ((runTasks & 0x3F) == 0) {  //当64个task后\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                if (lastExecutionTime >= deadline) {//当前时间超过截止时间，那么就退出\n                    break;\n                }\n            }\n\n            task = pollTask();\n            if (task == null) {\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                break;\n            }\n        }\n\n        afterRunningAllTasks();\n        this.lastExecutionTime = lastExecutionTime;\n        return true;\n    }\n```\n主要做了如下几件事:\n+ 从schedule队列取出任务向taskQueue中存放, 是一个有size<=16的、根据截至时间有优先级的阻塞队列。\n+ 从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.\n\nNioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。","source":"_posts/NioEventLoop篇.md","raw":"---\ntitle: NioEventLoop篇\ndate: 2018-01-22 08:53:40\ntags:\n---\n# 介绍\n在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:\n```\n            ch.eventLoop().execute(new Runnable() {\n                    @Override\n                    public void run() {...}\n            });\n```\n调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:\n```\n public void execute(Runnable task) {\n        boolean inEventLoop = inEventLoop();\n        if (inEventLoop) {\n            addTask(task);\n        } else {\n            startThread();\n            addTask(task);\n            if (isShutdown() && removeTask(task)) {\n                reject();\n            }\n        }\n        if (!addTaskWakesUp && wakesUpForTask(task)) {\n            wakeup(inEventLoop);\n        }\n    }\n```\n首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。\n## startThread\nstartThread用来启动NioEventLoop里面的执行线程,代码如下:\n```\n  executor.execute(new Runnable() { //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动\n            @Override\n            public void run() {\n                thread = Thread.currentThread(); //获取当前这个线程\n                if (interrupted) {\n                    thread.interrupt();\n                }\n                boolean success = false;\n                updateLastExecutionTime();\n                try {\n                    SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环\n                    success = true;\n                } catch (Throwable t) {\n                }\n```\nexecutor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。\n\n\n# NioEventLoop\ntask分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。\n+ 非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头`ch.eventLoop().execute`)\n+ IO型: Accetp、Write、read等从远程节点发送过来的请求。\n\n为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:\n+ 若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。\n+ 若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。\n\nNioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:\n\n```\n  @Override\n    protected void run() {\n        for (;;) {\n            try {\n                switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) {\n                    case SelectStrategy.CONTINUE:\n                        continue;\n                    case SelectStrategy.SELECT:\n                        select(wakenUp.getAndSet(false));\n                        // 'wakenUp.compareAndSet(false, true)' is always evaluated\n                        // before calling 'selector.wakeup()' to reduce the wake-up\n                        // overhead. (Selector.wakeup() is an expensive operation.)\n                        //\n                        // However, there is a race condition in this approach.\n                        // The race condition is triggered when 'wakenUp' is set to\n                        // true too early.\n                        //\n                        // 'wakenUp' is set to true too early if:\n                        // 1) Selector is waken up between 'wakenUp.set(false)' and\n                        //    'selector.select(...)'. (BAD)\n                        // 2) Selector is waken up between 'selector.select(...)' and\n                        //    'if (wakenUp.get()) { ... }'. (OK)\n                        //\n                        // In the first case, 'wakenUp' is set to true and the\n                        // following 'selector.select(...)' will wake up immediately.\n                        // Until 'wakenUp' is set to false again in the next round,\n                        // 'wakenUp.compareAndSet(false, true)' will fail, and therefore\n                        // any attempt to wake up the Selector will fail, too, causing\n                        // the following 'selector.select(...)' call to block\n                        // unnecessarily.\n                        //\n                        // To fix this problem, we wake up the selector again if wakenUp\n                        // is true immediately after selector.select(...).\n                        // It is inefficient in that it wakes up the selector for both\n                        // the first case (BAD - wake-up required) and the second case\n                        // (OK - no wake-up required).\n\n                        if (wakenUp.get()) {\n                            selector.wakeup();\n                        }\n                    default:\n                        // fallthrough\n                }\n                cancelledKeys = 0;\n                needsToSelectAgain = false;\n                final int ioRatio = this.ioRatio;\n                if (ioRatio == 100) {\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        runAllTasks();\n                    }\n                } else {\n                    final long ioStartTime = System.nanoTime();\n                    try {\n                        processSelectedKeys();\n                    } finally {\n                        // Ensure we always run tasks.\n                        final long ioTime = System.nanoTime() - ioStartTime;\n                        runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n            // Always handle shutdown even if the loop processing threw an exception.\n            try {\n                if (isShuttingDown()) {\n                    closeAll();\n                    if (confirmShutdown()) {\n                        return;\n                    }\n                }\n            } catch (Throwable t) {\n                handleLoopException(t);\n            }\n        }\n    }\n```\nselector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()\nNioEventLoop.run()部分的逻辑还是比较清楚:\n(1) 检查是否累计有task:\n```\n@Override\n    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception {\n        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要\n    }\n```\n进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:\n```\nint selectNow() throws IOException {//相当于复写了NIO的select函数\n        try {\n            return selector.selectNow(); //返回的0, 直接跳出switch循环\n        } finally {\n            // restore wakeup state if needed\n            if (wakenUp.get()) {\n                selector.wakeup();\n            }\n        }\n    }\n```\n若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。\n(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。\nwakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:\n```\nprivate void select(boolean oldWakenUp) throws IOException {\n        Selector selector = this.selector;\n        try {\n            int selectCnt = 0;\n            long currentTimeNanos = System.nanoTime();\n            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间\n            for (;;) {  //timeoutMillis下次等待需要的时间\n                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns\n                if (timeoutMillis <= 0) {//距离第一个执行计划开始时间已经过了（1ms）\n                    if (selectCnt == 0) { //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()\n                        selector.selectNow();\n                        selectCnt = 1;\n                    }\n                    break;\n                }\n                // If a task was submitted when wakenUp value was true, the task didn't get a chance to call\n                // Selector#wakeup. So we need to check task queue again before executing select operation.\n                // If we don't, the task might be pended until select operation was timed out.\n                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.\n                if (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                int selectedKeys = selector.select(timeoutMillis);\n                selectCnt ++;\n                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环\n                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {\n                    // - Selected something,\n                    // - waken up by user, or\n                    // - the task queue has a pending task.\n                    // - a scheduled task is ready for processing\n                    break;\n                }\n                long time = System.nanoTime();//selector.select(timeoutMillis);\n                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {\n                    // timeoutMillis elapsed without anything selected.\n                    selectCnt = 1;\n                } else if (SELECTOR_AUTO_REBUILD_THRESHOLD > 0 &&\n                        selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。\n                    // The selector returned prematurely many times in a row.\n                    // Rebuild the selector to work around the problem.\n                    rebuildSelector();\n                    selector = this.selector;\n                    // Select again to populate selectedKeys.\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n                currentTimeNanos = time;\n            }\n\n        } catch (CancelledKeyException e) {\n        }\n    }\n\n```\n可以看出代码做了如下事情:\n2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时\n如果当前时间 > 截止时间 + 0.5ms的话,就立刻退出执行task。\n2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。\n+ 此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。\n+ 若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。\n别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:\n ```\nprotected void wakeup(boolean inEventLoop) { //inEventLoop说的是NioEventLoop还没有启动\n        if (!inEventLoop && wakenUp.compareAndSet(false, true)) {\n            selector.wakeup();\n        }\n    }\n ```\n 当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。\n2.3 执行selector.select(timeoutMillis)\n+ 若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。\n+ 若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。\n+ 若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。\n\n2.4 检查是否需要跳出循环:\n+ 有IO task了\n+ 上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。\n+ 此轮有task处于penging.\n+ 有schedule task截止时间已经到了。\nselect(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。\n这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:\n```\nivate void rebuildSelector0() {\n        newSelectorTuple = openSelector();//打开一个新的Selector\n        // Register all channels to the new Selector.\n        int nChannels = 0;\n        for (SelectionKey key: oldSelector.keys()) {////SelectionKey无效或者已经注册上了则跳过\n            Object a = key.attachment();\n            try {\n                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) {\n                    continue;\n                }\n                int interestOps = key.interestOps();\n                key.cancel();//取消SelectionKey\n                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);\n            }\n        }\n        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector\n        unwrappedSelector = newSelectorTuple.unwrappedSelector;\n```\n主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。\n如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过`SELECTOR_AUTO_REBUILD_THRESHOLD`则说明触发了, 默认为512次。\n\nselect(wakenUp.getAndSet(false))完成后,会有这段代码\n```\nif (wakenUp.get()) {\n        selector.wakeup(); //下次\n }\n```\n参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。\n假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:\n```\nif (hasTasks() && wakenUp.compareAndSet(false, true)) {\n                    selector.selectNow();\n                    selectCnt = 1;\n                    break;\n                }\n```\n那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -> 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)\n```\n     if (hasTasks() && wakenUp.compareAndSet(false, true)) {//若果当前有task，并且是可以叫醒的，则中断selector.select\n                    selector.selectNow();//selectNow()返回，否则会耽误任务执行\n                    selectCnt = 1;   //\n                    break;\n                }\n```\n\n只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。\n所以说, 那部分代码是没有没有意义的。\n\n(3) 开始执行IO task和非IO task\n前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。\n## IO任务执行processSelectedKeysPlain\nprocessSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:\n```\n        final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();\n        eventLoop = ch.eventLoop();\n        try {\n            int readyOps = k.readyOps();\n            if ((readyOps & SelectionKey.OP_CONNECT) != 0) {\n                int ops = k.interestOps();\n                ops &= ~SelectionKey.OP_CONNECT;\n                k.interestOps(ops);\n                unsafe.finishConnect();\n            }\n            if ((readyOps & SelectionKey.OP_WRITE) != 0) { //如果是写\n                ch.unsafe().forceFlush();\n            }\n            if ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) {\n                unsafe.read(); //这里很重要，NioMessageUnsafe\n            }\n        } catch (CancelledKeyException ignored) {\n            unsafe.close(unsafe.voidPromise());\n        }\n```\n这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)\n ###  SelectionKey.OP_ACCEPT部分\n 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面\n```\n            assert eventLoop().inEventLoop();\n            final ChannelConfig config = config(); //NioServerSocketChannelConf\n            final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline\n            final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();\n            allocHandle.reset(config);\n\n            boolean closed = false;\n            Throwable exception = null;\n            try {\n                try {\n                    do { //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法\n                        int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接\n                        if (localRead == 0) {\n                            break;\n                        }\n                        if (localRead < 0) {\n                            closed = true;\n                            break;\n                        }\n\n                        allocHandle.incMessagesRead(localRead);\n                    } while (allocHandle.continueReading()); //当前连接是否该继续\n                } catch (Throwable t) {\n                    exception = t;\n                }\n\n                int size = readBuf.size();\n                for (int i = 0; i < size; i ++) {\n                    readPending = false;//// 对每个连接调用pipeline的fireChannelRead\n                    pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面\n                }\n                readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf\n                allocHandle.readComplete();\n                pipeline.fireChannelReadComplete();\n\n                if (exception != null) {\n                    closed = closeOnReadError(exception);\n\n                    pipeline.fireExceptionCaught(exception);\n                }\n\n                if (closed) {\n                    inputShutdown = true;\n                    if (isOpen()) {\n                        close(voidPromise());\n                    }\n                }\n            } finally {\n                // Check if there is a readPending which was not processed yet.\n                // This could be for two reasons:\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method\n                // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method\n                //\n                // See https://github.com/netty/netty/issues/2254\n                if (!readPending && !config.isAutoRead()) {\n                    removeReadOp();\n                }\n            }\n```\n1. 循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:\n```\n         SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，\n        try {\n            if (ch != null) {\n                buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel\n                return 1;\n            }\n        } catch (Throwable t) {\n        }\n\n        return 0;\n```\n同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个\nSocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。\nNioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:\n```\n         this.parent = parent; //NioServerSocketChannel\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。\n```\n\n2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。\n初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:\n ```\npublic final ChannelPipeline fireChannelRead(Object msg) { //msg是新建立的SocketChannel\n        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了\n        return this;\n    }\n```\n读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以`static`注释的。\n```\n static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) { ////msg是新建立的NioSocketChannel\n        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, \"msg\"), next); //pipe是同一个，\n        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为\n        if (executor.inEventLoop()) { //本线程是否是EventLoop线程\n            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类\n        } else {\n            executor.execute(new Runnable() {\n                @Override\n                public void run() {\n                    next.invokeChannelRead(m);\n                }\n            });\n        }\n    }\n````\n2.1 会以根据HeadContext开始讲起:\n+ 首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。\n```\n public EventExecutor executor() {  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop\n        if (executor == null) {\n            return channel().eventLoop();\n        } else {\n            return executor;\n        }\n    }\n\n```\n+ 确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的`static void invokeChannelRead`\nstatic void invokeChannelRead\n```\n private AbstractChannelHandlerContext findContextInbound() { //从Head当前位置找，直到向后找到一个inbound的，就退出\n        AbstractChannelHandlerContext ctx = this;\n        do {\n            ctx = ctx.next;//直接找下一个\n        } while (!ctx.inbound);\n        return ctx;\n    }\n```\n到第二个Context, 其中会执行`((ChannelInboundHandler) handler()).channelRead(this, msg)`, 即ServerBootstrapAcceptor.channelRead(), 如下所示:\n```\n public void channelRead(ChannelHandlerContext ctx, Object msg) {\n            final Channel child = (Channel) msg; //// child = NioSocketChannel\n            child.pipeline().addLast(childHandler);\n            setChannelOptions(child, childOptions, logger);\n            for (Entry<AttributeKey<?>, Object> e: childAttrs) {\n                child.attr((AttributeKey<Object>) e.getKey()).set(e.getValue());\n            }\n            try {  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接\n                childGroup.register(child).addListener(new ChannelFutureListener() {   ///这里使用的是childGroup\n                    @Override\n                    public void operationComplete(ChannelFuture future) throws Exception {\n                        if (!future.isSuccess()) { //如果有连接完成，但是失败的情况下\n                            forceClose(child, future.cause());\n                        }\n                    }\n                });\n            } catch (Throwable t) {\n            }\n```\n主要做的事:\n+ 其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.\n+ 从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。\n+ 当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。\n\n其中第二步骤, 注册的代码在`ServerBootStrap初始篇`中已经展示, 为了讲解方便在此再次罗列:\n```\n                 boolean firstRegistration = neverRegistered;\n                doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中\n                neverRegistered = false;\n                registered = true;// register状态设置为true，\n\n                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the\n                // user may already fire events through the pipeline in the ChannelFutureListener.\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0->accept\n                pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n```\n其中需要注意的是:\n+ invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:\nHeadContext-> EncoderContext->DecoderContext->SelfCustemHanderContext->TailContext.\n+ 会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:\n```\n public void channelActive(ChannelHandlerContext ctx) throws Exception {\n            ctx.fireChannelActive();\n\n            readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性\n        }\n```\nctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin\n```\n@Override\n    protected void doBeginRead() throws Exception {\n        // Channel.read() or ChannelHandlerContext.read() was called\n        final SelectionKey selectionKey = this.selectionKey;\n        if (!selectionKey.isValid()) {\n            return;\n        }\n\n        readPending = true;\n\n        final int interestOps = selectionKey.interestOps();\n        if ((interestOps & readInterestOp) == 0) { //将设置可接受\n            selectionKey.interestOps(interestOps | readInterestOp);\n        }\n    }\n```\n每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。\n### SelectionKey.OP_READ\n 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在`Netty通信编解码源码解读`讲解。\n\n## 执行非IO Task.\n进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:\n```\nprotected boolean runAllTasks(long timeoutNanos) {//处理非I/O任务。\n        fetchFromScheduledTaskQueue();\n        Runnable task = pollTask();//从\n        if (task == null) {\n            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()\n            return false;\n        }\n        //截止时间=ScheduledFutureTask当前相对时间+ 超时\n        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;\n        long runTasks = 0;\n        long lastExecutionTime;\n        for (;;) {\n            safeExecute(task);  //顺序执行所有task\n\n            runTasks ++;\n\n            // Check timeout every 64 tasks because nanoTime() is relatively expensive.\n            // XXX: Hard-coded value - will make it configurable if it is really a problem.\n            if ((runTasks & 0x3F) == 0) {  //当64个task后\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                if (lastExecutionTime >= deadline) {//当前时间超过截止时间，那么就退出\n                    break;\n                }\n            }\n\n            task = pollTask();\n            if (task == null) {\n                lastExecutionTime = ScheduledFutureTask.nanoTime();\n                break;\n            }\n        }\n\n        afterRunningAllTasks();\n        this.lastExecutionTime = lastExecutionTime;\n        return true;\n    }\n```\n主要做了如下几件事:\n+ 从schedule队列取出任务向taskQueue中存放, 是一个有size<=16的、根据截至时间有优先级的阻塞队列。\n+ 从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.\n\nNioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。","slug":"NioEventLoop篇","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadwh0009miu5lx9vnx9k","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch.eventLoop().execute(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;...&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void execute(Runnable task) &#123;</div><div class=\"line\">       boolean inEventLoop = inEventLoop();</div><div class=\"line\">       if (inEventLoop) &#123;</div><div class=\"line\">           addTask(task);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           startThread();</div><div class=\"line\">           addTask(task);</div><div class=\"line\">           if (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">               reject();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">           wakeup(inEventLoop);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。</p>\n<h2 id=\"startThread\"><a href=\"#startThread\" class=\"headerlink\" title=\"startThread\"></a>startThread</h2><p>startThread用来启动NioEventLoop里面的执行线程,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">executor.execute(new Runnable() &#123; //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动</div><div class=\"line\">          @Override</div><div class=\"line\">          public void run() &#123;</div><div class=\"line\">              thread = Thread.currentThread(); //获取当前这个线程</div><div class=\"line\">              if (interrupted) &#123;</div><div class=\"line\">                  thread.interrupt();</div><div class=\"line\">              &#125;</div><div class=\"line\">              boolean success = false;</div><div class=\"line\">              updateLastExecutionTime();</div><div class=\"line\">              try &#123;</div><div class=\"line\">                  SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环</div><div class=\"line\">                  success = true;</div><div class=\"line\">              &#125; catch (Throwable t) &#123;</div><div class=\"line\">              &#125;</div></pre></td></tr></table></figure></p>\n<p>executor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。</p>\n<h1 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h1><p>task分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。</p>\n<ul>\n<li>非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头<code>ch.eventLoop().execute</code>)</li>\n<li>IO型: Accetp、Write、read等从远程节点发送过来的请求。</li>\n</ul>\n<p>为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:</p>\n<ul>\n<li>若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。</li>\n<li>若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。</li>\n</ul>\n<p>NioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  protected void run() &#123;</div><div class=\"line\">      for (;;) &#123;</div><div class=\"line\">          try &#123;</div><div class=\"line\">              switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) &#123;</div><div class=\"line\">                  case SelectStrategy.CONTINUE:</div><div class=\"line\">                      continue;</div><div class=\"line\">                  case SelectStrategy.SELECT:</div><div class=\"line\">                      select(wakenUp.getAndSet(false));</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</div><div class=\"line\">                      // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</div><div class=\"line\">                      // overhead. (Selector.wakeup() is an expensive operation.)</div><div class=\"line\">                      //</div><div class=\"line\">                      // However, there is a race condition in this approach.</div><div class=\"line\">                      // The race condition is triggered when &apos;wakenUp&apos; is set to</div><div class=\"line\">                      // true too early.</div><div class=\"line\">                      //</div><div class=\"line\">                      // &apos;wakenUp&apos; is set to true too early if:</div><div class=\"line\">                      // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</div><div class=\"line\">                      //    &apos;selector.select(...)&apos;. (BAD)</div><div class=\"line\">                      // 2) Selector is waken up between &apos;selector.select(...)&apos; and</div><div class=\"line\">                      //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</div><div class=\"line\">                      //</div><div class=\"line\">                      // In the first case, &apos;wakenUp&apos; is set to true and the</div><div class=\"line\">                      // following &apos;selector.select(...)&apos; will wake up immediately.</div><div class=\"line\">                      // Until &apos;wakenUp&apos; is set to false again in the next round,</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</div><div class=\"line\">                      // any attempt to wake up the Selector will fail, too, causing</div><div class=\"line\">                      // the following &apos;selector.select(...)&apos; call to block</div><div class=\"line\">                      // unnecessarily.</div><div class=\"line\">                      //</div><div class=\"line\">                      // To fix this problem, we wake up the selector again if wakenUp</div><div class=\"line\">                      // is true immediately after selector.select(...).</div><div class=\"line\">                      // It is inefficient in that it wakes up the selector for both</div><div class=\"line\">                      // the first case (BAD - wake-up required) and the second case</div><div class=\"line\">                      // (OK - no wake-up required).</div><div class=\"line\"></div><div class=\"line\">                      if (wakenUp.get()) &#123;</div><div class=\"line\">                          selector.wakeup();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                  default:</div><div class=\"line\">                      // fallthrough</div><div class=\"line\">              &#125;</div><div class=\"line\">              cancelledKeys = 0;</div><div class=\"line\">              needsToSelectAgain = false;</div><div class=\"line\">              final int ioRatio = this.ioRatio;</div><div class=\"line\">              if (ioRatio == 100) &#123;</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      runAllTasks();</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125; else &#123;</div><div class=\"line\">                  final long ioStartTime = System.nanoTime();</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      final long ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                      runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">          // Always handle shutdown even if the loop processing threw an exception.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              if (isShuttingDown()) &#123;</div><div class=\"line\">                  closeAll();</div><div class=\"line\">                  if (confirmShutdown()) &#123;</div><div class=\"line\">                      return;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>selector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()<br>NioEventLoop.run()部分的逻辑还是比较清楚:<br>(1) 检查是否累计有task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;</div><div class=\"line\">        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int selectNow() throws IOException &#123;//相当于复写了NIO的select函数</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return selector.selectNow(); //返回的0, 直接跳出switch循环</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // restore wakeup state if needed</div><div class=\"line\">            if (wakenUp.get()) &#123;</div><div class=\"line\">                selector.wakeup();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。<br>(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。<br>wakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</div><div class=\"line\">        Selector selector = this.selector;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            int selectCnt = 0;</div><div class=\"line\">            long currentTimeNanos = System.nanoTime();</div><div class=\"line\">            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间</div><div class=\"line\">            for (;;) &#123;  //timeoutMillis下次等待需要的时间</div><div class=\"line\">                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns</div><div class=\"line\">                if (timeoutMillis &lt;= 0) &#123;//距离第一个执行计划开始时间已经过了（1ms）</div><div class=\"line\">                    if (selectCnt == 0) &#123; //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()</div><div class=\"line\">                        selector.selectNow();</div><div class=\"line\">                        selectCnt = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</div><div class=\"line\">                // Selector#wakeup. So we need to check task queue again before executing select operation.</div><div class=\"line\">                // If we don&apos;t, the task might be pended until select operation was timed out.</div><div class=\"line\">                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</div><div class=\"line\">                if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int selectedKeys = selector.select(timeoutMillis);</div><div class=\"line\">                selectCnt ++;</div><div class=\"line\">                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环</div><div class=\"line\">                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class=\"line\">                    // - Selected something,</div><div class=\"line\">                    // - waken up by user, or</div><div class=\"line\">                    // - the task queue has a pending task.</div><div class=\"line\">                    // - a scheduled task is ready for processing</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                long time = System.nanoTime();//selector.select(timeoutMillis);</div><div class=\"line\">                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class=\"line\">                    // timeoutMillis elapsed without anything selected.</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class=\"line\">                        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。</div><div class=\"line\">                    // The selector returned prematurely many times in a row.</div><div class=\"line\">                    // Rebuild the selector to work around the problem.</div><div class=\"line\">                    rebuildSelector();</div><div class=\"line\">                    selector = this.selector;</div><div class=\"line\">                    // Select again to populate selectedKeys.</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentTimeNanos = time;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出代码做了如下事情:<br>2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时<br>如果当前时间 &gt; 截止时间 + 0.5ms的话,就立刻退出执行task。<br>2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。</p>\n<ul>\n<li>此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。</li>\n<li><p>若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。<br>别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void wakeup(boolean inEventLoop) &#123; //inEventLoop说的是NioEventLoop还没有启动</div><div class=\"line\">        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">            selector.wakeup();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。<br>2.3 执行selector.select(timeoutMillis)</p>\n</li>\n<li>若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。</li>\n<li>若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。</li>\n<li>若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。</li>\n</ul>\n<p>2.4 检查是否需要跳出循环:</p>\n<ul>\n<li>有IO task了</li>\n<li>上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。</li>\n<li>此轮有task处于penging.</li>\n<li>有schedule task截止时间已经到了。<br>select(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。<br>这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ivate void rebuildSelector0() &#123;</div><div class=\"line\">        newSelectorTuple = openSelector();//打开一个新的Selector</div><div class=\"line\">        // Register all channels to the new Selector.</div><div class=\"line\">        int nChannels = 0;</div><div class=\"line\">        for (SelectionKey key: oldSelector.keys()) &#123;////SelectionKey无效或者已经注册上了则跳过</div><div class=\"line\">            Object a = key.attachment();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int interestOps = key.interestOps();</div><div class=\"line\">                key.cancel();//取消SelectionKey</div><div class=\"line\">                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector</div><div class=\"line\">        unwrappedSelector = newSelectorTuple.unwrappedSelector;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。<br>如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>则说明触发了, 默认为512次。</p>\n<p>select(wakenUp.getAndSet(false))完成后,会有这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (wakenUp.get()) &#123;</div><div class=\"line\">        selector.wakeup(); //下次</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。<br>假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div></pre></td></tr></table></figure></p>\n<p>那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -&gt; 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;//若果当前有task，并且是可以叫醒的，则中断selector.select</div><div class=\"line\">               selector.selectNow();//selectNow()返回，否则会耽误任务执行</div><div class=\"line\">               selectCnt = 1;   //</div><div class=\"line\">               break;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。<br>所以说, 那部分代码是没有没有意义的。</p>\n<p>(3) 开始执行IO task和非IO task<br>前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。</p>\n<h2 id=\"IO任务执行processSelectedKeysPlain\"><a href=\"#IO任务执行processSelectedKeysPlain\" class=\"headerlink\" title=\"IO任务执行processSelectedKeysPlain\"></a>IO任务执行processSelectedKeysPlain</h2><p>processSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class=\"line\">eventLoop = ch.eventLoop();</div><div class=\"line\">try &#123;</div><div class=\"line\">    int readyOps = k.readyOps();</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class=\"line\">        int ops = k.interestOps();</div><div class=\"line\">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class=\"line\">        k.interestOps(ops);</div><div class=\"line\">        unsafe.finishConnect();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; //如果是写</div><div class=\"line\">        ch.unsafe().forceFlush();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class=\"line\">        unsafe.read(); //这里很重要，NioMessageUnsafe</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (CancelledKeyException ignored) &#123;</div><div class=\"line\">    unsafe.close(unsafe.voidPromise());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)</p>\n<h3 id=\"SelectionKey-OP-ACCEPT部分\"><a href=\"#SelectionKey-OP-ACCEPT部分\" class=\"headerlink\" title=\"SelectionKey.OP_ACCEPT部分\"></a>SelectionKey.OP_ACCEPT部分</h3><p> 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert eventLoop().inEventLoop();</div><div class=\"line\">final ChannelConfig config = config(); //NioServerSocketChannelConf</div><div class=\"line\">final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline</div><div class=\"line\">final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class=\"line\">allocHandle.reset(config);</div><div class=\"line\"></div><div class=\"line\">boolean closed = false;</div><div class=\"line\">Throwable exception = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        do &#123; //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法</div><div class=\"line\">            int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接</div><div class=\"line\">            if (localRead == 0) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localRead &lt; 0) &#123;</div><div class=\"line\">                closed = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            allocHandle.incMessagesRead(localRead);</div><div class=\"line\">        &#125; while (allocHandle.continueReading()); //当前连接是否该继续</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">        exception = t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int size = readBuf.size();</div><div class=\"line\">    for (int i = 0; i &lt; size; i ++) &#123;</div><div class=\"line\">        readPending = false;//// 对每个连接调用pipeline的fireChannelRead</div><div class=\"line\">        pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面</div><div class=\"line\">    &#125;</div><div class=\"line\">    readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf</div><div class=\"line\">    allocHandle.readComplete();</div><div class=\"line\">    pipeline.fireChannelReadComplete();</div><div class=\"line\"></div><div class=\"line\">    if (exception != null) &#123;</div><div class=\"line\">        closed = closeOnReadError(exception);</div><div class=\"line\"></div><div class=\"line\">        pipeline.fireExceptionCaught(exception);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (closed) &#123;</div><div class=\"line\">        inputShutdown = true;</div><div class=\"line\">        if (isOpen()) &#123;</div><div class=\"line\">            close(voidPromise());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    // Check if there is a readPending which was not processed yet.</div><div class=\"line\">    // This could be for two reasons:</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</div><div class=\"line\">    //</div><div class=\"line\">    // See https://github.com/netty/netty/issues/2254</div><div class=\"line\">    if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</div><div class=\"line\">        removeReadOp();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，</div><div class=\"line\">try &#123;</div><div class=\"line\">    if (ch != null) &#123;</div><div class=\"line\">        buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return 0;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个<br>SocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。<br>NioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> this.parent = parent; //NioServerSocketChannel</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。</div></pre></td></tr></table></figure></p>\n<p>2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。<br>初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ChannelPipeline fireChannelRead(Object msg) &#123; //msg是新建立的SocketChannel</div><div class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以<code>static</code>注释的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; ////msg是新建立的NioSocketChannel</div><div class=\"line\">        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next); //pipe是同一个，</div><div class=\"line\">        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为</div><div class=\"line\">        if (executor.inEventLoop()) &#123; //本线程是否是EventLoop线程</div><div class=\"line\">            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            executor.execute(new Runnable() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void run() &#123;</div><div class=\"line\">                    next.invokeChannelRead(m);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>2.1 会以根据HeadContext开始讲起:</p>\n<ul>\n<li><p>首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor executor() &#123;  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop</div><div class=\"line\">       if (executor == null) &#123;</div><div class=\"line\">           return channel().eventLoop();</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return executor;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的<code>static void invokeChannelRead</code><br>static void invokeChannelRead</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AbstractChannelHandlerContext findContextInbound() &#123; //从Head当前位置找，直到向后找到一个inbound的，就退出</div><div class=\"line\">       AbstractChannelHandlerContext ctx = this;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           ctx = ctx.next;//直接找下一个</div><div class=\"line\">       &#125; while (!ctx.inbound);</div><div class=\"line\">       return ctx;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到第二个Context, 其中会执行<code>((ChannelInboundHandler) handler()).channelRead(this, msg)</code>, 即ServerBootstrapAcceptor.channelRead(), 如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</div><div class=\"line\">           final Channel child = (Channel) msg; //// child = NioSocketChannel</div><div class=\"line\">           child.pipeline().addLast(childHandler);</div><div class=\"line\">           setChannelOptions(child, childOptions, logger);</div><div class=\"line\">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</div><div class=\"line\">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class=\"line\">           &#125;</div><div class=\"line\">           try &#123;  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接</div><div class=\"line\">               childGroup.register(child).addListener(new ChannelFutureListener() &#123;   ///这里使用的是childGroup</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                       if (!future.isSuccess()) &#123; //如果有连接完成，但是失败的情况下</div><div class=\"line\">                           forceClose(child, future.cause());</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.</li>\n<li>从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。</li>\n<li>当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。</li>\n</ul>\n<p>其中第二步骤, 注册的代码在<code>ServerBootStrap初始篇</code>中已经展示, 为了讲解方便在此再次罗列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean firstRegistration = neverRegistered;</div><div class=\"line\">doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中</div><div class=\"line\">neverRegistered = false;</div><div class=\"line\">registered = true;// register状态设置为true，</div><div class=\"line\"></div><div class=\"line\">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</div><div class=\"line\">// user may already fire events through the pipeline in the ChannelFutureListener.</div><div class=\"line\">pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0-&gt;accept</div><div class=\"line\">pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，</div><div class=\"line\">// Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">// multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">if (isActive()) &#123;  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用</div><div class=\"line\">    if (firstRegistration) &#123;</div><div class=\"line\">        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()</div><div class=\"line\">    &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">        // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">        // again so that we process inbound data.</div><div class=\"line\">        //</div><div class=\"line\">        // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">        beginRead();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中需要注意的是:</p>\n<ul>\n<li>invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:<br>HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.</li>\n<li>会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">           ctx.fireChannelActive();</div><div class=\"line\"></div><div class=\"line\">           readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">        // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">        final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">        if (!selectionKey.isValid()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        readPending = true;</div><div class=\"line\"></div><div class=\"line\">        final int interestOps = selectionKey.interestOps();</div><div class=\"line\">        if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">            selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。</p>\n<h3 id=\"SelectionKey-OP-READ\"><a href=\"#SelectionKey-OP-READ\" class=\"headerlink\" title=\"SelectionKey.OP_READ\"></a>SelectionKey.OP_READ</h3><p> 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在<code>Netty通信编解码源码解读</code>讲解。</p>\n<h2 id=\"执行非IO-Task\"><a href=\"#执行非IO-Task\" class=\"headerlink\" title=\"执行非IO Task.\"></a>执行非IO Task.</h2><p>进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;//处理非I/O任务。</div><div class=\"line\">        fetchFromScheduledTaskQueue();</div><div class=\"line\">        Runnable task = pollTask();//从</div><div class=\"line\">        if (task == null) &#123;</div><div class=\"line\">            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //截止时间=ScheduledFutureTask当前相对时间+ 超时</div><div class=\"line\">        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class=\"line\">        long runTasks = 0;</div><div class=\"line\">        long lastExecutionTime;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            safeExecute(task);  //顺序执行所有task</div><div class=\"line\"></div><div class=\"line\">            runTasks ++;</div><div class=\"line\"></div><div class=\"line\">            // Check timeout every 64 tasks because nanoTime() is relatively expensive.</div><div class=\"line\">            // XXX: Hard-coded value - will make it configurable if it is really a problem.</div><div class=\"line\">            if ((runTasks &amp; 0x3F) == 0) &#123;  //当64个task后</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                if (lastExecutionTime &gt;= deadline) &#123;//当前时间超过截止时间，那么就退出</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            task = pollTask();</div><div class=\"line\">            if (task == null) &#123;</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        afterRunningAllTasks();</div><div class=\"line\">        this.lastExecutionTime = lastExecutionTime;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几件事:</p>\n<ul>\n<li>从schedule队列取出任务向taskQueue中存放, 是一个有size&lt;=16的、根据截至时间有优先级的阻塞队列。</li>\n<li>从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.</li>\n</ul>\n<p>NioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><p>在ServerBootstrap初始篇初始篇中说过, 每个NioEventLoop里面, 都拥有属性thread, 用来执行对应channel产生的所有task, 该thread最早在register的时候被生成, 首先调用如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">ch.eventLoop().execute(new Runnable() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void run() &#123;...&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>调用NioEventLoop.execute(), 然后进入到SingleThreadEventExecutor.execute(NioEventLoop的父类), 执行如下代码:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void execute(Runnable task) &#123;</div><div class=\"line\">       boolean inEventLoop = inEventLoop();</div><div class=\"line\">       if (inEventLoop) &#123;</div><div class=\"line\">           addTask(task);</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           startThread();</div><div class=\"line\">           addTask(task);</div><div class=\"line\">           if (isShutdown() &amp;&amp; removeTask(task)) &#123;</div><div class=\"line\">               reject();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;</div><div class=\"line\">       if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</div><div class=\"line\">           wakeup(inEventLoop);</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>首先判断NioEventLoop里面的那个线程是否启动, 若是的话, 就将当前task放进任务队列; 否则说明NioEventLoop里面执行task的那个唯一线程还没有启动, 调用startThread来启动。</p>\n<h2 id=\"startThread\"><a href=\"#startThread\" class=\"headerlink\" title=\"startThread\"></a>startThread</h2><p>startThread用来启动NioEventLoop里面的执行线程,代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">executor.execute(new Runnable() &#123; //就是一个执行器，ThreadPerTaskExecutor。只要想，可以一直启动</div><div class=\"line\">          @Override</div><div class=\"line\">          public void run() &#123;</div><div class=\"line\">              thread = Thread.currentThread(); //获取当前这个线程</div><div class=\"line\">              if (interrupted) &#123;</div><div class=\"line\">                  thread.interrupt();</div><div class=\"line\">              &#125;</div><div class=\"line\">              boolean success = false;</div><div class=\"line\">              updateLastExecutionTime();</div><div class=\"line\">              try &#123;</div><div class=\"line\">                  SingleThreadEventExecutor.this.run(); //调用NioEventLoop里面run,进行无限循环</div><div class=\"line\">                  success = true;</div><div class=\"line\">              &#125; catch (Throwable t) &#123;</div><div class=\"line\">              &#125;</div></pre></td></tr></table></figure></p>\n<p>executor仅仅是一个执行器, 唤醒了一个线程后, 这个线程就是NioEventLoop线程的核心部分, 该线程生命周期很长, 即使执行发生异常, 也不会主动退出。</p>\n<h1 id=\"NioEventLoop\"><a href=\"#NioEventLoop\" class=\"headerlink\" title=\"NioEventLoop\"></a>NioEventLoop</h1><p>task分为两类任务: 非IO型和IO型, 它们的执行时间比例由ioRatio参数控制, 默认50%,非IO型执行时间 = IO型执行时间。</p>\n<ul>\n<li>非IO型: 本进程内, 别的线程发送的请求, 比如将新的Context(hanlder)添加到Pipieline中等等(代码见文章开头<code>ch.eventLoop().execute</code>)</li>\n<li>IO型: Accetp、Write、read等从远程节点发送过来的请求。</li>\n</ul>\n<p>为了更好地理解代码, 我们需要大致了解selector.wakeup()的作用:</p>\n<ul>\n<li>若当前线程有由于调用selector.select()/selector.select(time)阻塞的, 那么当调用selector.wakeup()后会被立刻唤醒。</li>\n<li>若当前没有线程因为selector.select()/selector.select(time)而阻塞的函数, 当调用selector.wakeup()后, 会对下次调用selector.select()/selector.select(time)/selector.selectNow()立刻返回, 而不会被阻塞。</li>\n</ul>\n<p>NioEventLoop.run()作为执行所有task执行任务的核心, 主要处理逻辑如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  protected void run() &#123;</div><div class=\"line\">      for (;;) &#123;</div><div class=\"line\">          try &#123;</div><div class=\"line\">              switch (selectStrategy.calculateStrategy(selectNowSupplier, hahasTaskssTasks())) &#123;</div><div class=\"line\">                  case SelectStrategy.CONTINUE:</div><div class=\"line\">                      continue;</div><div class=\"line\">                  case SelectStrategy.SELECT:</div><div class=\"line\">                      select(wakenUp.getAndSet(false));</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; is always evaluated</div><div class=\"line\">                      // before calling &apos;selector.wakeup()&apos; to reduce the wake-up</div><div class=\"line\">                      // overhead. (Selector.wakeup() is an expensive operation.)</div><div class=\"line\">                      //</div><div class=\"line\">                      // However, there is a race condition in this approach.</div><div class=\"line\">                      // The race condition is triggered when &apos;wakenUp&apos; is set to</div><div class=\"line\">                      // true too early.</div><div class=\"line\">                      //</div><div class=\"line\">                      // &apos;wakenUp&apos; is set to true too early if:</div><div class=\"line\">                      // 1) Selector is waken up between &apos;wakenUp.set(false)&apos; and</div><div class=\"line\">                      //    &apos;selector.select(...)&apos;. (BAD)</div><div class=\"line\">                      // 2) Selector is waken up between &apos;selector.select(...)&apos; and</div><div class=\"line\">                      //    &apos;if (wakenUp.get()) &#123; ... &#125;&apos;. (OK)</div><div class=\"line\">                      //</div><div class=\"line\">                      // In the first case, &apos;wakenUp&apos; is set to true and the</div><div class=\"line\">                      // following &apos;selector.select(...)&apos; will wake up immediately.</div><div class=\"line\">                      // Until &apos;wakenUp&apos; is set to false again in the next round,</div><div class=\"line\">                      // &apos;wakenUp.compareAndSet(false, true)&apos; will fail, and therefore</div><div class=\"line\">                      // any attempt to wake up the Selector will fail, too, causing</div><div class=\"line\">                      // the following &apos;selector.select(...)&apos; call to block</div><div class=\"line\">                      // unnecessarily.</div><div class=\"line\">                      //</div><div class=\"line\">                      // To fix this problem, we wake up the selector again if wakenUp</div><div class=\"line\">                      // is true immediately after selector.select(...).</div><div class=\"line\">                      // It is inefficient in that it wakes up the selector for both</div><div class=\"line\">                      // the first case (BAD - wake-up required) and the second case</div><div class=\"line\">                      // (OK - no wake-up required).</div><div class=\"line\"></div><div class=\"line\">                      if (wakenUp.get()) &#123;</div><div class=\"line\">                          selector.wakeup();</div><div class=\"line\">                      &#125;</div><div class=\"line\">                  default:</div><div class=\"line\">                      // fallthrough</div><div class=\"line\">              &#125;</div><div class=\"line\">              cancelledKeys = 0;</div><div class=\"line\">              needsToSelectAgain = false;</div><div class=\"line\">              final int ioRatio = this.ioRatio;</div><div class=\"line\">              if (ioRatio == 100) &#123;</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      runAllTasks();</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125; else &#123;</div><div class=\"line\">                  final long ioStartTime = System.nanoTime();</div><div class=\"line\">                  try &#123;</div><div class=\"line\">                      processSelectedKeys();</div><div class=\"line\">                  &#125; finally &#123;</div><div class=\"line\">                      // Ensure we always run tasks.</div><div class=\"line\">                      final long ioTime = System.nanoTime() - ioStartTime;</div><div class=\"line\">                      runAllTasks(ioTime * (100 - ioRatio) / ioRatio);</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">          // Always handle shutdown even if the loop processing threw an exception.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              if (isShuttingDown()) &#123;</div><div class=\"line\">                  closeAll();</div><div class=\"line\">                  if (confirmShutdown()) &#123;</div><div class=\"line\">                      return;</div><div class=\"line\">                  &#125;</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125; catch (Throwable t) &#123;</div><div class=\"line\">              handleLoopException(t);</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<p>selector.wakeup()是一个非常耗时的操作, 需要通过wakenUp变量标记在合适的时候调用selector.wakeup()来唤醒selector.select(), 当需要唤醒时, 标记为true, 就调用调用selector.wakeup()<br>NioEventLoop.run()部分的逻辑还是比较清楚:<br>(1) 检查是否累计有task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public int calculateStrategy(IntSupplier selectSupplier, boolean hasTasks) throws Exception &#123;</div><div class=\"line\">        return hasTasks ? selectSupplier.get() : SelectStrategy.SELECT; //若当前没有非IO类型task时，需要</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>进入selectStrategy.calculateStrategy(), 如果没有非IO task, 那么直接跳掉SelectStrategy.SELECT, 开始select; 若有task, 则立刻去执行task:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">int selectNow() throws IOException &#123;//相当于复写了NIO的select函数</div><div class=\"line\">        try &#123;</div><div class=\"line\">            return selector.selectNow(); //返回的0, 直接跳出switch循环</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            // restore wakeup state if needed</div><div class=\"line\">            if (wakenUp.get()) &#123;</div><div class=\"line\">                selector.wakeup();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>若wakenUp置为true, 顺便执行selector.wakeup()使selector处于唤醒状态。<br>(2) 若有task, 进入select(wakenUp.getAndSet(false))进行等待。<br>wakenUp标志为false, 意味着新的一轮刚开始。NioEventLoop.select()与Selector.select()有异曲同工之处, 都是等待task出现, 主要代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void select(boolean oldWakenUp) throws IOException &#123;</div><div class=\"line\">        Selector selector = this.selector;</div><div class=\"line\">        try &#123;</div><div class=\"line\">            int selectCnt = 0;</div><div class=\"line\">            long currentTimeNanos = System.nanoTime();</div><div class=\"line\">            long selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos); //第一个任务执行执行的时间，绝对时间</div><div class=\"line\">            for (;;) &#123;  //timeoutMillis下次等待需要的时间</div><div class=\"line\">                long timeoutMillis = (selectDeadLineNanos - currentTimeNanos + 500000L) / 1000000L;//如果延迟任务队列中第一个任务开始执行的时间距离现在已经过了1ms,则小于0   1ms = 1000, 000ns</div><div class=\"line\">                if (timeoutMillis &lt;= 0) &#123;//距离第一个执行计划开始时间已经过了（1ms）</div><div class=\"line\">                    if (selectCnt == 0) &#123; //selectCnt 用来记录selector.select方法的执行次数和标识是否执行过selector.selectNow()</div><div class=\"line\">                        selector.selectNow();</div><div class=\"line\">                        selectCnt = 1;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                // If a task was submitted when wakenUp value was true, the task didn&apos;t get a chance to call</div><div class=\"line\">                // Selector#wakeup. So we need to check task queue again before executing select operation.</div><div class=\"line\">                // If we don&apos;t, the task might be pended until select operation was timed out.</div><div class=\"line\">                // It might be pended until idle timeout if IdleStateHandler existed in pipeline.</div><div class=\"line\">                if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int selectedKeys = selector.select(timeoutMillis);</div><div class=\"line\">                selectCnt ++;</div><div class=\"line\">                //如果已经存在ready的selectionKey，或者selector被唤醒，或者taskQueue不为空，或则scheduledTaskQueue不为空，则退出循环</div><div class=\"line\">                if (selectedKeys != 0 || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</div><div class=\"line\">                    // - Selected something,</div><div class=\"line\">                    // - waken up by user, or</div><div class=\"line\">                    // - the task queue has a pending task.</div><div class=\"line\">                    // - a scheduled task is ready for processing</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                long time = System.nanoTime();//selector.select(timeoutMillis);</div><div class=\"line\">                if (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</div><div class=\"line\">                    // timeoutMillis elapsed without anything selected.</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                &#125; else if (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; 0 &amp;&amp;</div><div class=\"line\">                        selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;//在某个周期内如果连续N次空轮询，则说明触发了JDK NIO的epoll死循环bug。</div><div class=\"line\">                    // The selector returned prematurely many times in a row.</div><div class=\"line\">                    // Rebuild the selector to work around the problem.</div><div class=\"line\">                    rebuildSelector();</div><div class=\"line\">                    selector = this.selector;</div><div class=\"line\">                    // Select again to populate selectedKeys.</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">                currentTimeNanos = time;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>可以看出代码做了如下事情:<br>2.1 从schedule task中取出顶点task的截止执行时间(最早开始执行那个scedule task), 若没有task的话, 超时时间取值1s。截止时间 = 此刻+超时<br>如果当前时间 &gt; 截止时间 + 0.5ms的话,就立刻退出执行task。<br>2.2 检查当前是否有task排队。若有而且wakenUp为false, 则置位wakeup, 并唤醒selector, 并立刻退出。</p>\n<ul>\n<li>此时已经有task, 那么需要开始执行具体放入task, 如果不检查的话, 则进入selector.select(timeoutMillis)阻塞直到超时, 但这是没有必要的。</li>\n<li><p>若wakenUp为true, 代表着什么含义? 表示当前有别的线程唤醒了selector, 并向队列中放入了task, 那么执行selector.select(timeoutMillis)时会立刻返回。<br>别的线程向队列中添加task见(SingleThreadEventExecutor.execute(NioEventLoop的父类)部分), 其中唤醒selector的代码如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected void wakeup(boolean inEventLoop) &#123; //inEventLoop说的是NioEventLoop还没有启动</div><div class=\"line\">        if (!inEventLoop &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">            selector.wakeup();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>当且此时wakenUp为false才唤醒, 意味着什么呢? 此时还没有task添加过, 只用在这一轮switch第一个来的task的时候需要唤醒, 当再有任务来的时候, 没必要再次执行耗时的selector.wakeup()。<br>2.3 执行selector.select(timeoutMillis)</p>\n</li>\n<li>若selector并没有唤醒(selector.wakeup()还在生效), 说明并没有task来, 并不需要唤醒。</li>\n<li>若若selector处于唤醒状态, 则说明此轮循环中有来的task, 需要立刻执行task。</li>\n<li>若阻塞了一段时间, 有task来, 别的线程执行了wakeup(boolean inEventLoop)函数, 阻塞也会立刻返回。</li>\n</ul>\n<p>2.4 检查是否需要跳出循环:</p>\n<ul>\n<li>有IO task了</li>\n<li>上一轮的oldWakenUp仍然置为着, 说明因为上一轮走完, selector仍然处于唤醒状态, 需要这个唤醒作用清空。</li>\n<li>此轮有task处于penging.</li>\n<li>有schedule task截止时间已经到了。<br>select(boolean oldWakenUp)主要判断逻辑基本已经完成了, 为啥后面还有那么多代码? 主要是为了解决可能触发epool cpu100%的bug。这个bug的意思是selector.select(timeoutMillis)并不会超时阻塞timeoutMillis, 它会立刻返回。<br>这样的话, 这个函数也就失去了意义, 如果不加控制的话, 这里的for循环会无限制下去而没有意义。 解决的方法就是selector, 具体处理函数rebuildSelector0如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">ivate void rebuildSelector0() &#123;</div><div class=\"line\">        newSelectorTuple = openSelector();//打开一个新的Selector</div><div class=\"line\">        // Register all channels to the new Selector.</div><div class=\"line\">        int nChannels = 0;</div><div class=\"line\">        for (SelectionKey key: oldSelector.keys()) &#123;////SelectionKey无效或者已经注册上了则跳过</div><div class=\"line\">            Object a = key.attachment();</div><div class=\"line\">            try &#123;</div><div class=\"line\">                if (!key.isValid() || key.channel().keyFor(newSelectorTuple.unwrappedSelector) != null) &#123;</div><div class=\"line\">                    continue;</div><div class=\"line\">                &#125;</div><div class=\"line\">                int interestOps = key.interestOps();</div><div class=\"line\">                key.cancel();//取消SelectionKey</div><div class=\"line\">                SelectionKey newKey = key.channel().register(newSelectorTuple.unwrappedSelector, interestOps, a);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        selector = newSelectorTuple.selector;//用新的Selector替换老的Selector</div><div class=\"line\">        unwrappedSelector = newSelectorTuple.unwrappedSelector;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>主要过程就是新建一个selector, 并且将原来selector等待时间都迁移过来。<br>如何判断是否触发了epool cpu100%的bug? 则是通过执行selector.select()函数的次数selectCnt来判断, 若当前循环次数超过<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>则说明触发了, 默认为512次。</p>\n<p>select(wakenUp.getAndSet(false))完成后,会有这段代码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (wakenUp.get()) &#123;</div><div class=\"line\">        selector.wakeup(); //下次</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p>参考提示, 始终是想不明白这里代码的作用, 并且认为是多余的,作者的本意是为了当wakenUp为true时, selector始终处于醒着的状态, 同时在不合适的时候被阻塞。我们来反推这里代码的不合理。<br>假设task来了, 而selector.selector()却被阻塞没有返回, 而改代码前面存在这样的检查:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;</div><div class=\"line\">                    selector.selectNow();</div><div class=\"line\">                    selectCnt = 1;</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div></pre></td></tr></table></figure></p>\n<p>那么wakenUp只能为true, 并且selector处于阻塞状态。 而在该函数新一轮调用开始, wakenUp刚被置为为false, 从false -&gt; 变为true, 不可能是同个函数中的下面的代码执行导致的(若执行了会立刻退出)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">if (hasTasks() &amp;&amp; wakenUp.compareAndSet(false, true)) &#123;//若果当前有task，并且是可以叫醒的，则中断selector.select</div><div class=\"line\">               selector.selectNow();//selectNow()返回，否则会耽误任务执行</div><div class=\"line\">               selectCnt = 1;   //</div><div class=\"line\">               break;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>只可能是task来了, 同时执行了wakenUp.compareAndSet(false, true)代码 ,那么一定会执行selector.wakeup()部分, 那么selector.selector()一定会立刻返回。。<br>所以说, 那部分代码是没有没有意义的。</p>\n<p>(3) 开始执行IO task和非IO task<br>前面也提到了, 两种任务执行的时间是成比例的, 非IO任务执行的时间 由IO任务执行的时间*比例。</p>\n<h2 id=\"IO任务执行processSelectedKeysPlain\"><a href=\"#IO任务执行processSelectedKeysPlain\" class=\"headerlink\" title=\"IO任务执行processSelectedKeysPlain\"></a>IO任务执行processSelectedKeysPlain</h2><p>processSelectedKeysPlain根据selector.selectedKeys()获取到所有的IO事件,然后轮训每一个事件,对于每个事件主要处理逻辑processSelectedKey如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">final AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</div><div class=\"line\">eventLoop = ch.eventLoop();</div><div class=\"line\">try &#123;</div><div class=\"line\">    int readyOps = k.readyOps();</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_CONNECT) != 0) &#123;</div><div class=\"line\">        int ops = k.interestOps();</div><div class=\"line\">        ops &amp;= ~SelectionKey.OP_CONNECT;</div><div class=\"line\">        k.interestOps(ops);</div><div class=\"line\">        unsafe.finishConnect();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; SelectionKey.OP_WRITE) != 0) &#123; //如果是写</div><div class=\"line\">        ch.unsafe().forceFlush();</div><div class=\"line\">    &#125;</div><div class=\"line\">    if ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != 0 || readyOps == 0) &#123;</div><div class=\"line\">        unsafe.read(); //这里很重要，NioMessageUnsafe</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (CancelledKeyException ignored) &#123;</div><div class=\"line\">    unsafe.close(unsafe.voidPromise());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里主要逻辑是判断当前IO task的类型, 然后分别处理, 我们重点分析Accept 和read两种类型的task(这两部分的处理都抽象成read()函数)</p>\n<h3 id=\"SelectionKey-OP-ACCEPT部分\"><a href=\"#SelectionKey-OP-ACCEPT部分\" class=\"headerlink\" title=\"SelectionKey.OP_ACCEPT部分\"></a>SelectionKey.OP_ACCEPT部分</h3><p> 此时实际从unsafe.read()进入的代码如下(NioMessageUnsafe.read()里面<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div></pre></td><td class=\"code\"><pre><div class=\"line\">assert eventLoop().inEventLoop();</div><div class=\"line\">final ChannelConfig config = config(); //NioServerSocketChannelConf</div><div class=\"line\">final ChannelPipeline pipeline = pipeline();//DefaultChannelPipeline</div><div class=\"line\">final RecvByteBufAllocator.Handle allocHandle = unsafe().recvBufAllocHandle();</div><div class=\"line\">allocHandle.reset(config);</div><div class=\"line\"></div><div class=\"line\">boolean closed = false;</div><div class=\"line\">Throwable exception = null;</div><div class=\"line\">try &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        do &#123; //                        // 此处会调用到NioServerSocketChannel中的doReadMessages方法</div><div class=\"line\">            int localRead = doReadMessages(readBuf);//将会产生一个NioSocketChannel建立C-S连接</div><div class=\"line\">            if (localRead == 0) &#123;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (localRead &lt; 0) &#123;</div><div class=\"line\">                closed = true;</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            allocHandle.incMessagesRead(localRead);</div><div class=\"line\">        &#125; while (allocHandle.continueReading()); //当前连接是否该继续</div><div class=\"line\">    &#125; catch (Throwable t) &#123;</div><div class=\"line\">        exception = t;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    int size = readBuf.size();</div><div class=\"line\">    for (int i = 0; i &lt; size; i ++) &#123;</div><div class=\"line\">        readPending = false;//// 对每个连接调用pipeline的fireChannelRead</div><div class=\"line\">        pipeline.fireChannelRead(readBuf.get(i));//回调到DefaultChannelPipeline里面</div><div class=\"line\">    &#125;</div><div class=\"line\">    readBuf.clear(); //// 清理获取到的数据，下次继续使用该buf</div><div class=\"line\">    allocHandle.readComplete();</div><div class=\"line\">    pipeline.fireChannelReadComplete();</div><div class=\"line\"></div><div class=\"line\">    if (exception != null) &#123;</div><div class=\"line\">        closed = closeOnReadError(exception);</div><div class=\"line\"></div><div class=\"line\">        pipeline.fireExceptionCaught(exception);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    if (closed) &#123;</div><div class=\"line\">        inputShutdown = true;</div><div class=\"line\">        if (isOpen()) &#123;</div><div class=\"line\">            close(voidPromise());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; finally &#123;</div><div class=\"line\">    // Check if there is a readPending which was not processed yet.</div><div class=\"line\">    // This could be for two reasons:</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</div><div class=\"line\">    // * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</div><div class=\"line\">    //</div><div class=\"line\">    // See https://github.com/netty/netty/issues/2254</div><div class=\"line\">    if (!readPending &amp;&amp; !config.isAutoRead()) &#123;</div><div class=\"line\">        removeReadOp();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ol>\n<li>循环遍历所有的accept请求, doReadMessages对每个请求做具体的具体,实现类在NioServerSocketChannel.doReadMessages中:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"> SocketChannel ch = SocketUtils.accept(javaChannel()); //接受连接请求，产生一个SocketChannelImpl，</div><div class=\"line\">try &#123;</div><div class=\"line\">    if (ch != null) &#123;</div><div class=\"line\">        buf.add(new NioSocketChannel(this, ch)); //这里就是新产生的NioSocketChannel,ch=SocketChannel</div><div class=\"line\">        return 1;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">return 0;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>同时遍历的时候设置了当前此轮循环处理的请求,不能超过maxMessagesPerRead,默认16个<br>SocketUtils.accept产生的SocketChannel是不是在NIO中很常见的方法, 产生具体的SocketChannelImp连接, 将该链接包装成NioSocketChannel, 然后放在readBuf中。<br>NioSocketChannel初始化, 默认监听的事件为SelectionKey.OP_READ, 同时自动拥有如下属性:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> this.parent = parent; //NioServerSocketChannel</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline, pipiline里面默认只拥有head和tail上下文事件,。</div></pre></td></tr></table></figure></p>\n<p>2.对产生的每个NioSocketChannel进行初始化, 使其设置为监听事件为SelectionKey.OP_READ。<br>初始化的时候, 首先调用NioServerSocketChannel的pipieline.fireChannelRead(), 开始遍历pipeLine上每个Context, 调用每个Context上面的channelRead()函数, 从HeadContext开始:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">public final ChannelPipeline fireChannelRead(Object msg) &#123; //msg是新建立的SocketChannel</div><div class=\"line\">        AbstractChannelHandlerContext.invokeChannelRead(head, msg); //fireChannelRead方法只是简单的往后传递事件，最终目的是向链中添加了</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>读每个Context上面执行channelRead()都以下面函数为开头, 注意该函数是以<code>static</code>注释的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> static void invokeChannelRead(final AbstractChannelHandlerContext next, Object msg) &#123; ////msg是新建立的NioSocketChannel</div><div class=\"line\">        final Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, &quot;msg&quot;), next); //pipe是同一个，</div><div class=\"line\">        EventExecutor executor = next.executor(); //executor = NioEventLoop， 因为</div><div class=\"line\">        if (executor.inEventLoop()) &#123; //本线程是否是EventLoop线程</div><div class=\"line\">            next.invokeChannelRead(m); //DefaultChannelHandlerContext， 即为下面这个类</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            executor.execute(new Runnable() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void run() &#123;</div><div class=\"line\">                    next.invokeChannelRead(m);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<p>2.1 会以根据HeadContext开始讲起:</p>\n<ul>\n<li><p>首先根据HeadContext, 找到对应的executor: 没若有, 找到对应HeadContext拥有的pipeLine, 返回该pipeLine的executor, 也就是NioServerSocketChannel的NioEventLoop。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor executor() &#123;  //若为空，就返回该pipLine拥有的chanel的executor， 即NioEventLoop</div><div class=\"line\">       if (executor == null) &#123;</div><div class=\"line\">           return channel().eventLoop();</div><div class=\"line\">       &#125; else &#123;</div><div class=\"line\">           return executor;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>确定该线程即是NioEventLoop里面的执行线程, 然后调用该head的invokeChannelRead(), 但是head的invokeChannelRead()并不做任何事,仅仅是找到下一个拥有in属性的Context(即DefaultChannelHandlerContext, 即拥有handler为ServerBootstrapAcceptor)  ,然后向下传递invokeChannelRead, 会从头开始执行前面介绍的<code>static void invokeChannelRead</code><br>static void invokeChannelRead</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">private AbstractChannelHandlerContext findContextInbound() &#123; //从Head当前位置找，直到向后找到一个inbound的，就退出</div><div class=\"line\">       AbstractChannelHandlerContext ctx = this;</div><div class=\"line\">       do &#123;</div><div class=\"line\">           ctx = ctx.next;//直接找下一个</div><div class=\"line\">       &#125; while (!ctx.inbound);</div><div class=\"line\">       return ctx;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>到第二个Context, 其中会执行<code>((ChannelInboundHandler) handler()).channelRead(this, msg)</code>, 即ServerBootstrapAcceptor.channelRead(), 如下所示:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelRead(ChannelHandlerContext ctx, Object msg) &#123;</div><div class=\"line\">           final Channel child = (Channel) msg; //// child = NioSocketChannel</div><div class=\"line\">           child.pipeline().addLast(childHandler);</div><div class=\"line\">           setChannelOptions(child, childOptions, logger);</div><div class=\"line\">           for (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</div><div class=\"line\">               child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</div><div class=\"line\">           &#125;</div><div class=\"line\">           try &#123;  // 将连接注册到childGroup中（也就是我们常说的workGroup)，注册完成如果发现注册失败则关闭此链接</div><div class=\"line\">               childGroup.register(child).addListener(new ChannelFutureListener() &#123;   ///这里使用的是childGroup</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">                       if (!future.isSuccess()) &#123; //如果有连接完成，但是失败的情况下</div><div class=\"line\">                           forceClose(child, future.cause());</div><div class=\"line\">                       &#125;</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做的事:</p>\n<ul>\n<li>其中第三行的childHandler是在外层向ServerBootstrap添加的自定义处理链(比如b.childHandler(new HelloServerInitializer()))里面的handler。 此时该channel的PipeLine链上共有三个Context, 分别是HeadContext, HelloServerInitializer, TailContext.</li>\n<li>从childGroup里面轮训选择一个NioEventLoop, 将这个NioSocketchannel绑定到该NioEventLoop上面。</li>\n<li>当注册完成后, 会执行这个ChannelFutureListener, 基本什么都不会做。</li>\n</ul>\n<p>其中第二步骤, 注册的代码在<code>ServerBootStrap初始篇</code>中已经展示, 为了讲解方便在此再次罗列:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"> boolean firstRegistration = neverRegistered;</div><div class=\"line\">doRegister(); // AbstractNioChannel,// 真正的注册方法，只是将channel.regester注册到对应EventLoop的selector中</div><div class=\"line\">neverRegistered = false;</div><div class=\"line\">registered = true;// register状态设置为true，</div><div class=\"line\"></div><div class=\"line\">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</div><div class=\"line\">// user may already fire events through the pipeline in the ChannelFutureListener.</div><div class=\"line\">pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">safeSetSuccess(promise); //设置安全后，会去主动调用operationComplete()，会触发channel状态修改从0-&gt;accept</div><div class=\"line\">pipeline.fireChannelRegistered();//// NioServerSocketChannel管道已经注册到EventLoops上了触发channelRegistered事件，</div><div class=\"line\">// Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">// multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">if (isActive()) &#123;  //将回到NioServerSocketChannel.isActive()中,   // 第一次注册时触发fireChannelActive事件，防止deregister后再次register触发多次fireChannelActive调用</div><div class=\"line\">    if (firstRegistration) &#123;</div><div class=\"line\">        pipeline.fireChannelActive();//// 这里和前面的ServerSocketChannel分析一样,最终会触发unsafe.beginRead()</div><div class=\"line\">    &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">        // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">        // again so that we process inbound data.</div><div class=\"line\">        //</div><div class=\"line\">        // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">        beginRead();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>其中需要注意的是:</p>\n<ul>\n<li>invokeHandlerAddedIfNeeded()会执行handlerAdded任务, 具体会执行到我们自定的编解码模板, 也就是HelloServerInitializer里面通过initChannel添加的channel, 接着会执行remove(ctx), 将HelloServerInitializer对应的Context从PipeLine中去掉, 此时队列中拥有的context如下:<br>HeadContext-&gt; EncoderContext-&gt;DecoderContext-&gt;SelfCustemHanderContext-&gt;TailContext.</li>\n<li>会进入到pipeline.fireChannelActive(),  如同前面讲述的会对每个Context执行channelActive()一样, 这里也会对每个Context执行channelActive(), 其中HeadContext.channelActive()需要提一下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">           ctx.fireChannelActive();</div><div class=\"line\"></div><div class=\"line\">           readIfIsAutoRead(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">       &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>ctx.fireChannelActive()调用的所有Context并不会做什么时, 但是该HeadContext.readIfIsAutoRead()需要我们值得注意下, 会从TailContext向前执行context.read(), 直达HeadContext.read需要我们注意下, 会执行doReadBegin<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    protected void doBeginRead() throws Exception &#123;</div><div class=\"line\">        // Channel.read() or ChannelHandlerContext.read() was called</div><div class=\"line\">        final SelectionKey selectionKey = this.selectionKey;</div><div class=\"line\">        if (!selectionKey.isValid()) &#123;</div><div class=\"line\">            return;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        readPending = true;</div><div class=\"line\"></div><div class=\"line\">        final int interestOps = selectionKey.interestOps();</div><div class=\"line\">        if ((interestOps &amp; readInterestOp) == 0) &#123; //将设置可接受</div><div class=\"line\">            selectionKey.interestOps(interestOps | readInterestOp);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>每个NioSocketChannel初始话的时候, readInterestOp被赋值为SelectionKey.OP_READ, 此时直接也将selectionKey赋值为可读。 基本初始化新建立的NioSocketChannel完成了。</p>\n<h3 id=\"SelectionKey-OP-READ\"><a href=\"#SelectionKey-OP-READ\" class=\"headerlink\" title=\"SelectionKey.OP_READ\"></a>SelectionKey.OP_READ</h3><p> 此时实际从unsafe.read()进入的代码如下(NioByteUnsafe.read()里面, 该模块涉及到自定义的编解码模块, 将在<code>Netty通信编解码源码解读</code>讲解。</p>\n<h2 id=\"执行非IO-Task\"><a href=\"#执行非IO-Task\" class=\"headerlink\" title=\"执行非IO Task.\"></a>执行非IO Task.</h2><p>进入runAllTasks函数执行非IO task, timeoutNanos指的当前执行task最多使用的时间, 过程如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\">protected boolean runAllTasks(long timeoutNanos) &#123;//处理非I/O任务。</div><div class=\"line\">        fetchFromScheduledTaskQueue();</div><div class=\"line\">        Runnable task = pollTask();//从</div><div class=\"line\">        if (task == null) &#123;</div><div class=\"line\">            afterRunningAllTasks();  //SingleThreadEventLoop.afterRunningAllTasks()</div><div class=\"line\">            return false;</div><div class=\"line\">        &#125;</div><div class=\"line\">        //截止时间=ScheduledFutureTask当前相对时间+ 超时</div><div class=\"line\">        final long deadline = ScheduledFutureTask.nanoTime() + timeoutNanos;</div><div class=\"line\">        long runTasks = 0;</div><div class=\"line\">        long lastExecutionTime;</div><div class=\"line\">        for (;;) &#123;</div><div class=\"line\">            safeExecute(task);  //顺序执行所有task</div><div class=\"line\"></div><div class=\"line\">            runTasks ++;</div><div class=\"line\"></div><div class=\"line\">            // Check timeout every 64 tasks because nanoTime() is relatively expensive.</div><div class=\"line\">            // XXX: Hard-coded value - will make it configurable if it is really a problem.</div><div class=\"line\">            if ((runTasks &amp; 0x3F) == 0) &#123;  //当64个task后</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                if (lastExecutionTime &gt;= deadline) &#123;//当前时间超过截止时间，那么就退出</div><div class=\"line\">                    break;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            task = pollTask();</div><div class=\"line\">            if (task == null) &#123;</div><div class=\"line\">                lastExecutionTime = ScheduledFutureTask.nanoTime();</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        afterRunningAllTasks();</div><div class=\"line\">        this.lastExecutionTime = lastExecutionTime;</div><div class=\"line\">        return true;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>主要做了如下几件事:</p>\n<ul>\n<li>从schedule队列取出任务向taskQueue中存放, 是一个有size&lt;=16的、根据截至时间有优先级的阻塞队列。</li>\n<li>从taskQueue中取出最早执行的那个task, 开始执行, 每当执行64个task退出一次,处理IO task.</li>\n</ul>\n<p>NioEventLoop核心函数及 OP_READ、OP_ACCEPT等基本讲完了。</p>\n"},{"title":"ServerBootstrap初始篇","date":"2018-01-14T10:32:43.000Z","_content":"&emsp;本文将以一个最简单的netty服务器端代码进行讲解。\n# 服务器示例\n ```\n public class HelloServer {\n    /**\n     * 服务端监听的端口地址\n     */\n    private static final int portNumber = 7878;\n    public static void main(String[] args) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup,WorkGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.childHandler(new HelloServerInitializer());\n            ChannelFuture f = b.bind(portNumber).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nclass HelloServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override       //  ch = NioSocketChannel\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n        pipeline.addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n        // 自己的逻辑Handler\n        pipeline.addLast(\"handler\", new HelloServerHandler());\n    }\n}\n\nclass HelloServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n        // 收到消息直接打印输出\n        System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);\n        // 返回客户端消息 - 我已经接收到了你的消息\n        ctx.writeAndFlush(\"Received your message !\\n\");\n    }\n    /*\n     *\n     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)\n     *\n     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述\n     * */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");\n        super.channelActive(ctx);\n    }\n}\n ```\n # NioEventLoop和NioEventLoopGroup分析\n  + NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为`NettyRuntime.availableProcessors() * 2)`\n  + NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。\n\n# 一些概念对应关系\n  + 一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。\n  + NioEventLoop里面处理task的线程唯一。\n  + Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。\n<img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\" />\n\n\n# 具体过程分析\n ## 首先分析AbstractBootstrap.doBind()\n ```\n     final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel(); //NioServerSocketChannel\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            // At this point we know that the registration was complete and successful.\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            // Registration future is almost always fulfilled already, but just in case it's not.\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                        // IllegalStateException once we try to access the EventLoop of the Channel.\n                        promise.setFailure(cause);\n                    } else {\n                        // Registration was successful, so set the correct executor to use.\n                        // See https://github.com/netty/netty/issues/2586\n                        promise.registered();\n\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n```\n主要干的事:\n1. 生成并初始化NioServerSocketChannel,见initAndRegister():\n2. 检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见`doBind0`)。\n\ninitAndRegister()主要作用:\n(1) 生成一个NioServerSocketChannel, 实际使用的`SelectorProvider.provider().openServerSocketChannel()`;\nNioServerSocketChannel构造函数如下:\n```\n        this.parent = parent;\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline，\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false); //\n        } catch (IOException e) {\n            try {\n                ch.close();\n            } catch (IOException e2) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Failed to close a partially initialized socket.\", e2);\n                }\n            }\n            throw new ChannelException(\"Failed to enter non-blocking mode.\", e);\n        }\n```\n+ 每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:\n```\nthis.channel = ObjectUtil.checkNotNull(channel, \"channel\");\ntail = new TailContext(this);   //只是in\nhead = new HeadContext(this);  //只是out\n\nhead.next = tail;\ntail.prev = head;\n```\n基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。\n+ TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身\n+ ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())\n+ 将该channel设置为非block类型,这里是不是与NIO很像。\n(2) 对channel初始化(见`分析init(channel)`)\n(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。\n\n&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。\n\n<font size=6>分析init(channel)</font>\n<p>代码实际会跑到ServerBootstrap.init():\n```\n            ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine\n            p.addLast(new ChannelInitializer<Channel>() { //新建的ChannelInitializer.initChannel\n            @Override\n            public void initChannel(final Channel ch) throws Exception {//NioServerSocketChannel\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n                ch.eventLoop().execute(new Runnable() {//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n```\n\n主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>\n<font size=6>p.addLast</font>\n<p>具体添加代码操作如下:\n```\n        synchronized (this) {\n            newCtx = newContext(group, filterName(name, handler), handler);\n            addLast0(newCtx);\n            if (!registered) {//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的\n                newCtx.setAddPending();\n                callHandlerCallbackLater(newCtx, true);\n                return this;\n            }\n            EventExecutor executor = newCtx.executor();\n            if (!executor.inEventLoop()) {\n                newCtx.setAddPending();\n                executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        callHandlerAdded0(newCtx);\n                    }\n                });\n                return this;\n            }\n        }\n        callHandlerAdded0(newCtx);\n        return this;\n```\n\n主要操作就是:\n+ 新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。\n+ 将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。\n+ 如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());\n  若注册了, 那么调用callHandlerAdded0()->ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:\n  ```\n  @SuppressWarnings(\"unchecked\")\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.\n            try {\n                initChannel((C) ctx.channel());\n            } catch (Throwable cause) {\n                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).\n                // We do so to prevent multiple calls to initChannel(...).\n                exceptionCaught(ctx, cause);\n            } finally {\n                remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型\n            }\n            return true;\n        }\n        return false;\n    }\n  ```\n  + 这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。\n  + 这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head->tail),和可能已经放进来的的ServerBootstrapAcceptor。\n\n<font size=6>register</font><p>\n根据`config().group().register(channel)`进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:\n当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。\n```\npublic EventExecutor next() {\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n```\n如何判断一个数是否为2^n呢, 方法如下:\n```\nprivate static boolean isPowerOfTwo(int val) {\n    return (val & -val) == val;\n}\n```\n选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:\n```\n            try {\n                // check if the channel is still open as it could be closed in the mean time when the register\n                // call was outside of the eventLoop\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n                doRegister();\n                neverRegistered = false;\n                registered = true;\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise);\n                pipeline.fireChannelRegistered();\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                // Close the channel directly to avoid FD leak.\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n```\ndoRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:\n```\n        for (;;) {\n            try {\n                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                    // cached and not removed because no Select.select(..) operation was called yet.\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    // We forced a select operation on the selector before but the SelectionKey is still cached\n                    // for whatever reason. JDK bug ?\n                    throw e;\n                }\n            }\n        }\n```\n这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。\n\n继续回到register()上,  channel与selector完成register之后:\n1. 执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD->ServerBootstrapAcceptor->TAIL\n2. 执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:\n```\n boolean wasActive = isActive();\n            try {\n                doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n            if (!wasActive && isActive()) { //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性\n                    }\n                });\n            }\n```\n\n\n自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\" />\n其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:\n```\nnew ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)\n```\ncurrentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。\n\n","source":"_posts/ServerBootstrap初始篇.md","raw":"---\ntitle: ServerBootstrap初始篇\ndate: 2018-01-14 18:32:43\ntags: netty4, ServerBootstrap, Initiale\n---\n&emsp;本文将以一个最简单的netty服务器端代码进行讲解。\n# 服务器示例\n ```\n public class HelloServer {\n    /**\n     * 服务端监听的端口地址\n     */\n    private static final int portNumber = 7878;\n    public static void main(String[] args) throws InterruptedException {\n        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);\n        try {\n            ServerBootstrap b = new ServerBootstrap();\n            b.group(bossGroup,WorkGroup);\n            b.channel(NioServerSocketChannel.class);\n            b.childHandler(new HelloServerInitializer());\n            ChannelFuture f = b.bind(portNumber).sync();\n            f.channel().closeFuture().sync();\n        } finally {\n            bossGroup.shutdownGracefully();\n        }\n    }\n}\n\nclass HelloServerInitializer extends ChannelInitializer<SocketChannel> {\n    @Override       //  ch = NioSocketChannel\n    protected void initChannel(SocketChannel ch) throws Exception {\n        ChannelPipeline pipeline = ch.pipeline();\n        pipeline.addLast(\"frameDecoder\", new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));\n        pipeline.addLast(\"frameEncoder\", new LengthFieldPrepender(4));\n        pipeline.addLast(\"decoder\", new StringDecoder(CharsetUtil.UTF_8));\n        pipeline.addLast(\"encoder\", new StringEncoder(CharsetUtil.UTF_8));\n        // 自己的逻辑Handler\n        pipeline.addLast(\"handler\", new HelloServerHandler());\n    }\n}\n\nclass HelloServerHandler extends SimpleChannelInboundHandler<String> {\n    @Override\n    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception {\n        // 收到消息直接打印输出\n        System.out.println(ctx.channel().remoteAddress() + \" Say : \" + msg);\n        // 返回客户端消息 - 我已经接收到了你的消息\n        ctx.writeAndFlush(\"Received your message !\\n\");\n    }\n    /*\n     *\n     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)\n     *\n     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述\n     * */\n    @Override\n    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n        ctx.writeAndFlush(\"Welcome to \" + InetAddress.getLocalHost().getHostName() + \" service!\\n\");\n        super.channelActive(ctx);\n    }\n}\n ```\n # NioEventLoop和NioEventLoopGroup分析\n  + NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为`NettyRuntime.availableProcessors() * 2)`\n  + NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。\n\n# 一些概念对应关系\n  + 一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。\n  + NioEventLoop里面处理task的线程唯一。\n  + Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。\n<img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\" />\n\n\n# 具体过程分析\n ## 首先分析AbstractBootstrap.doBind()\n ```\n     final ChannelFuture regFuture = initAndRegister();\n        final Channel channel = regFuture.channel(); //NioServerSocketChannel\n        if (regFuture.cause() != null) {\n            return regFuture;\n        }\n\n        if (regFuture.isDone()) {\n            // At this point we know that the registration was complete and successful.\n            ChannelPromise promise = channel.newPromise();\n            doBind0(regFuture, channel, localAddress, promise);\n            return promise;\n        } else {\n            // Registration future is almost always fulfilled already, but just in case it's not.\n            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);\n            regFuture.addListener(new ChannelFutureListener() {\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception {\n                    Throwable cause = future.cause();\n                    if (cause != null) {\n                        // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an\n                        // IllegalStateException once we try to access the EventLoop of the Channel.\n                        promise.setFailure(cause);\n                    } else {\n                        // Registration was successful, so set the correct executor to use.\n                        // See https://github.com/netty/netty/issues/2586\n                        promise.registered();\n\n                        doBind0(regFuture, channel, localAddress, promise);\n                    }\n                }\n            });\n            return promise;\n        }\n```\n主要干的事:\n1. 生成并初始化NioServerSocketChannel,见initAndRegister():\n2. 检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见`doBind0`)。\n\ninitAndRegister()主要作用:\n(1) 生成一个NioServerSocketChannel, 实际使用的`SelectorProvider.provider().openServerSocketChannel()`;\nNioServerSocketChannel构造函数如下:\n```\n        this.parent = parent;\n        id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值\n        unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe\n        pipeline = newChannelPipeline();//// 初始化pipeline，\n        this.ch = ch;\n        this.readInterestOp = readInterestOp;\n        try {\n            ch.configureBlocking(false); //\n        } catch (IOException e) {\n            try {\n                ch.close();\n            } catch (IOException e2) {\n                if (logger.isWarnEnabled()) {\n                    logger.warn(\n                            \"Failed to close a partially initialized socket.\", e2);\n                }\n            }\n            throw new ChannelException(\"Failed to enter non-blocking mode.\", e);\n        }\n```\n+ 每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:\n```\nthis.channel = ObjectUtil.checkNotNull(channel, \"channel\");\ntail = new TailContext(this);   //只是in\nhead = new HeadContext(this);  //只是out\n\nhead.next = tail;\ntail.prev = head;\n```\n基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。\n+ TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身\n+ ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())\n+ 将该channel设置为非block类型,这里是不是与NIO很像。\n(2) 对channel初始化(见`分析init(channel)`)\n(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。\n\n&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。\n\n<font size=6>分析init(channel)</font>\n<p>代码实际会跑到ServerBootstrap.init():\n```\n            ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine\n            p.addLast(new ChannelInitializer<Channel>() { //新建的ChannelInitializer.initChannel\n            @Override\n            public void initChannel(final Channel ch) throws Exception {//NioServerSocketChannel\n                final ChannelPipeline pipeline = ch.pipeline();\n                ChannelHandler handler = config.handler();\n                if (handler != null) {\n                    pipeline.addLast(handler);\n                }\n                ch.eventLoop().execute(new Runnable() {//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是\n                    @Override\n                    public void run() {\n                        pipeline.addLast(new ServerBootstrapAcceptor(\n                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                    }\n                });\n            }\n        });\n```\n\n主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br>\n<font size=6>p.addLast</font>\n<p>具体添加代码操作如下:\n```\n        synchronized (this) {\n            newCtx = newContext(group, filterName(name, handler), handler);\n            addLast0(newCtx);\n            if (!registered) {//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的\n                newCtx.setAddPending();\n                callHandlerCallbackLater(newCtx, true);\n                return this;\n            }\n            EventExecutor executor = newCtx.executor();\n            if (!executor.inEventLoop()) {\n                newCtx.setAddPending();\n                executor.execute(new Runnable() {\n                    @Override\n                    public void run() {\n                        callHandlerAdded0(newCtx);\n                    }\n                });\n                return this;\n            }\n        }\n        callHandlerAdded0(newCtx);\n        return this;\n```\n\n主要操作就是:\n+ 新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。\n+ 将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。\n+ 如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());\n  若注册了, 那么调用callHandlerAdded0()->ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:\n  ```\n  @SuppressWarnings(\"unchecked\")\n    private boolean initChannel(ChannelHandlerContext ctx) throws Exception {\n        if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) { // Guard against re-entrance.\n            try {\n                initChannel((C) ctx.channel());\n            } catch (Throwable cause) {\n                // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).\n                // We do so to prevent multiple calls to initChannel(...).\n                exceptionCaught(ctx, cause);\n            } finally {\n                remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型\n            }\n            return true;\n        }\n        return false;\n    }\n  ```\n  + 这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。\n  + 这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head->tail),和可能已经放进来的的ServerBootstrapAcceptor。\n\n<font size=6>register</font><p>\n根据`config().group().register(channel)`进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:\n当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。\n```\npublic EventExecutor next() {\n    return executors[idx.getAndIncrement() & executors.length - 1];\n}\n```\n如何判断一个数是否为2^n呢, 方法如下:\n```\nprivate static boolean isPowerOfTwo(int val) {\n    return (val & -val) == val;\n}\n```\n选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:\n```\n            try {\n                // check if the channel is still open as it could be closed in the mean time when the register\n                // call was outside of the eventLoop\n                if (!promise.setUncancellable() || !ensureOpen(promise)) {\n                    return;\n                }\n                boolean firstRegistration = neverRegistered;\n                doRegister();\n                neverRegistered = false;\n                registered = true;\n                pipeline.invokeHandlerAddedIfNeeded();\n\n                safeSetSuccess(promise);\n                pipeline.fireChannelRegistered();\n                // Only fire a channelActive if the channel has never been registered. This prevents firing\n                // multiple channel actives if the channel is deregistered and re-registered.\n                if (isActive()) {\n                    if (firstRegistration) {\n                        pipeline.fireChannelActive();\n                    } else if (config().isAutoRead()) {\n                        // This channel was registered before and autoRead() is set. This means we need to begin read\n                        // again so that we process inbound data.\n                        //\n                        // See https://github.com/netty/netty/issues/4805\n                        beginRead();\n                    }\n                }\n            } catch (Throwable t) {\n                // Close the channel directly to avoid FD leak.\n                closeForcibly();\n                closeFuture.setClosed();\n                safeSetFailure(promise, t);\n            }\n```\ndoRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:\n```\n        for (;;) {\n            try {\n                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n                return;\n            } catch (CancelledKeyException e) {\n                if (!selected) {\n                    // Force the Selector to select now as the \"canceled\" SelectionKey may still be\n                    // cached and not removed because no Select.select(..) operation was called yet.\n                    eventLoop().selectNow();\n                    selected = true;\n                } else {\n                    // We forced a select operation on the selector before but the SelectionKey is still cached\n                    // for whatever reason. JDK bug ?\n                    throw e;\n                }\n            }\n        }\n```\n这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。\n\n继续回到register()上,  channel与selector完成register之后:\n1. 执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD->ServerBootstrapAcceptor->TAIL\n2. 执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:\n```\n boolean wasActive = isActive();\n            try {\n                doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定\n            } catch (Throwable t) {\n                safeSetFailure(promise, t);\n                closeIfClosed();\n                return;\n            }\n            if (!wasActive && isActive()) { //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了\n                invokeLater(new Runnable() {\n                    @Override\n                    public void run() {\n                        pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性\n                    }\n                });\n            }\n```\n\n\n自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:\n<img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\" />\n其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:\n```\nnew ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)\n```\ncurrentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。\n\n","slug":"ServerBootstrap初始篇","published":1,"updated":"2018-05-02T12:20:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjjmpadwi000amiu5fnvfnzoy","content":"<p>&emsp;本文将以一个最简单的netty服务器端代码进行讲解。</p>\n<h1 id=\"服务器示例\"><a href=\"#服务器示例\" class=\"headerlink\" title=\"服务器示例\"></a>服务器示例</h1> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class HelloServer &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * 服务端监听的端口地址</div><div class=\"line\">     */</div><div class=\"line\">    private static final int portNumber = 7878;</div><div class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</div><div class=\"line\">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</div><div class=\"line\">        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ServerBootstrap b = new ServerBootstrap();</div><div class=\"line\">            b.group(bossGroup,WorkGroup);</div><div class=\"line\">            b.channel(NioServerSocketChannel.class);</div><div class=\"line\">            b.childHandler(new HelloServerInitializer());</div><div class=\"line\">            ChannelFuture f = b.bind(portNumber).sync();</div><div class=\"line\">            f.channel().closeFuture().sync();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            bossGroup.shutdownGracefully();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</div><div class=\"line\">    @Override       //  ch = NioSocketChannel</div><div class=\"line\">    protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</div><div class=\"line\">        pipeline.addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(4));</div><div class=\"line\">        pipeline.addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.UTF_8));</div><div class=\"line\">        pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</div><div class=\"line\">        // 自己的逻辑Handler</div><div class=\"line\">        pipeline.addLast(&quot;handler&quot;, new HelloServerHandler());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</div><div class=\"line\">        // 收到消息直接打印输出</div><div class=\"line\">        System.out.println(ctx.channel().remoteAddress() + &quot; Say : &quot; + msg);</div><div class=\"line\">        // 返回客户端消息 - 我已经接收到了你的消息</div><div class=\"line\">        ctx.writeAndFlush(&quot;Received your message !\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">     *</div><div class=\"line\">     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)</div><div class=\"line\">     *</div><div class=\"line\">     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述</div><div class=\"line\">     * */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">        ctx.writeAndFlush(&quot;Welcome to &quot; + InetAddress.getLocalHost().getHostName() + &quot; service!\\n&quot;);</div><div class=\"line\">        super.channelActive(ctx);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"NioEventLoop和NioEventLoopGroup分析\"><a href=\"#NioEventLoop和NioEventLoopGroup分析\" class=\"headerlink\" title=\"NioEventLoop和NioEventLoopGroup分析\"></a>NioEventLoop和NioEventLoopGroup分析</h1><ul>\n<li>NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为<code>NettyRuntime.availableProcessors() * 2)</code></li>\n<li>NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。</li>\n</ul>\n<h1 id=\"一些概念对应关系\"><a href=\"#一些概念对应关系\" class=\"headerlink\" title=\"一些概念对应关系\"></a>一些概念对应关系</h1><ul>\n<li>一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。</li>\n<li>NioEventLoop里面处理task的线程唯一。</li>\n<li>Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。<br><img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\"></li>\n</ul>\n<h1 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h1><h2 id=\"首先分析AbstractBootstrap-doBind\"><a href=\"#首先分析AbstractBootstrap-doBind\" class=\"headerlink\" title=\"首先分析AbstractBootstrap.doBind()\"></a>首先分析AbstractBootstrap.doBind()</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ChannelFuture regFuture = initAndRegister();</div><div class=\"line\">   final Channel channel = regFuture.channel(); //NioServerSocketChannel</div><div class=\"line\">   if (regFuture.cause() != null) &#123;</div><div class=\"line\">       return regFuture;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   if (regFuture.isDone()) &#123;</div><div class=\"line\">       // At this point we know that the registration was complete and successful.</div><div class=\"line\">       ChannelPromise promise = channel.newPromise();</div><div class=\"line\">       doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">       // Registration future is almost always fulfilled already, but just in case it&apos;s not.</div><div class=\"line\">       final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</div><div class=\"line\">       regFuture.addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">               Throwable cause = future.cause();</div><div class=\"line\">               if (cause != null) &#123;</div><div class=\"line\">                   // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</div><div class=\"line\">                   // IllegalStateException once we try to access the EventLoop of the Channel.</div><div class=\"line\">                   promise.setFailure(cause);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Registration was successful, so set the correct executor to use.</div><div class=\"line\">                   // See https://github.com/netty/netty/issues/2586</div><div class=\"line\">                   promise.registered();</div><div class=\"line\"></div><div class=\"line\">                   doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>主要干的事:</p>\n<ol>\n<li>生成并初始化NioServerSocketChannel,见initAndRegister():</li>\n<li>检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见<code>doBind0</code>)。</li>\n</ol>\n<p>initAndRegister()主要作用:<br>(1) 生成一个NioServerSocketChannel, 实际使用的<code>SelectorProvider.provider().openServerSocketChannel()</code>;<br>NioServerSocketChannel构造函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.parent = parent;</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline，</div><div class=\"line\">this.ch = ch;</div><div class=\"line\">this.readInterestOp = readInterestOp;</div><div class=\"line\">try &#123;</div><div class=\"line\">    ch.configureBlocking(false); //</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        ch.close();</div><div class=\"line\">    &#125; catch (IOException e2) &#123;</div><div class=\"line\">        if (logger.isWarnEnabled()) &#123;</div><div class=\"line\">            logger.warn(</div><div class=\"line\">                    &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class=\"line\">tail = new TailContext(this);   //只是in</div><div class=\"line\">head = new HeadContext(this);  //只是out</div><div class=\"line\"></div><div class=\"line\">head.next = tail;</div><div class=\"line\">tail.prev = head;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。</p>\n<ul>\n<li>TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身</li>\n<li>ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())</li>\n<li>将该channel设置为非block类型,这里是不是与NIO很像。<br>(2) 对channel初始化(见<code>分析init(channel)</code>)<br>(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。</li>\n</ul>\n<p>&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。</p>\n<p><font size=\"6\">分析init(channel)</font></p>\n<p></p><p>代码实际会跑到ServerBootstrap.init():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine</div><div class=\"line\">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; //新建的ChannelInitializer.initChannel</div><div class=\"line\">    @Override</div><div class=\"line\">    public void initChannel(final Channel ch) throws Exception &#123;//NioServerSocketChannel</div><div class=\"line\">        final ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        ChannelHandler handler = config.handler();</div><div class=\"line\">        if (handler != null) &#123;</div><div class=\"line\">            pipeline.addLast(handler);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ch.eventLoop().execute(new Runnable() &#123;//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                pipeline.addLast(new ServerBootstrapAcceptor(</div><div class=\"line\">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br></p>\n<p><font size=\"6\">p.addLast</font></p>\n<p></p><p>具体添加代码操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">    newCtx = newContext(group, filterName(name, handler), handler);</div><div class=\"line\">    addLast0(newCtx);</div><div class=\"line\">    if (!registered) &#123;//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        callHandlerCallbackLater(newCtx, true);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    EventExecutor executor = newCtx.executor();</div><div class=\"line\">    if (!executor.inEventLoop()) &#123;</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        executor.execute(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                callHandlerAdded0(newCtx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">callHandlerAdded0(newCtx);</div><div class=\"line\">return this;</div></pre></td></tr></table></figure></p>\n<p>主要操作就是:</p>\n<ul>\n<li>新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。</li>\n<li>将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。</li>\n<li><p>如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());<br>若注册了, 那么调用callHandlerAdded0()-&gt;ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">  private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">      if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              initChannel((C) ctx.channel());</div><div class=\"line\">          &#125; catch (Throwable cause) &#123;</div><div class=\"line\">              // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</div><div class=\"line\">              // We do so to prevent multiple calls to initChannel(...).</div><div class=\"line\">              exceptionCaught(ctx, cause);</div><div class=\"line\">          &#125; finally &#123;</div><div class=\"line\">              remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型</div><div class=\"line\">          &#125;</div><div class=\"line\">          return true;</div><div class=\"line\">      &#125;</div><div class=\"line\">      return false;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。</li>\n<li>这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head-&gt;tail),和可能已经放进来的的ServerBootstrapAcceptor。</li>\n</ul>\n</li>\n</ul>\n<p><font size=\"6\">register</font></p><p><br>根据<code>config().group().register(channel)</code>进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:<br>当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor next() &#123;</div><div class=\"line\">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如何判断一个数是否为2^n呢, 方法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isPowerOfTwo(int val) &#123;</div><div class=\"line\">    return (val &amp; -val) == val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    // check if the channel is still open as it could be closed in the mean time when the register</div><div class=\"line\">    // call was outside of the eventLoop</div><div class=\"line\">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean firstRegistration = neverRegistered;</div><div class=\"line\">    doRegister();</div><div class=\"line\">    neverRegistered = false;</div><div class=\"line\">    registered = true;</div><div class=\"line\">    pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">    safeSetSuccess(promise);</div><div class=\"line\">    pipeline.fireChannelRegistered();</div><div class=\"line\">    // Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">    // multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">    if (isActive()) &#123;</div><div class=\"line\">        if (firstRegistration) &#123;</div><div class=\"line\">            pipeline.fireChannelActive();</div><div class=\"line\">        &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">            // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">            // again so that we process inbound data.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">            beginRead();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">    // Close the channel directly to avoid FD leak.</div><div class=\"line\">    closeForcibly();</div><div class=\"line\">    closeFuture.setClosed();</div><div class=\"line\">    safeSetFailure(promise, t);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>doRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        if (!selected) &#123;</div><div class=\"line\">            // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</div><div class=\"line\">            // cached and not removed because no Select.select(..) operation was called yet.</div><div class=\"line\">            eventLoop().selectNow();</div><div class=\"line\">            selected = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We forced a select operation on the selector before but the SelectionKey is still cached</div><div class=\"line\">            // for whatever reason. JDK bug ?</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。</p>\n<p>继续回到register()上,  channel与selector完成register之后:</p>\n<ol>\n<li>执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD-&gt;ServerBootstrapAcceptor-&gt;TAIL</li>\n<li>执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean wasActive = isActive();</div><div class=\"line\">           try &#123;</div><div class=\"line\">               doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">               safeSetFailure(promise, t);</div><div class=\"line\">               closeIfClosed();</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           if (!wasActive &amp;&amp; isActive()) &#123; //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了</div><div class=\"line\">               invokeLater(new Runnable() &#123;</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void run() &#123;</div><div class=\"line\">                       pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\"><br>其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)</div></pre></td></tr></table></figure></p>\n<p>currentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>&emsp;本文将以一个最简单的netty服务器端代码进行讲解。</p>\n<h1 id=\"服务器示例\"><a href=\"#服务器示例\" class=\"headerlink\" title=\"服务器示例\"></a>服务器示例</h1> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class HelloServer &#123;</div><div class=\"line\">    /**</div><div class=\"line\">     * 服务端监听的端口地址</div><div class=\"line\">     */</div><div class=\"line\">    private static final int portNumber = 7878;</div><div class=\"line\">    public static void main(String[] args) throws InterruptedException &#123;</div><div class=\"line\">        EventLoopGroup bossGroup = new NioEventLoopGroup(1);</div><div class=\"line\">        EventLoopGroup WorkGroup = new NioEventLoopGroup(4);</div><div class=\"line\">        try &#123;</div><div class=\"line\">            ServerBootstrap b = new ServerBootstrap();</div><div class=\"line\">            b.group(bossGroup,WorkGroup);</div><div class=\"line\">            b.channel(NioServerSocketChannel.class);</div><div class=\"line\">            b.childHandler(new HelloServerInitializer());</div><div class=\"line\">            ChannelFuture f = b.bind(portNumber).sync();</div><div class=\"line\">            f.channel().closeFuture().sync();</div><div class=\"line\">        &#125; finally &#123;</div><div class=\"line\">            bossGroup.shutdownGracefully();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerInitializer extends ChannelInitializer&lt;SocketChannel&gt; &#123;</div><div class=\"line\">    @Override       //  ch = NioSocketChannel</div><div class=\"line\">    protected void initChannel(SocketChannel ch) throws Exception &#123;</div><div class=\"line\">        ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        pipeline.addLast(&quot;frameDecoder&quot;, new LengthFieldBasedFrameDecoder(Integer.MAX_VALUE, 0, 4, 0, 4));</div><div class=\"line\">        pipeline.addLast(&quot;frameEncoder&quot;, new LengthFieldPrepender(4));</div><div class=\"line\">        pipeline.addLast(&quot;decoder&quot;, new StringDecoder(CharsetUtil.UTF_8));</div><div class=\"line\">        pipeline.addLast(&quot;encoder&quot;, new StringEncoder(CharsetUtil.UTF_8));</div><div class=\"line\">        // 自己的逻辑Handler</div><div class=\"line\">        pipeline.addLast(&quot;handler&quot;, new HelloServerHandler());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">class HelloServerHandler extends SimpleChannelInboundHandler&lt;String&gt; &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void channelRead0(ChannelHandlerContext ctx, String msg) throws Exception &#123;</div><div class=\"line\">        // 收到消息直接打印输出</div><div class=\"line\">        System.out.println(ctx.channel().remoteAddress() + &quot; Say : &quot; + msg);</div><div class=\"line\">        // 返回客户端消息 - 我已经接收到了你的消息</div><div class=\"line\">        ctx.writeAndFlush(&quot;Received your message !\\n&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\">    /*</div><div class=\"line\">     *</div><div class=\"line\">     * 覆盖 channelActive 方法 在channel被启用的时候触发 (在建立连接的时候)</div><div class=\"line\">     *</div><div class=\"line\">     * channelActive 和 channelInActive 在后面的内容中讲述，这里先不做详细的描述</div><div class=\"line\">     * */</div><div class=\"line\">    @Override</div><div class=\"line\">    public void channelActive(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">        ctx.writeAndFlush(&quot;Welcome to &quot; + InetAddress.getLocalHost().getHostName() + &quot; service!\\n&quot;);</div><div class=\"line\">        super.channelActive(ctx);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h1 id=\"NioEventLoop和NioEventLoopGroup分析\"><a href=\"#NioEventLoop和NioEventLoopGroup分析\" class=\"headerlink\" title=\"NioEventLoop和NioEventLoopGroup分析\"></a>NioEventLoop和NioEventLoopGroup分析</h1><ul>\n<li>NioEventLoop:是一个单线程执行器(所有),所有task的具体执行者,每个task都是一个Runnable实例。NioEventLoop内的线程池线程,默认取值为<code>NettyRuntime.availableProcessors() * 2)</code></li>\n<li>NioEventLoopGroup:每个NioEventLoop都有一个分组,NioEventLoopGroup一般分为两组parentGroup、childGroup,parentGroup管理一类NioEventLoop,这类执行器主要生成boss类的线程,实际使用时,childGroup管理的一类NioEventLoop主要生成work类的线程。</li>\n</ul>\n<h1 id=\"一些概念对应关系\"><a href=\"#一些概念对应关系\" class=\"headerlink\" title=\"一些概念对应关系\"></a>一些概念对应关系</h1><ul>\n<li>一个NioEventLoop可以处理分配给多个Channel(包含NioServerSocketChannel), 是一对多的关系。</li>\n<li>NioEventLoop里面处理task的线程唯一。</li>\n<li>Channel与NioEventLoop绑定称之为register。在它的生命周期产生的所有task内只能由固定的某一个NioEventLoop处理。<br><img src=\"http://owqu66xvx.bkt.clouddn.com/Netty%E6%A6%82%E5%BF%B5.png\"></li>\n</ul>\n<h1 id=\"具体过程分析\"><a href=\"#具体过程分析\" class=\"headerlink\" title=\"具体过程分析\"></a>具体过程分析</h1><h2 id=\"首先分析AbstractBootstrap-doBind\"><a href=\"#首先分析AbstractBootstrap-doBind\" class=\"headerlink\" title=\"首先分析AbstractBootstrap.doBind()\"></a>首先分析AbstractBootstrap.doBind()</h2> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">final ChannelFuture regFuture = initAndRegister();</div><div class=\"line\">   final Channel channel = regFuture.channel(); //NioServerSocketChannel</div><div class=\"line\">   if (regFuture.cause() != null) &#123;</div><div class=\"line\">       return regFuture;</div><div class=\"line\">   &#125;</div><div class=\"line\"></div><div class=\"line\">   if (regFuture.isDone()) &#123;</div><div class=\"line\">       // At this point we know that the registration was complete and successful.</div><div class=\"line\">       ChannelPromise promise = channel.newPromise();</div><div class=\"line\">       doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125; else &#123;</div><div class=\"line\">       // Registration future is almost always fulfilled already, but just in case it&apos;s not.</div><div class=\"line\">       final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);</div><div class=\"line\">       regFuture.addListener(new ChannelFutureListener() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void operationComplete(ChannelFuture future) throws Exception &#123;</div><div class=\"line\">               Throwable cause = future.cause();</div><div class=\"line\">               if (cause != null) &#123;</div><div class=\"line\">                   // Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</div><div class=\"line\">                   // IllegalStateException once we try to access the EventLoop of the Channel.</div><div class=\"line\">                   promise.setFailure(cause);</div><div class=\"line\">               &#125; else &#123;</div><div class=\"line\">                   // Registration was successful, so set the correct executor to use.</div><div class=\"line\">                   // See https://github.com/netty/netty/issues/2586</div><div class=\"line\">                   promise.registered();</div><div class=\"line\"></div><div class=\"line\">                   doBind0(regFuture, channel, localAddress, promise);</div><div class=\"line\">               &#125;</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;);</div><div class=\"line\">       return promise;</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure>\n<p>主要干的事:</p>\n<ol>\n<li>生成并初始化NioServerSocketChannel,见initAndRegister():</li>\n<li>检查该channel是否应注册到selector上。若注册上去后, 才会进行真正的channel与address、事件(OP_ACCEPT)绑定(见<code>doBind0</code>)。</li>\n</ol>\n<p>initAndRegister()主要作用:<br>(1) 生成一个NioServerSocketChannel, 实际使用的<code>SelectorProvider.provider().openServerSocketChannel()</code>;<br>NioServerSocketChannel构造函数如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.parent = parent;</div><div class=\"line\">id = newId();// 分配一个全局唯一的id，默认为MAC+进程id+自增的序列号+时间戳相关的数值+随机值</div><div class=\"line\">unsafe = newUnsafe(); // 初始化Unsafe, NioSocketChannel对应的是NioSocketChannelUnsafe</div><div class=\"line\">pipeline = newChannelPipeline();//// 初始化pipeline，</div><div class=\"line\">this.ch = ch;</div><div class=\"line\">this.readInterestOp = readInterestOp;</div><div class=\"line\">try &#123;</div><div class=\"line\">    ch.configureBlocking(false); //</div><div class=\"line\">&#125; catch (IOException e) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        ch.close();</div><div class=\"line\">    &#125; catch (IOException e2) &#123;</div><div class=\"line\">        if (logger.isWarnEnabled()) &#123;</div><div class=\"line\">            logger.warn(</div><div class=\"line\">                    &quot;Failed to close a partially initialized socket.&quot;, e2);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    throw new ChannelException(&quot;Failed to enter non-blocking mode.&quot;, e);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>每一个channel都将独自拥有一个DefaultChannelPipeline, DefaultChannelPipeline主要的属性如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">this.channel = ObjectUtil.checkNotNull(channel, &quot;channel&quot;);</div><div class=\"line\">tail = new TailContext(this);   //只是in</div><div class=\"line\">head = new HeadContext(this);  //只是out</div><div class=\"line\"></div><div class=\"line\">head.next = tail;</div><div class=\"line\">tail.prev = head;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>基本含义就是每个DefaultChannelPipeline与一个channel绑定, 该channle对应的处理链由head和tail串联起来。</p>\n<ul>\n<li>TailContext和HeadContext是所有Pipeline默认拥有的,他们本身同时继承了AbstractChannelHandlerContext, 另外HeadContext继承了ChannelOutboundHandler, ChannelInboundHandler两种属性, TailContext继承了ChannelOutboundHandler一种, 返回handler都是本身</li>\n<li>ch传递过来的参数是SelectionKey.OP_ACCEPT, 之后会再次初始化成0(0并不是SelectionKey其中的一种), (见doRegister())</li>\n<li>将该channel设置为非block类型,这里是不是与NIO很像。<br>(2) 对channel初始化(见<code>分析init(channel)</code>)<br>(3) 将产生的NioServerSocketChannel注册到对应EventLoop上,见register()部分。</li>\n</ul>\n<p>&emsp;regFuture.isDone()当且仅当执行NioServerSocketChannel.register(selector, SelectionKey)之后, 也就是将NioServerSocketChannel注册到parentGroup管理的NioEventLoop的selector上(代码见AbstractChannel.register0()), ChannelPromise状态才置为success。 后面会详细讲解doBind0函数。</p>\n<p><font size=\"6\">分析init(channel)</font></p>\n<p></p><p>代码实际会跑到ServerBootstrap.init():<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">    ChannelPipeline p = channel.pipeline(); //DefaultChannalPipeLine</div><div class=\"line\">    p.addLast(new ChannelInitializer&lt;Channel&gt;() &#123; //新建的ChannelInitializer.initChannel</div><div class=\"line\">    @Override</div><div class=\"line\">    public void initChannel(final Channel ch) throws Exception &#123;//NioServerSocketChannel</div><div class=\"line\">        final ChannelPipeline pipeline = ch.pipeline();</div><div class=\"line\">        ChannelHandler handler = config.handler();</div><div class=\"line\">        if (handler != null) &#123;</div><div class=\"line\">            pipeline.addLast(handler);</div><div class=\"line\">        &#125;</div><div class=\"line\">        ch.eventLoop().execute(new Runnable() &#123;//ChannelInitializer和ServerBootstrapAcceptor都是Inbound,区别就是</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                pipeline.addLast(new ServerBootstrapAcceptor(</div><div class=\"line\">                        ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<p>主要干的事是向NioServerSocketChannel的DefaultChannalPipeLine对应的处理链添加ChannelInitializer(实际也是一个InBoundHandler), ChannelInitializer对于后面还有作用, 先留个印象。<br></p>\n<p><font size=\"6\">p.addLast</font></p>\n<p></p><p>具体添加代码操作如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">synchronized (this) &#123;</div><div class=\"line\">    newCtx = newContext(group, filterName(name, handler), handler);</div><div class=\"line\">    addLast0(newCtx);</div><div class=\"line\">    if (!registered) &#123;//只有这个channel被register到某个具体的EventLoop后，才会考虑执行一些任务，这里考虑的任务是将对应的handler加入到对应的pipe中,DefaultChannelPipeline是与NioServerSocketChannel一一对应的</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        callHandlerCallbackLater(newCtx, true);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">    EventExecutor executor = newCtx.executor();</div><div class=\"line\">    if (!executor.inEventLoop()) &#123;</div><div class=\"line\">        newCtx.setAddPending();</div><div class=\"line\">        executor.execute(new Runnable() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void run() &#123;</div><div class=\"line\">                callHandlerAdded0(newCtx);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        return this;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">callHandlerAdded0(newCtx);</div><div class=\"line\">return this;</div></pre></td></tr></table></figure></p>\n<p>主要操作就是:</p>\n<ul>\n<li>新产生一个DefaultChannelHandlerContext, 主要作用就是存放对应的handler,也就是ChannelInitializer。</li>\n<li>将DefaultChannelHandlerContext添加进DefaultChannalPipeLine的倒数第二个, 也就是tail之前。</li>\n<li><p>如果NioServerSocketChannel并没有注册到对应的selector上(代码见AbstractChannel.register0()), 那么将生成PendingHandlerAddedTask, 并将该task线程放入pendingHandlerCallbackHead(属于Pipeline), 等待NioServerSocketChannel被注册到对应的selector时执行(见NioMessageUnsafe.register());<br>若注册了, 那么调用callHandlerAdded0()-&gt;ChannelInitializer.initChannel(ChannelHandlerContext ctx)函数中,如下:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@SuppressWarnings(&quot;unchecked&quot;)</div><div class=\"line\">  private boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;</div><div class=\"line\">      if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.</div><div class=\"line\">          try &#123;</div><div class=\"line\">              initChannel((C) ctx.channel());</div><div class=\"line\">          &#125; catch (Throwable cause) &#123;</div><div class=\"line\">              // Explicitly call exceptionCaught(...) as we removed the handler before calling initChannel(...).</div><div class=\"line\">              // We do so to prevent multiple calls to initChannel(...).</div><div class=\"line\">              exceptionCaught(ctx, cause);</div><div class=\"line\">          &#125; finally &#123;</div><div class=\"line\">              remove(ctx); //初始化完善后，删除自身。又要把最开始注册的HelloServerInitializer删掉，也是ChannelInboundHandler类型</div><div class=\"line\">          &#125;</div><div class=\"line\">          return true;</div><div class=\"line\">      &#125;</div><div class=\"line\">      return false;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<ul>\n<li>这里会进入ChannelInitializer.initChannel(final Channel ch)(详见ServerBootstrap.init()), 会向pipeLine添加ServerBootstrapAcceptor, 传递的参数也可以注意下, 有childGroup、以及自定义的HelloServerInitializer。之后新建立的连接请求SocketChannel, 将根据这两个参数创建, 之后会详解(见NioEventLoop篇)。</li>\n<li>这里还需要注意remove(ctx), 在对channel之后, 会将该匿名ChannelInitializer(见ServerBootstrap.init())从NioServerSocketChannel的pipeline中删掉。这样该pipeline里的handler包含(head-&gt;tail),和可能已经放进来的的ServerBootstrapAcceptor。</li>\n</ul>\n</li>\n</ul>\n<p><font size=\"6\">register</font></p><p><br>根据<code>config().group().register(channel)</code>进行注册, 首先这里的group()使用的是ParentGroup里面的EventLoop, 具体从EventLoop选取哪个EventLoop来与该channel绑定呢,使用的轮训策略。每次选取都会+1。 这里分两种决策策略:PowerOfTwoEventExecutorChooser和GenericEventExecutorChooser,都实现了+1的效果, 两者的唯一区别就是求余的效果不同:<br>当该Group定义的EventLoop为2^n时, PowerOfTwoEventExecutorChooser使用的是位运算的方式求余, 位运算能减少计算的时间复杂度。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">public EventExecutor next() &#123;</div><div class=\"line\">    return executors[idx.getAndIncrement() &amp; executors.length - 1];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>如何判断一个数是否为2^n呢, 方法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static boolean isPowerOfTwo(int val) &#123;</div><div class=\"line\">    return (val &amp; -val) == val;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>选出一个NioEventLoop后, 最终会进入NioMessageUnsafe.register()中(是AbstractUnsafe的函数), 该对象在NioServerSocketChannel构造函数中生成。接着会进入AbstractUnsafe.register0(), 代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div></pre></td><td class=\"code\"><pre><div class=\"line\">try &#123;</div><div class=\"line\">    // check if the channel is still open as it could be closed in the mean time when the register</div><div class=\"line\">    // call was outside of the eventLoop</div><div class=\"line\">    if (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</div><div class=\"line\">        return;</div><div class=\"line\">    &#125;</div><div class=\"line\">    boolean firstRegistration = neverRegistered;</div><div class=\"line\">    doRegister();</div><div class=\"line\">    neverRegistered = false;</div><div class=\"line\">    registered = true;</div><div class=\"line\">    pipeline.invokeHandlerAddedIfNeeded();</div><div class=\"line\"></div><div class=\"line\">    safeSetSuccess(promise);</div><div class=\"line\">    pipeline.fireChannelRegistered();</div><div class=\"line\">    // Only fire a channelActive if the channel has never been registered. This prevents firing</div><div class=\"line\">    // multiple channel actives if the channel is deregistered and re-registered.</div><div class=\"line\">    if (isActive()) &#123;</div><div class=\"line\">        if (firstRegistration) &#123;</div><div class=\"line\">            pipeline.fireChannelActive();</div><div class=\"line\">        &#125; else if (config().isAutoRead()) &#123;</div><div class=\"line\">            // This channel was registered before and autoRead() is set. This means we need to begin read</div><div class=\"line\">            // again so that we process inbound data.</div><div class=\"line\">            //</div><div class=\"line\">            // See https://github.com/netty/netty/issues/4805</div><div class=\"line\">            beginRead();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125; catch (Throwable t) &#123;</div><div class=\"line\">    // Close the channel directly to avoid FD leak.</div><div class=\"line\">    closeForcibly();</div><div class=\"line\">    closeFuture.setClosed();</div><div class=\"line\">    safeSetFailure(promise, t);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>doRegister()函数将会跑到AbstractNioChannel.doRegister()里面, 如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">for (;;) &#123;</div><div class=\"line\">    try &#123;</div><div class=\"line\">        selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);</div><div class=\"line\">        return;</div><div class=\"line\">    &#125; catch (CancelledKeyException e) &#123;</div><div class=\"line\">        if (!selected) &#123;</div><div class=\"line\">            // Force the Selector to select now as the &quot;canceled&quot; SelectionKey may still be</div><div class=\"line\">            // cached and not removed because no Select.select(..) operation was called yet.</div><div class=\"line\">            eventLoop().selectNow();</div><div class=\"line\">            selected = true;</div><div class=\"line\">        &#125; else &#123;</div><div class=\"line\">            // We forced a select operation on the selector before but the SelectionKey is still cached</div><div class=\"line\">            // for whatever reason. JDK bug ?</div><div class=\"line\">            throw e;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这里是不是很熟悉? 不断地轮训注册, 将该channel注册到NioEventLoop上面的Selector上面, 并且select_ops置为0, 表示什么都不感兴趣。</p>\n<p>继续回到register()上,  channel与selector完成register之后:</p>\n<ol>\n<li>执行一些挂起的任务(invokeHandlerAddedIfNeeded()), 比如p.addLast所介绍的, 此时pileline对应的的handler链如下:HEAD-&gt;ServerBootstrapAcceptor-&gt;TAIL</li>\n<li>执行safeSetSuccess(promise), 最终会去调用AbstractBootstrap.doBind()里面介绍的ChannelFutureListener.operationComplete()函数, 注意doBind0()函数, 这里将完成channel与port的绑定和channel感兴趣事件为OP_ACCEPT,具体代码见AbstractChannel.bin(), 代码如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean wasActive = isActive();</div><div class=\"line\">           try &#123;</div><div class=\"line\">               doBind(localAddress); //doBind0最终调用channel.bind方法对执行端口进行绑定</div><div class=\"line\">           &#125; catch (Throwable t) &#123;</div><div class=\"line\">               safeSetFailure(promise, t);</div><div class=\"line\">               closeIfClosed();</div><div class=\"line\">               return;</div><div class=\"line\">           &#125;</div><div class=\"line\">           if (!wasActive &amp;&amp; isActive()) &#123; //之前没有绑定，现在绑定了，绑定的意思是NioServerSocketChannel里面的SocketChannel的Address有值了</div><div class=\"line\">               invokeLater(new Runnable() &#123;</div><div class=\"line\">                   @Override</div><div class=\"line\">                   public void run() &#123;</div><div class=\"line\">                       pipeline.fireChannelActive(); //最终修改的是NioServerSocketChannel的可读属性</div><div class=\"line\">                   &#125;</div><div class=\"line\">               &#125;);</div><div class=\"line\">           &#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>自此NioServerSocketChannel已经初始化完成, NioServerSocketChannel拥有的pipeLine的里面的上下文:<br><img src=\"http://owqu66xvx.bkt.clouddn.com/PipeLine.png\"><br>其中第二个Context的handler为ServerBootstrapAcceptor, 它的构造时的代码如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">new ServerBootstrapAcceptor(ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)</div></pre></td></tr></table></figure></p>\n<p>currentChildHandler就是我们自定的HelloServerInitializer, 该handler包含了我们所需要的所有逻辑,这些handler将在NioEventLoop篇构造NioSocketChannel时使用。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjjmpadvt0000miu5h40zhw69","tag_id":"cjjmpadw30002miu52qyi4duf","_id":"cjjmpadwb0006miu52acknek3"},{"post_id":"cjjmpadwi000amiu5fnvfnzoy","tag_id":"cjjmpadwk000bmiu5q7o8sgfp","_id":"cjjmpadwl000cmiu54m1ee116"}],"Tag":[{"name":"AbstractQueuedSynchronizer,源码,BaseFuture","_id":"cjjmpadw30002miu52qyi4duf"},{"name":"netty4, ServerBootstrap, Initiale","_id":"cjjmpadwk000bmiu5q7o8sgfp"}]}}