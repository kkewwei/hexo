---
title: JAVA JNI实现hello world
date: 2017-06-15 18:15:08
tags:
---
jvm作为扩平台执行的环境, 屏蔽了代码与底层操作系统打交道, 这样代码就可以在不同平台下无缝迁移。但是也有一个坏处, java不能访问底层硬件资源并且执行速度相对c/c++很慢, 要是可以在java代码中调用c/c++语言, 那就可以弥补这方面的不足。 JNI(java native interface)就是来作为沟通桥梁的。 当函数被定义为native, 就说明本函数不是用java语言编写的。 本文展示java 如何使用native来调用c++代码的。
# 使用
```
public class Native1{
    public native void  sayHello();

    public static void main(String[] args) {
        System.loadLibrary("hellworld");
        new Native1().sayHello();
    }
}
```
我们定义了sayHello函数为native属性的。这里System.loadLibrary("hellworld")必不可少, 否则会报如下异常
```
Exception in thread "main" java.lang.UnsatisfiedLinkError: Native1.sayHello()V
        at Native1.sayHello(Native Method)
        at Native1.main(Native1.java:6)
```
之后再讲解这行代码, 主要步骤如下:
1. 首先执行javac Native1.java, 这样获得了Native1.class文件
2. 执行javah Native1, 获得Native1.h。 javah用于输出对应c语言头文件, 生成代码如下
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class Native1 */

#ifndef _Included_Native1
#define _Included_Native1
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     Native1
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_Native1_sayHello
  (JNIEnv *, jobject);
#ifdef __cplusplus
}
#endif
#endif
```
java的native方法转变为c++函数的规则如下：Java_{package_and_classname}_{function_name}(JNI arguments)。包名中的点换成单下划线。需要说明的是生成函数中的两个参数：
++ JNIEnv *：这是一个指向JNI运行环境的指针，后面我们会看到，我们通过这个指针访问JNI函数
++ jobject：这里指代java中的this对象。 如果定义为static函数,这里类型将是jclass
我们需要在myNative.c(.cpp文件也是支持的)里面实现Java_Native_sayHello函数:
```
#include "/Users/xiaoyu/Workspace_10.28/es2.3/es2.3/src/main/java/Native1.h"
#include <stdio.h>
JNIEXPORT void JNICALL Java_Native_sayHello(JNIEnv *env, jobject thisObj)
{
    printf("Hello，JNI");
}
```
头文件指明了Native1.h。这里主要定义了Java_Native_sayHello函数。
3. 生成动态链接库libhelloworld.jnilib
`gcc -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include/darwin -I/Library/Java/JavaVirtualMachines/jdk1.8.0_74.jdk/Contents/Home/include -dynamiclib /Users/xiaoyu/TEST/c++/Native1.c -o libhelloworld.jnilib`
这样的话, 会生成一个动态链接库文件:libhelloworld.jnilib 注意这里的名称不是随便起的。在mac系统上, 库名必须libXXX.jnilib这种结构, 我们在代码中加上这句:System.loadLibrary("hellworld"); 系统才能正常识别。
4. 执行java Native1, 获得如下结果。
```
Hello，JNI%
```

# 参考
https://www.chilkatsoft.com/java-loadLibrary-MacOSX.asp
https://blog.csdn.net/createchance/article/details/53783490
https://blog.csdn.net/abc5382334/article/details/18052757